_professorj_

ProfessorJ is a compiler for Java and related languages. The languages 
include three teaching languages, Java 1.1 (with some incomplete 
features, see below), and an experimental language supporting interoperability
between Java and Scheme. For details about the teaching languages, please
see the language manuals.

In all of the ProfessorJ language levels, the interactions window accepts variable 
declaration, statements and expressions legal for the language level. If the text 
is not sending, type Alt+Enter to force the text to send.

The definitions window expects class and interface definitions,
Java examples boxes, and test suite boxes. (i.e. what would be given to
javac plus two graphical boxes). Descriptions of these boxes can be
found in the DrScheme manual.

_ProfessorJ Beginner
 In Version 300, the Beginner language level has undergone significant changes.
 Largest among these is that interfaces are supported within the language, but
 abstract classes are no longer allowed. Further, interface implementation is supported
 but class extension is not. For further details please see the language manual.

_ProfessorJ Intermediate
 In Version 300, instanceof is now allowed. For further language details please see
 the language manual.
 
_ProfessorJ Advanced
 For details, please see the language manual.
 
_ProfessorJ Full
 Supports Java 1.1, no 1.5 features have been included. Few libraries are available.
 Where the libraries are supported, they are from version 1.4 (there are no language
 differences between 1.1 and 1.4). Please see the list of unsupported features to see
 what constructs are not available within this language level. 

_Java + dynamic_ language level
 Version 299.200 +
 This language level allows programs to contain a value that will be 
 checked dynamically rather than statically.
 
 The following code presents the use of a dynamically typed value, that
 will be checked during execution.
 
 class RuntimeCheck {
  int checkForNumber( dynamic var ) {
     return var;
  }
 }
 In RuntimeCheck, var will be checked to be an integer when checkForNumber
 is executed. Values declared with type 'dynamic' can also be used as
 any primitive or object value in Java. In addition, values with type
 'dynamic' can also be used as methods: var() is a legal use.
 
 In general, variables declared with type 'dynamic' will generate a contract
 check with coercians at each usage to ensure consistency with the Java type
 system.
 
 A Java String will be converted to a Scheme string, and vice-versa.
 
 Within the Java + dynamic language level, Scheme libraries may be 
 imported and used within the Java program.
 
 The import form is either:
   import scheme.lib.$PATH$;
   import scheme.$PATH$;
 where $PATH$ is the set of directories that leads to the Scheme module, ending
 with the modules name. The lib form is used to access Scheme modules within the
 collects hierarchy.
 The Scheme require statement (require (lib "compile.ss" "profj")) would be written
   import scheme.lib.profj.compile;
 within Java + dynamic
 
 Values provided by the scheme libraries may be used within a Java program, with
 access to them treated as though the Scheme module were a class and the provided
 value a static member. If the compile module mentioned above provides a types
 function, this would be accessed with the following code:
   ... compile.types() ...
 This value has type dynamic within the Java program, and will be dynamically checked
 based on use.
 
 As many Scheme names are not valid Java names, the following automatic name translations
 will be used:
 JName = [a-zA-Z0-9_]
   Scheme name        <->   Java name
   JName.*[-][a-zA-Z0-9] <-> JName.*[A-Z0-9]     i.e. make-foo      <->   makeFoo
   JName.*[?]            <-> JName.*[P]          i.e. foo?          <->   fooP
   JName.*[->][a-zA-Z0-9]<-> JName.*[To][A-Z0-9] i.e. foo->string   <->   fooToString
   JName.*[!]            <-> JName.*[Set]        i.e. set-foo-baz!  <->   setFooBazSet
   JName.*[%]            <-> Jname.*[Obj]        i.e. object%       <->   objectObj
   
 
Known bugs for dynamic:
  Programs of the following form will not produce the expected result:
    Object o = new Object();
    dynamic x = o; 
    boolean  t = x == o;
  In this program, t will have the value false, not true as expected.
  Some casts will fail and instanceof's return false that aught to succeed:
    interface I { }
    class C implements I { }
    I ic = new C();
    dynamic x = ic;
    C c = (C) x; 
  In this program, the cast of x to C will fail, even though the value is an intstanceof C.
  These issues will be addressed in future versions. 
  Some assignments (with implicit downcasts) will also fail.
 
_Libraries available to ProfessorJ:

  java.lang.Object
  java.lang.String (see exceptions)
  java.lang.Throwable
  java.lang.*Exception
  java.lang.System (only currentTimeMillis, gc, and identityHashCode)
  java.lang.Comparable
  java.lang.Number
  java.lang.Double (see exceptions) 
  java.lang.Float (see exceptions) 
  java.lang.Boolean (see exceptions) 
  java.io.Serializable
  java.util.Random

  Teachpacks (PLT/collects/htdch)
  draw.*

  exceptions:
   String: String(byte[],int,int,String) -- incorrect
           String(byte[],int,int,int) -- incorrect
           getBytes() -- partially incorrect
           replaceAll(String,String) -- not implemented
           replaceFirst(String,String) -- not implemented
           matches(String) -- not implemented
           split(String,int) -- not implemented
           split(String) -- not implemented
           trim -- not implemented
   Double: doubleToLongBits -- not implemented
           doubleToRawBits -- not implemented
           longBitsToDouble -- not implemented
   Float:  floatToIntBits, floatToRawBits, longBitsToFloat -- not implemented
   Boolean: getBoolean(String) not implemented


_Unfinished constructs:
  static nested classes
  switch
  labeled statements (compiles but does not work correctly)
  reflection
  unicode
  synchronized (compiles but is ignored)
  strictfp (compiles but is ignored)

