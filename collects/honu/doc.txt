_Honu_

_TODO_

  * Admit statements as elements of mixin bodies, i.e., 

     struct ExamplesC() : Examples {
      IStack s0 = new StackC();
      int d0 = s0.depth();
      s0.push(s0);
     }

    should work. -- MF

  * Work out details of standard library, including boxed versions of
    primitive types.

  * If you do have a standard library, document it please. -- MF 

  * Let's add arrays. 

  * Add new statement that uses positional initialization arguments.

  * Add autoboxing of primitive types.

  * Add generics (parametric polymorphism and bounded polymorphism).
    RESEARCH! 

_Primitive types_

  int    - integers
  float  - floating point numbers
  string - strings    (double quoted)
  bool   - booleans   (true, false)
  char   - characters (single quoted)

_Built-in functions_

Error reporting:

> error(string message) => 'a
    - Raises an error and prints the string as an error message.
    - Calls to error() do not return.

Input/output:

> printString(string message) => void
    - Takes a string and prints it on the standard output.

> printLine(string message) => void
    - Like printString, but prints a newline after printing the string.

> readChar() => char
    - Reads a single character from the standard input.

> readLine() => string
    - Reads a line of text from the standard input.

Conversions to string:

> intToString(int val) => string
    - Converts an integer to a string.

> floatToString(float val) => string
    - Converts a floating point number to a string.

> charToString(char val) => string
    - Converts a character to a string.

String conversions:

> stringToInt(string val) => int
    - Converts a string to an integer.
    - Raises an error if the string cannot be converted.

> stringToFloat(string val) => float
    - Converts a string to a floating point number.
    - Raises an error if the string cannot be converted.

String operations:

> strlen(string s) => int
    - Takes a string and returns the string length.

> substr(string s, int start, int end) => string
    - Takes a string, a start index, and an end index and
      returns the corresponding substring.
    - The indexes are zero-based.
    - The start index cannot be negative or greater than the end index.
    - The end index must be less than or equal to the string length.

> charAt(string s, int i) => char
    - Takes a string and an index into the string and returns
      the corresponding character.
    - The zero-based index cannot be negative and must be less
      than the string length.

Numeric operations:

> sqrt(float f) => float
    - Produces the square root of its argument.

_Operators_

Unary operators:

> ! : bool -> bool
    - Boolean negation (not)

> - : bool -> bool
    - Arithmetic negation

Binary operators:

> || : bool * bool -> bool
    - Boolean disjunction (or)

> && : bool * bool -> bool
    - Boolean conjunction (and)

> == : bool   * bool   -> bool
> == : int    * int    -> bool
> == : char   * char   -> bool
> == : float  * float  -> bool
> == : string * string -> bool
    - Equivalence for primitives (value equality)

> == : Any * Any -> bool
    - Identity for classes (pointer equality)

> != (same types as ==)
    - Boolean negation of equivalence/identity

> ==== : Any * Any -> bool
    - Equivalence for classes (value equality)

> < : int    * int    -> bool
> < : float  * float  -> bool
> < : char   * char   -> bool
> < : string * string -> bool
    - Less than (numeric / character set / lexiographic)

> >  (same types as <)
    - Greater than

> <= (same types as <)
    - Less than or equal to

> >= (same types as <)
    - Greater than or equal to

> + : int   * int   -> int
> + : float * float -> float
    - Addition

> + : string * string -> string
    - String concatenation

> - : int   * int   -> int
> - : float * float -> float
    - Subtraction

> * : int   * int   -> int
> * : float * float -> float
    - Multiplication

> / : int * int -> int
    - Integer division

> / : float * float -> float
    - Division

> % : int * int -> int
    - Remainder (from integer division)

_Grammar_

NOTE: Since I want to use parentheses to mean "real" parentheses, I use
      square brackets for grouping inside of rules.

<program>  ::= <defn>*

<defn>     ::= <function>
             | <top-bind>
             | <type>
             | <class>
             | <mixin>
             | <subclass>

<top-bind> ::= <bind> = <expr> ;
             | ( <bind> [, <bind>]* ) = <expr>;

<bind>     ::= <tid> <id>
             | _

<function> ::= <tid> <id> ( <argdecls> ) <block>

<tid>      ::= <ifacet>
             | <primtype>
             | <funtype>
             | <tuptype>

<funtype>  ::= <tid> -> <tid>

<tuptype>  ::= < >
             | < <tid> [, <tid>]* >

<ifacet>   ::= id
             | Any

<primtype> ::= int
             | float
             | bool
             | str
             | char
             | void

<type>     ::= type <id> <extends> { <mfdecl>* }
             | interface <id> <extends> { <mfdecl>* }

<extends>  ::= extends <ifacet> [, <ifacet>]*
             | <: <ifacet> [, <ifacet>]*
             |

<mfdecl>   ::= <tid> <fdid> ;
             | <tid> <mdid> ( <argdecls>* ) ;

<argdecls> ::= <argdecl> [, <argdecl>]*
             |

<argdecl>  ::= <tid>
             | <tid> <varid>

<struct>   ::= struct <id> <initargs> : <ifacet> <impls> <clsbody>
             | final struct <id> <initargs> : <ifacet> <impls> <clsbody>
             | struct <id> <initargs> : <ifacet>
                   extends <id> <initargs> : <ifacet> <impls> <mixbody>
             | final struct <id> <initargs> : <ifacet>
                   extends <id> <initargs> : <ifacet> <impls> <mixbody>

<class>    ::= class <id> <initargs> : <ifacet> <impls> <clsbody>
             | final class <initargs> <id> : <ifacet> <impls> <clsbody>
             | class <id> = <id> ( <id> ) ;
             | class <id> <initargs> : <ifacet> 
                  extends <id> <initargs> : <ifacet> <impls> <mixbody>
             | final class <id> <initargs> : <ifacet> 
                  extends <id> <initargs> : <ifacet> <impls> <mixbody>


<mixin>    ::= mixin <id> <initargs> : <ifacet> <initargs> -> <ifacet>
                  <impls> <mixbody>
             | final mixin <id> <initargs> : <ifacet> <initargs> -> <ifacet>
                  <impls> <mixbody>

<initargs> ::= ( <tid> <id> [, <tid> <id>]* )
             | ( )

<impls>    ::= implements <ifacet> [, <ifacet>]*
             | impl <ifacet> [, <ifacet>]*
             |

<clsbody>  ::= { <mfidefn>* <export>* }

<mixbody>  ::= { <mfidefn>* <supernew> <mfidefn>* <export>* }

<mfidefn>  ::= init <tid> <id> ;
             | init <tid> <id> = <expr> ;
             | <tid> <id> = <expr> ;
             | <tid> <id> ( <argdefns> ) <block>

<supernew> ::= super( <newargs> ) ;

<argdefns> ::= <argdefn> [, <argdefn>]* 
             |

<argdefn>  ::= <tid> <id>

<newargs>  ::= <newarg> [, <newarg>]*
             |

<newarg>   ::= <id> = <expr>

<export>   ::= export <ifacet> : <renames> ;

<renames>  ::= <rename> [, <rename>]*

<rename>   ::= <id>
             | <id> as <id>

<expr>     ::= <literal>
             | <lambda>
             | <tuple>
             | #n <expr>
             | <id>
             | <expr> = <expr>
             | <expr> <tuple>
             | this
             | <expr> : <ifacet>
             | <expr> isa <ifacet>
             | if <expr> <block> [else <block>]?
             | cond { [<expr> => <expr> ;]+ }
             | cond { [<expr> => <expr> ;]* else <expr> ; }
             | while <expr> <block>
             | new <id> : <ifacet> ( <newargs> )
             | new <id> ( <newargs> )
             | ! <expr>
             | - <expr>
             | <expr> || <expr>
             | <expr> && <expr>
             | <expr> == <expr>
             | <expr> != <expr>
             | <expr> ==== <expr>
             | <expr> < <expr>
             | <expr> > <expr>
             | <expr> <= <expr>
             | <expr> >= <expr>
             | <expr> + <expr>
             | <expr> - <expr>
             | <expr> * <expr>
             | <expr> / <expr>
             | <expr> % <expr>
             | <expr> . <id>
             | return <expr>
             | <block>

NOTE: Here's the precedence and associativity of things above.
      Top is most strongly binding, bottom is least.  Things on
      the same line have same precedence.  The : below refers to
      casting, and the = is for assignment.  else requires a
      precedence to avoid shift/reduce errors, even though we
      don't have the dangling else problem.

   LEFT   |   RIGHT  |  NONASSOC
----------+----------+-----------
    .     |          |
          |          |    (        (function application)
          |          |   #n        (tuple selector)
          |  :  isa  |
          |          | !, - (un)
   * / %  |          |
   +  -   |          |
          |          | < <= > >=
          |          |   ====
  ==  !=  |          |
    &&    |          |
    ||    |          |
    =     |          |
   else   |          |
          |          |  return

<tuple>    ::= ( )
             | ( <exprs-cd> )
<lambda>   ::= <tid> fun ( <argdecls> ) <block>

<exprs-cd> ::= <expr> [, <expr>]*
             | <expr>

<literal>  ::= <intlit>
             | <floatlit>
             | true
             | false
             | <strlit>
             | <charlit>
             | null

<block>    ::= { <stmts> }

<stmts>    ::= <expr-sc>
             | <vardefn> <stmts>
             | <expr-sc> <stmts>

<vardefn>  ::= <bind> = <expr> ;
             | ( <bind> [, <bind>]* ) = <expr> ;

<expr-sc>  ::= <expr> ;

_Mixin Definitions_

Assume a mixin of the following form:

[final] mixin MixinName( initType1 initArg1, ..., initTypeN initArgN ) :
    ParentIFace( superType1 superArg1, ..., superTypeM superArgM ) -> SelfIFace
    [implements IFace1, ..., IFaceK]
{
    Member1; ... MemberI;
    SuperNew;
    MemberI+1; ... MemberJ;
    Exports;
}

This defines a mixin called MixinName.  This mixin consumes a class with
selftype ParentIFace and produces one with selftype SelfIFace.  The parent class
must have the initialization arguments listed after ParentIFace.  These
arguments are supplied by the new class's initialization.  The new class
provides interfaces IFace1 through IFaceK for clients and interface SelfIFace
(its selftype) for further mixins.

The new class introduces the arguments listed after MixinName as well as all
init fields declared in the members (Member1 through MemberJ).  All init
arguments, whether declared in the header or the body of the mixin definition,
are both initialization arguments to the new class and fields usable within
the body of the class.  Init field declarations in the body may include default
values.  All other initialization arguments to the new class are passed on to
its superclass initializer.

Member definitions include fields, init fields, and methods, and exactly one
call to the superclass initializer; as mentioned above, init arguments are also
implicit field definitions.  Export declarations define a mapping from exported
names to internal member names.
