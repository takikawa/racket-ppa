#lang racket/base
(require "test-util.rkt")

(parameterize ([current-contract-namespace
                (make-basic-contract-namespace
                 'racket/class)])

  (define (test-flat-contract contract pass fail)
    (contract-eval `(,test #t flat-contract? ,contract))
    (define (run-two-tests maybe-rewrite)
      (let ([name (if (pair? contract)
                      (car contract)
                      contract)])
        (let/ec k
          (test/spec-failed (format "~a fail" name)
                            (maybe-rewrite `(contract ,contract ',fail 'pos 'neg) k)
                            'pos))
        (let/ec k
          (test/spec-passed/result
           (format "~a pass" name)
           (maybe-rewrite `(contract ,contract ',pass 'pos 'neg) k)
           pass))))
    (run-two-tests (位 (x k) x))
    (run-two-tests rewrite-to-add-opt/c))
  
  (define flat-contract-predicate (contract-eval 'flat-contract-predicate))
  
  (test-flat-contract '(and/c number? integer?) 1 3/2)
  (test-flat-contract '(not/c integer?) #t 1)
  (test-flat-contract '(=/c 2) 2 3)
  (test-flat-contract '(>/c 5) 10 5)
  (test-flat-contract '(>=/c 5) 5 0)
  (test-flat-contract '(<=/c 5) 5 10)
  (test-flat-contract '(</c 5) 0 5)
  (test-flat-contract '(=/c 2) 2 0+1i)
  (test-flat-contract '(>/c 5) 10 0+1i)
  (test-flat-contract '(>=/c 5) 5 0+1i)
  (test-flat-contract '(<=/c 5) 5 0+1i)
  (test-flat-contract '(</c 5) 0 0+1i)
  (test-flat-contract '(integer-in 0 10) 0 11)
  (test-flat-contract '(integer-in 0 10) 10 3/2)
  (test-flat-contract '(integer-in 0 10) 1 1.0)
  (test-flat-contract '(real-in 1 10) 3/2 20)
  (test-flat-contract '(string-len/c 3) "ab" "abc")
  (test-flat-contract 'natural-number/c 5 -1)
  (test-flat-contract 'natural-number/c #e3 #i3.0)
  (test-flat-contract 'natural-number/c 0 -1)
  (test-flat-contract 'false/c #f #t)
  (test-flat-contract 'contract? #f (位 (x y) 'whatever))
  
  (test-flat-contract #t #t "x")
  (test-flat-contract #f #f "x")
  (test-flat-contract #\a #\a #\b)
  (test-flat-contract #\a #\a 'a)
  (test-flat-contract ''a 'a 'b)
  (test-flat-contract ''a 'a #\a)
  (test-flat-contract "x" "x" "y")
  (test-flat-contract "x" "x" 'x)
  (test-flat-contract 1 1 2)
  (test-flat-contract #e1 #i1.0 'x)
  (test-flat-contract #rx".x." "axq" "x")
  (test-flat-contract #rx#".x." #"axq" #"x")
  (test-flat-contract #rx".x." #"axq" #"x")
  (test-flat-contract #rx#".x." "axq" "x")
  (test-flat-contract ''() '() #f)

  (test/spec-passed 'any/c '(contract any/c 1 'pos 'neg))
  (test-flat-contract 'printable/c (vector (cons 1 (box #f))) (lambda (x) x))
  (let ()
    (define-struct s (a b) #:prefab)
    (test-flat-contract 'printable/c (make-s 1 2) (位 (x) x)))
  (test-flat-contract 'printable/c (hash 'x 1) (make-hash (list (cons 'x 1))))
  (test-flat-contract 'printable/c 1 (hash (位 (x) x) 1))
  
  (test-flat-contract '(symbols 'a 'b 'c) 'a 'd)
  (test-flat-contract '(one-of/c (expt 2 65)) (expt 2 65) 12)
  (test-flat-contract '(one-of/c '#:x '#:z) '#:x '#:y)

  (let ([c% (contract-eval '(class object% (super-new)))])
    (test-flat-contract `(subclass?/c ,c%) c% (contract-eval `object%))
    (test-flat-contract `(subclass?/c ,c%)
                        (contract-eval `(class ,c%)) (contract-eval `(class object%))))

  (let ([i<%> (contract-eval '(interface ()))])
    (test-flat-contract `(implementation?/c ,i<%>)
                        (contract-eval `(class* object% (,i<%>) (super-new)))
                        (contract-eval 'object%))
    (test-flat-contract `(implementation?/c ,i<%>)
                        (contract-eval `(class* object% (,i<%>) (super-new)))
                        #f))

  (begin
    (contract-eval '(define flat-is-a-test<%> (interface ())))
    (contract-eval '(define flat-is-a-test% (class object% (super-new))))
    (test-flat-contract `(is-a?/c flat-is-a-test<%>)
                        (contract-eval `(new (class* object% (flat-is-a-test<%>) (super-new))))
                        (contract-eval '(new object%)))
    (test-flat-contract `(is-a?/c flat-is-a-test%)
                        (contract-eval `(new flat-is-a-test%))
                        (contract-eval '(new object%)))
    (test-flat-contract `(or/c #f (is-a?/c flat-is-a-test<%>))
                        (contract-eval `(new (class* object% (flat-is-a-test<%>) (super-new))))
                        (contract-eval '(new object%)))
    (test-flat-contract `(or/c #f (is-a?/c flat-is-a-test%))
                        (contract-eval `(new flat-is-a-test%))
                        (contract-eval '(new object%))))

  (test-flat-contract '(listof boolean?) (list #t #f) (list #f 3 #t))
  (test-flat-contract '(listof any/c) (list #t #f) 3)

  (test-flat-contract '(vectorof boolean? #:flat? #t) (vector #t #f) (vector #f 3 #t))
  (test-flat-contract '(vectorof any/c #:flat? #t) (vector #t #f) 3)
  (test-flat-contract '(vector-immutableof boolean?) 
                      (vector-immutable #t #f)
                      (vector-immutable #f 3 #t))
  (test-flat-contract '(vector-immutableof any/c) (vector-immutable #t #f) 3)

  (test-flat-contract '(vector/c boolean? (flat-contract integer?) #:flat? #t)
                      (vector #t 1)
                      (vector 1 #f))
  (test-flat-contract '(vector/c boolean? (flat-contract integer?) #:flat? #t) (vector #t 1) #f)
  (test-flat-contract '(vector-immutable/c boolean? (flat-contract integer?))
                      (vector-immutable #t 1) (vector-immutable 1 #f))
  (test-flat-contract '(vector-immutable/c boolean? (flat-contract integer?))
                      (vector-immutable #t 1)
                      #f)

  (test-flat-contract '(cons/c boolean? (flat-contract integer?)) (cons #t 1) (cons 1 #f))
  (test-flat-contract '(cons/c boolean? (flat-contract integer?)) (cons #t 1) #f)
  (test-flat-contract '(list/c boolean? (flat-contract integer?)) (list #t 1) (list 1 #f))
  (test-flat-contract '(list/c boolean? (flat-contract integer?)) (list #t 1) #f)

  (contract-eval '(define (a-predicate-that-wont-be-optimized x) (boolean? x)))
  (test-flat-contract '(cons/c a-predicate-that-wont-be-optimized (flat-contract integer?))
                      (cons #t 1)
                      (cons 1 #f))
  (test-flat-contract '(cons/c a-predicate-that-wont-be-optimized (flat-contract integer?))
                      (cons #t 1)
                      #f)
  (test-flat-contract '(list/c a-predicate-that-wont-be-optimized (flat-contract integer?))
                      (list #t 1)
                      (list 1 #f))
  (test-flat-contract '(list/c a-predicate-that-wont-be-optimized (flat-contract integer?))
                      (list #t 1)
                      #f)

  (test-flat-contract '(box/c boolean? #:flat? #t) (box #f) (box 1))
  (test-flat-contract '(box/c (flat-contract boolean?) #:flat? #t) (box #t) #f)
  (test-flat-contract '(box-immutable/c boolean?) (box-immutable #f) (box-immutable 1))
  (test-flat-contract '(box-immutable/c (flat-contract boolean?)) (box-immutable #t) #f)

  (test-flat-contract '(flat-rec-contract sexp (cons/c sexp sexp) number?) '(1 2 . 3) '(1 . #f))
  (test-flat-contract '(flat-murec-contract ([even1 (or/c null? (cons/c number? even2))]
                                             [even2 (cons/c number? even1)])
                                            even1)
                      '(1 2 3 4)
                      '(1 2 3))

  (test-flat-contract '(hash/c symbol? boolean? #:flat? #t) (make-hash) 1)
  (test-flat-contract '(hash/c symbol? boolean? #:flat? #t)
                      (let ([ht (make-hash)])
                        (hash-set! ht 'x #t)
                        ht)
                      (let ([ht (make-hash)])
                        (hash-set! ht 'x 1)
                        ht))
  (test-flat-contract '(hash/c symbol? boolean? #:flat? #t)
                      (let ([ht (make-hash)])
                        (hash-set! ht 'x #t)
                        ht)
                      (let ([ht (make-hash)])
                        (hash-set! ht 'x 1)
                        ht))
  
  (test-flat-contract '(between/c 1 10) 3 11)
  (test-flat-contract '(between/c 1 10) 4 1+1i)
  (test-flat-contract '(<=/c 1) 0 1+1i)
  (test-flat-contract '(</c 1) 0 1+1i)
  (test-flat-contract '(>/c 1) 4 1+1i)
  (test-flat-contract '(>=/c 1) 4 1+1i)
  
  (test #t 'malformed-binder
        (with-handlers ((exn? exn:fail:syntax?))
          (contract-eval '(flat-murec-contract ([(x) y]) x))
          'no-err))
  (test #t 'missing-body
        (with-handlers ((exn? exn:fail:syntax?))
          (contract-eval '(flat-murec-contract ([x y])))
          'no-err))

  (test-flat-contract '(or/c (flat-contract integer?) char?) #\a #t)
  (test-flat-contract '(or/c (flat-contract integer?) char?) 1 #t)

  
  ;; test flat-contract-predicate
  (test #t (flat-contract-predicate integer?) 1)
  (test #t (flat-contract-predicate #t) #t))