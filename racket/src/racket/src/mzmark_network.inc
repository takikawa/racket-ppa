/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int mark_listener_SIZE(void *p, struct NewGC *gc) {
  listener_t *l = (listener_t *)p;

  return
  gcBYTES_TO_WORDS(sizeof(listener_t) + ((l->count - mzFLEX_DELTA) * sizeof(tcp_t)));
}

static int mark_listener_MARK(void *p, struct NewGC *gc) {
  listener_t *l = (listener_t *)p;


  gcMARK2(l->mref, gc);
# ifdef HAVE_POLL_SYSCALL
  gcMARK2(l->pfd, gc);
# endif

  return
  gcBYTES_TO_WORDS(sizeof(listener_t) + ((l->count - mzFLEX_DELTA) * sizeof(tcp_t)));
}

static int mark_listener_FIXUP(void *p, struct NewGC *gc) {
  listener_t *l = (listener_t *)p;


  gcFIXUP2(l->mref, gc);
# ifdef HAVE_POLL_SYSCALL
  gcFIXUP2(l->pfd, gc);
# endif

  return
  gcBYTES_TO_WORDS(sizeof(listener_t) + ((l->count - mzFLEX_DELTA) * sizeof(tcp_t)));
}

#define mark_listener_IS_ATOMIC 0
#define mark_listener_IS_CONST_SIZE 0


#ifdef USE_TCP
static int mark_tcp_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Tcp));
}

static int mark_tcp_MARK(void *p, struct NewGC *gc) {
  Scheme_Tcp *tcp = (Scheme_Tcp *)p;

  gcMARK2(tcp->b.buffer, gc);
  gcMARK2(tcp->b.out_buffer, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Tcp));
}

static int mark_tcp_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Tcp *tcp = (Scheme_Tcp *)p;

  gcFIXUP2(tcp->b.buffer, gc);
  gcFIXUP2(tcp->b.out_buffer, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Tcp));
}

#define mark_tcp_IS_ATOMIC 0
#define mark_tcp_IS_CONST_SIZE 1


# ifdef UDP_IS_SUPPORTED
static int mark_udp_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP));
}

static int mark_udp_MARK(void *p, struct NewGC *gc) {
  Scheme_UDP *udp = (Scheme_UDP *)p;

  gcMARK2(udp->previous_from_addr, gc);
  gcMARK2(udp->mref, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP));
}

static int mark_udp_FIXUP(void *p, struct NewGC *gc) {
  Scheme_UDP *udp = (Scheme_UDP *)p;

  gcFIXUP2(udp->previous_from_addr, gc);
  gcFIXUP2(udp->mref, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP));
}

#define mark_udp_IS_ATOMIC 0
#define mark_udp_IS_CONST_SIZE 1


static int mark_udp_evt_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP_Evt));
}

static int mark_udp_evt_MARK(void *p, struct NewGC *gc) {
  Scheme_UDP_Evt *uw = (Scheme_UDP_Evt *)p;

  gcMARK2(uw->udp, gc);
  gcMARK2(uw->str, gc);
  gcMARK2(uw->dest_addr, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP_Evt));
}

static int mark_udp_evt_FIXUP(void *p, struct NewGC *gc) {
  Scheme_UDP_Evt *uw = (Scheme_UDP_Evt *)p;

  gcFIXUP2(uw->udp, gc);
  gcFIXUP2(uw->str, gc);
  gcFIXUP2(uw->dest_addr, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP_Evt));
}

#define mark_udp_evt_IS_ATOMIC 0
#define mark_udp_evt_IS_CONST_SIZE 1

# endif
#endif

