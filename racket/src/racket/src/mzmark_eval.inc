/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int mark_comp_info_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compile_Info));
}

static int mark_comp_info_MARK(void *p, struct NewGC *gc) {
  Scheme_Compile_Info *i = (Scheme_Compile_Info *)p;
  
  gcMARK2(i->value_name, gc);
  gcMARK2(i->observer, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compile_Info));
}

static int mark_comp_info_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Compile_Info *i = (Scheme_Compile_Info *)p;
  
  gcFIXUP2(i->value_name, gc);
  gcFIXUP2(i->observer, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compile_Info));
}

#define mark_comp_info_IS_ATOMIC 0
#define mark_comp_info_IS_CONST_SIZE 1


static int mark_saved_stack_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Saved_Stack));
}

static int mark_saved_stack_MARK(void *p, struct NewGC *gc) {
  Scheme_Saved_Stack *saved = (Scheme_Saved_Stack *)p;
  
  gcMARK2(saved->prev, gc);
  gcMARK2(saved->runstack_start, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Saved_Stack));
}

static int mark_saved_stack_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Saved_Stack *saved = (Scheme_Saved_Stack *)p;
  
  gcFIXUP2(saved->prev, gc);
  gcFIXUP2(saved->runstack_start, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Saved_Stack));
}

#define mark_saved_stack_IS_ATOMIC 0
#define mark_saved_stack_IS_CONST_SIZE 1


