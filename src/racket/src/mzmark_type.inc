/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int variable_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
}

static int variable_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcMARK2(b->key, gc);
  gcMARK2(b->val, gc);
  gcMARK2(((Scheme_Bucket_With_Home *)b)->home_link, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
}

static int variable_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcFIXUP2(b->key, gc);
  gcFIXUP2(b->val, gc);
  gcFIXUP2(((Scheme_Bucket_With_Home *)b)->home_link, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
}

#define variable_obj_IS_ATOMIC 0
#define variable_obj_IS_CONST_SIZE 1


static int module_var_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Module_Variable));
}

static int module_var_MARK(void *p, struct NewGC *gc) {
  Module_Variable *mv = (Module_Variable *)p;

  gcMARK2(mv->modidx, gc);
  gcMARK2(mv->sym, gc);
  gcMARK2(mv->insp, gc);
  gcMARK2(mv->shape, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Module_Variable));
}

static int module_var_FIXUP(void *p, struct NewGC *gc) {
  Module_Variable *mv = (Module_Variable *)p;

  gcFIXUP2(mv->modidx, gc);
  gcFIXUP2(mv->sym, gc);
  gcFIXUP2(mv->insp, gc);
  gcFIXUP2(mv->shape, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Module_Variable));
}

#define module_var_IS_ATOMIC 0
#define module_var_IS_CONST_SIZE 1


static int bucket_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
}

static int bucket_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcMARK2(b->key, gc);
  gcMARK2(b->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
}

static int bucket_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcFIXUP2(b->key, gc);
  gcFIXUP2(b->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
}

#define bucket_obj_IS_ATOMIC 0
#define bucket_obj_IS_CONST_SIZE 1


static int local_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
}

static int local_obj_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
}

static int local_obj_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
}

#define local_obj_IS_ATOMIC 1
#define local_obj_IS_CONST_SIZE 1


static int toplevel_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
}

static int toplevel_obj_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
}

static int toplevel_obj_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
}

#define toplevel_obj_IS_ATOMIC 1
#define toplevel_obj_IS_CONST_SIZE 1


static int quotesyntax_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Quote_Syntax));
}

static int quotesyntax_obj_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Quote_Syntax));
}

static int quotesyntax_obj_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Quote_Syntax));
}

#define quotesyntax_obj_IS_ATOMIC 1
#define quotesyntax_obj_IS_CONST_SIZE 1


static int cpointer_obj_SIZE(void *p, struct NewGC *gc) {
  return
   (SCHEME_CPTR_HAS_OFFSET(p)
    ? gcBYTES_TO_WORDS(sizeof(Scheme_Offset_Cptr))
    : gcBYTES_TO_WORDS(sizeof(Scheme_Cptr)));
}

static int cpointer_obj_MARK(void *p, struct NewGC *gc) {
  if (!(SCHEME_CPTR_FLAGS(p) & 0x1)) {
    gcMARK2(SCHEME_CPTR_VAL(p), gc);
  }
  gcMARK2(SCHEME_CPTR_TYPE(p), gc);
  return
   (SCHEME_CPTR_HAS_OFFSET(p)
    ? gcBYTES_TO_WORDS(sizeof(Scheme_Offset_Cptr))
    : gcBYTES_TO_WORDS(sizeof(Scheme_Cptr)));
}

static int cpointer_obj_FIXUP(void *p, struct NewGC *gc) {
  if (!(SCHEME_CPTR_FLAGS(p) & 0x1)) {
    gcFIXUP2(SCHEME_CPTR_VAL(p), gc);
  }
  gcFIXUP2(SCHEME_CPTR_TYPE(p), gc);
  return
   (SCHEME_CPTR_HAS_OFFSET(p)
    ? gcBYTES_TO_WORDS(sizeof(Scheme_Offset_Cptr))
    : gcBYTES_TO_WORDS(sizeof(Scheme_Cptr)));
}

#define cpointer_obj_IS_ATOMIC 0
#define cpointer_obj_IS_CONST_SIZE 0


static int twoptr_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int twoptr_obj_MARK(void *p, struct NewGC *gc) {
  gcMARK2(SCHEME_PTR1_VAL((Scheme_Object *)p), gc);
  gcMARK2(SCHEME_PTR2_VAL((Scheme_Object *)p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int twoptr_obj_FIXUP(void *p, struct NewGC *gc) {
  gcFIXUP2(SCHEME_PTR1_VAL((Scheme_Object *)p), gc);
  gcFIXUP2(SCHEME_PTR2_VAL((Scheme_Object *)p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define twoptr_obj_IS_ATOMIC 0
#define twoptr_obj_IS_CONST_SIZE 1


static int iptr_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int iptr_obj_MARK(void *p, struct NewGC *gc) {
  gcMARK2(SCHEME_IPTR_VAL((Scheme_Object *)p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int iptr_obj_FIXUP(void *p, struct NewGC *gc) {
  gcFIXUP2(SCHEME_IPTR_VAL((Scheme_Object *)p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define iptr_obj_IS_ATOMIC 0
#define iptr_obj_IS_CONST_SIZE 1


static int small_object_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int small_object_MARK(void *p, struct NewGC *gc) {
  gcMARK2(((Scheme_Small_Object *)p)->u.ptr_value, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int small_object_FIXUP(void *p, struct NewGC *gc) {
  gcFIXUP2(((Scheme_Small_Object *)p)->u.ptr_value, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

#define small_object_IS_ATOMIC 0
#define small_object_IS_CONST_SIZE 1


static int small_atomic_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int small_atomic_obj_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int small_atomic_obj_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

#define small_atomic_obj_IS_ATOMIC 1
#define small_atomic_obj_IS_CONST_SIZE 1


static int app_rec_SIZE(void *p, struct NewGC *gc) {
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + ((r->num_args + 1 - mzFLEX_DELTA) * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
}

static int app_rec_MARK(void *p, struct NewGC *gc) {
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  int i = r->num_args + 1;
  while (i--) 
    gcMARK2(r->args[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + ((r->num_args + 1 - mzFLEX_DELTA) * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
}

static int app_rec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  int i = r->num_args + 1;
  while (i--) 
    gcFIXUP2(r->args[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + ((r->num_args + 1 - mzFLEX_DELTA) * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
}

#define app_rec_IS_ATOMIC 0
#define app_rec_IS_CONST_SIZE 0


static int app2_rec_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
}

static int app2_rec_MARK(void *p, struct NewGC *gc) {
  Scheme_App2_Rec *r = (Scheme_App2_Rec *)p;
  gcMARK2(r->rator, gc);
  gcMARK2(r->rand, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
}

static int app2_rec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_App2_Rec *r = (Scheme_App2_Rec *)p;
  gcFIXUP2(r->rator, gc);
  gcFIXUP2(r->rand, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
}

#define app2_rec_IS_ATOMIC 0
#define app2_rec_IS_CONST_SIZE 1


static int app3_rec_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
}

static int app3_rec_MARK(void *p, struct NewGC *gc) {
  Scheme_App3_Rec *r = (Scheme_App3_Rec *)p;
  gcMARK2(r->rator, gc);
  gcMARK2(r->rand1, gc);
  gcMARK2(r->rand2, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
}

static int app3_rec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_App3_Rec *r = (Scheme_App3_Rec *)p;
  gcFIXUP2(r->rator, gc);
  gcFIXUP2(r->rand1, gc);
  gcFIXUP2(r->rand2, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
}

#define app3_rec_IS_ATOMIC 0
#define app3_rec_IS_CONST_SIZE 1


static int seq_rec_SIZE(void *p, struct NewGC *gc) {
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

static int seq_rec_MARK(void *p, struct NewGC *gc) {
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  int i = s->count;
  while (i--)
    gcMARK2(s->array[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

static int seq_rec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  int i = s->count;
  while (i--)
    gcFIXUP2(s->array[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

#define seq_rec_IS_ATOMIC 0
#define seq_rec_IS_CONST_SIZE 0


static int branch_rec_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
}

static int branch_rec_MARK(void *p, struct NewGC *gc) {
  Scheme_Branch_Rec *b = (Scheme_Branch_Rec *)p;
  
  gcMARK2(b->test, gc);
  gcMARK2(b->tbranch, gc);
  gcMARK2(b->fbranch, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
}

static int branch_rec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Branch_Rec *b = (Scheme_Branch_Rec *)p;
  
  gcFIXUP2(b->test, gc);
  gcFIXUP2(b->tbranch, gc);
  gcFIXUP2(b->fbranch, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
}

#define branch_rec_IS_ATOMIC 0
#define branch_rec_IS_CONST_SIZE 1


static int unclosed_proc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Closure_Data));
}

static int unclosed_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Closure_Data *d = (Scheme_Closure_Data *)p;

  gcMARK2(d->name, gc);
  gcMARK2(d->code, gc);
  gcMARK2(d->closure_map, gc);
  gcMARK2(d->tl_map, gc);
#ifdef MZ_USE_JIT
  gcMARK2(d->u.native_code, gc);
  gcMARK2(d->context, gc);
#endif

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Closure_Data));
}

static int unclosed_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Closure_Data *d = (Scheme_Closure_Data *)p;

  gcFIXUP2(d->name, gc);
  gcFIXUP2(d->code, gc);
  gcFIXUP2(d->closure_map, gc);
  gcFIXUP2(d->tl_map, gc);
#ifdef MZ_USE_JIT
  gcFIXUP2(d->u.native_code, gc);
  gcFIXUP2(d->context, gc);
#endif

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Closure_Data));
}

#define unclosed_proc_IS_ATOMIC 0
#define unclosed_proc_IS_CONST_SIZE 1


static int let_value_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
}

static int let_value_MARK(void *p, struct NewGC *gc) {
  Scheme_Let_Value *l = (Scheme_Let_Value *)p;
  
  gcMARK2(l->value, gc);
  gcMARK2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
}

static int let_value_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Let_Value *l = (Scheme_Let_Value *)p;
  
  gcFIXUP2(l->value, gc);
  gcFIXUP2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
}

#define let_value_IS_ATOMIC 0
#define let_value_IS_CONST_SIZE 1


static int let_void_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
}

static int let_void_MARK(void *p, struct NewGC *gc) {
  Scheme_Let_Void *l = (Scheme_Let_Void *)p;

  gcMARK2(l->body, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
}

static int let_void_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Let_Void *l = (Scheme_Let_Void *)p;

  gcFIXUP2(l->body, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
}

#define let_void_IS_ATOMIC 0
#define let_void_IS_CONST_SIZE 1


static int letrec_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
}

static int letrec_MARK(void *p, struct NewGC *gc) {
  Scheme_Letrec *l = (Scheme_Letrec *)p;
  
  gcMARK2(l->procs, gc);
  gcMARK2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
}

static int letrec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Letrec *l = (Scheme_Letrec *)p;
  
  gcFIXUP2(l->procs, gc);
  gcFIXUP2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
}

#define letrec_IS_ATOMIC 0
#define letrec_IS_CONST_SIZE 1


static int let_one_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
}

static int let_one_MARK(void *p, struct NewGC *gc) {
  Scheme_Let_One *l = (Scheme_Let_One *)p;
  
  gcMARK2(l->value, gc);
  gcMARK2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
}

static int let_one_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Let_One *l = (Scheme_Let_One *)p;
  
  gcFIXUP2(l->value, gc);
  gcFIXUP2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
}

#define let_one_IS_ATOMIC 0
#define let_one_IS_CONST_SIZE 1


static int with_cont_mark_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
}

static int with_cont_mark_MARK(void *p, struct NewGC *gc) {
  Scheme_With_Continuation_Mark *w = (Scheme_With_Continuation_Mark *)p;

  gcMARK2(w->key, gc);
  gcMARK2(w->val, gc);
  gcMARK2(w->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
}

static int with_cont_mark_FIXUP(void *p, struct NewGC *gc) {
  Scheme_With_Continuation_Mark *w = (Scheme_With_Continuation_Mark *)p;

  gcFIXUP2(w->key, gc);
  gcFIXUP2(w->val, gc);
  gcFIXUP2(w->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
}

#define with_cont_mark_IS_ATOMIC 0
#define with_cont_mark_IS_CONST_SIZE 1


static int comp_let_value_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compiled_Let_Value));
}

static int comp_let_value_MARK(void *p, struct NewGC *gc) {
  Scheme_Compiled_Let_Value *c = (Scheme_Compiled_Let_Value *)p;

  gcMARK2(c->flags, gc);
  gcMARK2(c->value, gc);
  gcMARK2(c->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compiled_Let_Value));
}

static int comp_let_value_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Compiled_Let_Value *c = (Scheme_Compiled_Let_Value *)p;

  gcFIXUP2(c->flags, gc);
  gcFIXUP2(c->value, gc);
  gcFIXUP2(c->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compiled_Let_Value));
}

#define comp_let_value_IS_ATOMIC 0
#define comp_let_value_IS_CONST_SIZE 1


static int let_header_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Header));
}

static int let_header_MARK(void *p, struct NewGC *gc) {
  Scheme_Let_Header *h = (Scheme_Let_Header *)p;
  
  gcMARK2(h->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Header));
}

static int let_header_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Let_Header *h = (Scheme_Let_Header *)p;
  
  gcFIXUP2(h->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Header));
}

#define let_header_IS_ATOMIC 0
#define let_header_IS_CONST_SIZE 1


static int set_bang_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Set_Bang));
}

static int set_bang_MARK(void *p, struct NewGC *gc) {
  Scheme_Set_Bang *b = (Scheme_Set_Bang *)p;
  
  gcMARK2(b->var, gc);
  gcMARK2(b->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Set_Bang));
}

static int set_bang_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Set_Bang *b = (Scheme_Set_Bang *)p;
  
  gcFIXUP2(b->var, gc);
  gcFIXUP2(b->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Set_Bang));
}

#define set_bang_IS_ATOMIC 0
#define set_bang_IS_CONST_SIZE 1


static int prim_proc_SIZE(void *p, struct NewGC *gc) {
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  return
  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - mzFLEX_DELTA)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
}

static int prim_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  gcMARK2(prim->name, gc);
  if (prim->mina < 0) {
    gcMARK2(prim->mu.cases, gc);
  }
  if (prim->pp.flags & SCHEME_PRIM_IS_CLOSURE) {
    Scheme_Primitive_Closure *cc = (Scheme_Primitive_Closure *)prim;
    int i;
    for (i = cc->count; i--; ) {
      gcMARK2(cc->val[i], gc);
    }
  }  
  
  return
  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - mzFLEX_DELTA)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
}

static int prim_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  gcFIXUP2(prim->name, gc);
  if (prim->mina < 0) {
    gcFIXUP2(prim->mu.cases, gc);
  }
  if (prim->pp.flags & SCHEME_PRIM_IS_CLOSURE) {
    Scheme_Primitive_Closure *cc = (Scheme_Primitive_Closure *)prim;
    int i;
    for (i = cc->count; i--; ) {
      gcFIXUP2(cc->val[i], gc);
    }
  }  
  
  return
  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - mzFLEX_DELTA)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
}

#define prim_proc_IS_ATOMIC 0
#define prim_proc_IS_CONST_SIZE 0


static int closed_prim_proc_SIZE(void *p, struct NewGC *gc) {
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  return
  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
}

static int closed_prim_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  gcMARK2(c->name, gc);
  gcMARK2(SCHEME_CLSD_PRIM_DATA(c), gc);
  if (c->mina == -2) {
    gcMARK2(((Scheme_Closed_Case_Primitive_Proc *)c)->cases, gc);
  }
  
  return
  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
}

static int closed_prim_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  gcFIXUP2(c->name, gc);
  gcFIXUP2(SCHEME_CLSD_PRIM_DATA(c), gc);
  if (c->mina == -2) {
    gcFIXUP2(((Scheme_Closed_Case_Primitive_Proc *)c)->cases, gc);
  }
  
  return
  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
}

#define closed_prim_proc_IS_ATOMIC 0
#define closed_prim_proc_IS_CONST_SIZE 0


static int scm_closure_SIZE(void *p, struct NewGC *gc) {
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = (c->code 
                      ? ((Scheme_Closure_Data *)GC_resolve2(c->code, gc))->closure_size
                      : 0);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - mzFLEX_DELTA) * sizeof(Scheme_Object *)));
}

static int scm_closure_MARK(void *p, struct NewGC *gc) {
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = (c->code 
                      ? ((Scheme_Closure_Data *)GC_resolve2(c->code, gc))->closure_size
                      : 0);


  int i = closure_size;
# define CLOSURE_DATA_TYPE Scheme_Closure_Data
# include "mzclpf_decl.inc"

  gcMARK2(c->code, gc);

# include "mzclpf_pre.inc"

  while (i--)
    gcMARK2(c->vals[i], gc);

# include "mzclpf_post.inc"
# undef CLOSURE_DATA_TYPE
  
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - mzFLEX_DELTA) * sizeof(Scheme_Object *)));
}

static int scm_closure_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = (c->code 
                      ? ((Scheme_Closure_Data *)GC_resolve2(c->code, gc))->closure_size
                      : 0);


  int i = closure_size;

  gcFIXUP2(c->code, gc);


  while (i--)
    gcFIXUP2(c->vals[i], gc);

  
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - mzFLEX_DELTA) * sizeof(Scheme_Object *)));
}

#define scm_closure_IS_ATOMIC 0
#define scm_closure_IS_CONST_SIZE 0


static int case_closure_SIZE(void *p, struct NewGC *gc) {
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

static int case_closure_MARK(void *p, struct NewGC *gc) {
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  int i;
  
  for (i = c->count; i--; )
    gcMARK2(c->array[i], gc);
  gcMARK2(c->name, gc);
#ifdef MZ_USE_JIT
  gcMARK2(c->native_code, gc);
#endif

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

static int case_closure_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  int i;
  
  for (i = c->count; i--; )
    gcFIXUP2(c->array[i], gc);
  gcFIXUP2(c->name, gc);
#ifdef MZ_USE_JIT
  gcFIXUP2(c->native_code, gc);
#endif

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

#define case_closure_IS_ATOMIC 0
#define case_closure_IS_CONST_SIZE 0


static int cont_proc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
}

static int cont_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Cont *c = (Scheme_Cont *)p;
  
  gcMARK2(c->dw, gc);
  gcMARK2(c->prompt_tag, gc);
  gcMARK2(c->meta_continuation, gc);
  gcMARK2(c->common_dw, gc);
  gcMARK2(c->save_overflow, gc);
  gcMARK2(c->runstack_copied, gc);
  gcMARK2(c->runstack_owner, gc);
  gcMARK2(c->cont_mark_stack_copied, gc);
  gcMARK2(c->cont_mark_stack_owner, gc);
  gcMARK2(c->init_config, gc);
  gcMARK2(c->init_break_cell, gc);
#ifdef MZ_USE_JIT
  gcMARK2(c->native_trace, gc);
#endif

  gcMARK2(c->buf_ptr, gc);
  MARK_cjs(&c->cjs, gc);
  MARK_stack_state(&c->ss, gc);
  gcMARK2(c->barrier_prompt, gc);
  if (!GC_merely_accounting()) {
    gcMARK2(c->runstack_start, gc);
    gcMARK2(c->runstack_saved, gc);
  }

  gcMARK2(c->prompt_id, gc);
  gcMARK2(c->prompt_buf, gc);

  gcMARK2(c->escape_cont, gc);

  gcMARK2(c->value, gc);
  gcMARK2(c->resume_to, gc);
  gcMARK2(c->use_next_cont, gc);
  gcMARK2(c->extra_marks, gc);
  gcMARK2(c->shortcut_prompt, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
}

static int cont_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Cont *c = (Scheme_Cont *)p;
  
  gcFIXUP2(c->dw, gc);
  gcFIXUP2(c->prompt_tag, gc);
  gcFIXUP2(c->meta_continuation, gc);
  gcFIXUP2(c->common_dw, gc);
  gcFIXUP2(c->save_overflow, gc);
  gcFIXUP2(c->runstack_copied, gc);
  gcFIXUP2(c->runstack_owner, gc);
  gcFIXUP2(c->cont_mark_stack_copied, gc);
  gcFIXUP2(c->cont_mark_stack_owner, gc);
  gcFIXUP2(c->init_config, gc);
  gcFIXUP2(c->init_break_cell, gc);
#ifdef MZ_USE_JIT
  gcFIXUP2(c->native_trace, gc);
#endif

  gcFIXUP2(c->buf_ptr, gc);
  FIXUP_cjs(&c->cjs, gc);
  FIXUP_stack_state(&c->ss, gc);
  gcFIXUP2(c->barrier_prompt, gc);
  if (!GC_merely_accounting()) {
    gcFIXUP2(c->runstack_start, gc);
    gcFIXUP2(c->runstack_saved, gc);
  }

  gcFIXUP2(c->prompt_id, gc);
  gcFIXUP2(c->prompt_buf, gc);

  gcFIXUP2(c->escape_cont, gc);

  gcFIXUP2(c->value, gc);
  gcFIXUP2(c->resume_to, gc);
  gcFIXUP2(c->use_next_cont, gc);
  gcFIXUP2(c->extra_marks, gc);
  gcFIXUP2(c->shortcut_prompt, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
}

#define cont_proc_IS_ATOMIC 0
#define cont_proc_IS_CONST_SIZE 1


static int cont_jmp_proc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Jmp));
}

static int cont_jmp_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Cont_Jmp *c = (Scheme_Cont_Jmp *)p;

  MARK_jmpup(&c->buf, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Jmp));
}

static int cont_jmp_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Cont_Jmp *c = (Scheme_Cont_Jmp *)p;

  FIXUP_jmpup(&c->buf, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Jmp));
}

#define cont_jmp_proc_IS_ATOMIC 0
#define cont_jmp_proc_IS_CONST_SIZE 1


static int meta_cont_proc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Meta_Continuation));
}

static int meta_cont_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Meta_Continuation *c = (Scheme_Meta_Continuation *)p;
  
  gcMARK2(c->prompt_tag, gc);
  gcMARK2(c->overflow, gc);
  gcMARK2(c->next, gc);
  gcMARK2(c->cont_mark_stack_copied, gc);
  gcMARK2(c->cont, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Meta_Continuation));
}

static int meta_cont_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Meta_Continuation *c = (Scheme_Meta_Continuation *)p;
  
  gcFIXUP2(c->prompt_tag, gc);
  gcFIXUP2(c->overflow, gc);
  gcFIXUP2(c->next, gc);
  gcFIXUP2(c->cont_mark_stack_copied, gc);
  gcFIXUP2(c->cont, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Meta_Continuation));
}

#define meta_cont_proc_IS_ATOMIC 0
#define meta_cont_proc_IS_CONST_SIZE 1


static int mark_dyn_wind_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
}

static int mark_dyn_wind_MARK(void *p, struct NewGC *gc) {
  Scheme_Dynamic_Wind *dw = (Scheme_Dynamic_Wind *)p;
  
  gcMARK2(dw->id, gc);
  gcMARK2(dw->data, gc);
  gcMARK2(dw->prompt_tag, gc);
  gcMARK2(dw->prev, gc);
    
  MARK_stack_state(&dw->envss, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
}

static int mark_dyn_wind_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Dynamic_Wind *dw = (Scheme_Dynamic_Wind *)p;
  
  gcFIXUP2(dw->id, gc);
  gcFIXUP2(dw->data, gc);
  gcFIXUP2(dw->prompt_tag, gc);
  gcFIXUP2(dw->prev, gc);
    
  FIXUP_stack_state(&dw->envss, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
}

#define mark_dyn_wind_IS_ATOMIC 0
#define mark_dyn_wind_IS_CONST_SIZE 1


static int mark_overflow_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
}

static int mark_overflow_MARK(void *p, struct NewGC *gc) {
  Scheme_Overflow *o = (Scheme_Overflow *)p;

  gcMARK2(o->prev, gc);
  gcMARK2(o->jmp, gc);
  gcMARK2(o->id, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
}

static int mark_overflow_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Overflow *o = (Scheme_Overflow *)p;

  gcFIXUP2(o->prev, gc);
  gcFIXUP2(o->jmp, gc);
  gcFIXUP2(o->id, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
}

#define mark_overflow_IS_ATOMIC 0
#define mark_overflow_IS_CONST_SIZE 1


static int mark_overflow_jmp_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow_Jmp));
}

static int mark_overflow_jmp_MARK(void *p, struct NewGC *gc) {
  Scheme_Overflow_Jmp *o = (Scheme_Overflow_Jmp *)p;

  MARK_jmpup(&o->cont, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow_Jmp));
}

static int mark_overflow_jmp_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Overflow_Jmp *o = (Scheme_Overflow_Jmp *)p;

  FIXUP_jmpup(&o->cont, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow_Jmp));
}

#define mark_overflow_jmp_IS_ATOMIC 0
#define mark_overflow_jmp_IS_CONST_SIZE 1


static int escaping_cont_proc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
}

static int escaping_cont_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Escaping_Cont *c = (Scheme_Escaping_Cont *)p;

#ifdef MZ_USE_JIT
  gcMARK2(c->native_trace, gc);
#endif

  gcMARK2(c->barrier_prompt, gc);
  MARK_stack_state(&c->envss, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
}

static int escaping_cont_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Escaping_Cont *c = (Scheme_Escaping_Cont *)p;

#ifdef MZ_USE_JIT
  gcFIXUP2(c->native_trace, gc);
#endif

  gcFIXUP2(c->barrier_prompt, gc);
  FIXUP_stack_state(&c->envss, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
}

#define escaping_cont_proc_IS_ATOMIC 0
#define escaping_cont_proc_IS_CONST_SIZE 1


static int bignum_obj_SIZE(void *p, struct NewGC *gc) {
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  return
  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
}

static int bignum_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  if (!SCHEME_BIGINLINE(b)) {
    gcMARK2(b->digits, gc);
  } else {
    
  }

  return
  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
}

static int bignum_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  if (!SCHEME_BIGINLINE(b)) {
    gcFIXUP2(b->digits, gc);
  } else {
    b->digits = ((Small_Bignum *)GC_fixup_self(b))->v;
  }

  return
  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
}

#define bignum_obj_IS_ATOMIC 0
#define bignum_obj_IS_CONST_SIZE 0


static int rational_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
}

static int rational_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Rational *r = (Scheme_Rational *)p;
  
  gcMARK2(r->num, gc);
  gcMARK2(r->denom, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
}

static int rational_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Rational *r = (Scheme_Rational *)p;
  
  gcFIXUP2(r->num, gc);
  gcFIXUP2(r->denom, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
}

#define rational_obj_IS_ATOMIC 0
#define rational_obj_IS_CONST_SIZE 1


static int float_obj_SIZE(void *p, struct NewGC *gc) {
  return
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
}

static int float_obj_MARK(void *p, struct NewGC *gc) {
  return
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
}

static int float_obj_FIXUP(void *p, struct NewGC *gc) {
  return
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
}

#define float_obj_IS_ATOMIC 1
#define float_obj_IS_CONST_SIZE 0


static int double_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
}

static int double_obj_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
}

static int double_obj_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
}

#define double_obj_IS_ATOMIC 1
#define double_obj_IS_CONST_SIZE 1


#ifdef MZ_LONG_DOUBLE
static int long_double_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
}

static int long_double_obj_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
}

static int long_double_obj_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
}

#define long_double_obj_IS_ATOMIC 1
#define long_double_obj_IS_CONST_SIZE 1

#else
static int long_double_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
}

static int long_double_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Long_Double *ld = (Scheme_Long_Double *)p;
  gcMARK2(ld->printed_form, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
}

static int long_double_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Long_Double *ld = (Scheme_Long_Double *)p;
  gcFIXUP2(ld->printed_form, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Long_Double));
}

#define long_double_obj_IS_ATOMIC 0
#define long_double_obj_IS_CONST_SIZE 1

#endif

static int complex_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
}

static int complex_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Complex *c = (Scheme_Complex *)p;
  
  gcMARK2(c->r, gc);
  gcMARK2(c->i, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
}

static int complex_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Complex *c = (Scheme_Complex *)p;
  
  gcFIXUP2(c->r, gc);
  gcFIXUP2(c->i, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
}

#define complex_obj_IS_ATOMIC 0
#define complex_obj_IS_CONST_SIZE 1


static int string_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int string_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcMARK2(SCHEME_CHAR_STR_VAL(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int string_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcFIXUP2(SCHEME_CHAR_STR_VAL(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define string_obj_IS_ATOMIC 0
#define string_obj_IS_CONST_SIZE 1


static int bstring_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int bstring_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcMARK2(SCHEME_BYTE_STR_VAL(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int bstring_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcFIXUP2(SCHEME_BYTE_STR_VAL(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define bstring_obj_IS_ATOMIC 0
#define bstring_obj_IS_CONST_SIZE 1


static int symbol_obj_SIZE(void *p, struct NewGC *gc) {
  Scheme_Symbol *s = (Scheme_Symbol *)p;

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + s->len + 1 - mzFLEX4_DELTA);
}

static int symbol_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Symbol *s = (Scheme_Symbol *)p;

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + s->len + 1 - mzFLEX4_DELTA);
}

static int symbol_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Symbol *s = (Scheme_Symbol *)p;

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + s->len + 1 - mzFLEX4_DELTA);
}

#define symbol_obj_IS_ATOMIC 1
#define symbol_obj_IS_CONST_SIZE 0


static int cons_cell_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int cons_cell_MARK(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  
  gcMARK2(SCHEME_CAR(o), gc);
  gcMARK2(SCHEME_CDR(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int cons_cell_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  
  gcFIXUP2(SCHEME_CAR(o), gc);
  gcFIXUP2(SCHEME_CDR(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define cons_cell_IS_ATOMIC 0
#define cons_cell_IS_CONST_SIZE 1


static int vector_obj_SIZE(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

static int vector_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  int i;
  for (i = vec->size; i--; )
    gcMARK2(vec->els[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

static int vector_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  int i;
  for (i = vec->size; i--; )
    gcFIXUP2(vec->els[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

#define vector_obj_IS_ATOMIC 0
#define vector_obj_IS_CONST_SIZE 0


static int fxvector_obj_SIZE(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

static int fxvector_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

static int fxvector_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(Scheme_Object *))));
}

#define fxvector_obj_IS_ATOMIC 1
#define fxvector_obj_IS_CONST_SIZE 0


static int flvector_obj_SIZE(void *p, struct NewGC *gc) {
  Scheme_Double_Vector *vec = (Scheme_Double_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Double_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(double))));
}

static int flvector_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Double_Vector *vec = (Scheme_Double_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Double_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(double))));
}

static int flvector_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Double_Vector *vec = (Scheme_Double_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Double_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(double))));
}

#define flvector_obj_IS_ATOMIC 1
#define flvector_obj_IS_CONST_SIZE 0


#ifdef MZ_LONG_DOUBLE
static int extflvector_obj_SIZE(void *p, struct NewGC *gc) {
  Scheme_Long_Double_Vector *vec = (Scheme_Long_Double_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Long_Double_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(long double))));
}

static int extflvector_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Long_Double_Vector *vec = (Scheme_Long_Double_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Long_Double_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(long double))));
}

static int extflvector_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Long_Double_Vector *vec = (Scheme_Long_Double_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Long_Double_Vector) 
		    + ((vec->size - mzFLEX_DELTA) * sizeof(long double))));
}

#define extflvector_obj_IS_ATOMIC 1
#define extflvector_obj_IS_CONST_SIZE 0

#endif

static int input_port_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
}

static int input_port_MARK(void *p, struct NewGC *gc) {
  Scheme_Input_Port *ip = (Scheme_Input_Port *)p;
  
  gcMARK2(ip->p.position_redirect, gc);
  gcMARK2(ip->sub_type, gc);
  gcMARK2(ip->port_data, gc);
  gcMARK2(ip->name, gc);
  gcMARK2(ip->peeked_read, gc);
  gcMARK2(ip->peeked_write, gc);
  gcMARK2(ip->read_handler, gc);
  gcMARK2(ip->closed_evt, gc);
  gcMARK2(ip->mref, gc);
  gcMARK2(ip->output_half, gc);
  gcMARK2(ip->special, gc);
  gcMARK2(ip->ungotten_special, gc);
  gcMARK2(ip->progress_evt, gc);
  gcMARK2(ip->input_lock, gc);
  gcMARK2(ip->input_giveup, gc);
  gcMARK2(ip->input_extras, gc);
  gcMARK2(ip->input_extras_ready, gc);
  gcMARK2(ip->unless, gc);
  gcMARK2(ip->unless_cache, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
}

static int input_port_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Input_Port *ip = (Scheme_Input_Port *)p;
  
  gcFIXUP2(ip->p.position_redirect, gc);
  gcFIXUP2(ip->sub_type, gc);
  gcFIXUP2(ip->port_data, gc);
  gcFIXUP2(ip->name, gc);
  gcFIXUP2(ip->peeked_read, gc);
  gcFIXUP2(ip->peeked_write, gc);
  gcFIXUP2(ip->read_handler, gc);
  gcFIXUP2(ip->closed_evt, gc);
  gcFIXUP2(ip->mref, gc);
  gcFIXUP2(ip->output_half, gc);
  gcFIXUP2(ip->special, gc);
  gcFIXUP2(ip->ungotten_special, gc);
  gcFIXUP2(ip->progress_evt, gc);
  gcFIXUP2(ip->input_lock, gc);
  gcFIXUP2(ip->input_giveup, gc);
  gcFIXUP2(ip->input_extras, gc);
  gcFIXUP2(ip->input_extras_ready, gc);
  gcFIXUP2(ip->unless, gc);
  gcFIXUP2(ip->unless_cache, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
}

#define input_port_IS_ATOMIC 0
#define input_port_IS_CONST_SIZE 1


static int output_port_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
}

static int output_port_MARK(void *p, struct NewGC *gc) {
  Scheme_Output_Port *op = (Scheme_Output_Port *)p;

  gcMARK2(op->p.position_redirect, gc);
  gcMARK2(op->sub_type, gc);
  gcMARK2(op->port_data, gc);
  gcMARK2(op->name, gc);
  gcMARK2(op->display_handler, gc);
  gcMARK2(op->write_handler, gc);
  gcMARK2(op->print_handler, gc);
  gcMARK2(op->closed_evt, gc);
  gcMARK2(op->mref, gc);
  gcMARK2(op->input_half, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
}

static int output_port_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Output_Port *op = (Scheme_Output_Port *)p;

  gcFIXUP2(op->p.position_redirect, gc);
  gcFIXUP2(op->sub_type, gc);
  gcFIXUP2(op->port_data, gc);
  gcFIXUP2(op->name, gc);
  gcFIXUP2(op->display_handler, gc);
  gcFIXUP2(op->write_handler, gc);
  gcFIXUP2(op->print_handler, gc);
  gcFIXUP2(op->closed_evt, gc);
  gcFIXUP2(op->mref, gc);
  gcFIXUP2(op->input_half, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
}

#define output_port_IS_ATOMIC 0
#define output_port_IS_CONST_SIZE 1



static int syntax_compiler_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int syntax_compiler_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int syntax_compiler_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define syntax_compiler_IS_ATOMIC 1
#define syntax_compiler_IS_CONST_SIZE 1


static int thread_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
}

static int thread_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Thread *pr = (Scheme_Thread *)p;

  gcMARK2(pr->next, gc);
  gcMARK2(pr->prev, gc);

  gcMARK2(pr->t_set_parent, gc);
  gcMARK2(pr->t_set_next, gc);
  gcMARK2(pr->t_set_prev, gc);

  MARK_cjs(&pr->cjs, gc);
  gcMARK2(pr->decompose_mc, gc);

  gcMARK2(pr->cell_values, gc);
  gcMARK2(pr->init_config, gc);
  gcMARK2(pr->init_break_cell, gc);

  if (!pr->runstack_owner
      || !GC_merely_accounting()
      || (*pr->runstack_owner == pr)) {
    Scheme_Object **rs = pr->runstack_start;
    gcMARK2( pr->runstack_start, gc);
    if (pr->runstack != pr->runstack_start + (pr->runstack - rs))
      pr->runstack = pr->runstack_start + (pr->runstack - rs);

    gcMARK2(pr->runstack_saved, gc);
  }
  gcMARK2(pr->runstack_owner, gc);
  gcMARK2(pr->runstack_swapped, gc);
  pr->spare_runstack = NULL; /* just in case */

  gcMARK2(pr->meta_prompt, gc);
  gcMARK2(pr->meta_continuation, gc);
  gcMARK2(pr->acting_barrier_prompt, gc);
  
  gcMARK2(pr->cont_mark_stack_segments, gc);
  gcMARK2(pr->cont_mark_stack_owner, gc);
  gcMARK2(pr->cont_mark_stack_swapped, gc);

  MARK_jmpup(&pr->jmpup_buf, gc);
  
  gcMARK2(pr->dw, gc);
  
  gcMARK2(pr->nester, gc);
  gcMARK2(pr->nestee, gc);

  gcMARK2(pr->current_ft, gc);
  
  gcMARK2(pr->blocker, gc);
  gcMARK2(pr->overflow, gc);

  gcMARK2(pr->return_marks_to, gc);
  gcMARK2(pr->returned_marks, gc);
  
  gcMARK2(pr->current_local_env, gc);
  gcMARK2(pr->current_local_mark, gc);
  gcMARK2(pr->current_local_name, gc);
  gcMARK2(pr->current_local_modidx, gc);
  gcMARK2(pr->current_local_menv, gc);
  gcMARK2(pr->current_local_bindings, gc);

  gcMARK2(pr->current_mt, gc);

  gcMARK2(pr->constant_folding, gc);
  gcMARK2(pr->reading_delayed, gc);
  
  gcMARK2(pr->overflow_reply, gc);

  gcMARK2(pr->values_buffer, gc);

  gcMARK2(pr->tail_buffer, gc);
  
  gcMARK2(pr->ku.eval.wait_expr, gc);

  gcMARK2(pr->ku.apply.tail_rator, gc);
  gcMARK2(pr->ku.apply.tail_rands, gc);

  gcMARK2(pr->ku.multiple.array, gc);

  gcMARK2(pr->ku.k.p1, gc);
  gcMARK2(pr->ku.k.p2, gc);
  gcMARK2(pr->ku.k.p3, gc);
  gcMARK2(pr->ku.k.p4, gc);
  gcMARK2(pr->ku.k.p5, gc);
  
  gcMARK2(pr->list_stack, gc);
  
  gcMARK2(pr->kill_data, gc);
  gcMARK2(pr->private_kill_data, gc);
  gcMARK2(pr->private_kill_next, gc);
  
  gcMARK2(pr->user_tls, gc);
  gcMARK2(pr->gmp_tls_data, gc);
  
  gcMARK2(pr->mr_hop, gc);
  gcMARK2(pr->mref, gc);
  gcMARK2(pr->extra_mrefs, gc);

  gcMARK2(pr->name, gc);

  gcMARK2(pr->transitive_resumes, gc);

  gcMARK2(pr->suspended_box, gc);
  gcMARK2(pr->resumed_box, gc);
  gcMARK2(pr->dead_box, gc);
  gcMARK2(pr->running_box, gc);

  gcMARK2(pr->mbox_first, gc);
  gcMARK2(pr->mbox_last, gc);
  gcMARK2(pr->mbox_sema, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
}

static int thread_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Thread *pr = (Scheme_Thread *)p;

  gcFIXUP2(pr->next, gc);
  gcFIXUP2(pr->prev, gc);

  gcFIXUP2(pr->t_set_parent, gc);
  gcFIXUP2(pr->t_set_next, gc);
  gcFIXUP2(pr->t_set_prev, gc);

  FIXUP_cjs(&pr->cjs, gc);
  gcFIXUP2(pr->decompose_mc, gc);

  gcFIXUP2(pr->cell_values, gc);
  gcFIXUP2(pr->init_config, gc);
  gcFIXUP2(pr->init_break_cell, gc);

  if (!pr->runstack_owner
      || !GC_merely_accounting()
      || (*pr->runstack_owner == pr)) {
    Scheme_Object **rs = pr->runstack_start;
    gcFIXUP2_TYPED_NOW(Scheme_Object **, pr->runstack_start, gc);
    if (pr->runstack != pr->runstack_start + (pr->runstack - rs))
      pr->runstack = pr->runstack_start + (pr->runstack - rs);

    gcFIXUP2(pr->runstack_saved, gc);
  }
  gcFIXUP2(pr->runstack_owner, gc);
  gcFIXUP2(pr->runstack_swapped, gc);
  pr->spare_runstack = NULL; /* just in case */

  gcFIXUP2(pr->meta_prompt, gc);
  gcFIXUP2(pr->meta_continuation, gc);
  gcFIXUP2(pr->acting_barrier_prompt, gc);
  
  gcFIXUP2(pr->cont_mark_stack_segments, gc);
  gcFIXUP2(pr->cont_mark_stack_owner, gc);
  gcFIXUP2(pr->cont_mark_stack_swapped, gc);

  FIXUP_jmpup(&pr->jmpup_buf, gc);
  
  gcFIXUP2(pr->dw, gc);
  
  gcFIXUP2(pr->nester, gc);
  gcFIXUP2(pr->nestee, gc);

  gcFIXUP2(pr->current_ft, gc);
  
  gcFIXUP2(pr->blocker, gc);
  gcFIXUP2(pr->overflow, gc);

  gcFIXUP2(pr->return_marks_to, gc);
  gcFIXUP2(pr->returned_marks, gc);
  
  gcFIXUP2(pr->current_local_env, gc);
  gcFIXUP2(pr->current_local_mark, gc);
  gcFIXUP2(pr->current_local_name, gc);
  gcFIXUP2(pr->current_local_modidx, gc);
  gcFIXUP2(pr->current_local_menv, gc);
  gcFIXUP2(pr->current_local_bindings, gc);

  gcFIXUP2(pr->current_mt, gc);

  gcFIXUP2(pr->constant_folding, gc);
  gcFIXUP2(pr->reading_delayed, gc);
  
  gcFIXUP2(pr->overflow_reply, gc);

  gcFIXUP2(pr->values_buffer, gc);

  gcFIXUP2(pr->tail_buffer, gc);
  
  gcFIXUP2(pr->ku.eval.wait_expr, gc);

  gcFIXUP2(pr->ku.apply.tail_rator, gc);
  gcFIXUP2(pr->ku.apply.tail_rands, gc);

  gcFIXUP2(pr->ku.multiple.array, gc);

  gcFIXUP2(pr->ku.k.p1, gc);
  gcFIXUP2(pr->ku.k.p2, gc);
  gcFIXUP2(pr->ku.k.p3, gc);
  gcFIXUP2(pr->ku.k.p4, gc);
  gcFIXUP2(pr->ku.k.p5, gc);
  
  gcFIXUP2(pr->list_stack, gc);
  
  gcFIXUP2(pr->kill_data, gc);
  gcFIXUP2(pr->private_kill_data, gc);
  gcFIXUP2(pr->private_kill_next, gc);
  
  gcFIXUP2(pr->user_tls, gc);
  gcFIXUP2(pr->gmp_tls_data, gc);
  
  gcFIXUP2(pr->mr_hop, gc);
  gcFIXUP2(pr->mref, gc);
  gcFIXUP2(pr->extra_mrefs, gc);

  gcFIXUP2(pr->name, gc);

  gcFIXUP2(pr->transitive_resumes, gc);

  gcFIXUP2(pr->suspended_box, gc);
  gcFIXUP2(pr->resumed_box, gc);
  gcFIXUP2(pr->dead_box, gc);
  gcFIXUP2(pr->running_box, gc);

  gcFIXUP2(pr->mbox_first, gc);
  gcFIXUP2(pr->mbox_last, gc);
  gcFIXUP2(pr->mbox_sema, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
}

#define thread_val_IS_ATOMIC 0
#define thread_val_IS_CONST_SIZE 1


static int runstack_val_SIZE(void *p, struct NewGC *gc) {
  intptr_t *s = (intptr_t *)p;
  return
  s[1];
}

static int runstack_val_MARK(void *p, struct NewGC *gc) {
  intptr_t *s = (intptr_t *)p;
  void **a, **b;
  a = (void **)s + 4 + s[2];
  b = (void **)s + 4 + s[3];
  while (a < b) {
    gcMARK2(*a, gc);
    a++;
  }
  return
  s[1];
}

static int runstack_val_FIXUP(void *p, struct NewGC *gc) {
  intptr_t *s = (intptr_t *)p;
  void **a, **b;
  a = (void **)s + 4 + s[2];
  b = (void **)s + 4 + s[3];
  while (a < b) {
    gcFIXUP2(*a, gc);
    a++;
  }

  /* Zero out the part that we didn't mark, in case it becomes
     live later. */
  a = (void **)s + 4;
  b = (void **)s + 4 + s[2];
  while (a < b) {
    *a = RUNSTACK_ZERO_VAL;
    a++;
  }
  a = (void **)s + 4 + s[3];
  b = (void **)s + 4 + (s[1] - 4);
  while (a < b) {
    *a = RUNSTACK_ZERO_VAL;
    a++;
  }
  return
  s[1];
}

#define runstack_val_IS_ATOMIC 0
#define runstack_val_IS_CONST_SIZE 0


static int prompt_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Prompt));
}

static int prompt_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Prompt *pr = (Scheme_Prompt *)p;
  gcMARK2(pr->boundary_overflow_id, gc);
  if (!GC_merely_accounting())
    gcMARK2(pr->runstack_boundary_start, gc);
  gcMARK2(pr->tag, gc);
  gcMARK2(pr->id, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Prompt));
}

static int prompt_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Prompt *pr = (Scheme_Prompt *)p;
  gcFIXUP2(pr->boundary_overflow_id, gc);
  if (!GC_merely_accounting())
    gcFIXUP2(pr->runstack_boundary_start, gc);
  gcFIXUP2(pr->tag, gc);
  gcFIXUP2(pr->id, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Prompt));
}

#define prompt_val_IS_ATOMIC 0
#define prompt_val_IS_CONST_SIZE 1


static int cont_mark_set_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
}

static int cont_mark_set_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Cont_Mark_Set *s = (Scheme_Cont_Mark_Set *)p;
  gcMARK2(s->chain, gc);
  gcMARK2(s->native_stack_trace, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
}

static int cont_mark_set_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Cont_Mark_Set *s = (Scheme_Cont_Mark_Set *)p;
  gcFIXUP2(s->chain, gc);
  gcFIXUP2(s->native_stack_trace, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
}

#define cont_mark_set_val_IS_ATOMIC 0
#define cont_mark_set_val_IS_CONST_SIZE 1


static int sema_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
}

static int sema_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Sema *s = (Scheme_Sema *)p;

  gcMARK2(s->first, gc);
  gcMARK2(s->last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
}

static int sema_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Sema *s = (Scheme_Sema *)p;

  gcFIXUP2(s->first, gc);
  gcFIXUP2(s->last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
}

#define sema_val_IS_ATOMIC 0
#define sema_val_IS_CONST_SIZE 1


static int channel_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
}

static int channel_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Channel *s = (Scheme_Channel *)p;

  gcMARK2(s->get_first, gc);
  gcMARK2(s->get_last, gc);
  gcMARK2(s->put_first, gc);
  gcMARK2(s->put_last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
}

static int channel_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Channel *s = (Scheme_Channel *)p;

  gcFIXUP2(s->get_first, gc);
  gcFIXUP2(s->get_last, gc);
  gcFIXUP2(s->put_first, gc);
  gcFIXUP2(s->put_last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
}

#define channel_val_IS_ATOMIC 0
#define channel_val_IS_CONST_SIZE 1


static int channel_put_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
}

static int channel_put_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Channel_Put *s = (Scheme_Channel_Put *)p;

  gcMARK2(s->ch, gc);
  gcMARK2(s->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
}

static int channel_put_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Channel_Put *s = (Scheme_Channel_Put *)p;

  gcFIXUP2(s->ch, gc);
  gcFIXUP2(s->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
}

#define channel_put_val_IS_ATOMIC 0
#define channel_put_val_IS_CONST_SIZE 1


static int hash_table_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
}

static int hash_table_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Hash_Table *ht = (Scheme_Hash_Table *)p;

  gcMARK2(ht->keys, gc);
  gcMARK2(ht->vals, gc);
  gcMARK2(ht->mutex, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
}

static int hash_table_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Hash_Table *ht = (Scheme_Hash_Table *)p;

  gcFIXUP2(ht->keys, gc);
  gcFIXUP2(ht->vals, gc);
  gcFIXUP2(ht->mutex, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
}

#define hash_table_val_IS_ATOMIC 0
#define hash_table_val_IS_CONST_SIZE 1


static int bucket_table_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
}

static int bucket_table_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Bucket_Table *ht = (Scheme_Bucket_Table *)p;

  gcMARK2(ht->buckets, gc);
  gcMARK2(ht->mutex, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
}

static int bucket_table_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Bucket_Table *ht = (Scheme_Bucket_Table *)p;

  gcFIXUP2(ht->buckets, gc);
  gcFIXUP2(ht->mutex, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
}

#define bucket_table_val_IS_ATOMIC 0
#define bucket_table_val_IS_CONST_SIZE 1


static int namespace_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
}

static int namespace_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Env *e = (Scheme_Env *)p;

  gcMARK2(e->module, gc);
  gcMARK2(e->module_registry, gc);
  gcMARK2(e->module_pre_registry, gc);
  gcMARK2(e->guard_insp, gc);
  gcMARK2(e->access_insp, gc);

  gcMARK2(e->rename_set, gc);
  gcMARK2(e->temp_marked_names, gc);
  gcMARK2(e->post_ex_rename_set, gc);

  gcMARK2(e->syntax, gc);
  gcMARK2(e->exp_env, gc);
  gcMARK2(e->template_env, gc);
  gcMARK2(e->label_env, gc);
  gcMARK2(e->instance_env, gc);

  gcMARK2(e->shadowed_syntax, gc);

  gcMARK2(e->link_midx, gc);
  gcMARK2(e->require_names, gc);
  gcMARK2(e->et_require_names, gc);
  gcMARK2(e->tt_require_names, gc);
  gcMARK2(e->dt_require_names, gc);
  gcMARK2(e->other_require_names, gc);
  gcMARK2(e->running, gc);
  gcMARK2(e->did_starts, gc);
  gcMARK2(e->available_next[0], gc);
  gcMARK2(e->available_next[1], gc);

  gcMARK2(e->toplevel, gc);
  gcMARK2(e->modchain, gc);

  gcMARK2(e->modvars, gc);

  gcMARK2(e->weak_self_link, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
}

static int namespace_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Env *e = (Scheme_Env *)p;

  gcFIXUP2(e->module, gc);
  gcFIXUP2(e->module_registry, gc);
  gcFIXUP2(e->module_pre_registry, gc);
  gcFIXUP2(e->guard_insp, gc);
  gcFIXUP2(e->access_insp, gc);

  gcFIXUP2(e->rename_set, gc);
  gcFIXUP2(e->temp_marked_names, gc);
  gcFIXUP2(e->post_ex_rename_set, gc);

  gcFIXUP2(e->syntax, gc);
  gcFIXUP2(e->exp_env, gc);
  gcFIXUP2(e->template_env, gc);
  gcFIXUP2(e->label_env, gc);
  gcFIXUP2(e->instance_env, gc);

  gcFIXUP2(e->shadowed_syntax, gc);

  gcFIXUP2(e->link_midx, gc);
  gcFIXUP2(e->require_names, gc);
  gcFIXUP2(e->et_require_names, gc);
  gcFIXUP2(e->tt_require_names, gc);
  gcFIXUP2(e->dt_require_names, gc);
  gcFIXUP2(e->other_require_names, gc);
  gcFIXUP2(e->running, gc);
  gcFIXUP2(e->did_starts, gc);
  gcFIXUP2(e->available_next[0], gc);
  gcFIXUP2(e->available_next[1], gc);

  gcFIXUP2(e->toplevel, gc);
  gcFIXUP2(e->modchain, gc);

  gcFIXUP2(e->modvars, gc);

  gcFIXUP2(e->weak_self_link, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
}

#define namespace_val_IS_ATOMIC 0
#define namespace_val_IS_CONST_SIZE 1


static int module_reg_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Registry));
}

static int module_reg_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Module_Registry *r = (Scheme_Module_Registry *)p;
  gcMARK2(r->loaded, gc);
  gcMARK2(r->exports, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Registry));
}

static int module_reg_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Module_Registry *r = (Scheme_Module_Registry *)p;
  gcFIXUP2(r->loaded, gc);
  gcFIXUP2(r->exports, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Registry));
}

#define module_reg_val_IS_ATOMIC 0
#define module_reg_val_IS_CONST_SIZE 1


static int random_state_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
}

static int random_state_val_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
}

static int random_state_val_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
}

#define random_state_val_IS_ATOMIC 1
#define random_state_val_IS_CONST_SIZE 1


static int compilation_top_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compilation_Top));
}

static int compilation_top_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Compilation_Top *t = (Scheme_Compilation_Top *)p;
  gcMARK2(t->code, gc);
  gcMARK2(t->prefix, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compilation_Top));
}

static int compilation_top_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Compilation_Top *t = (Scheme_Compilation_Top *)p;
  gcFIXUP2(t->code, gc);
  gcFIXUP2(t->prefix, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compilation_Top));
}

#define compilation_top_val_IS_ATOMIC 0
#define compilation_top_val_IS_CONST_SIZE 1


static int prefix_val_SIZE(void *p, struct NewGC *gc) {
  Scheme_Prefix *pf = (Scheme_Prefix *)p;
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Prefix) 
		    + ((pf->num_slots-mzFLEX_DELTA) * sizeof(Scheme_Object *))
                    + ((((pf->num_slots - (pf->num_stxes ? (pf->num_stxes+1) : 0)) + 31) / 32) 
                       * sizeof(int))));
}

static int prefix_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Prefix *pf = (Scheme_Prefix *)p;
  int i;
  for (i = pf->num_slots; i--; )
    gcMARK2(pf->a[i], gc);
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Prefix) 
		    + ((pf->num_slots-mzFLEX_DELTA) * sizeof(Scheme_Object *))
                    + ((((pf->num_slots - (pf->num_stxes ? (pf->num_stxes+1) : 0)) + 31) / 32) 
                       * sizeof(int))));
}

static int prefix_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Prefix *pf = (Scheme_Prefix *)p;
  int i;
  for (i = pf->num_slots; i--; )
    gcFIXUP2(pf->a[i], gc);
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Prefix) 
		    + ((pf->num_slots-mzFLEX_DELTA) * sizeof(Scheme_Object *))
                    + ((((pf->num_slots - (pf->num_stxes ? (pf->num_stxes+1) : 0)) + 31) / 32) 
                       * sizeof(int))));
}

#define prefix_val_IS_ATOMIC 0
#define prefix_val_IS_CONST_SIZE 0


static int resolve_prefix_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Prefix));
}

static int resolve_prefix_val_MARK(void *p, struct NewGC *gc) {
  Resolve_Prefix *rp = (Resolve_Prefix *)p;
  gcMARK2(rp->toplevels, gc);
  gcMARK2(rp->stxes, gc);
  gcMARK2(rp->delay_info_rpair, gc);
  gcMARK2(rp->uses_unsafe, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Prefix));
}

static int resolve_prefix_val_FIXUP(void *p, struct NewGC *gc) {
  Resolve_Prefix *rp = (Resolve_Prefix *)p;
  gcFIXUP2(rp->toplevels, gc);
  gcFIXUP2(rp->stxes, gc);
  gcFIXUP2(rp->delay_info_rpair, gc);
  gcFIXUP2(rp->uses_unsafe, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Prefix));
}

#define resolve_prefix_val_IS_ATOMIC 0
#define resolve_prefix_val_IS_CONST_SIZE 1


static int comp_prefix_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Comp_Prefix));
}

static int comp_prefix_val_MARK(void *p, struct NewGC *gc) {
  Comp_Prefix *cp = (Comp_Prefix *)p;
  gcMARK2(cp->toplevels, gc);
  gcMARK2(cp->inline_variants, gc);
  gcMARK2(cp->unbound, gc);
  gcMARK2(cp->stxes, gc);
  gcMARK2(cp->uses_unsafe, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Comp_Prefix));
}

static int comp_prefix_val_FIXUP(void *p, struct NewGC *gc) {
  Comp_Prefix *cp = (Comp_Prefix *)p;
  gcFIXUP2(cp->toplevels, gc);
  gcFIXUP2(cp->inline_variants, gc);
  gcFIXUP2(cp->unbound, gc);
  gcFIXUP2(cp->stxes, gc);
  gcFIXUP2(cp->uses_unsafe, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Comp_Prefix));
}

#define comp_prefix_val_IS_ATOMIC 0
#define comp_prefix_val_IS_CONST_SIZE 1


static int svector_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int svector_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;

  gcMARK2(SCHEME_SVEC_VEC(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int svector_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;

  gcFIXUP2(SCHEME_SVEC_VEC(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define svector_val_IS_ATOMIC 0
#define svector_val_IS_CONST_SIZE 1


static int stx_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
}

static int stx_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Stx *stx = (Scheme_Stx *)p;
  gcMARK2(stx->val, gc);
  gcMARK2(stx->srcloc, gc);
  gcMARK2(stx->wraps, gc);
  gcMARK2(stx->taints, gc);
  gcMARK2(stx->props, gc);
  if (!(MZ_OPT_HASH_KEY(&(stx)->iso) & STX_SUBSTX_FLAG))
    gcMARK2(stx->u.modinfo_cache, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
}

static int stx_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Stx *stx = (Scheme_Stx *)p;
  gcFIXUP2(stx->val, gc);
  gcFIXUP2(stx->srcloc, gc);
  gcFIXUP2(stx->wraps, gc);
  gcFIXUP2(stx->taints, gc);
  gcFIXUP2(stx->props, gc);
  if (!(MZ_OPT_HASH_KEY(&(stx)->iso) & STX_SUBSTX_FLAG))
    gcFIXUP2(stx->u.modinfo_cache, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
}

#define stx_val_IS_ATOMIC 0
#define stx_val_IS_CONST_SIZE 1


static int stx_off_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Offset));
}

static int stx_off_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Stx_Offset *o = (Scheme_Stx_Offset *)p;
  gcMARK2(o->src, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Offset));
}

static int stx_off_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Stx_Offset *o = (Scheme_Stx_Offset *)p;
  gcFIXUP2(o->src, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Offset));
}

#define stx_off_val_IS_ATOMIC 0
#define stx_off_val_IS_CONST_SIZE 1


static int module_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module));
}

static int module_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Module *m = (Scheme_Module *)p;

  gcMARK2(m->phaseless, gc);

  gcMARK2(m->code_key, gc);

  gcMARK2(m->modname, gc);
  gcMARK2(m->modsrc, gc);

  gcMARK2(m->et_requires, gc);
  gcMARK2(m->requires, gc);
  gcMARK2(m->tt_requires, gc);
  gcMARK2(m->dt_requires, gc);
  gcMARK2(m->other_requires, gc);

  gcMARK2(m->bodies, gc);

  gcMARK2(m->me, gc);

  gcMARK2(m->exp_infos, gc);

  gcMARK2(m->self_modidx, gc);

  gcMARK2(m->insp, gc);

  gcMARK2(m->lang_info, gc);

  gcMARK2(m->hints, gc);
  gcMARK2(m->ii_src, gc);
  gcMARK2(m->super_bxs_info, gc);

  gcMARK2(m->comp_prefix, gc);
  gcMARK2(m->prefix, gc);
  gcMARK2(m->dummy, gc);

  gcMARK2(m->rn_stx, gc);

  gcMARK2(m->submodule_path, gc);
  gcMARK2(m->pre_submodules, gc);
  gcMARK2(m->post_submodules, gc);
  gcMARK2(m->pre_submodule_names, gc);
  gcMARK2(m->supermodule, gc);
  gcMARK2(m->submodule_ancestry, gc);

  gcMARK2(m->primitive, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module));
}

static int module_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Module *m = (Scheme_Module *)p;

  gcFIXUP2(m->phaseless, gc);

  gcFIXUP2(m->code_key, gc);

  gcFIXUP2(m->modname, gc);
  gcFIXUP2(m->modsrc, gc);

  gcFIXUP2(m->et_requires, gc);
  gcFIXUP2(m->requires, gc);
  gcFIXUP2(m->tt_requires, gc);
  gcFIXUP2(m->dt_requires, gc);
  gcFIXUP2(m->other_requires, gc);

  gcFIXUP2(m->bodies, gc);

  gcFIXUP2(m->me, gc);

  gcFIXUP2(m->exp_infos, gc);

  gcFIXUP2(m->self_modidx, gc);

  gcFIXUP2(m->insp, gc);

  gcFIXUP2(m->lang_info, gc);

  gcFIXUP2(m->hints, gc);
  gcFIXUP2(m->ii_src, gc);
  gcFIXUP2(m->super_bxs_info, gc);

  gcFIXUP2(m->comp_prefix, gc);
  gcFIXUP2(m->prefix, gc);
  gcFIXUP2(m->dummy, gc);

  gcFIXUP2(m->rn_stx, gc);

  gcFIXUP2(m->submodule_path, gc);
  gcFIXUP2(m->pre_submodules, gc);
  gcFIXUP2(m->post_submodules, gc);
  gcFIXUP2(m->pre_submodule_names, gc);
  gcFIXUP2(m->supermodule, gc);
  gcFIXUP2(m->submodule_ancestry, gc);

  gcFIXUP2(m->primitive, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module));
}

#define module_val_IS_ATOMIC 0
#define module_val_IS_CONST_SIZE 1


static int exp_info_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Export_Info));
}

static int exp_info_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Module_Export_Info *m = (Scheme_Module_Export_Info *)p;

  gcMARK2(m->provide_protects, gc);
  gcMARK2(m->indirect_provides, gc);

  gcMARK2(m->indirect_syntax_provides, gc);

  gcMARK2(m->accessible, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Export_Info));
}

static int exp_info_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Module_Export_Info *m = (Scheme_Module_Export_Info *)p;

  gcFIXUP2(m->provide_protects, gc);
  gcFIXUP2(m->indirect_provides, gc);

  gcFIXUP2(m->indirect_syntax_provides, gc);

  gcFIXUP2(m->accessible, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Export_Info));
}

#define exp_info_val_IS_ATOMIC 0
#define exp_info_val_IS_CONST_SIZE 1


static int module_phase_exports_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Phase_Exports));
}

static int module_phase_exports_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Module_Phase_Exports *m = (Scheme_Module_Phase_Exports *)p;

  gcMARK2(m->phase_index, gc);

  gcMARK2(m->src_modidx, gc);

  gcMARK2(m->provides, gc);
  gcMARK2(m->provide_srcs, gc);
  gcMARK2(m->provide_src_names, gc);
  gcMARK2(m->provide_nominal_srcs, gc);
  gcMARK2(m->provide_src_phases, gc);

  gcMARK2(m->kernel_exclusion, gc);
  gcMARK2(m->kernel_exclusion2, gc);

  gcMARK2(m->ht, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Phase_Exports));
}

static int module_phase_exports_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Module_Phase_Exports *m = (Scheme_Module_Phase_Exports *)p;

  gcFIXUP2(m->phase_index, gc);

  gcFIXUP2(m->src_modidx, gc);

  gcFIXUP2(m->provides, gc);
  gcFIXUP2(m->provide_srcs, gc);
  gcFIXUP2(m->provide_src_names, gc);
  gcFIXUP2(m->provide_nominal_srcs, gc);
  gcFIXUP2(m->provide_src_phases, gc);

  gcFIXUP2(m->kernel_exclusion, gc);
  gcFIXUP2(m->kernel_exclusion2, gc);

  gcFIXUP2(m->ht, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Phase_Exports));
}

#define module_phase_exports_val_IS_ATOMIC 0
#define module_phase_exports_val_IS_CONST_SIZE 1


static int module_exports_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Exports));
}

static int module_exports_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Module_Exports *m = (Scheme_Module_Exports *)p;

  gcMARK2(m->rt, gc);
  gcMARK2(m->et, gc);
  gcMARK2(m->dt, gc);
  gcMARK2(m->other_phases, gc);

  gcMARK2(m->src_modidx, gc);
  gcMARK2(m->modsrc, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Exports));
}

static int module_exports_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Module_Exports *m = (Scheme_Module_Exports *)p;

  gcFIXUP2(m->rt, gc);
  gcFIXUP2(m->et, gc);
  gcFIXUP2(m->dt, gc);
  gcFIXUP2(m->other_phases, gc);

  gcFIXUP2(m->src_modidx, gc);
  gcFIXUP2(m->modsrc, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Exports));
}

#define module_exports_val_IS_ATOMIC 0
#define module_exports_val_IS_CONST_SIZE 1


static int modidx_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Modidx));
}

static int modidx_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Modidx *modidx = (Scheme_Modidx *)p;

  gcMARK2(modidx->path, gc);
  gcMARK2(modidx->base, gc);
  gcMARK2(modidx->resolved, gc);
  gcMARK2(modidx->shift_cache, gc);
  gcMARK2(modidx->cache_next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Modidx));
}

static int modidx_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Modidx *modidx = (Scheme_Modidx *)p;

  gcFIXUP2(modidx->path, gc);
  gcFIXUP2(modidx->base, gc);
  gcFIXUP2(modidx->resolved, gc);
  gcFIXUP2(modidx->shift_cache, gc);
  gcFIXUP2(modidx->cache_next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Modidx));
}

#define modidx_val_IS_ATOMIC 0
#define modidx_val_IS_CONST_SIZE 1


static int guard_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
}

static int guard_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Security_Guard *g = (Scheme_Security_Guard *)p;

  gcMARK2(g->parent, gc);
  gcMARK2(g->file_proc, gc);
  gcMARK2(g->network_proc, gc);
  gcMARK2(g->link_proc, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
}

static int guard_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Security_Guard *g = (Scheme_Security_Guard *)p;

  gcFIXUP2(g->parent, gc);
  gcFIXUP2(g->file_proc, gc);
  gcFIXUP2(g->network_proc, gc);
  gcFIXUP2(g->link_proc, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
}

#define guard_val_IS_ATOMIC 0
#define guard_val_IS_CONST_SIZE 1


static int buf_holder_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
}

static int buf_holder_MARK(void *p, struct NewGC *gc) {
  Scheme_Jumpup_Buf_Holder *h = (Scheme_Jumpup_Buf_Holder *)p;
 
  MARK_jmpup(&h->buf, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
}

static int buf_holder_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Jumpup_Buf_Holder *h = (Scheme_Jumpup_Buf_Holder *)p;
 
  FIXUP_jmpup(&h->buf, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
}

#define buf_holder_IS_ATOMIC 0
#define buf_holder_IS_CONST_SIZE 1


static int mark_inspector_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
}

static int mark_inspector_MARK(void *p, struct NewGC *gc) {
  Scheme_Inspector *i = (Scheme_Inspector *)p;
  gcMARK2(i->superior, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
}

static int mark_inspector_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Inspector *i = (Scheme_Inspector *)p;
  gcFIXUP2(i->superior, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
}

#define mark_inspector_IS_ATOMIC 0
#define mark_inspector_IS_CONST_SIZE 1


static int mark_pipe_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
}

static int mark_pipe_MARK(void *p, struct NewGC *gc) {
  Scheme_Pipe *pp = (Scheme_Pipe *)p;
    
  gcMARK2(pp->buf, gc);
  gcMARK2(pp->wakeup_on_read, gc);
  gcMARK2(pp->wakeup_on_write, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
}

static int mark_pipe_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Pipe *pp = (Scheme_Pipe *)p;
    
  gcFIXUP2(pp->buf, gc);
  gcFIXUP2(pp->wakeup_on_read, gc);
  gcFIXUP2(pp->wakeup_on_write, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
}

#define mark_pipe_IS_ATOMIC 0
#define mark_pipe_IS_CONST_SIZE 1


static int mark_logger_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Logger));
}

static int mark_logger_MARK(void *p, struct NewGC *gc) {
  Scheme_Logger *l = (Scheme_Logger *)p;
  gcMARK2(l->name, gc);
  gcMARK2(l->parent, gc);
  gcMARK2(l->callback, gc);
  gcMARK2(l->timestamp, gc);
  gcMARK2(l->syslog_level, gc);
  gcMARK2(l->stderr_level, gc);
  gcMARK2(l->readers, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Logger));
}

static int mark_logger_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Logger *l = (Scheme_Logger *)p;
  gcFIXUP2(l->name, gc);
  gcFIXUP2(l->parent, gc);
  gcFIXUP2(l->callback, gc);
  gcFIXUP2(l->timestamp, gc);
  gcFIXUP2(l->syslog_level, gc);
  gcFIXUP2(l->stderr_level, gc);
  gcFIXUP2(l->readers, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Logger));
}

#define mark_logger_IS_ATOMIC 0
#define mark_logger_IS_CONST_SIZE 1


static int mark_log_reader_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Log_Reader));
}

static int mark_log_reader_MARK(void *p, struct NewGC *gc) {
  Scheme_Log_Reader *lr = (Scheme_Log_Reader *)p;
  gcMARK2(lr->level, gc);
  gcMARK2(lr->sema, gc);
  gcMARK2(lr->head, gc);
  gcMARK2(lr->tail, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Log_Reader));
}

static int mark_log_reader_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Log_Reader *lr = (Scheme_Log_Reader *)p;
  gcFIXUP2(lr->level, gc);
  gcFIXUP2(lr->sema, gc);
  gcFIXUP2(lr->head, gc);
  gcFIXUP2(lr->tail, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Log_Reader));
}

#define mark_log_reader_IS_ATOMIC 0
#define mark_log_reader_IS_CONST_SIZE 1


