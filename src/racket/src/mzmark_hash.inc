/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int hash_tree_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Tree));
}

static int hash_tree_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Hash_Tree *ht = (Scheme_Hash_Tree *)p;

  gcMARK2(ht->root, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Tree));
}

static int hash_tree_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Hash_Tree *ht = (Scheme_Hash_Tree *)p;

  gcFIXUP2(ht->root, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Tree));
}

#define hash_tree_val_IS_ATOMIC 0
#define hash_tree_val_IS_CONST_SIZE 1


static int mark_avl_node_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(AVLNode));
}

static int mark_avl_node_MARK(void *p, struct NewGC *gc) {
  AVLNode *avl = (AVLNode *)p;

  /* Short-circuit on NULL pointers, which are especially likely */
  if (avl->left) {
    gcMARK2(avl->left, gc);
  }
  if (avl->right) {
    gcMARK2(avl->right, gc);
  }
  gcMARK2(avl->key, gc);
  gcMARK2(avl->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(AVLNode));
}

static int mark_avl_node_FIXUP(void *p, struct NewGC *gc) {
  AVLNode *avl = (AVLNode *)p;

  /* Short-circuit on NULL pointers, which are especially likely */
  if (avl->left) {
    gcFIXUP2(avl->left, gc);
  }
  if (avl->right) {
    gcFIXUP2(avl->right, gc);
  }
  gcFIXUP2(avl->key, gc);
  gcFIXUP2(avl->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(AVLNode));
}

#define mark_avl_node_IS_ATOMIC 0
#define mark_avl_node_IS_CONST_SIZE 1


