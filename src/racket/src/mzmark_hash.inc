/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int hash_tree_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Tree));
}

static int hash_tree_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Hash_Tree *ht = (Scheme_Hash_Tree *)p;

  gcMARK2(ht->root, gc);
  gcMARK2(ht->elems_box, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Tree));
}

static int hash_tree_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Hash_Tree *ht = (Scheme_Hash_Tree *)p;

  gcFIXUP2(ht->root, gc);
  gcFIXUP2(ht->elems_box, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Tree));
}

#define hash_tree_val_IS_ATOMIC 0
#define hash_tree_val_IS_CONST_SIZE 1


static int mark_rb_node_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(RBNode));
}

static int mark_rb_node_MARK(void *p, struct NewGC *gc) {
  RBNode *rb = (RBNode *)p;

  /* Short-circuit on NULL pointers, which are especially likely */
  if (rb->left) {
    gcMARK2(rb->left, gc);
  }
  if (rb->right) {
    gcMARK2(rb->right, gc);
  }
  gcMARK2(rb->key, gc);
  gcMARK2(rb->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(RBNode));
}

static int mark_rb_node_FIXUP(void *p, struct NewGC *gc) {
  RBNode *rb = (RBNode *)p;

  /* Short-circuit on NULL pointers, which are especially likely */
  if (rb->left) {
    gcFIXUP2(rb->left, gc);
  }
  if (rb->right) {
    gcFIXUP2(rb->right, gc);
  }
  gcFIXUP2(rb->key, gc);
  gcFIXUP2(rb->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(RBNode));
}

#define mark_rb_node_IS_ATOMIC 0
#define mark_rb_node_IS_CONST_SIZE 1


