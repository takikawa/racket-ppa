/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int native_closure_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_Native_Closure *c = (Scheme_Native_Closure *)p;
  int closure_size = ((Scheme_Native_Closure_Data *)GC_resolve2(c->code, gc))->closure_size;

  if (closure_size < 0) {
    closure_size = -(closure_size + 1);
  }

  gcBYTES_TO_WORDS((sizeof(Scheme_Native_Closure)
		    + (closure_size - mzFLEX_DELTA) * sizeof(Scheme_Object *)));
#else
  return 0;
#endif
}

static int native_closure_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Native_Closure *c = (Scheme_Native_Closure *)p;
  int closure_size = ((Scheme_Native_Closure_Data *)GC_resolve2(c->code, gc))->closure_size;

  if (closure_size < 0) {
    closure_size = -(closure_size + 1);
  }

  {
  int i = closure_size;
# define CLOSURE_DATA_TYPE Scheme_Native_Closure_Data
# include "mzclpf_decl.inc"

  gcMARK2(c->code, gc);

# include "mzclpf_pre.inc"

  while (i--)
    gcMARK2(c->vals[i], gc);

# include "mzclpf_post.inc"
# undef CLOSURE_DATA_TYPE
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Native_Closure)
		    + (closure_size - mzFLEX_DELTA) * sizeof(Scheme_Object *)));
# endif
#endif
}

static int native_closure_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Native_Closure *c = (Scheme_Native_Closure *)p;
  int closure_size = ((Scheme_Native_Closure_Data *)GC_resolve2(c->code, gc))->closure_size;

  if (closure_size < 0) {
    closure_size = -(closure_size + 1);
  }

  {
  int i = closure_size;

  gcFIXUP2(c->code, gc);


  while (i--)
    gcFIXUP2(c->vals[i], gc);

  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Native_Closure)
		    + (closure_size - mzFLEX_DELTA) * sizeof(Scheme_Object *)));
# endif
#endif
}

#define native_closure_IS_ATOMIC 0
#define native_closure_IS_CONST_SIZE 0


static int mark_jit_state_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(mz_jit_state));
#else
  return 0;
#endif
}

static int mark_jit_state_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  mz_jit_state *j = (mz_jit_state *)p;
  gcMARK2(j->mappings, gc);
  gcMARK2(j->self_data, gc);
  gcMARK2(j->example_argv, gc);
  gcMARK2(j->nc, gc);
  gcMARK2(j->retaining_data, gc);
  gcMARK2(j->patch_depth, gc);
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(mz_jit_state));
# endif
#endif
}

static int mark_jit_state_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  mz_jit_state *j = (mz_jit_state *)p;
  gcFIXUP2(j->mappings, gc);
  gcFIXUP2(j->self_data, gc);
  gcFIXUP2(j->example_argv, gc);
  gcFIXUP2(j->nc, gc);
  gcFIXUP2(j->retaining_data, gc);
  gcFIXUP2(j->patch_depth, gc);
  
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(mz_jit_state));
# endif
#endif
}

#define mark_jit_state_IS_ATOMIC 0
#define mark_jit_state_IS_CONST_SIZE 1


static int native_unclosed_proc_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data));
#else
  return 0;
#endif
}

static int native_unclosed_proc_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Native_Closure_Data *d = (Scheme_Native_Closure_Data *)p;
  int i;

  gcMARK2(d->u2.name, gc);
  if (d->retained) {
    for (i = SCHEME_INT_VAL(d->retained[0]); i--; ) {
      gcMARK2(d->retained[i], gc);
    }
  }
  if (d->closure_size < 0) {
    gcMARK2(d->u.arities, gc);
  }
  gcMARK2(d->tl_map, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data));
# endif
#endif
}

static int native_unclosed_proc_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Native_Closure_Data *d = (Scheme_Native_Closure_Data *)p;
  int i;

  gcFIXUP2(d->u2.name, gc);
  if (d->retained) {
    for (i = SCHEME_INT_VAL(d->retained[0]); i--; ) {
      gcFIXUP2(d->retained[i], gc);
    }
  }
  if (d->closure_size < 0) {
    gcFIXUP2(d->u.arities, gc);
  }
  gcFIXUP2(d->tl_map, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data));
# endif
#endif
}

#define native_unclosed_proc_IS_ATOMIC 0
#define native_unclosed_proc_IS_CONST_SIZE 1


static int native_unclosed_proc_plus_case_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data_Plus_Case));
#else
  return 0;
#endif
}

static int native_unclosed_proc_plus_case_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Native_Closure_Data_Plus_Case *d = (Scheme_Native_Closure_Data_Plus_Case *)p;

  native_unclosed_proc_MARK(p, gc);
  gcMARK2(d->case_lam, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data_Plus_Case));
# endif
#endif
}

static int native_unclosed_proc_plus_case_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Native_Closure_Data_Plus_Case *d = (Scheme_Native_Closure_Data_Plus_Case *)p;

  native_unclosed_proc_FIXUP(p, gc);
  gcFIXUP2(d->case_lam, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data_Plus_Case));
# endif
#endif
}

#define native_unclosed_proc_plus_case_IS_ATOMIC 0
#define native_unclosed_proc_plus_case_IS_CONST_SIZE 1


