/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int mark_resolve_info_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Info));
}

static int mark_resolve_info_MARK(void *p, struct NewGC *gc) {
  Resolve_Info *i = (Resolve_Info *)p;
  
  gcMARK2(i->prefix, gc);
  gcMARK2(i->stx_map, gc);
  gcMARK2(i->tl_map, gc);
  gcMARK2(i->old_pos, gc);
  gcMARK2(i->new_pos, gc);
  gcMARK2(i->old_stx_pos, gc);
  gcMARK2(i->flags, gc);
  gcMARK2(i->lifts, gc);
  gcMARK2(i->lifted, gc);
  gcMARK2(i->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Info));
}

static int mark_resolve_info_FIXUP(void *p, struct NewGC *gc) {
  Resolve_Info *i = (Resolve_Info *)p;
  
  gcFIXUP2(i->prefix, gc);
  gcFIXUP2(i->stx_map, gc);
  gcFIXUP2(i->tl_map, gc);
  gcFIXUP2(i->old_pos, gc);
  gcFIXUP2(i->new_pos, gc);
  gcFIXUP2(i->old_stx_pos, gc);
  gcFIXUP2(i->flags, gc);
  gcFIXUP2(i->lifts, gc);
  gcFIXUP2(i->lifted, gc);
  gcFIXUP2(i->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Info));
}

#define mark_resolve_info_IS_ATOMIC 0
#define mark_resolve_info_IS_CONST_SIZE 1


static int mark_unresolve_info_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Unresolve_Info));
}

static int mark_unresolve_info_MARK(void *p, struct NewGC *gc) {
  Unresolve_Info *i = (Unresolve_Info *)p;
  
  gcMARK2(i->flags, gc);
  gcMARK2(i->depths, gc);
  gcMARK2(i->prefix, gc);
  gcMARK2(i->closures, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Unresolve_Info));
}

static int mark_unresolve_info_FIXUP(void *p, struct NewGC *gc) {
  Unresolve_Info *i = (Unresolve_Info *)p;
  
  gcFIXUP2(i->flags, gc);
  gcFIXUP2(i->depths, gc);
  gcFIXUP2(i->prefix, gc);
  gcFIXUP2(i->closures, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Unresolve_Info));
}

#define mark_unresolve_info_IS_ATOMIC 0
#define mark_unresolve_info_IS_CONST_SIZE 1


