/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int mark_input_file_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_File));
#else
  return 0;
#endif
}

static int mark_input_file_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Input_File *i = (Scheme_Input_File *)p;

  gcMARK2(i->f, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_File));
# endif
#endif
}

static int mark_input_file_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Input_File *i = (Scheme_Input_File *)p;

  gcFIXUP2(i->f, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_File));
# endif
#endif
}

#define mark_input_file_IS_ATOMIC 0
#define mark_input_file_IS_CONST_SIZE 1


static int mark_output_file_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_File));
#else
  return 0;
#endif
}

static int mark_output_file_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Output_File *o = (Scheme_Output_File *)p;

  gcMARK2(o->f, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_File));
# endif
#endif
}

static int mark_output_file_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Output_File *o = (Scheme_Output_File *)p;

  gcFIXUP2(o->f, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_File));
# endif
#endif
}

#define mark_output_file_IS_ATOMIC 0
#define mark_output_file_IS_CONST_SIZE 1


#ifdef MZ_FDS
static int mark_input_fd_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_FD));
#else
  return 0;
#endif
}

static int mark_input_fd_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_FD *fd = (Scheme_FD *)p;

  gcMARK2(fd->buffer, gc);
  gcMARK2(fd->refcount, gc);
  gcMARK2(fd->flush_handle, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_FD));
# endif
#endif
}

static int mark_input_fd_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_FD *fd = (Scheme_FD *)p;

  gcFIXUP2(fd->buffer, gc);
  gcFIXUP2(fd->refcount, gc);
  gcFIXUP2(fd->flush_handle, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_FD));
# endif
#endif
}

#define mark_input_fd_IS_ATOMIC 0
#define mark_input_fd_IS_CONST_SIZE 1

#endif

#if defined(UNIX_PROCESSES) && !(defined(MZ_USE_PLACES) && defined(MZ_PRECISE_GC))
static int mark_system_child_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(System_Child));
#else
  return 0;
#endif
}

static int mark_system_child_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  System_Child *sc = (System_Child *)p;

  gcMARK2(sc->next, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(System_Child));
# endif
#endif
}

static int mark_system_child_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  System_Child *sc = (System_Child *)p;

  gcFIXUP2(sc->next, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(System_Child));
# endif
#endif
}

#define mark_system_child_IS_ATOMIC 0
#define mark_system_child_IS_CONST_SIZE 1

#endif

#ifdef USE_OSKIT_CONSOLE
static int mark_oskit_console_input_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(osk_console_input));
#else
  return 0;
#endif
}

static int mark_oskit_console_input_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  osk_console_input *c = (osk_console_input *)p;
    
  gcMARK2(c->buffer, gc);
  gcMARK2(c->next, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(osk_console_input));
# endif
#endif
}

static int mark_oskit_console_input_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  osk_console_input *c = (osk_console_input *)p;
    
  gcFIXUP2(c->buffer, gc);
  gcFIXUP2(c->next, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(osk_console_input));
# endif
#endif
}

#define mark_oskit_console_input_IS_ATOMIC 0
#define mark_oskit_console_input_IS_CONST_SIZE 1

#endif

static int mark_subprocess_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Subprocess));
#else
  return 0;
#endif
}

static int mark_subprocess_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
#ifndef WINDOWS_PROCESSES
  Scheme_Subprocess *sp = (Scheme_Subprocess *)p;
  gcMARK2(sp->handle, gc);
  gcMARK2(sp->mref, gc);
#endif
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Subprocess));
# endif
#endif
}

static int mark_subprocess_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
#ifndef WINDOWS_PROCESSES
  Scheme_Subprocess *sp = (Scheme_Subprocess *)p;
  gcFIXUP2(sp->handle, gc);
  gcFIXUP2(sp->mref, gc);
#endif
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Subprocess));
# endif
#endif
}

#define mark_subprocess_IS_ATOMIC 0
#define mark_subprocess_IS_CONST_SIZE 1


static int mark_read_write_evt_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Read_Write_Evt));
#else
  return 0;
#endif
}

static int mark_read_write_evt_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Read_Write_Evt *rww = (Scheme_Read_Write_Evt *)p;
  gcMARK2(rww->port, gc);
  gcMARK2(rww->v, gc);
  gcMARK2(rww->str, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Read_Write_Evt));
# endif
#endif
}

static int mark_read_write_evt_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Read_Write_Evt *rww = (Scheme_Read_Write_Evt *)p;
  gcFIXUP2(rww->port, gc);
  gcFIXUP2(rww->v, gc);
  gcFIXUP2(rww->str, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Read_Write_Evt));
# endif
#endif
}

#define mark_read_write_evt_IS_ATOMIC 0
#define mark_read_write_evt_IS_CONST_SIZE 1


static int mark_filesystem_change_evt_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Filesystem_Change_Evt));
#else
  return 0;
#endif
}

static int mark_filesystem_change_evt_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Filesystem_Change_Evt *fc = (Scheme_Filesystem_Change_Evt *)p;
  gcMARK2(fc->sema, gc);
  gcMARK2(fc->mref, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Filesystem_Change_Evt));
# endif
#endif
}

static int mark_filesystem_change_evt_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Filesystem_Change_Evt *fc = (Scheme_Filesystem_Change_Evt *)p;
  gcFIXUP2(fc->sema, gc);
  gcFIXUP2(fc->mref, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Filesystem_Change_Evt));
# endif
#endif
}

#define mark_filesystem_change_evt_IS_ATOMIC 0
#define mark_filesystem_change_evt_IS_CONST_SIZE 1


