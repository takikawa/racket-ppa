/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int mark_srcloc_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
#else
  return 0;
#endif
}

static int mark_srcloc_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Stx_Srcloc *s = (Scheme_Stx_Srcloc *)p;
  gcMARK2(s->src, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
# endif
#endif
}

static int mark_srcloc_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Stx_Srcloc *s = (Scheme_Stx_Srcloc *)p;
  gcFIXUP2(s->src, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
# endif
#endif
}

#define mark_srcloc_IS_ATOMIC 0
#define mark_srcloc_IS_CONST_SIZE 1


static int mark_scope_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_Scope *m = (Scheme_Scope *)p;
  int for_multi = SCHEME_SCOPE_HAS_OWNER(m);
 (for_multi
  ? gcBYTES_TO_WORDS(sizeof(Scheme_Scope_With_Owner))
  : gcBYTES_TO_WORDS(sizeof(Scheme_Scope)));
#else
  return 0;
#endif
}

static int mark_scope_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Scope *m = (Scheme_Scope *)p;
  int for_multi = SCHEME_SCOPE_HAS_OWNER(m);
  gcMARK2(m->bindings, gc);
  if (for_multi) {
    gcMARK2(((Scheme_Scope_With_Owner *)m)->owner_multi_scope, gc);
    gcMARK2(((Scheme_Scope_With_Owner *)m)->phase, gc);
  }
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
 (for_multi
  ? gcBYTES_TO_WORDS(sizeof(Scheme_Scope_With_Owner))
  : gcBYTES_TO_WORDS(sizeof(Scheme_Scope)));
# endif
#endif
}

static int mark_scope_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Scope *m = (Scheme_Scope *)p;
  int for_multi = SCHEME_SCOPE_HAS_OWNER(m);
  gcFIXUP2(m->bindings, gc);
  if (for_multi) {
    gcFIXUP2(((Scheme_Scope_With_Owner *)m)->owner_multi_scope, gc);
    gcFIXUP2(((Scheme_Scope_With_Owner *)m)->phase, gc);
  }
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
 (for_multi
  ? gcBYTES_TO_WORDS(sizeof(Scheme_Scope_With_Owner))
  : gcBYTES_TO_WORDS(sizeof(Scheme_Scope)));
# endif
#endif
}

#define mark_scope_IS_ATOMIC 0
#define mark_scope_IS_CONST_SIZE 0


static int mark_scope_table_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Scope_Table));
#else
  return 0;
#endif
}

static int mark_scope_table_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Scope_Table *m = (Scheme_Scope_Table *)p;
  gcMARK2(m->simple_scopes, gc);
  gcMARK2(m->multi_scopes, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Scope_Table));
# endif
#endif
}

static int mark_scope_table_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Scope_Table *m = (Scheme_Scope_Table *)p;
  gcFIXUP2(m->simple_scopes, gc);
  gcFIXUP2(m->multi_scopes, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Scope_Table));
# endif
#endif
}

#define mark_scope_table_IS_ATOMIC 0
#define mark_scope_table_IS_CONST_SIZE 1


static int mark_propagate_table_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Propagate_Table));
#else
  return 0;
#endif
}

static int mark_propagate_table_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Propagate_Table *m = (Scheme_Propagate_Table *)p;
  mark_scope_table_MARK(&m->st, gc);
  gcMARK2(m->prev, gc);
  gcMARK2(m->phase_shift, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Propagate_Table));
# endif
#endif
}

static int mark_propagate_table_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Propagate_Table *m = (Scheme_Propagate_Table *)p;
  mark_scope_table_FIXUP(&m->st, gc);
  gcFIXUP2(m->prev, gc);
  gcFIXUP2(m->phase_shift, gc);
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Propagate_Table));
# endif
#endif
}

#define mark_propagate_table_IS_ATOMIC 0
#define mark_propagate_table_IS_CONST_SIZE 1


