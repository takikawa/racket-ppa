#define EVAL_STARTUP EVAL_ONE_STR(startup_source)
static const char *startup_source =
"(linklet"
"()"
"((boot boot)"
"(1/bound-identifier=? bound-identifier=?)"
"(1/compile compile)"
"(compile-keep-source-locations! compile-keep-source-locations!)"
"(1/compiled-expression-recompile compiled-expression-recompile)"
"(1/current-compile current-compile)"
"(1/current-compiled-file-roots current-compiled-file-roots)"
"(1/current-eval current-eval)"
"(1/current-library-collection-links current-library-collection-links)"
"(1/current-library-collection-paths current-library-collection-paths)"
"(1/current-load current-load)"
"(1/current-load/use-compiled current-load/use-compiled)"
"(1/current-namespace current-namespace)"
"(datum->kernel-syntax datum->kernel-syntax)"
"(1/datum->syntax datum->syntax)"
"(declare-primitive-module! declare-primitive-module!)"
"(1/dynamic-require dynamic-require)"
"(embedded-load embedded-load)"
"(1/eval eval)"
"(eval$1 eval-top-level)"
"(expand$1 expand)"
"(expander-place-init! expander-place-init!)"
"(1/fasl->s-exp/intern fasl->s-exp/intern)"
"(1/find-library-collection-links find-library-collection-links)"
"(1/find-library-collection-paths find-library-collection-paths)"
"(find-main-config find-main-config)"
"(1/identifier-binding identifier-binding)"
"(identifier? identifier?)"
"(1/load load)"
"(1/load-extension load-extension)"
"(1/load/use-compiled load/use-compiled)"
"(make-namespace make-namespace)"
"(maybe-raise-missing-module maybe-raise-missing-module)"
"(maybe-syntax->datum maybe-syntax->datum)"
"(1/module->language-info module->language-info)"
"(1/module-compiled-exports module-compiled-exports)"
"(1/module-compiled-indirect-exports module-compiled-indirect-exports)"
"(1/module-declared? module-declared?)"
"(1/module-path-index-join module-path-index-join)"
"(1/module-path-index? module-path-index?)"
"(1/module-path? module-path?)"
"(1/module-predefined? module-predefined?)"
"(namespace->instance namespace->instance)"
"(1/namespace-attach-module namespace-attach-module)"
"(1/namespace-attach-module-declaration namespace-attach-module-declaration)"
"(namespace-datum-introduce namespace-datum-introduce)"
"(1/namespace-mapped-symbols namespace-mapped-symbols)"
"(1/namespace-module-identifier namespace-module-identifier)"
"(1/namespace-require namespace-require)"
"(1/namespace-syntax-introduce namespace-syntax-introduce)"
"(1/namespace-variable-value namespace-variable-value)"
"(1/read read)"
"(1/read-accept-compiled read-accept-compiled)"
"(1/read-syntax read-syntax)"
"(1/resolved-module-path? resolved-module-path?)"
"(seal seal)"
"(1/syntax->datum syntax->datum)"
"(1/syntax-debug-info syntax-debug-info)"
"(1/syntax-e syntax-e)"
"(syntax-property$1 syntax-property)"
"(1/syntax-shift-phase-level syntax-shift-phase-level)"
"(syntax?$1 syntax?)"
"(1/use-collection-link-paths use-collection-link-paths)"
"(1/use-compiled-file-check use-compiled-file-check)"
"(1/use-compiled-file-paths use-compiled-file-paths)"
"(1/use-user-specific-search-paths use-user-specific-search-paths))"
"(define-values"
"(qq-append)"
"  (lambda (a_0 b_0) (begin (if (list? a_0) (append a_0 b_0) (raise-argument-error 'unquote-splicing \"list?\" a_0)))))"
"(define-values(call/ec) call-with-escape-continuation)"
"(define-values"
"(bad-list$1)"
"  (lambda (who_0 orig-l_0) (begin 'bad-list (raise-mismatch-error who_0 \"not a proper list: \" orig-l_0))))"
"(define-values"
"(memq memv member)"
"(let-values()"
"(let-values()"
"(values"
"(let-values(((memq_0)"
"(lambda(v_0 orig-l_0)"
"(begin"
" 'memq"
"((letrec-values(((loop_0)"
"(lambda(ls_0)"
"(begin"
" 'loop"
"(if(null? ls_0)"
"(let-values() #f)"
"(if(not(pair? ls_0))"
"(let-values()(bad-list$1 'memq orig-l_0))"
"(if(eq? v_0(car ls_0))"
"(let-values() ls_0)"
"(let-values()(loop_0(cdr ls_0))))))))))"
" loop_0)"
" orig-l_0)))))"
" memq_0)"
"(let-values(((memv_0)"
"(lambda(v_0 orig-l_0)"
"(begin"
" 'memv"
"((letrec-values(((loop_0)"
"(lambda(ls_0)"
"(begin"
" 'loop"
"(if(null? ls_0)"
"(let-values() #f)"
"(if(not(pair? ls_0))"
"(let-values()(bad-list$1 'memv orig-l_0))"
"(if(eqv? v_0(car ls_0))"
"(let-values() ls_0)"
"(let-values()(loop_0(cdr ls_0))))))))))"
" loop_0)"
" orig-l_0)))))"
" memv_0)"
"(let-values(((default_0)"
"(let-values(((member_0)"
"(lambda(v_0 orig-l_0)"
"(begin"
" 'member"
"((letrec-values(((loop_0)"
"(lambda(ls_0)"
"(begin"
" 'loop"
"(if(null? ls_0)"
"(let-values() #f)"
"(if(not(pair? ls_0))"
"(let-values()(bad-list$1 'member orig-l_0))"
"(if(equal? v_0(car ls_0))"
"(let-values() ls_0)"
"(let-values()(loop_0(cdr ls_0))))))))))"
" loop_0)"
" orig-l_0)))))"
" member_0)))"
"(let-values(((member_0)"
"(case-lambda"
"((v_0 orig-l_0)(begin 'member(default_0 v_0 orig-l_0)))"
"((v_0 orig-l_0 eq?_0)"
"(begin"
"(if(if(procedure? eq?_0)(procedure-arity-includes? eq?_0 2) #f)"
"(void)"
"                             (raise-argument-error 'member \"(procedure-arity-includes/c 2)\" eq?_0))"
"((let-values(((member_0)"
"(lambda(v_1 orig-l_1)"
"(begin"
" 'member"
"((letrec-values(((loop_0)"
"(lambda(ls_0)"
"(begin"
" 'loop"
"(if(null? ls_0)"
"(let-values() #f)"
"(if(not(pair? ls_0))"
"(let-values()(bad-list$1 'member orig-l_1))"
"(if(eq?_0 v_1(car ls_0))"
"(let-values() ls_0)"
"(let-values()(loop_0(cdr ls_0))))))))))"
" loop_0)"
" orig-l_1)))))"
" member_0)"
" v_0"
" orig-l_0))))))"
" member_0))))))"
"(define-values"
"(current-parameterization)"
"(lambda()(begin(extend-parameterization(continuation-mark-set-first #f parameterization-key)))))"
"(define-values"
"(call-with-parameterization)"
"(lambda(paramz_0 thunk_0)"
"(begin"
"(begin"
"(if(parameterization? paramz_0)"
"(void)"
"          (let-values () (raise-argument-error 'call-with-parameterization \"parameterization?\" 0 paramz_0 thunk_0)))"
"(if(if(procedure? thunk_0)(procedure-arity-includes? thunk_0 0) #f)"
"(void)"
"          (let-values () (raise-argument-error 'call-with-parameterization \"(-> any)\" 1 paramz_0 thunk_0)))"
"(with-continuation-mark parameterization-key paramz_0(thunk_0))))))"
"(define-values"
"(struct:break-paramz make-break-paramz break-paramz? break-paramz-ref break-paramz-set!)"
"(make-struct-type 'break-parameterization #f 1 0 #f))"
"(define-values"
"(current-break-parameterization)"
"(lambda()(begin(make-break-paramz(continuation-mark-set-first #f break-enabled-key)))))"
"(define-values"
"(call-with-break-parameterization)"
"(lambda(paramz_0 thunk_0)"
"(begin"
"(begin"
"(if(break-paramz? paramz_0)"
"(void)"
"(let-values()"
"            (raise-argument-error 'call-with-break-parameterization \"break-parameterization?\" 0 paramz_0 thunk_0)))"
"(if(if(procedure? thunk_0)(procedure-arity-includes? thunk_0 0) #f)"
"(void)"
"          (let-values () (raise-argument-error 'call-with-parameterization \"(-> any)\" 1 paramz_0 thunk_0)))"
"(begin0"
"(with-continuation-mark break-enabled-key(break-paramz-ref paramz_0 0)(begin(check-for-break)(thunk_0)))"
"(check-for-break))))))"
"(define-values"
"(select-handler/no-breaks)"
"(lambda(e_0 bpz_0 l_0)"
"(begin"
"(with-continuation-mark"
" break-enabled-key"
"(make-thread-cell #f)"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null? l_1)"
"(let-values()(raise e_0))"
"(if((caar l_1) e_0)"
"(let-values()"
"(begin0"
"((cdar l_1) e_0)"
"(with-continuation-mark break-enabled-key bpz_0(check-for-break))))"
"(let-values()(loop_0(cdr l_1)))))))))"
" loop_0)"
" l_0)))))"
"(define-values(false-thread-cell)(make-thread-cell #f))"
"(define-values(handler-prompt-key)(make-continuation-prompt-tag 'handler-prompt-tag))"
"(define-values"
"(call-handled-body)"
"(lambda(bpz_0 handle-proc_0 body-thunk_0)"
"(begin"
"(with-continuation-mark"
" break-enabled-key"
" false-thread-cell"
"(call-with-continuation-prompt"
"(lambda(bpz_1 body-thunk_1)"
"(with-continuation-mark"
" break-enabled-key"
" bpz_1"
"(with-continuation-mark"
" exception-handler-key"
"(lambda(e_0)(abort-current-continuation handler-prompt-key e_0))"
"(body-thunk_1))))"
" handler-prompt-key"
" handle-proc_0"
" bpz_0"
" body-thunk_0)))))"
"(define-values"
"(call-with-exception-handler)"
"(lambda(exnh_0 thunk_0)(begin(begin0(with-continuation-mark exception-handler-key exnh_0(thunk_0))(void)))))"
"(define-values(not-there)(gensym))"
"(define-values"
"(do-hash-update)"
"(lambda(who_0 mut?_0 set_0 ht_0 key_0 xform_0 default_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()"
"(begin"
"(if(if(hash? ht_0)(if mut?_0(not(immutable? ht_0))(immutable? ht_0)) #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                   (if mut?_0 \"(and/c hash? (not/c immutable?))\" \"(and/c hash? immutable?)\")"
" ht_0)))"
"(if(if(procedure? xform_0)(procedure-arity-includes? xform_0 1) #f)"
"(void)"
"                (let-values () (raise-argument-error who_0 \"(any/c . -> . any/c)\" xform_0))))))"
"(let-values(((v_0)(hash-ref ht_0 key_0 default_0)))"
"(if(eq? v_0 not-there)"
"            (raise-mismatch-error who_0 \"no value found for key: \" key_0)"
"(set_0 ht_0 key_0(xform_0 v_0))))))))"
"(define-values"
"(hash-update)"
"(case-lambda"
"((ht_0 key_0 xform_0 default_0)(begin(do-hash-update 'hash-update #f hash-set ht_0 key_0 xform_0 default_0)))"
"((ht_0 key_0 xform_0)(hash-update ht_0 key_0 xform_0 not-there))))"
"(define-values"
"(hash-update!)"
"(case-lambda"
"((ht_0 key_0 xform_0 default_0)(begin(do-hash-update 'hash-update! #t hash-set! ht_0 key_0 xform_0 default_0)))"
"((ht_0 key_0 xform_0)(hash-update! ht_0 key_0 xform_0 not-there))))"
"(define-values"
"(hash-ref!)"
"(lambda(ht_0 key_0 new_0)"
"(begin"
"(begin"
"(if(if(hash? ht_0)(not(immutable? ht_0)) #f)"
"(void)"
"          (let-values () (raise-argument-error 'hash-ref! \"(and/c hash? (not/c immutable?))\" 0 ht_0 key_0 new_0)))"
"(let-values(((v_0)(hash-ref ht_0 key_0 not-there)))"
"(if(eq? not-there v_0)"
"(let-values(((n_0)(if(procedure? new_0)(new_0) new_0)))(begin(hash-set! ht_0 key_0 n_0) n_0))"
" v_0))))))"
"(define-values"
"(path-string?)"
"(lambda(s_0)"
"(begin"
"(let-values(((or-part_0)(path? s_0)))"
"(if or-part_0"
" or-part_0"
"(if(string? s_0)"
"(let-values(((or-part_1)(relative-path? s_0)))(if or-part_1 or-part_1(absolute-path? s_0)))"
" #f))))))"
"(define-values(bsbs)(string '#\\\\ '#\\\\))"
"(define-values"
"(normal-case-path)"
"(lambda(s_0)"
"(begin"
"(begin"
"(if(let-values(((or-part_0)(path-for-some-system? s_0)))(if or-part_0 or-part_0(path-string? s_0)))"
"(void)"
"          (let-values () (raise-argument-error 'normal-path-case \"(or/c path-for-some-system? path-string?)\" s_0)))"
"(if(if(path-for-some-system? s_0)(eq?(path-convention-type s_0) 'windows)(eq?(system-type) 'windows))"
"(let-values()"
"(let-values(((str_0)(if(string? s_0) s_0(bytes->string/locale(path->bytes s_0)))))"
"              (if (regexp-match? '#rx\"^[\\\\][\\\\][?][\\\\]\" str_0)"
"(if(string? s_0)(string->path s_0) s_0)"
"(let-values(((s_1)(string-locale-downcase str_0)))"
"(bytes->path"
"(string->bytes/locale"
"(regexp-replace*"
"                     '#rx\"/\""
"                     (if (regexp-match? '#rx\"[/\\\\][. ]+[/\\\\]*$\" s_1)"
" s_1"
"                       (regexp-replace* '#rx\"[ .]+([/\\\\]*)$\" s_1 \"\\\\1\"))"
" bsbs))"
" 'windows)))))"
"(if(string? s_0)(let-values()(string->path s_0))(let-values() s_0)))))))"
"(define-values"
"(check-extension-call)"
"(lambda(s_0 sfx_0 who_0 sep_0 trust-sep?_0)"
"(begin"
"(begin"
"(let-values(((err-msg_0 err-index_0)"
"(if(not"
"(let-values(((or-part_0)(path-for-some-system? s_0)))"
"(if or-part_0 or-part_0(path-string? s_0))))"
"                        (let-values () (values \"(or/c path-for-some-system? path-string?)\" 0))"
"(if(not(let-values(((or-part_0)(string? sfx_0)))(if or-part_0 or-part_0(bytes? sfx_0))))"
"                          (let-values () (values \"(or/c string? bytes?)\" 1))"
"(if(not"
"(let-values(((or-part_0) trust-sep?_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(string? sep_0)))"
"(if or-part_1 or-part_1(bytes? sep_0))))))"
"                            (let-values () (values \"(or/c string? bytes?)\" 2))"
"(let-values()(values #f #f)))))))"
"(if err-msg_0"
"(let-values()"
"(if trust-sep?_0"
"(raise-argument-error who_0 err-msg_0 err-index_0 s_0 sfx_0)"
"(raise-argument-error who_0 err-msg_0 err-index_0 s_0 sfx_0 sep_0)))"
"(void)))"
"(let-values(((base_0 name_0 dir?_0)(split-path s_0)))"
"(begin"
"(if(not base_0)"
"              (let-values () (raise-mismatch-error who_0 \"cannot add an extension to a root path: \" s_0))"
"(void))"
"(values base_0 name_0)))))))"
"(define-values"
"(path-adjust-extension)"
"(lambda(name_0 sep_0 rest-bytes_0 s_0 sfx_0 trust-sep?_0)"
"(begin"
"(let-values(((base_0 name_1)(check-extension-call s_0 sfx_0 name_0 sep_0 trust-sep?_0)))"
"(let-values(((bs_0)(path-element->bytes name_1)))"
"(let-values(((finish_0)"
"(lambda(i_0 sep_1 i2_0)"
"(begin"
" 'finish"
"(bytes->path-element"
"(bytes-append"
"(subbytes bs_0 0 i_0)"
"(if(string? sep_1)(string->bytes/locale sep_1(char->integer '#\\?)) sep_1)"
"(rest-bytes_0 bs_0 i2_0)"
"(if(string? sfx_0)(string->bytes/locale sfx_0(char->integer '#\\?)) sfx_0))"
"(if(path-for-some-system? s_0)"
"(path-convention-type s_0)"
"(system-path-convention-type)))))))"
"(let-values(((new-name_0)"
"(letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(zero? i_0)"
"                                                 (finish_0 (bytes-length bs_0) #\"\" (bytes-length bs_0))"
"(let-values(((i_1)(sub1 i_0)))"
"(if(if(not(zero? i_1))"
"(eq?(char->integer '#\\.)(bytes-ref bs_0 i_1))"
" #f)"
"(finish_0 i_1 sep_0(add1 i_1))"
"(loop_0 i_1))))))))"
"(loop_0(bytes-length bs_0)))))"
"(if(path-for-some-system? base_0)(build-path base_0 new-name_0) new-name_0))))))))"
"(define-values"
"(path-replace-extension)"
"  (lambda (s_0 sfx_0) (begin (path-adjust-extension 'path-replace-extension #\"\" (lambda (bs_0 i_0) #\"\") s_0 sfx_0 #t))))"
"(define-values"
"(path-add-extension)"
"(case-lambda"
"   ((s_0 sfx_0) (begin (path-adjust-extension 'path-add-extension #\"_\" subbytes s_0 sfx_0 #t)))"
"((s_0 sfx_0 sep_0)(path-adjust-extension 'path-add-extension sep_0 subbytes s_0 sfx_0 #f))))"
"(define-values"
"(reroot-path)"
"(lambda(p_0 root_0)"
"(begin"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(path-string? p_0)))"
"(if or-part_0 or-part_0(path-for-some-system? p_0)))"
"(void)"
"(let-values()"
"                          (raise-argument-error 'reroot-path \"(or/c path-string? path-for-some-system?)\" 0 p_0 root_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(path-string? root_0)))"
"(if or-part_0 or-part_0(path-for-some-system? root_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'reroot-path"
"                             \"(or/c path-string? path-for-some-system?)\""
" 1"
" p_0"
" root_0)))"
"(values))))"
"(let-values(((conv_0)"
"(if(path-for-some-system? p_0)(path-convention-type p_0)(system-path-convention-type))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(complete-path? p_0)))"
"(if or-part_0 or-part_0(eq?(system-path-convention-type) conv_0)))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'reroot-path"
"                                 \"path is not complete and not the platform's convention\""
"                                 \"path\""
" p_0"
"                                 \"platform convention type\""
"(system-path-convention-type))))"
"(values))))"
"(let-values((()"
"(begin"
"(if(eq?"
"(if(path-for-some-system? root_0)"
"(path-convention-type root_0)"
"(system-path-convention-type))"
" conv_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'reroot-path"
"                                   \"given paths use different conventions\""
"                                   \"path\""
" p_0"
"                                   \"root path\""
" root_0)))"
"(values))))"
"(let-values(((c-p_0)"
"(normal-case-path"
"(cleanse-path(if(complete-path? p_0) p_0(path->complete-path p_0))))))"
"(let-values(((bstr_0)(path->bytes c-p_0)))"
"(if(eq? conv_0 'unix)"
"(let-values()"
"                        (if (bytes=? bstr_0 #\"/\")"
"(if(path-for-some-system? root_0) root_0(string->path root_0))"
"(build-path root_0(bytes->path(subbytes(path->bytes c-p_0) 1) conv_0))))"
"(if(eq? conv_0 'windows)"
"(let-values()"
"(build-path"
" root_0"
"(bytes->path"
"                            (if (regexp-match? '#rx\"^\\\\\\\\\\\\\\\\[?]\\\\\\\\[a-z]:\" bstr_0)"
"(let-values()"
"                                (bytes-append #\"\\\\\\\\?\\\\REL\\\\\" (subbytes bstr_0 4 5) #\"\\\\\" (subbytes bstr_0 6)))"
"                              (if (regexp-match? '#rx\"^\\\\\\\\\\\\\\\\[?]\\\\\\\\UNC\\\\\\\\\" bstr_0)"
"                                (let-values () (bytes-append #\"\\\\\\\\?\\\\REL\\\\\" (subbytes bstr_0 4)))"
"                                (if (regexp-match? '#rx\"^\\\\\\\\\\\\\\\\[?]\\\\\\\\UNC\\\\\\\\\" bstr_0)"
"                                  (let-values () (bytes-append #\"\\\\\\\\?\\\\REL\\\\\" (subbytes bstr_0 4)))"
"                                  (if (regexp-match? '#rx\"^\\\\\\\\\\\\\\\\\" bstr_0)"
"                                    (let-values () (bytes-append #\"UNC\\\\\" (subbytes bstr_0 2)))"
"                                    (if (regexp-match? '#rx\"^[a-z]:\" bstr_0)"
"(let-values()(bytes-append(subbytes bstr_0 0 1)(subbytes bstr_0 2)))"
"(void))))))"
" conv_0)))"
"(void)))))))))))))"
"(define-values(rx:path-list) #f)"
"(define-values"
"(init-rx:path-list!)"
"(lambda()"
"(begin"
"(if rx:path-list"
"(void)"
"(let-values()"
"(set! rx:path-list"
"(byte-regexp"
"(string->bytes/utf-8"
"              (let-values (((sep_0) (if (eq? (system-type) 'windows) \";\" \":\")))"
"                (format \"([^~a]*)~a(.*)\" sep_0 sep_0))))))))))"
"(define-values"
"(cons-path)"
"(lambda(default_0 s_0 l_0)"
"(begin"
"      (let-values (((s_1) (if (eq? (system-type) 'windows) (regexp-replace* '#rx#\"\\\"\" s_0 #\"\") s_0)))"
"        (if (bytes=? s_1 #\"\") (append default_0 l_0) (cons (bytes->path s_1) l_0))))))"
"(define-values"
"(path-list-string->path-list)"
"(lambda(s_0 default_0)"
"(begin"
"(begin"
"(if(let-values(((or-part_0)(bytes? s_0)))(if or-part_0 or-part_0(string? s_0)))"
"(void)"
"          (let-values () (raise-argument-error 'path-list-string->path-list \"(or/c bytes? string?)\" s_0)))"
"(if(if(list? default_0)(andmap path? default_0) #f)"
"(void)"
"          (let-values () (raise-argument-error 'path-list-string->path-list \"(listof path?)\" default_0)))"
"(init-rx:path-list!)"
"((letrec-values(((loop_0)"
"(lambda(s_1)"
"(begin"
" 'loop"
"(let-values(((m_0)(regexp-match rx:path-list s_1)))"
"(if m_0"
"(cons-path default_0(cadr m_0)(loop_0(caddr m_0)))"
"(cons-path default_0 s_1 null)))))))"
" loop_0)"
"(if(string? s_0)(string->bytes/utf-8 s_0) s_0))))))"
"(define-values"
"(find-executable-path)"
"(case-lambda"
"((program_0 libpath_0 reverse?_0)"
"(begin"
"(begin"
"(if(path-string? program_0)"
"(void)"
"          (let-values () (raise-argument-error 'find-executable-path \"path-string?\" program_0)))"
"(if(let-values(((or-part_0)(not libpath_0)))"
"(if or-part_0 or-part_0(if(path-string? libpath_0)(relative-path? libpath_0) #f)))"
"(void)"
"(let-values()"
"            (raise-argument-error 'find-executable-path \"(or/c #f (and/c path-string? relative-path?))\" libpath_0)))"
"(letrec-values(((found-exec_0)"
"(lambda(exec-name_0)"
"(begin"
" 'found-exec"
"(if libpath_0"
"(let-values(((base_0 name_0 isdir?_0)(split-path exec-name_0)))"
"(let-values(((next_0)"
"(lambda()"
"(begin"
" 'next"
"(let-values(((resolved_0)(resolve-path exec-name_0)))"
"(if(equal? resolved_0 exec-name_0)"
"(let-values() #f)"
"(if(relative-path? resolved_0)"
"(let-values()(found-exec_0(build-path base_0 resolved_0)))"
"(let-values()(found-exec_0 resolved_0)))))))))"
"(let-values(((or-part_0)(if reverse?_0(next_0) #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if(path? base_0)"
"(let-values(((lib_0)(build-path base_0 libpath_0)))"
"(if(let-values(((or-part_1)(directory-exists? lib_0)))"
"(if or-part_1 or-part_1(file-exists? lib_0)))"
" lib_0"
" #f))"
" #f)))"
"(if or-part_1 or-part_1(if(not reverse?_0)(next_0) #f)))))))"
" exec-name_0)))))"
"(if(if(relative-path? program_0)"
"(let-values(((base_0 name_0 dir?_0)(split-path program_0)))(eq? base_0 'relative))"
" #f)"
"            (let-values (((paths-str_0) (environment-variables-ref (current-environment-variables) #\"PATH\"))"
"((win-add_0)"
"(lambda(s_0)"
"                            (begin 'win-add (if (eq? (system-type) 'windows) (cons (bytes->path #\".\") s_0) s_0)))))"
"((letrec-values(((loop_0)"
"(lambda(paths_0)"
"(begin"
" 'loop"
"(if(null? paths_0)"
" #f"
"(let-values(((base_0)(path->complete-path(car paths_0))))"
"(let-values(((name_0)(build-path base_0 program_0)))"
"(if(file-exists? name_0)(found-exec_0 name_0)(loop_0(cdr paths_0))))))))))"
" loop_0)"
"(win-add_0"
"(if paths-str_0(path-list-string->path-list(bytes->string/locale paths-str_0 '#\\?) null) null))))"
"(let-values(((p_0)(path->complete-path program_0)))(if(file-exists? p_0)(found-exec_0 p_0) #f)))))))"
"((program_0 libpath_0)(find-executable-path program_0 libpath_0 #f))"
"((program_0)(find-executable-path program_0 #f #f))))"
"(define-values"
"(call-with-default-reading-parameterization)"
"(lambda(thunk_0)"
"(begin"
"(if(if(procedure? thunk_0)(procedure-arity-includes? thunk_0 0) #f)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" read-case-sensitive"
" #t"
" 1/read-square-bracket-as-paren"
" #t"
" 1/read-curly-brace-as-paren"
" #t"
" 1/read-square-bracket-with-tag"
" #f"
" 1/read-curly-brace-with-tag"
" #f"
" 1/read-accept-box"
" #t"
" 1/read-accept-compiled"
" #f"
" read-accept-bar-quote"
" #t"
" 1/read-accept-graph"
" #t"
" 1/read-decimal-as-inexact"
" #t"
" 1/read-cdot"
" #f"
" 1/read-accept-dot"
" #t"
" 1/read-accept-infix-dot"
" #t"
" 1/read-accept-quasiquote"
" #t"
" 1/read-accept-reader"
" #f"
" 1/read-accept-lang"
" #t"
" 1/current-readtable"
" #f)"
"(let-values()(thunk_0)))"
"        (raise-argument-error 'call-with-default-reading-parameterization \"(procedure-arity-includes/c 0)\" thunk_0)))))"
"(define-values"
"(prop:keyword-impersonator keyword-impersonator? keyword-impersonator-ref)"
"(make-struct-type-property 'keyword-impersonator))"
"(define-values"
"(keyword-procedure-impersonator-of)"
"(lambda(v_0)"
"(begin(if(keyword-impersonator? v_0)(let-values()((keyword-impersonator-ref v_0) v_0))(let-values() #f)))))"
"(define-values"
"(struct:keyword-procedure mk-kw-proc keyword-procedure? keyword-procedure-ref keyword-procedure-set!)"
"(make-struct-type"
" 'keyword-procedure"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:checked-procedure #t)(cons prop:impersonator-of keyword-procedure-impersonator-of))"
"(current-inspector)"
" #f"
" '(0 1 2 3)))"
"(define-values(keyword-procedure-required)(make-struct-field-accessor keyword-procedure-ref 2))"
"(define-values(keyword-procedure-allowed)(make-struct-field-accessor keyword-procedure-ref 3))"
"(define-values"
"(prop:procedure-accessor procedure-accessor? procedure-accessor-ref)"
"(make-struct-type-property"
" 'procedure"
"(lambda(v_0 info-l_0)(if(exact-integer? v_0)(make-struct-field-accessor(list-ref info-l_0 3) v_0) #f))))"
"(define-values"
"(new-prop:procedure new-procedure? new-procedure-ref)"
"(make-struct-type-property"
" 'procedure"
" #f"
"(list(cons prop:procedure values)(cons prop:procedure-accessor values))"
" #t))"
"(define-values"
"(procedure-keywords)"
"(lambda(p_0)"
"(begin"
"(if(keyword-procedure? p_0)"
"(let-values()(values(keyword-procedure-required p_0)(keyword-procedure-allowed p_0)))"
"(if(procedure? p_0)"
"(let-values()"
"(if(new-procedure? p_0)"
"(let-values(((v_0)(new-procedure-ref p_0)))"
"(if(procedure? v_0)"
"(procedure-keywords v_0)"
"(let-values(((a_0)(procedure-accessor-ref p_0)))"
"(if a_0(procedure-keywords(a_0 p_0))(values null null)))))"
"(values null null)))"
"          (let-values () (raise-argument-error 'procedure-keywords \"procedure?\" p_0)))))))"
"(define-values(print-values)(lambda vs_0(begin(begin(for-each(current-print) vs_0)(apply values vs_0)))))"
"(define-values"
"(reverse$1)"
"(lambda(l_0)"
"(begin"
" 'reverse"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"          (if (list? l_0) (void) (raise-argument-error 'reverse \"list?\" l_0)))"
"(letrec-values(((loop_0)"
"(lambda(a_0 l_1)(begin 'loop(if(null? l_1) a_0(loop_0(cons(car l_1) a_0)(cdr l_1)))))))"
"(loop_0 null l_0))))))"
"(define-values"
"(sort vector-sort vector-sort!)"
"(let-values()"
"(let-values(((generic-sort_0)"
"(lambda(A_0 less-than?_0 n_0)"
"(begin"
" 'generic-sort"
"(let-values()"
"(let-values()"
"(let-values(((n/2-_0)(unsafe-fxrshift n_0 1)))"
"(let-values(((n/2+_0)(unsafe-fx- n_0 n/2-_0)))"
"(letrec-values(((copying-mergesort_0)"
"(lambda(Alo_0 Blo_0 n_1)"
"(begin"
" 'copying-mergesort"
"(if(unsafe-fx= n_1 1)"
"(let-values()"
"(unsafe-vector-set! A_0 Blo_0(unsafe-vector-ref A_0 Alo_0)))"
"(if(unsafe-fx= n_1 2)"
"(let-values()"
"(let-values(((x_0)(unsafe-vector-ref A_0 Alo_0))"
"((y_0)"
"(unsafe-vector-ref A_0(unsafe-fx+ Alo_0 1))))"
"(if(less-than?_0 y_0 x_0)"
"(begin"
"(unsafe-vector-set! A_0 Blo_0 y_0)"
"(unsafe-vector-set! A_0(unsafe-fx+ Blo_0 1) x_0))"
"(begin"
"(unsafe-vector-set! A_0 Blo_0 x_0)"
"(unsafe-vector-set! A_0(unsafe-fx+ Blo_0 1) y_0)))))"
"(if(unsafe-fx< n_1 16)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" Blo_0"
"(unsafe-vector-ref A_0 Alo_0))"
"((letrec-values(((iloop_0)"
"(lambda(i_0)"
"(begin"
" 'iloop"
"(if(unsafe-fx< i_0 n_1)"
"(let-values()"
"(let-values(((ref-i_0)"
"(unsafe-vector-ref"
" A_0"
"(unsafe-fx+"
" Alo_0"
" i_0))))"
"((letrec-values(((jloop_0)"
"(lambda(j_0)"
"(begin"
" 'jloop"
"(let-values(((ref-j-1_0)"
"(unsafe-vector-ref"
" A_0"
"(unsafe-fx-"
" j_0"
" 1))))"
"(if(if(unsafe-fx<"
" Blo_0"
" j_0)"
"(less-than?_0"
" ref-i_0"
" ref-j-1_0)"
" #f)"
"(begin"
"(unsafe-vector-set!"
" A_0"
" j_0"
" ref-j-1_0)"
"(jloop_0"
"(unsafe-fx-"
" j_0"
" 1)))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" j_0"
" ref-i_0)"
"(iloop_0"
"(unsafe-fx+"
" i_0"
" 1)))))))))"
" jloop_0)"
"(unsafe-fx+ Blo_0 i_0))))"
"(void))))))"
" iloop_0)"
" 1)))"
"(let-values()"
"(let-values(((n/2-_1)(unsafe-fxrshift n_1 1)))"
"(let-values(((n/2+_1)(unsafe-fx- n_1 n/2-_1)))"
"(let-values(((Amid1_0)(unsafe-fx+ Alo_0 n/2-_1))"
"((Amid2_0)(unsafe-fx+ Alo_0 n/2+_1))"
"((Bmid1_0)(unsafe-fx+ Blo_0 n/2-_1)))"
"(begin"
"(copying-mergesort_0 Amid1_0 Bmid1_0 n/2+_1)"
"(copying-mergesort_0 Alo_0 Amid2_0 n/2-_1)"
"(let-values(((b2_0)(unsafe-fx+ Blo_0 n_1)))"
"((letrec-values(((loop_0)"
"(lambda(a1_0 b1_0 c1_0)"
"(begin"
" 'loop"
"(let-values(((x_0)"
"(unsafe-vector-ref"
" A_0"
" a1_0))"
"((y_0)"
"(unsafe-vector-ref"
" A_0"
" b1_0)))"
"(if(not"
"(less-than?_0"
" y_0"
" x_0))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_0"
" x_0)"
"(let-values(((a1_1)"
"(unsafe-fx+"
" a1_0"
" 1))"
"((c1_1)"
"(unsafe-fx+"
" c1_0"
" 1)))"
"(if(unsafe-fx<"
" c1_1"
" b1_0)"
"(let-values()"
"(loop_0"
" a1_1"
" b1_0"
" c1_1))"
"(void))))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_0"
" y_0)"
"(let-values(((b1_1)"
"(unsafe-fx+"
" b1_0"
" 1))"
"((c1_1)"
"(unsafe-fx+"
" c1_0"
" 1)))"
"(if(unsafe-fx<="
" b2_0"
" b1_1)"
"((letrec-values(((loop_1)"
"(lambda(a1_1"
" c1_2)"
"(begin"
" 'loop"
"(if(unsafe-fx<"
" c1_2"
" b1_1)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_2"
"(unsafe-vector-ref"
" A_0"
" a1_1))"
"(loop_1"
"(unsafe-fx+"
" a1_1"
" 1)"
"(unsafe-fx+"
" c1_2"
" 1))))"
"(void))))))"
" loop_1)"
" a1_0"
" c1_1)"
"(loop_0"
" a1_0"
" b1_1"
" c1_1))))))))))"
" loop_0)"
" Amid2_0"
" Bmid1_0"
" Blo_0))))))))))))))"
"(let-values(((Alo_0) 0)"
"((Amid1_0) n/2-_0)"
"((Amid2_0) n/2+_0)"
"((Ahi_0) n_0)"
"((B1lo_0) n_0))"
"(begin"
"(copying-mergesort_0 Amid1_0 B1lo_0 n/2+_0)"
"(if(zero? n/2-_0)"
"(void)"
"(let-values()(copying-mergesort_0 Alo_0 Amid2_0 n/2-_0)))"
"(let-values(((b2_0) Ahi_0))"
"((letrec-values(((loop_0)"
"(lambda(a1_0 b1_0 c1_0)"
"(begin"
" 'loop"
"(let-values(((x_0)(unsafe-vector-ref A_0 a1_0))"
"((y_0)(unsafe-vector-ref A_0 b1_0)))"
"(if(less-than?_0 x_0 y_0)"
"(begin"
"(unsafe-vector-set! A_0 c1_0 x_0)"
"(let-values(((a1_1)(unsafe-fx+ a1_0 1))"
"((c1_1)(unsafe-fx+ c1_0 1)))"
"(if(unsafe-fx< c1_1 b1_0)"
"(let-values()(loop_0 a1_1 b1_0 c1_1))"
"(void))))"
"(begin"
"(unsafe-vector-set! A_0 c1_0 y_0)"
"(let-values(((b1_1)(unsafe-fx+ b1_0 1))"
"((c1_1)(unsafe-fx+ c1_0 1)))"
"(if(unsafe-fx<= b2_0 b1_1)"
"((letrec-values(((loop_1)"
"(lambda(a1_1 c1_2)"
"(begin"
" 'loop"
"(if(unsafe-fx< c1_2 b1_1)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_2"
"(unsafe-vector-ref"
" A_0"
" a1_1))"
"(loop_1"
"(unsafe-fx+ a1_1 1)"
"(unsafe-fx+"
" c1_2"
" 1))))"
"(void))))))"
" loop_1)"
" a1_0"
" c1_1)"
"(loop_0 a1_0 b1_1 c1_1))))))))))"
" loop_0)"
" B1lo_0"
" Amid2_0"
" Alo_0)))))))))))))"
"(let-values(((generic-sort/key_0)"
"(lambda(A_0 less-than?_0 n_0 key_0)"
"(begin"
" 'generic-sort/key"
"(let-values()"
"(let-values()"
"(let-values(((n/2-_0)(unsafe-fxrshift n_0 1)))"
"(let-values(((n/2+_0)(unsafe-fx- n_0 n/2-_0)))"
"(letrec-values(((copying-mergesort_0)"
"(lambda(Alo_0 Blo_0 n_1)"
"(begin"
" 'copying-mergesort"
"(if(unsafe-fx= n_1 1)"
"(let-values()"
"(unsafe-vector-set! A_0 Blo_0(unsafe-vector-ref A_0 Alo_0)))"
"(if(unsafe-fx= n_1 2)"
"(let-values()"
"(let-values(((x_0)(unsafe-vector-ref A_0 Alo_0))"
"((y_0)"
"(unsafe-vector-ref A_0(unsafe-fx+ Alo_0 1))))"
"(if(if key_0"
"(less-than?_0(key_0 y_0)(key_0 x_0))"
"(less-than?_0 y_0 x_0))"
"(begin"
"(unsafe-vector-set! A_0 Blo_0 y_0)"
"(unsafe-vector-set! A_0(unsafe-fx+ Blo_0 1) x_0))"
"(begin"
"(unsafe-vector-set! A_0 Blo_0 x_0)"
"(unsafe-vector-set! A_0(unsafe-fx+ Blo_0 1) y_0)))))"
"(if(unsafe-fx< n_1 16)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" Blo_0"
"(unsafe-vector-ref A_0 Alo_0))"
"((letrec-values(((iloop_0)"
"(lambda(i_0)"
"(begin"
" 'iloop"
"(if(unsafe-fx< i_0 n_1)"
"(let-values()"
"(let-values(((ref-i_0)"
"(unsafe-vector-ref"
" A_0"
"(unsafe-fx+"
" Alo_0"
" i_0))))"
"((letrec-values(((jloop_0)"
"(lambda(j_0)"
"(begin"
" 'jloop"
"(let-values(((ref-j-1_0)"
"(unsafe-vector-ref"
" A_0"
"(unsafe-fx-"
" j_0"
" 1))))"
"(if(if(unsafe-fx<"
" Blo_0"
" j_0)"
"(if key_0"
"(less-than?_0"
"(key_0"
" ref-i_0)"
"(key_0"
" ref-j-1_0))"
"(less-than?_0"
" ref-i_0"
" ref-j-1_0))"
" #f)"
"(begin"
"(unsafe-vector-set!"
" A_0"
" j_0"
" ref-j-1_0)"
"(jloop_0"
"(unsafe-fx-"
" j_0"
" 1)))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" j_0"
" ref-i_0)"
"(iloop_0"
"(unsafe-fx+"
" i_0"
" 1)))))))))"
" jloop_0)"
"(unsafe-fx+ Blo_0 i_0))))"
"(void))))))"
" iloop_0)"
" 1)))"
"(let-values()"
"(let-values(((n/2-_1)(unsafe-fxrshift n_1 1)))"
"(let-values(((n/2+_1)(unsafe-fx- n_1 n/2-_1)))"
"(let-values(((Amid1_0)(unsafe-fx+ Alo_0 n/2-_1))"
"((Amid2_0)(unsafe-fx+ Alo_0 n/2+_1))"
"((Bmid1_0)(unsafe-fx+ Blo_0 n/2-_1)))"
"(begin"
"(copying-mergesort_0 Amid1_0 Bmid1_0 n/2+_1)"
"(copying-mergesort_0 Alo_0 Amid2_0 n/2-_1)"
"(let-values(((b2_0)(unsafe-fx+ Blo_0 n_1)))"
"((letrec-values(((loop_0)"
"(lambda(a1_0 b1_0 c1_0)"
"(begin"
" 'loop"
"(let-values(((x_0)"
"(unsafe-vector-ref"
" A_0"
" a1_0))"
"((y_0)"
"(unsafe-vector-ref"
" A_0"
" b1_0)))"
"(if(not"
"(if key_0"
"(less-than?_0"
"(key_0 y_0)"
"(key_0 x_0))"
"(less-than?_0"
" y_0"
" x_0)))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_0"
" x_0)"
"(let-values(((a1_1)"
"(unsafe-fx+"
" a1_0"
" 1))"
"((c1_1)"
"(unsafe-fx+"
" c1_0"
" 1)))"
"(if(unsafe-fx<"
" c1_1"
" b1_0)"
"(let-values()"
"(loop_0"
" a1_1"
" b1_0"
" c1_1))"
"(void))))"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_0"
" y_0)"
"(let-values(((b1_1)"
"(unsafe-fx+"
" b1_0"
" 1))"
"((c1_1)"
"(unsafe-fx+"
" c1_0"
" 1)))"
"(if(unsafe-fx<="
" b2_0"
" b1_1)"
"((letrec-values(((loop_1)"
"(lambda(a1_1"
" c1_2)"
"(begin"
" 'loop"
"(if(unsafe-fx<"
" c1_2"
" b1_1)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_2"
"(unsafe-vector-ref"
" A_0"
" a1_1))"
"(loop_1"
"(unsafe-fx+"
" a1_1"
" 1)"
"(unsafe-fx+"
" c1_2"
" 1))))"
"(void))))))"
" loop_1)"
" a1_0"
" c1_1)"
"(loop_0"
" a1_0"
" b1_1"
" c1_1))))))))))"
" loop_0)"
" Amid2_0"
" Bmid1_0"
" Blo_0))))))))))))))"
"(let-values(((Alo_0) 0)"
"((Amid1_0) n/2-_0)"
"((Amid2_0) n/2+_0)"
"((Ahi_0) n_0)"
"((B1lo_0) n_0))"
"(begin"
"(copying-mergesort_0 Amid1_0 B1lo_0 n/2+_0)"
"(if(zero? n/2-_0)"
"(void)"
"(let-values()(copying-mergesort_0 Alo_0 Amid2_0 n/2-_0)))"
"(let-values(((b2_0) Ahi_0))"
"((letrec-values(((loop_0)"
"(lambda(a1_0 b1_0 c1_0)"
"(begin"
" 'loop"
"(let-values(((x_0)(unsafe-vector-ref A_0 a1_0))"
"((y_0)(unsafe-vector-ref A_0 b1_0)))"
"(if(if key_0"
"(less-than?_0(key_0 x_0)(key_0 y_0))"
"(less-than?_0 x_0 y_0))"
"(begin"
"(unsafe-vector-set! A_0 c1_0 x_0)"
"(let-values(((a1_1)(unsafe-fx+ a1_0 1))"
"((c1_1)(unsafe-fx+ c1_0 1)))"
"(if(unsafe-fx< c1_1 b1_0)"
"(let-values()(loop_0 a1_1 b1_0 c1_1))"
"(void))))"
"(begin"
"(unsafe-vector-set! A_0 c1_0 y_0)"
"(let-values(((b1_1)(unsafe-fx+ b1_0 1))"
"((c1_1)(unsafe-fx+ c1_0 1)))"
"(if(unsafe-fx<= b2_0 b1_1)"
"((letrec-values(((loop_1)"
"(lambda(a1_1 c1_2)"
"(begin"
" 'loop"
"(if(unsafe-fx< c1_2 b1_1)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" A_0"
" c1_2"
"(unsafe-vector-ref"
" A_0"
" a1_1))"
"(loop_1"
"(unsafe-fx+ a1_1 1)"
"(unsafe-fx+"
" c1_2"
" 1))))"
"(void))))))"
" loop_1)"
" a1_0"
" c1_1)"
"(loop_0 a1_0 b1_1 c1_1))))))))))"
" loop_0)"
" B1lo_0"
" Amid2_0"
" Alo_0)))))))))))))"
"(values"
"(case-lambda"
"((lst_0 less-than?_0)"
"(let-values(((n_0)(length lst_0)))"
"(let-values()"
"(if(unsafe-fx= n_0 0)"
"(let-values() lst_0)"
"(if((letrec-values(((loop_0)"
"(lambda(last_0 next_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(null? next_0)))"
"(if or-part_0"
" or-part_0"
"(if(not(less-than?_0(unsafe-car next_0) last_0))"
"(loop_0(unsafe-car next_0)(unsafe-cdr next_0))"
" #f)))))))"
" loop_0)"
"(car lst_0)"
"(cdr lst_0))"
"(let-values() lst_0)"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(if(unsafe-fx= n_0 1)"
"(let-values() lst_0)"
"(if(unsafe-fx= n_0 2)"
"(let-values()(list(cadr lst_0)(car lst_0)))"
"(let-values()"
"(let-values(((a_0)(car lst_0))((b_0)(cadr lst_0))((c_0)(caddr lst_0)))"
"(if(less-than?_0 b_0 a_0)"
"(if(less-than?_0 c_0 b_0)"
"(list c_0 b_0 a_0)"
"(if(less-than?_0 c_0 a_0)(list b_0 c_0 a_0)(list b_0 a_0 c_0)))"
"(if(less-than?_0 c_0 a_0)(list c_0 a_0 b_0)(list a_0 c_0 b_0))))))))"
"(let-values()"
"(let-values(((vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))))))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0 lst_1)"
"(begin"
" 'loop"
"(if(pair? lst_1)"
"(let-values()"
"(begin"
"(vector-set! vec_0 i_0(car lst_1))"
"(loop_0(add1 i_0)(cdr lst_1))))"
"(void))))))"
" loop_0)"
" 0"
" lst_0)"
"(generic-sort_0 vec_0 less-than?_0 n_0)"
"((letrec-values(((loop_0)"
"(lambda(i_0 r_0)"
"(begin"
" 'loop"
"(let-values(((i_1)(sub1 i_0)))"
"(if(< i_1 0)"
" r_0"
"(loop_0 i_1(cons(vector-ref vec_0 i_1) r_0))))))))"
" loop_0)"
" n_0"
" '()))))))))))"
"((lst_0 less-than?_0 getkey_0)"
"(if(if getkey_0(not(eq? values getkey_0)) #f)"
"(sort lst_0 less-than?_0 getkey_0 #f)"
"(sort lst_0 less-than?_0)))"
"((lst_0 less-than?_0 getkey_0 cache-keys?_0)"
"(if(if getkey_0(not(eq? values getkey_0)) #f)"
"(let-values(((n_0)(length lst_0)))"
"(let-values()"
"(if(unsafe-fx= n_0 0)"
"(let-values() lst_0)"
"(if cache-keys?_0"
"(let-values()"
"(let-values(((vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))))))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0 lst_1)"
"(begin"
" 'loop"
"(if(pair? lst_1)"
"(let-values()"
"(let-values(((x_0)(car lst_1)))"
"(begin"
"(unsafe-vector-set! vec_0 i_0(cons(getkey_0 x_0) x_0))"
"(loop_0(unsafe-fx+ i_0 1)(cdr lst_1)))))"
"(void))))))"
" loop_0)"
" 0"
" lst_0)"
"(generic-sort/key_0 vec_0 less-than?_0 n_0 unsafe-car)"
"((letrec-values(((loop_0)"
"(lambda(i_0 r_0)"
"(begin"
" 'loop"
"(let-values(((i_1)(unsafe-fx- i_0 1)))"
"(if(unsafe-fx< i_1 0)"
" r_0"
"(loop_0"
" i_1"
"(cons(unsafe-cdr(unsafe-vector-ref vec_0 i_1)) r_0))))))))"
" loop_0)"
" n_0"
" '()))))"
"(if((letrec-values(((loop_0)"
"(lambda(last_0 next_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(null? next_0)))"
"(if or-part_0"
" or-part_0"
"(if(not"
"(if getkey_0"
"(less-than?_0"
"(getkey_0(unsafe-car next_0))"
"(getkey_0 last_0))"
"(less-than?_0(unsafe-car next_0) last_0)))"
"(loop_0(unsafe-car next_0)(unsafe-cdr next_0))"
" #f)))))))"
" loop_0)"
"(car lst_0)"
"(cdr lst_0))"
"(let-values() lst_0)"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(if(unsafe-fx= n_0 1)"
"(let-values() lst_0)"
"(if(unsafe-fx= n_0 2)"
"(let-values()(list(cadr lst_0)(car lst_0)))"
"(let-values()"
"(let-values(((a_0)(car lst_0))((b_0)(cadr lst_0))((c_0)(caddr lst_0)))"
"(if(if getkey_0(less-than?_0(getkey_0 b_0)(getkey_0 a_0))(less-than?_0 b_0 a_0))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 b_0))"
"(less-than?_0 c_0 b_0))"
"(list c_0 b_0 a_0)"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(list b_0 c_0 a_0)"
"(list b_0 a_0 c_0)))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(list c_0 a_0 b_0)"
"(list a_0 c_0 b_0))))))))"
"(let-values()"
"(let-values(((vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))))))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0 lst_1)"
"(begin"
" 'loop"
"(if(pair? lst_1)"
"(let-values()"
"(begin"
"(vector-set! vec_0 i_0(car lst_1))"
"(loop_0(add1 i_0)(cdr lst_1))))"
"(void))))))"
" loop_0)"
" 0"
" lst_0)"
"(generic-sort/key_0 vec_0 less-than?_0 n_0 getkey_0)"
"((letrec-values(((loop_0)"
"(lambda(i_0 r_0)"
"(begin"
" 'loop"
"(let-values(((i_1)(sub1 i_0)))"
"(if(< i_1 0)"
" r_0"
"(loop_0 i_1(cons(vector-ref vec_0 i_1) r_0))))))))"
" loop_0)"
" n_0"
" '()))))))))))"
"(sort lst_0 less-than?_0))))"
"(case-lambda"
"((vec_0 less-than?_0 start_0 end_0)"
"(let-values(((n_0)(- end_0 start_0)))"
"(let-values(((dst-vec_0)(make-vector n_0)))"
"(let-values(((dst-start_0) 0))"
"(begin"
"(if(unsafe-fx= n_0 0)"
"(let-values()(void))"
"(if((letrec-values(((loop_0)"
"(lambda(prev-val_0 next-index_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(unsafe-fx= next-index_0 end_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((next-val_0)(unsafe-vector-ref vec_0 next-index_0)))"
"(if(not(less-than?_0 next-val_0 prev-val_0))"
"(loop_0 next-val_0(unsafe-fx+ next-index_0 1))"
" #f))))))))"
" loop_0)"
"(unsafe-vector-ref vec_0 start_0)"
"(unsafe-fx+ start_0 1))"
"(let-values()(let-values()(vector-copy! dst-vec_0 dst-start_0 vec_0 start_0 end_0)))"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(begin"
"(let-values()(vector-copy! dst-vec_0 dst-start_0 vec_0 start_0 end_0))"
"(if(unsafe-fx= n_0 1)"
"(let-values()(void))"
"(if(unsafe-fx= n_0 2)"
"(let-values()"
"(let-values(((tmp_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0))))"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ dst-start_0 0)"
"(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) tmp_0))))"
"(let-values()"
"(let-values(((a_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0)))"
"((b_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"((c_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 2))))"
"(if(less-than?_0 b_0 a_0)"
"(let-values()"
"(if(less-than?_0 c_0 b_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(if(less-than?_0 c_0 a_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0))))))"
"(if(less-than?_0 c_0 a_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))))))))))"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #f)))"
"(begin"
"(vector-copy! work-vec_0 0 vec_0 start_0 end_0)"
"(generic-sort_0 work-vec_0 less-than?_0 n_0)"
"(vector-copy! dst-vec_0 dst-start_0 work-vec_0 0 n_0)))))))"
" dst-vec_0)))))"
"((vec_0 less-than?_0 start_0 end_0 getkey_0 cache-keys?_0)"
"(if(if getkey_0(not(eq? values getkey_0)) #f)"
"(let-values(((n_0)(- end_0 start_0)))"
"(let-values(((dst-vec_0)(make-vector n_0)))"
"(let-values(((dst-start_0) 0))"
"(begin"
"(if(unsafe-fx= n_0 0)"
"(let-values()(void))"
"(if cache-keys?_0"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #t)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(unsafe-fx< i_0 n_0)"
"(let-values()"
"(begin"
"(let-values(((x_0)"
"(unsafe-vector-ref"
" vec_0"
"(unsafe-fx+ i_0 start_0))))"
"(unsafe-vector-set!"
" work-vec_0"
" i_0"
"(cons(getkey_0 x_0) x_0)))"
"(loop_0(unsafe-fx+ i_0 1))))"
"(void))))))"
" loop_0)"
" 0)"
"(generic-sort/key_0 work-vec_0 less-than?_0 n_0 unsafe-car)"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(unsafe-fx< i_0 n_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ i_0 dst-start_0)"
"(unsafe-cdr(unsafe-vector-ref work-vec_0 i_0)))"
"(loop_0(unsafe-fx+ i_0 1))))"
"(void))))))"
" loop_0)"
" 0))))"
"(if((letrec-values(((loop_0)"
"(lambda(prev-val_0 next-index_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(unsafe-fx= next-index_0 end_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((next-val_0)"
"(unsafe-vector-ref vec_0 next-index_0)))"
"(if(not"
"(if getkey_0"
"(less-than?_0"
"(getkey_0 next-val_0)"
"(getkey_0 prev-val_0))"
"(less-than?_0 next-val_0 prev-val_0)))"
"(loop_0 next-val_0(unsafe-fx+ next-index_0 1))"
" #f))))))))"
" loop_0)"
"(unsafe-vector-ref vec_0 start_0)"
"(unsafe-fx+ start_0 1))"
"(let-values()(let-values()(vector-copy! dst-vec_0 dst-start_0 vec_0 start_0 end_0)))"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(begin"
"(let-values()(vector-copy! dst-vec_0 dst-start_0 vec_0 start_0 end_0))"
"(if(unsafe-fx= n_0 1)"
"(let-values()(void))"
"(if(unsafe-fx= n_0 2)"
"(let-values()"
"(let-values(((tmp_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0))))"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ dst-start_0 0)"
"(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) tmp_0))))"
"(let-values()"
"(let-values(((a_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0)))"
"((b_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"((c_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 2))))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 b_0)(getkey_0 a_0))"
"(less-than?_0 b_0 a_0))"
"(let-values()"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 b_0))"
"(less-than?_0 c_0 b_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0))))))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))))))))))"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #f)))"
"(begin"
"(vector-copy! work-vec_0 0 vec_0 start_0 end_0)"
"(generic-sort/key_0 work-vec_0 less-than?_0 n_0 getkey_0)"
"(vector-copy! dst-vec_0 dst-start_0 work-vec_0 0 n_0))))))))"
" dst-vec_0))))"
"(vector-sort vec_0 less-than?_0 start_0 end_0))))"
"(case-lambda"
"((vec_0 less-than?_0 start_0 end_0)"
"(let-values(((n_0)(- end_0 start_0)))"
"(let-values(((dst-vec_0) vec_0))"
"(let-values(((dst-start_0) start_0))"
"(begin"
"(if(unsafe-fx= n_0 0)"
"(let-values()(void))"
"(if((letrec-values(((loop_0)"
"(lambda(prev-val_0 next-index_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(unsafe-fx= next-index_0 end_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((next-val_0)(unsafe-vector-ref vec_0 next-index_0)))"
"(if(not(less-than?_0 next-val_0 prev-val_0))"
"(loop_0 next-val_0(unsafe-fx+ next-index_0 1))"
" #f))))))))"
" loop_0)"
"(unsafe-vector-ref vec_0 start_0)"
"(unsafe-fx+ start_0 1))"
"(let-values()(void))"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(begin"
"(void)"
"(if(unsafe-fx= n_0 1)"
"(let-values()(void))"
"(if(unsafe-fx= n_0 2)"
"(let-values()"
"(let-values(((tmp_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0))))"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ dst-start_0 0)"
"(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) tmp_0))))"
"(let-values()"
"(let-values(((a_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0)))"
"((b_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"((c_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 2))))"
"(if(less-than?_0 b_0 a_0)"
"(let-values()"
"(if(less-than?_0 c_0 b_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(if(less-than?_0 c_0 a_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0))))))"
"(if(less-than?_0 c_0 a_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))))))))))"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #f)))"
"(begin"
"(vector-copy! work-vec_0 0 vec_0 start_0 end_0)"
"(generic-sort_0 work-vec_0 less-than?_0 n_0)"
"(vector-copy! dst-vec_0 dst-start_0 work-vec_0 0 n_0)))))))"
"(void))))))"
"((vec_0 less-than?_0 start_0 end_0 getkey_0 cache-keys?_0)"
"(if(if getkey_0(not(eq? values getkey_0)) #f)"
"(let-values(((n_0)(- end_0 start_0)))"
"(let-values(((dst-vec_0) vec_0))"
"(let-values(((dst-start_0) start_0))"
"(begin"
"(if(unsafe-fx= n_0 0)"
"(let-values()(void))"
"(if cache-keys?_0"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #t)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(unsafe-fx< i_0 n_0)"
"(let-values()"
"(begin"
"(let-values(((x_0)"
"(unsafe-vector-ref"
" vec_0"
"(unsafe-fx+ i_0 start_0))))"
"(unsafe-vector-set!"
" work-vec_0"
" i_0"
"(cons(getkey_0 x_0) x_0)))"
"(loop_0(unsafe-fx+ i_0 1))))"
"(void))))))"
" loop_0)"
" 0)"
"(generic-sort/key_0 work-vec_0 less-than?_0 n_0 unsafe-car)"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(unsafe-fx< i_0 n_0)"
"(let-values()"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ i_0 dst-start_0)"
"(unsafe-cdr(unsafe-vector-ref work-vec_0 i_0)))"
"(loop_0(unsafe-fx+ i_0 1))))"
"(void))))))"
" loop_0)"
" 0))))"
"(if((letrec-values(((loop_0)"
"(lambda(prev-val_0 next-index_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(unsafe-fx= next-index_0 end_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((next-val_0)"
"(unsafe-vector-ref vec_0 next-index_0)))"
"(if(not"
"(if getkey_0"
"(less-than?_0"
"(getkey_0 next-val_0)"
"(getkey_0 prev-val_0))"
"(less-than?_0 next-val_0 prev-val_0)))"
"(loop_0 next-val_0(unsafe-fx+ next-index_0 1))"
" #f))))))))"
" loop_0)"
"(unsafe-vector-ref vec_0 start_0)"
"(unsafe-fx+ start_0 1))"
"(let-values()(void))"
"(if(unsafe-fx<= n_0 3)"
"(let-values()"
"(begin"
"(void)"
"(if(unsafe-fx= n_0 1)"
"(let-values()(void))"
"(if(unsafe-fx= n_0 2)"
"(let-values()"
"(let-values(((tmp_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0))))"
"(begin"
"(unsafe-vector-set!"
" dst-vec_0"
"(unsafe-fx+ dst-start_0 0)"
"(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) tmp_0))))"
"(let-values()"
"(let-values(((a_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 0)))"
"((b_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 1)))"
"((c_0)(unsafe-vector-ref dst-vec_0(unsafe-fx+ dst-start_0 2))))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 b_0)(getkey_0 a_0))"
"(less-than?_0 b_0 a_0))"
"(let-values()"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 b_0))"
"(less-than?_0 c_0 b_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) a_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) b_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0))))))"
"(if(if getkey_0"
"(less-than?_0(getkey_0 c_0)(getkey_0 a_0))"
"(less-than?_0 c_0 a_0))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 0) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) a_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))"
"(let-values()"
"(begin"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 1) c_0)"
"(unsafe-vector-set! dst-vec_0(unsafe-fx+ dst-start_0 2) b_0)))))))))))"
"(let-values()"
"(let-values(((work-vec_0)(make-vector(+ n_0(ceiling(/ n_0 2))) #f)))"
"(begin"
"(vector-copy! work-vec_0 0 vec_0 start_0 end_0)"
"(generic-sort/key_0 work-vec_0 less-than?_0 n_0 getkey_0)"
"(vector-copy! dst-vec_0 dst-start_0 work-vec_0 0 n_0))))))))"
"(void)))))"
"(vector-sort! vec_0 less-than?_0 start_0 end_0)))))))))"
"(define-values"
"(prop:stream stream-via-prop? stream-ref)"
"(make-struct-type-property"
" 'stream"
"(lambda(v_0 si_0)"
"(begin"
"(if(if(vector? v_0)"
"(if(= 3(vector-length v_0))"
"(if(procedure?(vector-ref v_0 0))"
"(if(procedure-arity-includes?(vector-ref v_0 0) 1)"
"(if(procedure?(vector-ref v_0 1))"
"(if(procedure-arity-includes?(vector-ref v_0 1) 1)"
"(if(procedure?(vector-ref v_0 2))(procedure-arity-includes?(vector-ref v_0 2) 1) #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'guard-for-prop:stream"
"(string-append"
"             \"(vector/c (procedure-arity-includes/c 1)\\n\""
"             \"          (procedure-arity-includes/c 1)\\n\""
"             \"          (procedure-arity-includes/c 1))\")"
" v_0)))"
"(vector->immutable-vector v_0)))"
" '()"
" #t))"
"(define-values"
"(prop:gen-sequence sequence-via-prop? sequence-ref)"
"(make-struct-type-property"
" 'sequence"
"(lambda(v_0 si_0)"
"(begin"
"(if(if(procedure? v_0)(procedure-arity-includes? v_0 1) #f)"
"(void)"
"         (let-values () (raise-argument-error 'guard-for-prop:sequence \"(procedure-arity-includes/c 1)\" v_0)))"
" v_0))))"
"(define-values"
"(struct:range make-range range? range-ref range-set!)"
"(make-struct-type"
" 'stream"
" #f"
" 3"
" 0"
" #f"
"(list"
"(cons"
" prop:stream"
"(vector"
"(lambda(v_0)(let-values(((cont?_0)(range-ref v_0 2)))(if cont?_0(not(cont?_0(range-ref v_0 0))) #f)))"
"(lambda(v_0)(range-ref v_0 0))"
"(lambda(v_0)(make-range((range-ref v_0 1)(range-ref v_0 0))(range-ref v_0 1)(range-ref v_0 2)))))"
"(cons"
" prop:gen-sequence"
"(lambda(v_0)(values values #f(range-ref v_0 1)(range-ref v_0 0)(range-ref v_0 2) #f #f))))))"
"(define-values"
"(check-range)"
"(lambda(a_0 b_0 step_0)"
"(begin"
"(begin"
"        (if (real? a_0) (void) (let-values () (raise-argument-error 'in-range \"real?\" a_0)))"
"        (if (real? b_0) (void) (let-values () (raise-argument-error 'in-range \"real?\" b_0)))"
"        (if (real? step_0) (void) (let-values () (raise-argument-error 'in-range \"real?\" step_0)))))))"
"(define-values"
"(check-naturals)"
"(lambda(n_0)"
"(begin"
"(if(if(integer? n_0)(if(exact? n_0)(>= n_0 0) #f) #f)"
"(void)"
"        (let-values () (raise-argument-error 'in-naturals \"exact-nonnegative-integer?\" n_0))))))"
"(define-values"
"(struct:list-stream make-list-stream list-stream? list-stream-ref list-stream-set!)"
"(make-struct-type"
" 'stream"
" #f"
" 1"
" 0"
" #f"
"(list"
"(cons"
" prop:stream"
"(vector"
"(lambda(v_0)(not(pair?(list-stream-ref v_0 0))))"
"(lambda(v_0)(car(list-stream-ref v_0 0)))"
"(lambda(v_0)(make-list-stream(cdr(list-stream-ref v_0 0))))))"
"(cons prop:gen-sequence(lambda(v_0)(values car cdr values(list-stream-ref v_0 0) pair? #f #f))))))"
"(define-values"
"(check-list)"
"  (lambda (l_0) (begin (if (list? l_0) (void) (let-values () (raise-argument-error 'in-list \"list?\" l_0))))))"
"(define-values"
"(check-in-hash)"
"(lambda(ht_0)"
"(begin"
"      (if ((lambda (ht_1) (hash? ht_1)) ht_0) (void) (let-values () (raise-argument-error 'in-hash \"hash?\" ht_0))))))"
"(define-values"
"(check-in-immutable-hash)"
"(lambda(ht_0)"
"(begin"
"(if((lambda(ht_1)(if(hash? ht_1)(immutable? ht_1) #f)) ht_0)"
"(void)"
"        (let-values () (raise-argument-error 'in-immutable-hash \"(and/c hash? immutable?)\" ht_0))))))"
"(define-values"
"(check-in-hash-keys)"
"(lambda(ht_0)"
"(begin"
"(if((lambda(ht_1)(hash? ht_1)) ht_0)"
"(void)"
"        (let-values () (raise-argument-error 'in-hash-keys \"hash?\" ht_0))))))"
"(define-values"
"(check-in-immutable-hash-keys)"
"(lambda(ht_0)"
"(begin"
"(if((lambda(ht_1)(if(hash? ht_1)(immutable? ht_1) #f)) ht_0)"
"(void)"
"        (let-values () (raise-argument-error 'in-immutable-hash-keys \"(and/c hash? immutable?)\" ht_0))))))"
"(define-values"
"(check-in-hash-values)"
"(lambda(ht_0)"
"(begin"
"(if((lambda(ht_1)(hash? ht_1)) ht_0)"
"(void)"
"        (let-values () (raise-argument-error 'in-hash-values \"hash?\" ht_0))))))"
"(define-values"
"(check-ranges)"
"(lambda(who_0 vec_0 start_0 stop_0 step_0 len_0)"
"(begin"
"(begin"
"(if(if(exact-nonnegative-integer? start_0)"
"(let-values(((or-part_0)(< start_0 len_0)))(if or-part_0 or-part_0(= len_0 start_0 stop_0)))"
" #f)"
"(void)"
"          (let-values () (raise-range-error who_0 \"vector\" \"starting \" start_0 vec_0 0 (sub1 len_0))))"
"(if(if(exact-integer? stop_0)(if(<= -1 stop_0)(<= stop_0 len_0) #f) #f)"
"(void)"
"          (let-values () (raise-range-error who_0 \"vector\" \"stopping \" stop_0 vec_0 -1 len_0)))"
"(if(if(exact-integer? step_0)(not(zero? step_0)) #f)"
"(void)"
"          (let-values () (raise-argument-error who_0 \"(and/c exact-integer? (not/c zero?))\" step_0)))"
"(if(if(< start_0 stop_0)(< step_0 0) #f)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"             \"starting index less than stopping index, but given a negative step\""
"             \"starting index\""
" start_0"
"             \"stopping index\""
" stop_0"
"             \"step\""
" step_0))"
"(void))"
"(if(if(< stop_0 start_0)(> step_0 0) #f)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"             \"starting index more than stopping index, but given a positive step\""
"             \"starting index\""
" start_0"
"             \"stopping index\""
" stop_0"
"             \"step\""
" step_0))"
"(void))))))"
"(define-values"
"(normalise-inputs)"
"(lambda(who_0 type-name_0 vector?_0 unsafe-vector-length_0 vec_0 start_0 stop_0 step_0)"
"(begin"
"(begin"
"(if(vector?_0 vec_0)(void)(let-values()(raise-argument-error who_0 type-name_0 vec_0)))"
"(let-values(((len_0)(unsafe-vector-length_0 vec_0)))"
"(let-values(((stop*_0)(if stop_0 stop_0 len_0)))"
"(begin(check-ranges who_0 vec_0 start_0 stop*_0 step_0 len_0)(values vec_0 start_0 stop*_0 step_0))))))))"
"(define-values"
"(check-vector)"
"  (lambda (v_0) (begin (if (vector? v_0) (void) (let-values () (raise-argument-error 'in-vector \"vector\" v_0))))))"
"(define-values"
"(check-string)"
"  (lambda (v_0) (begin (if (string? v_0) (void) (let-values () (raise-argument-error 'in-string \"string\" v_0))))))"
"(define-values"
"(check-bytes)"
"  (lambda (v_0) (begin (if (bytes? v_0) (void) (let-values () (raise-argument-error 'in-bytes \"bytes\" v_0))))))"
"(define-values"
"(struct:do-stream make-do-stream do-stream? do-stream-ref do-stream-set!)"
"(make-struct-type"
" 'stream"
" #f"
" 3"
" 0"
" #f"
"(list"
"(cons"
" prop:stream"
"(vector"
"(lambda(v_0)((do-stream-ref v_0 0)))"
"(lambda(v_0)((do-stream-ref v_0 1)))"
"(lambda(v_0)((do-stream-ref v_0 2))))))))"
"(define-values(empty-stream)(make-do-stream(lambda() #t) void void))"
"(define-values"
"(grow-vector)"
"(lambda(vec_0)"
"(begin"
"(let-values(((n_0)(vector-length vec_0)))"
"(let-values(((new-vec_0)(make-vector(* 2 n_0))))"
"(begin(vector-copy! new-vec_0 0 vec_0 0 n_0) new-vec_0))))))"
"(define-values"
"(shrink-vector)"
"(lambda(vec_0 i_0)"
"(begin(let-values(((new-vec_0)(make-vector i_0)))(begin(vector-copy! new-vec_0 0 vec_0 0 i_0) new-vec_0)))))"
"(define-values"
"(map2)"
"(let-values(((map_0)"
"(case-lambda"
"((f_0 l_0)"
"(begin"
" 'map"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)(if(procedure-arity-includes? f_0 1)(list? l_0) #f) #f))"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null? l_1)"
"(let-values() null)"
"(let-values()"
"(let-values(((r_0)(cdr l_1)))"
"(cons(f_0(car l_1))(loop_0 r_0)))))))))"
" loop_0)"
" l_0)"
"(gen-map f_0(list l_0)))))"
"((f_0 l1_0 l2_0)"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)"
"(if(procedure-arity-includes? f_0 2)"
"(if(list? l1_0)(if(list? l2_0)(=(length l1_0)(length l2_0)) #f) #f)"
" #f)"
" #f))"
"((letrec-values(((loop_0)"
"(lambda(l1_1 l2_1)"
"(begin"
" 'loop"
"(if(null? l1_1)"
"(let-values() null)"
"(let-values()"
"(let-values(((r1_0)(cdr l1_1))((r2_0)(cdr l2_1)))"
"(cons(f_0(car l1_1)(car l2_1))(loop_0 r1_0 r2_0)))))))))"
" loop_0)"
" l1_0"
" l2_0)"
"(gen-map f_0(list l1_0 l2_0))))"
"((f_0 l_0 . args_0)(gen-map f_0(cons l_0 args_0))))))"
" map_0))"
"(define-values"
"(for-each2)"
"(let-values(((for-each_0)"
"(case-lambda"
"((f_0 l_0)"
"(begin"
" 'for-each"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)(if(procedure-arity-includes? f_0 1)(list? l_0) #f) #f))"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null? l_1)"
"(let-values()(void))"
"(let-values()"
"(let-values(((r_0)(cdr l_1)))"
"(begin(f_0(car l_1))(loop_0 r_0)))))))))"
" loop_0)"
" l_0)"
"(gen-for-each f_0(list l_0)))))"
"((f_0 l1_0 l2_0)"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)"
"(if(procedure-arity-includes? f_0 2)"
"(if(list? l1_0)(if(list? l2_0)(=(length l1_0)(length l2_0)) #f) #f)"
" #f)"
" #f))"
"((letrec-values(((loop_0)"
"(lambda(l1_1 l2_1)"
"(begin"
" 'loop"
"(if(null? l1_1)"
"(let-values()(void))"
"(let-values()"
"(let-values(((r1_0)(cdr l1_1))((r2_0)(cdr l2_1)))"
"(begin(f_0(car l1_1)(car l2_1))(loop_0 r1_0 r2_0)))))))))"
" loop_0)"
" l1_0"
" l2_0)"
"(gen-for-each f_0(list l1_0 l2_0))))"
"((f_0 l_0 . args_0)(gen-for-each f_0(cons l_0 args_0))))))"
" for-each_0))"
"(define-values"
"(andmap2)"
"(let-values(((andmap_0)"
"(case-lambda"
"((f_0 l_0)"
"(begin"
" 'andmap"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)(if(procedure-arity-includes? f_0 1)(list? l_0) #f) #f))"
"(if(null? l_0)"
" #t"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null?(cdr l_1))"
"(let-values()(f_0(car l_1)))"
"(let-values()"
"(let-values(((r_0)(cdr l_1)))"
"(if(f_0(car l_1))(loop_0 r_0) #f))))))))"
" loop_0)"
" l_0))"
"(gen-andmap f_0(list l_0)))))"
"((f_0 l1_0 l2_0)"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)"
"(if(procedure-arity-includes? f_0 2)"
"(if(list? l1_0)(if(list? l2_0)(=(length l1_0)(length l2_0)) #f) #f)"
" #f)"
" #f))"
"(if(null? l1_0)"
" #t"
"((letrec-values(((loop_0)"
"(lambda(l1_1 l2_1)"
"(begin"
" 'loop"
"(if(null?(cdr l1_1))"
"(let-values()(f_0(car l1_1)(car l2_1)))"
"(let-values()"
"(let-values(((r1_0)(cdr l1_1))((r2_0)(cdr l2_1)))"
"(if(f_0(car l1_1)(car l2_1))(loop_0 r1_0 r2_0) #f))))))))"
" loop_0)"
" l1_0"
" l2_0))"
"(gen-andmap f_0(list l1_0 l2_0))))"
"((f_0 l_0 . args_0)(gen-andmap f_0(cons l_0 args_0))))))"
" andmap_0))"
"(define-values"
"(ormap2)"
"(let-values(((ormap_0)"
"(case-lambda"
"((f_0 l_0)"
"(begin"
" 'ormap"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)(if(procedure-arity-includes? f_0 1)(list? l_0) #f) #f))"
"(if(null? l_0)"
" #f"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null?(cdr l_1))"
"(let-values()(f_0(car l_1)))"
"(let-values()"
"(let-values(((r_0)(cdr l_1)))"
"(let-values(((or-part_0)(f_0(car l_1))))"
"(if or-part_0 or-part_0(loop_0 r_0))))))))))"
" loop_0)"
" l_0))"
"(gen-ormap f_0(list l_0)))))"
"((f_0 l1_0 l2_0)"
"(if(if(variable-reference-from-unsafe?(#%variable-reference))"
" #t"
"(if(procedure? f_0)"
"(if(procedure-arity-includes? f_0 2)"
"(if(list? l1_0)(if(list? l2_0)(=(length l1_0)(length l2_0)) #f) #f)"
" #f)"
" #f))"
"(if(null? l1_0)"
" #f"
"((letrec-values(((loop_0)"
"(lambda(l1_1 l2_1)"
"(begin"
" 'loop"
"(if(null?(cdr l1_1))"
"(let-values()(f_0(car l1_1)(car l2_1)))"
"(let-values()"
"(let-values(((r1_0)(cdr l1_1))((r2_0)(cdr l2_1)))"
"(let-values(((or-part_0)(f_0(car l1_1)(car l2_1))))"
"(if or-part_0 or-part_0(loop_0 r1_0 r2_0))))))))))"
" loop_0)"
" l1_0"
" l2_0))"
"(gen-ormap f_0(list l1_0 l2_0))))"
"((f_0 l_0 . args_0)(gen-ormap f_0(cons l_0 args_0))))))"
" ormap_0))"
"(define-values"
"(check-args)"
"(lambda(who_0 f_0 ls_0)"
"(begin"
"(begin"
"        (if (procedure? f_0) (void) (let-values () (raise-argument-error who_0 \"procedure?\" f_0)))"
"((letrec-values(((loop_0)"
"(lambda(prev-len_0 ls_1 i_0)"
"(begin"
" 'loop"
"(if(null? ls_1)"
"(void)"
"(let-values()"
"(let-values(((l_0)(car ls_1)))"
"(begin"
"                                      (if (list? l_0) (void) (let-values () (raise-argument-error who_0 \"list?\" l_0)))"
"(let-values(((len_0)(length l_0)))"
"(begin"
"(if(if prev-len_0(not(= len_0 prev-len_0)) #f)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                               \"all lists must have same size\""
"                                               \"first list length\""
" prev-len_0"
"                                               \"other list length\""
" len_0"
"                                               \"procedure\""
" f_0))"
"(void))"
"(loop_0 len_0(cdr ls_1)(add1 i_0))))))))))))"
" loop_0)"
" #f"
" ls_0"
" 1)"
"(if(procedure-arity-includes? f_0(length ls_0))"
"(void)"
"(let-values()"
"(let-values(((required-keywords_0 optional-keywords_0)(procedure-keywords f_0)))"
"(apply"
" raise-arguments-error"
" who_0"
"(if(pair? required-keywords_0)"
"                 (string-append \"argument mismatch;\\n\" \" the given procedure expects keyword arguments\")"
"(string-append"
"                  \"argument mismatch;\\n\""
"                  \" the given procedure's expected number of arguments does not match\""
"                  \" the given number of lists\"))"
"               \"given procedure\""
"(unquoted-printing-string"
"(let-values(((or-part_0)"
"(let-values(((n_0)(object-name f_0)))(if(symbol? n_0)(symbol->string n_0) #f))))"
"                  (if or-part_0 or-part_0 \"#<procedure>\")))"
"(append"
"(let-values(((a_0)(procedure-arity f_0)))"
"(if(pair? required-keywords_0)"
"(let-values() null)"
"(if(integer? a_0)"
"                      (let-values () (list \"expected\" a_0))"
"(if(arity-at-least? a_0)"
"(let-values()"
"(list"
"                           \"expected\""
"(unquoted-printing-string"
"                            (string-append \"at least \" (number->string (arity-at-least-value a_0))))))"
"(let-values() null)))))"
"                (if (pair? required-keywords_0) (let-values () null) (let-values () (list \"given\" (length ls_0))))"
"(if(pair? required-keywords_0)"
"(let-values()"
"(list"
"                     \"required keywords\""
"(unquoted-printing-string"
"(apply"
" string-append"
"(cdr"
"((letrec-values(((loop_0)"
"(lambda(kws_0)"
"(begin"
" 'loop"
"(if(null? kws_0)"
"(let-values() null)"
"(let-values()"
"(list*"
"                                                   \" \""
"                                                   (string-append \"#:\" (keyword->string (car kws_0)))"
"(loop_0(cdr kws_0)))))))))"
" loop_0)"
" required-keywords_0))))))"
"(let-values() null))"
"(let-values(((w_0)(quotient(error-print-width)(length ls_0))))"
"(if(> w_0 10)"
"(list"
"                     \"argument lists...\""
"(unquoted-printing-string"
"(apply"
" string-append"
"((letrec-values(((loop_0)"
"(lambda(ls_1)"
"(begin"
" 'loop"
"(if(null? ls_1)"
"(let-values() null)"
"(let-values()"
"(cons"
"                                                  (string-append \"\\n   \" ((error-value->string-handler) (car ls_1) w_0))"
"(loop_0(cdr ls_1)))))))))"
" loop_0)"
" ls_0))))"
" null)))))))))))"
"(define-values"
"(gen-map)"
"(lambda(f_0 ls_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference)) #t(check-args 'map f_0 ls_0))"
"((letrec-values(((loop_0)"
"(lambda(ls_1)"
"(begin"
" 'loop"
"(if(null?(car ls_1))"
"(let-values() null)"
"(let-values()"
"(let-values(((next-ls_0)(map2 cdr ls_1)))"
"(cons(apply f_0(map2 car ls_1))(loop_0 next-ls_0)))))))))"
" loop_0)"
" ls_0)))))"
"(define-values"
"(gen-for-each)"
"(lambda(f_0 ls_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference)) #t(check-args 'for-each f_0 ls_0))"
"((letrec-values(((loop_0)"
"(lambda(ls_1)"
"(begin"
" 'loop"
"(if(null?(car ls_1))"
"(void)"
"(let-values()"
"(let-values(((next-ls_0)(map2 cdr ls_1)))"
"(begin(apply f_0(map2 car ls_1))(loop_0 next-ls_0)))))))))"
" loop_0)"
" ls_0)))))"
"(define-values"
"(gen-andmap)"
"(lambda(f_0 ls_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference)) #t(check-args 'andmap f_0 ls_0))"
"((letrec-values(((loop_0)"
"(lambda(ls_1)"
"(begin"
" 'loop"
"(if(null?(car ls_1))"
"(let-values() #t)"
"(if(null?(cdar ls_1))"
"(let-values()(apply f_0(map2 car ls_1)))"
"(let-values()"
"(let-values(((next-ls_0)(map2 cdr ls_1)))"
"(if(apply f_0(map2 car ls_1))(loop_0 next-ls_0) #f)))))))))"
" loop_0)"
" ls_0)))))"
"(define-values"
"(gen-ormap)"
"(lambda(f_0 ls_0)"
"(begin"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference)) #t(check-args 'ormap f_0 ls_0))"
"((letrec-values(((loop_0)"
"(lambda(ls_1)"
"(begin"
" 'loop"
"(if(null?(car ls_1))"
"(let-values() #f)"
"(if(null?(cdar ls_1))"
"(let-values()(apply f_0(map2 car ls_1)))"
"(let-values()"
"(let-values(((next-ls_0)(map2 cdr ls_1)))"
"(let-values(((or-part_0)(apply f_0(map2 car ls_1))))"
"(if or-part_0 or-part_0(loop_0 next-ls_0)))))))))))"
" loop_0)"
" ls_0)))))"
"(define-values"
"(hash-keys)"
"(lambda(h_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(pos_0)"
"(begin"
" 'loop"
"(if pos_0"
"(cons(hash-iterate-key h_0 pos_0)(loop_0(hash-iterate-next h_0 pos_0)))"
" null)))))"
" loop_0)"
"(hash-iterate-first h_0)))))"
"(define-values"
"(sort7.1)"
"(lambda(cache-keys?2_0 key1_0 lst5_0 less?6_0)"
"(begin"
" 'sort7"
"(let-values(((lst_0) lst5_0))"
"(let-values(((less?_0) less?6_0))"
"(let-values(((getkey_0) key1_0))"
"(let-values(((cache-keys?_0) cache-keys?2_0))"
"(let-values()"
"(begin"
"                  (if (list? lst_0) (void) (let-values () (raise-argument-error 'sort \"list?\" lst_0)))"
"(if(if(procedure? less?_0)(procedure-arity-includes? less?_0 2) #f)"
"(void)"
"                    (let-values () (raise-argument-error 'sort \"(any/c any/c . -> . any/c)\" less?_0)))"
"(if(if getkey_0(not(if(procedure? getkey_0)(procedure-arity-includes? getkey_0 1) #f)) #f)"
"                    (let-values () (raise-argument-error 'sort \"(any/c . -> . any/c)\" getkey_0))"
"(void))"
"(if getkey_0(sort lst_0 less?_0 getkey_0 cache-keys?_0)(sort lst_0 less?_0)))))))))))"
"(define-values"
"(bad-list)"
"  (lambda (who_0 orig-l_0) (begin (raise-mismatch-error who_0 \"not a proper list: \" orig-l_0))))"
"(define-values"
"(bad-item)"
"  (lambda (who_0 a_0 orig-l_0) (begin (raise-mismatch-error who_0 \"non-pair found in list: \" a_0 \" in \" orig-l_0))))"
"(define-values"
"(1/assq 1/assv 1/assoc assf)"
"(let-values()"
"(let-values()"
"(let-values(((assq_0)"
"(lambda(x_0 l_0)"
"(begin"
" 'assq"
"((letrec-values(((loop_0)"
"(lambda(l_1 t_0)"
"(begin"
" 'loop"
"(if(pair? l_1)"
"(let-values()"
"(let-values(((a_0)(unsafe-car l_1)))"
"(if(pair? a_0)"
"(if(eq? x_0(unsafe-car a_0))"
" a_0"
"(let-values(((l_2)(unsafe-cdr l_1)))"
"(if(pair? l_2)"
"(let-values()"
"(let-values(((a_1)(unsafe-car l_2)))"
"(if(pair? a_1)"
"(if(eq? x_0(unsafe-car a_1))"
" a_1"
"(let-values(((t_1)(unsafe-cdr t_0))"
"((l_3)(unsafe-cdr l_2)))"
"(if(eq? l_3 t_1)"
"(bad-list 'assq l_0)"
"(loop_0 l_3 t_1))))"
"(bad-item 'assq a_1 l_0))))"
"(if(null? l_2)"
"(let-values() #f)"
"(let-values()(bad-list 'assq l_0))))))"
"(bad-item 'assq a_0 l_0))))"
"(if(null? l_1)"
"(let-values() #f)"
"(let-values()(bad-list 'assq l_0))))))))"
" loop_0)"
" l_0"
" l_0))))"
"((assv_0)"
"(lambda(x_0 l_0)"
"(begin"
" 'assv"
"((letrec-values(((loop_0)"
"(lambda(l_1 t_0)"
"(begin"
" 'loop"
"(if(pair? l_1)"
"(let-values()"
"(let-values(((a_0)(unsafe-car l_1)))"
"(if(pair? a_0)"
"(if(eqv? x_0(unsafe-car a_0))"
" a_0"
"(let-values(((l_2)(unsafe-cdr l_1)))"
"(if(pair? l_2)"
"(let-values()"
"(let-values(((a_1)(unsafe-car l_2)))"
"(if(pair? a_1)"
"(if(eqv? x_0(unsafe-car a_1))"
" a_1"
"(let-values(((t_1)(unsafe-cdr t_0))"
"((l_3)(unsafe-cdr l_2)))"
"(if(eq? l_3 t_1)"
"(bad-list 'assv l_0)"
"(loop_0 l_3 t_1))))"
"(bad-item 'assv a_1 l_0))))"
"(if(null? l_2)"
"(let-values() #f)"
"(let-values()(bad-list 'assv l_0))))))"
"(bad-item 'assv a_0 l_0))))"
"(if(null? l_1)"
"(let-values() #f)"
"(let-values()(bad-list 'assv l_0))))))))"
" loop_0)"
" l_0"
" l_0))))"
"((assoc_0)"
"(case-lambda"
"((x_0 l_0)"
"(begin"
" 'assoc"
"((letrec-values(((loop_0)"
"(lambda(l_1 t_0)"
"(begin"
" 'loop"
"(if(pair? l_1)"
"(let-values()"
"(let-values(((a_0)(unsafe-car l_1)))"
"(if(pair? a_0)"
"(if(equal? x_0(unsafe-car a_0))"
" a_0"
"(let-values(((l_2)(unsafe-cdr l_1)))"
"(if(pair? l_2)"
"(let-values()"
"(let-values(((a_1)(unsafe-car l_2)))"
"(if(pair? a_1)"
"(if(equal? x_0(unsafe-car a_1))"
" a_1"
"(let-values(((t_1)(unsafe-cdr t_0))"
"((l_3)(unsafe-cdr l_2)))"
"(if(eq? l_3 t_1)"
"(bad-list 'assoc l_0)"
"(loop_0 l_3 t_1))))"
"(bad-item 'assoc a_1 l_0))))"
"(if(null? l_2)"
"(let-values() #f)"
"(let-values()(bad-list 'assoc l_0))))))"
"(bad-item 'assoc a_0 l_0))))"
"(if(null? l_1)"
"(let-values() #f)"
"(let-values()(bad-list 'assoc l_0))))))))"
" loop_0)"
" l_0"
" l_0)))"
"((x_0 l_0 is-equal?_0)"
"(begin"
"(if(if(procedure? is-equal?_0)(procedure-arity-includes? is-equal?_0 2) #f)"
"(void)"
"                          (let-values () (raise-argument-error 'assoc \"(any/c any/c . -> . any/c)\" is-equal?_0)))"
"((letrec-values(((loop_0)"
"(lambda(l_1 t_0)"
"(begin"
" 'loop"
"(if(pair? l_1)"
"(let-values()"
"(let-values(((a_0)(unsafe-car l_1)))"
"(if(pair? a_0)"
"(if(is-equal?_0 x_0(unsafe-car a_0))"
" a_0"
"(let-values(((l_2)(unsafe-cdr l_1)))"
"(if(pair? l_2)"
"(let-values()"
"(let-values(((a_1)(unsafe-car l_2)))"
"(if(pair? a_1)"
"(if(is-equal?_0 x_0(unsafe-car a_1))"
" a_1"
"(let-values(((t_1)(unsafe-cdr t_0))"
"((l_3)(unsafe-cdr l_2)))"
"(if(eq? l_3 t_1)"
"(bad-list 'assoc l_0)"
"(loop_0 l_3 t_1))))"
"(bad-item 'assoc a_1 l_0))))"
"(if(null? l_2)"
"(let-values() #f)"
"(let-values()(bad-list 'assoc l_0))))))"
"(bad-item 'assoc a_0 l_0))))"
"(if(null? l_1)"
"(let-values() #f)"
"(let-values()(bad-list 'assoc l_0))))))))"
" loop_0)"
" l_0"
" l_0)))))"
"((assf_0)"
"(lambda(f_0 l_0)"
"(begin"
" 'assf"
"(begin"
"(if(if(procedure? f_0)(procedure-arity-includes? f_0 1) #f)"
"(void)"
"                            (let-values () (raise-argument-error 'assf \"(any/c . -> . any/c)\" f_0)))"
"((letrec-values(((loop_0)"
"(lambda(l_1 t_0)"
"(begin"
" 'loop"
"(if(pair? l_1)"
"(let-values()"
"(let-values(((a_0)(unsafe-car l_1)))"
"(if(pair? a_0)"
"(if((lambda(__0 a_1)(f_0 a_1)) #f(unsafe-car a_0))"
" a_0"
"(let-values(((l_2)(unsafe-cdr l_1)))"
"(if(pair? l_2)"
"(let-values()"
"(let-values(((a_1)(unsafe-car l_2)))"
"(if(pair? a_1)"
"(if((lambda(__0 a_2)(f_0 a_2))"
" #f"
"(unsafe-car a_1))"
" a_1"
"(let-values(((t_1)(unsafe-cdr t_0))"
"((l_3)(unsafe-cdr l_2)))"
"(if(eq? l_3 t_1)"
"(bad-list 'assf l_0)"
"(loop_0 l_3 t_1))))"
"(bad-item 'assf a_1 l_0))))"
"(if(null? l_2)"
"(let-values() #f)"
"(let-values()(bad-list 'assf l_0))))))"
"(bad-item 'assf a_0 l_0))))"
"(if(null? l_1)"
"(let-values() #f)"
"(let-values()(bad-list 'assf l_0))))))))"
" loop_0)"
" l_0"
" l_0))))))"
"(values assq_0 assv_0 assoc_0 assf_0)))))"
"(define-values"
"(filter)"
"(lambda(f_0 list_0)"
"(begin"
"(begin"
"(if(if(procedure? f_0)(procedure-arity-includes? f_0 1) #f)"
"(void)"
"          (let-values () (raise-argument-error 'filter \"(any/c . -> . any/c)\" f_0)))"
"        (if (list? list_0) (void) (let-values () (raise-argument-error 'filter \"list?\" list_0)))"
"((letrec-values(((loop_0)"
"(lambda(l_0 result_0)"
"(begin"
" 'loop"
"(if(null? l_0)"
"(reverse$1 result_0)"
"(loop_0(cdr l_0)(if(f_0(car l_0))(cons(car l_0) result_0) result_0)))))))"
" loop_0)"
" list_0"
" null)))))"
"(define-values(no-empty-edge-table)(make-hash))"
" (define-values (binary-or-text-desc) \"(or/c 'binary 'text)\")"
"(define-values"
"(open-input-file6.1)"
"(lambda(for-module?2_0 mode1_0 path5_0)"
"(begin"
" 'open-input-file6"
"(let-values(((path_0) path5_0))"
"(let-values(((mode_0) mode1_0))"
"(let-values(((for-module?_0) for-module?2_0))"
"(let-values()"
"(begin"
"(if(path-string? path_0)"
"(void)"
"                  (let-values () (raise-argument-error 'open-input-file \"path-string?\" path_0)))"
"(if(memq mode_0 '(binary text))"
"(void)"
"(let-values()(raise-argument-error 'open-input-file binary-or-text-desc mode_0)))"
"(open-input-file path_0 mode_0(if for-module?_0 'module 'none))))))))))"
"(define-values"
"(with-input-from-file45.1)"
"(lambda(mode41_0 path43_0 proc44_0)"
"(begin"
" 'with-input-from-file45"
"(let-values(((path_0) path43_0))"
"(let-values(((proc_0) proc44_0))"
"(let-values(((mode_0) mode41_0))"
"(let-values()"
"(begin"
"(if(path-string? path_0)"
"(void)"
"                  (let-values () (raise-argument-error 'with-input-from-file \"path-string?\" path_0)))"
"(if(if(procedure? proc_0)(procedure-arity-includes? proc_0 0) #f)"
"(void)"
"                  (let-values () (raise-argument-error 'with-input-from-file \"(-> any)\" proc_0)))"
"(if(memq mode_0 '(binary text))"
"(void)"
"(let-values()(raise-argument-error 'with-input-from-file binary-or-text-desc mode_0)))"
"(with-input-from-file path_0 proc_0 mode_0)))))))))"
"(define-values"
"(call-with-input-file*61.1)"
"(lambda(mode57_0 path59_0 proc60_0)"
"(begin"
" 'call-with-input-file*61"
"(let-values(((path_0) path59_0))"
"(let-values(((proc_0) proc60_0))"
"(let-values(((mode_0) mode57_0))"
"(let-values()"
"(begin"
"(if(path-string? path_0)"
"(void)"
"                  (let-values () (raise-argument-error 'call-with-input-file* \"path-string?\" path_0)))"
"(if(if(procedure? proc_0)(procedure-arity-includes? proc_0 1) #f)"
"(void)"
"                  (let-values () (raise-argument-error 'call-with-input-file* \"(input-port? . -> . any)\" proc_0)))"
"(if(memq mode_0 '(binary text))"
"(void)"
"(let-values()(raise-argument-error 'call-with-input-file* binary-or-text-desc mode_0)))"
"(let-values(((p_0)(open-input-file path_0 mode_0)))"
"(dynamic-wind void(lambda()(proc_0 p_0))(lambda()(close-input-port p_0))))))))))))"
"(define-values(the-empty-hash) '#hash())"
"(define-values(the-empty-hasheq) '#hasheq())"
"(define-values(the-empty-hasheqv) '#hasheqv())"
"(define-values"
"(set)"
"(case-lambda"
"(()(begin the-empty-hash))"
"(l_0"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_1)"
"(let-values(((s_1) s_0))"
"(let-values(((s_2)(let-values()(hash-set s_1 e_0 #t))))"
"(values s_2)))))"
"(if(not #f)(for-loop_0 s_1 rest_0) s_1)))"
" s_0)))))"
" for-loop_0)"
" the-empty-hash"
" lst_0))))))"
"(define-values"
"(seteq)"
"(case-lambda"
"(()(begin the-empty-hasheq))"
"(l_0"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_1)"
"(let-values(((s_1) s_0))"
"(let-values(((s_2)(let-values()(hash-set s_1 e_0 #t))))"
"(values s_2)))))"
"(if(not #f)(for-loop_0 s_1 rest_0) s_1)))"
" s_0)))))"
" for-loop_0)"
" the-empty-hasheq"
" lst_0))))))"
"(define-values(seteqv)(lambda()(begin the-empty-hasheqv)))"
"(define-values(set?)(lambda(s_0)(begin(hash? s_0))))"
"(define-values(set-empty?)(lambda(s_0)(begin(zero?(hash-count s_0)))))"
"(define-values(set-member?)(lambda(s_0 e_0)(begin(hash-ref s_0 e_0 #f))))"
"(define-values(set-count)(lambda(s_0)(begin(hash-count s_0))))"
"(define-values(set-add)(lambda(s_0 e_0)(begin(hash-set s_0 e_0 #t))))"
"(define-values(set-remove)(lambda(s_0 e_0)(begin(hash-remove s_0 e_0))))"
"(define-values(set-first)(lambda(s_0)(begin(hash-iterate-key s_0(hash-iterate-first s_0)))))"
"(define-values(subset?)(lambda(s1_0 s2_0)(begin(hash-keys-subset? s1_0 s2_0))))"
"(define-values"
"(set=?)"
"(lambda(s1_0 s2_0)"
"(begin"
"(let-values(((or-part_0)(eq? s1_0 s2_0)))"
"(if or-part_0 or-part_0(if(=(hash-count s1_0)(hash-count s2_0))(hash-keys-subset? s1_0 s2_0) #f))))))"
"(define-values"
"(set-subtract)"
"(lambda(s1_0 s2_0)"
"(begin"
"(let-values(((ht_0) s2_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s1_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((s1_2)"
"(let-values(((s1_2) s1_1))"
"(let-values(((s1_3)(let-values()(hash-remove s1_2 k_0))))"
"(values s1_3)))))"
"(if(not #f)"
"(for-loop_0 s1_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" s1_2)))"
" s1_1)))))"
" for-loop_0)"
" s1_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(define-values"
"(set-union)"
"(lambda(s1_0 s2_0)"
"(begin"
"(if(<(set-count s1_0)(set-count s2_0))"
"(set-union s2_0 s1_0)"
"(let-values(((ht_0) s2_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s1_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((s1_2)"
"(let-values(((s1_2) s1_1))"
"(let-values(((s1_3)(let-values()(hash-set s1_2 k_0 #t))))"
"(values s1_3)))))"
"(if(not #f)"
"(for-loop_0 s1_2(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" s1_2)))"
" s1_1)))))"
" for-loop_0)"
" s1_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(define-values"
"(set-intersect)"
"(lambda(s1_0 s2_0)"
"(begin"
"(if(<(set-count s1_0)(set-count s2_0))"
"(set-intersect s2_0 s1_0)"
"(let-values(((ht_0) s2_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((s_1)"
"(let-values(((s_1) s_0))"
"(let-values(((s_2)"
"(let-values()"
"(if(hash-ref s1_0 k_0 #f)"
" s_1"
"(hash-remove s_1 k_0)))))"
"(values s_2)))))"
"(if(not #f)"
"(for-loop_0 s_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" s_1)))"
" s_0)))))"
" for-loop_0)"
" s2_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(define-values"
"(set-partition)"
"(lambda(s_0 pred_0 empty-y-set_0 empty-n-set_0)"
"(begin"
"(let-values(((ht_0) s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(y_0 n_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((v_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((y_1 n_1)"
"(let-values(((y_1) y_0)((n_1) n_0))"
"(let-values(((y_2 n_2)"
"(let-values()"
"(if(pred_0 v_0)"
"(values(set-add y_1 v_0) n_1)"
"(values y_1(set-add n_1 v_0))))))"
"(values y_2 n_2)))))"
"(if(not #f)"
"(for-loop_0 y_1 n_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
"(values y_1 n_1))))"
"(values y_0 n_0))))))"
" for-loop_0)"
" empty-y-set_0"
" empty-n-set_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(define-values"
"(set->list)"
"(lambda(s_0)"
"(begin"
"(reverse$1"
"(let-values(((ht_0) s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons(let-values() k_0) fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(define-values"
"(list->set)"
"(lambda(l_0)"
"(begin"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((k_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values(let-values() k_0) #t))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1 rest_0) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
" lst_0))))))"
"(define-values"
"(list->seteq)"
"(lambda(l_0)"
"(begin"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((k_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values(let-values() k_0) #t))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1 rest_0) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
" lst_0))))))"
"(define-values"
"(truncate-path)"
"(lambda(p_0)"
"(begin"
"(let-values(((base1_0 name1_0 dir?_0)(split-path p_0)))"
"(if(path? base1_0)"
"(let-values()"
"(let-values(((base2_0 name2_0 dir?_1)(split-path base1_0)))"
"(if(not base2_0)"
"(let-values()(path->string p_0))"
"(if(symbol? name2_0)"
"                  (let-values () (string-append \".../\" (path-elem->string name1_0)))"
"                  (let-values () (string-append \".../\" (path->string name2_0) \"/\" (path-elem->string name1_0)))))))"
"(if(eq? base1_0 'relative)"
"(let-values()(path-elem->string name1_0))"
"(let-values()(path->string p_0))))))))"
"(define-values"
"(path-elem->string)"
"(lambda(p_0)"
"(begin"
"(if(eq? p_0 'same)"
"        (let-values () \".\")"
"        (if (eq? p_0 'up) (let-values () \"..\") (let-values () (path->string p_0)))))))"
"(define-values"
"(make-path->relative-path-elements4.1)"
"(lambda(who1_0 wr-dir3_0)"
"(begin"
" 'make-path->relative-path-elements4"
"(let-values(((wr-dir_0)(if(eq? wr-dir3_0 unsafe-undefined)(current-write-relative-directory) wr-dir3_0)))"
"(let-values(((who_0) who1_0))"
"(let-values()"
"(begin"
"(if who_0"
"(let-values()"
"(if(let-values(((or-part_0)(not wr-dir_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(if(path-string? wr-dir_0)(complete-path? wr-dir_0) #f)))"
"(if or-part_1"
" or-part_1"
"(if(pair? wr-dir_0)"
"(if(path-string?(car wr-dir_0))"
"(if(complete-path?(car wr-dir_0))"
"(if(path-string?(cdr wr-dir_0))(complete-path?(cdr wr-dir_0)) #f)"
" #f)"
" #f)"
" #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"(string-append"
"                        \"(or/c (and/c path-string? complete-path?)\\n\""
"                        \"      (cons/c (and/c path-string? complete-path?)\\n\""
"                        \"              (and/c path-string? complete-path?))\\n\""
"                        \"      #f)\")"
" wr-dir_0))))"
"(void))"
"(if(not wr-dir_0)"
"(let-values()(lambda(v_0) #f))"
"(let-values()"
"(let-values(((exploded-base-dir_0) 'not-ready))"
"(let-values(((exploded-wrt-rel-dir_0) 'not-ready))"
"(lambda(v_0)"
"(begin"
"(if(if(eq? exploded-base-dir_0 'not-ready)(path? v_0) #f)"
"(let-values()"
"(let-values(((wrt-dir_0)(if wr-dir_0(if(pair? wr-dir_0)(car wr-dir_0) wr-dir_0) #f)))"
"(let-values(((exploded-wrt-dir_0)(explode-path wrt-dir_0)))"
"(let-values(((base-dir_0)"
"(if wr-dir_0(if(pair? wr-dir_0)(cdr wr-dir_0) wr-dir_0) #f)))"
"(begin"
"(set! exploded-base-dir_0(if base-dir_0(explode-path base-dir_0) #f))"
"(set! exploded-wrt-rel-dir_0"
"(if(eq? base-dir_0 wrt-dir_0)"
"(let-values() '())"
"(let-values()"
"(let-values(((exploded-wrt-dir_1)(explode-path wrt-dir_0)))"
"(let-values(((base-len_0)(length exploded-base-dir_0)))"
"(begin"
"(if who_0"
"(let-values()"
"(if(if(>=(length exploded-wrt-dir_1) base-len_0)"
"(let-values(((lst_0) exploded-wrt-dir_1)"
"((lst_1) exploded-base-dir_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)"
"(pair? lst_3)"
" #f)"
"(let-values(((a_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((b_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(equal?"
" a_0"
" b_0)))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
"(not result_1))"
" a_0))"
"(if(not"
"((lambda x_0"
"(not"
" result_1))"
" b_0))"
"(not #f)"
" #f)"
" #f)"
"(for-loop_0"
" result_1"
" rest_0"
" rest_1)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0"
" lst_1)))"
" #f)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                                           \"relative-directory pair's first path does not extend second path\""
"                                                           \"first path\""
" wrt-dir_0"
"                                                           \"second path\""
" base-dir_0))))"
"(void))"
"(list-tail exploded-wrt-dir_1 base-len_0))))))))))))"
"(void))"
"(if exploded-base-dir_0"
"(if(path? v_0)"
"(let-values(((exploded_0)(explode-path v_0)))"
"(if(let-values(((lst_0) exploded-base-dir_0)((lst_1) exploded_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((base-p_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((p_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(equal?"
" base-p_0"
" p_0)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) base-p_0))"
"(if(not((lambda x_0(not result_1)) p_0))"
"(not #f)"
" #f)"
" #f)"
"(for-loop_0 result_1 rest_0 rest_1)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0"
" lst_1)))"
"(if(>=(length exploded_0)(length exploded-base-dir_0))"
"((letrec-values(((loop_0)"
"(lambda(exploded-wrt-rel-dir_1 rel_0)"
"(begin"
" 'loop"
"(if(null? exploded-wrt-rel-dir_1)"
"(let-values()"
"(reverse$1"
"(let-values(((lst_0) rel_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((p_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if(path?"
" p_0)"
"(path-element->bytes"
" p_0)"
" p_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"(if(if(pair? rel_0)"
"(equal?(car rel_0)(car exploded-wrt-rel-dir_1))"
" #f)"
"(let-values()"
"(loop_0(cdr exploded-wrt-rel-dir_1)(cdr rel_0)))"
"(let-values()"
"(append"
"(reverse$1"
"(let-values(((lst_0) exploded-wrt-rel-dir_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((p_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" 'up)"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
"(reverse$1"
"(let-values(((lst_0) rel_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((p_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if(path?"
" p_0)"
"(path-element->bytes"
" p_0)"
" p_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))))))"
" loop_0)"
" exploded-wrt-rel-dir_0"
"(list-tail exploded_0(length exploded-base-dir_0)))"
" #f)"
" #f))"
" #f)"
" #f))))))))))))))"
"(define-values(1/write-byte)(lambda(byte_0 out_0)(begin 'write-byte(write-byte byte_0 out_0))))"
"(define-values"
"(1/write-bytes)"
"(let-values(((write-bytes5_0)"
"(lambda(bstr3_0 out4_0 start-pos1_0 end-pos2_0)"
"(begin"
" 'write-bytes5"
"(let-values(((bstr_0) bstr3_0))"
"(let-values(((out_0) out4_0))"
"(let-values(((start-pos_0) start-pos1_0))"
"(let-values(((end-pos_0)"
"(if(eq? end-pos2_0 unsafe-undefined)(bytes-length bstr_0) end-pos2_0)))"
"(let-values()(write-bytes bstr_0 out_0 start-pos_0 end-pos_0))))))))))"
"(case-lambda"
"((bstr_0 out_0)(begin 'write-bytes(write-bytes5_0 bstr_0 out_0 0 unsafe-undefined)))"
"((bstr_0 out_0 start-pos_0 end-pos2_0)(write-bytes5_0 bstr_0 out_0 start-pos_0 end-pos2_0))"
"((bstr_0 out_0 start-pos1_0)(write-bytes5_0 bstr_0 out_0 start-pos1_0 unsafe-undefined)))))"
"(define-values(fasl-graph-def-type) 1)"
"(define-values(fasl-graph-ref-type) 2)"
"(define-values(fasl-false-type) 3)"
"(define-values(fasl-true-type) 4)"
"(define-values(fasl-null-type) 5)"
"(define-values(fasl-void-type) 6)"
"(define-values(fasl-eof-type) 7)"
"(define-values(fasl-integer-type) 8)"
"(define-values(fasl-flonum-type) 9)"
"(define-values(fasl-single-flonum-type) 10)"
"(define-values(fasl-rational-type) 11)"
"(define-values(fasl-complex-type) 12)"
"(define-values(fasl-char-type) 13)"
"(define-values(fasl-symbol-type) 14)"
"(define-values(fasl-unreadable-symbol-type) 15)"
"(define-values(fasl-uninterned-symbol-type) 16)"
"(define-values(fasl-keyword-type) 17)"
"(define-values(fasl-string-type) 18)"
"(define-values(fasl-immutable-string-type) 19)"
"(define-values(fasl-bytes-type) 20)"
"(define-values(fasl-immutable-bytes-type) 21)"
"(define-values(fasl-path-type) 22)"
"(define-values(fasl-relative-path-type) 23)"
"(define-values(fasl-pregexp-type) 24)"
"(define-values(fasl-regexp-type) 25)"
"(define-values(fasl-byte-pregexp-type) 26)"
"(define-values(fasl-byte-regexp-type) 27)"
"(define-values(fasl-list-type) 28)"
"(define-values(fasl-list*-type) 29)"
"(define-values(fasl-pair-type) 30)"
"(define-values(fasl-vector-type) 31)"
"(define-values(fasl-immutable-vector-type) 32)"
"(define-values(fasl-box-type) 33)"
"(define-values(fasl-immutable-box-type) 34)"
"(define-values(fasl-prefab-type) 35)"
"(define-values(fasl-hash-type) 36)"
"(define-values(fasl-immutable-hash-type) 37)"
"(define-values(fasl-srcloc) 38)"
"(define-values(fasl-extflonum-type) 39)"
"(define-values(fasl-small-integer-start) 100)"
"(define-values(fasl-lowest-small-integer) -10)"
"(define-values(fasl-highest-small-integer)(- 255(- fasl-small-integer-start fasl-lowest-small-integer) 1))"
" (define-values (fasl-prefix) #\"racket/fasl:\")"
"(define-values(fasl-prefix-length)(bytes-length fasl-prefix))"
"(define-values(fasl-hash-eq-variant) 0)"
"(define-values(fasl-hash-equal-variant) 1)"
"(define-values(fasl-hash-eqv-variant) 2)"
"(define-values"
"(s-exp->fasl11.1)"
"(lambda(keep-mutable?7_0 v10_0 orig-o9_0)"
"(begin"
" 's-exp->fasl11"
"(let-values(((v_0) v10_0))"
"(let-values(((orig-o_0) orig-o9_0))"
"(let-values(((keep-mutable?_0) keep-mutable?7_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if orig-o_0"
"(let-values()"
"(if(output-port? orig-o_0)"
"(void)"
"(let-values()"
"                                      (raise-argument-error 'fasl->s-exp \"(or/c output-port? #f)\" orig-o_0))))"
"(void))"
"(values))))"
"(let-values(((o_0)(let-values(((or-part_0) orig-o_0))(if or-part_0 or-part_0(open-output-bytes)))))"
"(let-values(((shared_0)(make-hasheq)))"
"(let-values(((shared-counter_0) 0))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(v_1)"
"(begin"
" 'loop"
"(if(let-values(((or-part_0)(symbol? v_1)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(keyword? v_1)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(string? v_1)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(bytes? v_1)))"
"(if or-part_3"
" or-part_3"
"(path? v_1)))))))))"
"(let-values()(hash-update! shared_0 v_1 add1 0))"
"(if(pair? v_1)"
"(let-values()"
"(begin(loop_0(car v_1))(loop_0(cdr v_1))))"
"(if(vector? v_1)"
"(let-values()"
"(begin"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0) v_1))"
"(begin"
"(check-vector vec_0)"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))"
"(if(hash? v_1)"
"(let-values()"
"(hash-for-each"
" v_1"
"(lambda(k_0 v_2)"
"(begin(loop_0 k_0)(loop_0 v_2)))"
" #t))"
"(if(box? v_1)"
"(let-values()(loop_0(unbox v_1)))"
"(let-values(((c1_0)(prefab-struct-key v_1)))"
"(if c1_0"
"((lambda(k_0)"
"(begin"
"(loop_0 k_0)"
"(let-values(((v*_0"
" start*_0"
" stop*_0"
" step*_0)"
"(normalise-inputs"
" 'in-vector"
"                                                                                              \"vector\""
"(lambda(x_0)"
"(vector? x_0))"
"(lambda(x_0)"
"(unsafe-vector-length"
" x_0))"
"(struct->vector v_1)"
" 1"
" #f"
" 1)))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" idx_0"
" stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" idx_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start*_0)))"
"(void)))"
" c1_0)"
"(let-values()(void)))))))))))))"
" loop_0)"
" v_0)"
"(values))))"
"(let-values(((treat-immutable?_0)"
"(lambda(v_1)"
"(begin"
" 'treat-immutable?"
"(let-values(((or-part_0)(not keep-mutable?_0)))"
"(if or-part_0 or-part_0(immutable? v_1)))))))"
"(let-values(((path->relative-path-elements_0)"
"(let-values()(make-path->relative-path-elements4.1 #f unsafe-undefined))))"
"(let-values((()(begin(1/write-bytes fasl-prefix o_0)(values))))"
"(let-values(((bstr_0)"
"(let-values(((o_1)(open-output-bytes)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(v_1)"
"(begin"
" 'loop"
"(if(not(eq?(hash-ref shared_0 v_1 1) 1))"
"(let-values()"
"(let-values(((c_0)(hash-ref shared_0 v_1)))"
"(if(negative? c_0)"
"(let-values()"
"(begin"
"(1/write-byte fasl-graph-ref-type o_1)"
"(write-fasl-integer"
"(sub1(- c_0))"
" o_1)))"
"(let-values()"
"(let-values(((pos_0) shared-counter_0))"
"(begin"
"(set! shared-counter_0"
"(add1 shared-counter_0))"
"(1/write-byte"
" fasl-graph-def-type"
" o_1)"
"(write-fasl-integer pos_0 o_1)"
"(hash-remove! shared_0 v_1)"
"(loop_0 v_1)"
"(hash-set!"
" shared_0"
" v_1"
"(-(add1 pos_0)))))))))"
"(if(not v_1)"
"(let-values()"
"(1/write-byte fasl-false-type o_1))"
"(if(eq? v_1 #t)"
"(let-values()"
"(1/write-byte fasl-true-type o_1))"
"(if(null? v_1)"
"(let-values()"
"(1/write-byte fasl-null-type o_1))"
"(if(void? v_1)"
"(let-values()"
"(1/write-byte fasl-void-type o_1))"
"(if(eof-object? v_1)"
"(let-values()"
"(1/write-byte fasl-eof-type o_1))"
"(if(exact-integer? v_1)"
"(let-values()"
"(if(<="
" fasl-lowest-small-integer"
" v_1"
" fasl-highest-small-integer)"
"(let-values()"
"(1/write-byte"
"(+"
" fasl-small-integer-start"
"(-"
" v_1"
" fasl-lowest-small-integer))"
" o_1))"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-integer-type"
" o_1)"
"(write-fasl-integer"
" v_1"
" o_1)))))"
"(if(flonum? v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-flonum-type"
" o_1)"
"(1/write-bytes"
"(real->floating-point-bytes"
" v_1"
" 8"
" #f)"
" o_1)))"
"(if(single-flonum? v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-single-flonum-type"
" o_1)"
"(1/write-bytes"
"(real->floating-point-bytes"
" v_1"
" 4"
" #f)"
" o_1)))"
"(if(extflonum? v_1)"
"(let-values()"
"(let-values((()"
"(begin"
"(1/write-byte"
" fasl-extflonum-type"
" o_1)"
"(values))))"
"(let-values(((bstr_0)"
"(string->bytes/utf-8"
"(format"
"                                                                                                              \"~a\""
" v_1))))"
"(begin"
"(write-fasl-integer"
"(bytes-length bstr_0)"
" o_1)"
"(1/write-bytes"
" bstr_0"
" o_1)))))"
"(if(rational? v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-rational-type"
" o_1)"
"(loop_0(numerator v_1))"
"(loop_0"
"(denominator v_1))))"
"(if(complex? v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-complex-type"
" o_1)"
"(loop_0"
"(real-part v_1))"
"(loop_0"
"(imag-part v_1))))"
"(if(char? v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-char-type"
" o_1)"
"(write-fasl-integer"
"(char->integer v_1)"
" o_1)))"
"(if(symbol? v_1)"
"(let-values()"
"(let-values((()"
"(begin"
"(if(symbol-interned?"
" v_1)"
"(let-values()"
"(1/write-byte"
" fasl-symbol-type"
" o_1))"
"(if(symbol-unreadable?"
" v_1)"
"(let-values()"
"(1/write-byte"
" fasl-unreadable-symbol-type"
" o_1))"
"(let-values()"
"(1/write-byte"
" fasl-uninterned-symbol-type"
" o_1))))"
"(values))))"
"(let-values(((bstr_0)"
"(string->bytes/utf-8"
"(symbol->string"
" v_1))))"
"(begin"
"(write-fasl-integer"
"(bytes-length"
" bstr_0)"
" o_1)"
"(1/write-bytes"
" bstr_0"
" o_1)))))"
"(if(keyword? v_1)"
"(let-values()"
"(let-values((()"
"(begin"
"(1/write-byte"
" fasl-keyword-type"
" o_1)"
"(values))))"
"(let-values(((bstr_0)"
"(string->bytes/utf-8"
"(keyword->string"
" v_1))))"
"(begin"
"(write-fasl-integer"
"(bytes-length"
" bstr_0)"
" o_1)"
"(1/write-bytes"
" bstr_0"
" o_1)))))"
"(if(string? v_1)"
"(let-values()"
"(begin"
"(write-fasl-integer"
"(if(treat-immutable?_0"
" v_1)"
" fasl-immutable-string-type"
" fasl-string-type)"
" o_1)"
"(write-fasl-string"
" v_1"
" o_1)))"
"(if(bytes? v_1)"
"(let-values()"
"(begin"
"(write-fasl-integer"
"(if(treat-immutable?_0"
" v_1)"
" fasl-immutable-bytes-type"
" fasl-bytes-type)"
" o_1)"
"(write-fasl-bytes"
" v_1"
" o_1)))"
"(if(path-for-some-system?"
" v_1)"
"(let-values()"
"(let-values(((rel-elems_0)"
"(path->relative-path-elements_0"
" v_1)))"
"(if rel-elems_0"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-relative-path-type"
" o_1)"
"(loop_0"
" rel-elems_0)))"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-path-type"
" o_1)"
"(write-fasl-bytes"
"(path->bytes"
" v_1)"
" o_1)"
"(loop_0"
"(path-convention-type"
" v_1)))))))"
"(if(if(srcloc?"
" v_1)"
"(let-values(((src_0)"
"(srcloc-source"
" v_1)))"
"(let-values(((or-part_0)"
"(not"
" src_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(path-for-some-system?"
" src_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(string?"
" src_0)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)"
"(bytes?"
" src_0)))"
"(if or-part_3"
" or-part_3"
"(symbol?"
" src_0))))))))))"
" #f)"
"(let-values()"
"(let-values(((src_0)"
"(srcloc-source"
" v_1)))"
"(let-values(((new-src_0)"
"(if(if(path?"
" src_0)"
"(not"
"(path->relative-path-elements_0"
" src_0))"
" #f)"
"(let-values()"
"(truncate-path"
" src_0))"
"(let-values()"
" src_0))))"
"(begin"
"(write-fasl-integer"
" fasl-srcloc"
" o_1)"
"(loop_0"
" new-src_0)"
"(loop_0"
"(srcloc-line"
" v_1))"
"(loop_0"
"(srcloc-column"
" v_1))"
"(loop_0"
"(srcloc-position"
" v_1))"
"(loop_0"
"(srcloc-span"
" v_1))))))"
"(if(pair?"
" v_1)"
"(let-values()"
"(if(pair?"
"(cdr"
" v_1))"
"(let-values()"
"(let-values(((n_0"
" normal-list?_0)"
"((letrec-values(((loop_1)"
"(lambda(v_2"
" len_0)"
"(begin"
" 'loop"
"(if(null?"
" v_2)"
"(let-values()"
"(values"
" len_0"
" #t))"
"(if(pair?"
" v_2)"
"(let-values()"
"(loop_1"
"(cdr"
" v_2)"
"(add1"
" len_0)))"
"(let-values()"
"(values"
" len_0"
" #f))))))))"
" loop_1)"
" v_1"
" 0)))"
"(begin"
"(1/write-byte"
"(if normal-list?_0"
" fasl-list-type"
" fasl-list*-type)"
" o_1)"
"(write-fasl-integer"
" n_0"
" o_1)"
"((letrec-values(((ploop_0)"
"(lambda(v_2)"
"(begin"
" 'ploop"
"(if(pair?"
" v_2)"
"(let-values()"
"(begin"
"(loop_0"
"(car"
" v_2))"
"(ploop_0"
"(cdr"
" v_2))))"
"(let-values()"
"(if normal-list?_0"
"(void)"
"(let-values()"
"(loop_0"
" v_2)))))))))"
" ploop_0)"
" v_1))))"
"(let-values()"
"(begin"
"(1/write-byte"
" fasl-pair-type"
" o_1)"
"(loop_0"
"(car"
" v_1))"
"(loop_0"
"(cdr"
" v_1))))))"
"(if(vector?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
"(if(treat-immutable?_0"
" v_1)"
" fasl-immutable-vector-type"
" fasl-vector-type)"
" o_1)"
"(write-fasl-integer"
"(vector-length"
" v_1)"
" o_1)"
"(let-values(((vec_0"
" len_0)"
"(let-values(((vec_0)"
" v_1))"
"(begin"
"(check-vector"
" vec_0)"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))"
"(if(box?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
"(if(treat-immutable?_0"
" v_1)"
" fasl-immutable-box-type"
" fasl-box-type)"
" o_1)"
"(loop_0"
"(unbox"
" v_1))))"
"(let-values(((c2_0)"
"(prefab-struct-key"
" v_1)))"
"(if c2_0"
"((lambda(k_0)"
"(let-values((()"
"(begin"
"(1/write-byte"
" fasl-prefab-type"
" o_1)"
"(values))))"
"(let-values((()"
"(begin"
"(loop_0"
" k_0)"
"(values))))"
"(let-values(((vec_0)"
"(struct->vector"
" v_1)))"
"(begin"
"(write-fasl-integer"
"(sub1"
"(vector-length"
" vec_0))"
" o_1)"
"(let-values(((v*_0"
" start*_0"
" stop*_0"
" step*_0)"
"(normalise-inputs"
" 'in-vector"
"                                                                                                                                                \"vector\""
"(lambda(x_0)"
"(vector?"
" x_0))"
"(lambda(x_0)"
"(unsafe-vector-length"
" x_0))"
" vec_0"
" 1"
" #f"
" 1)))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" idx_0"
" stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" idx_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start*_0)))"
"(void))))))"
" c2_0)"
"(if(hash?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
"(if(treat-immutable?_0"
" v_1)"
" fasl-immutable-hash-type"
" fasl-hash-type)"
" o_1)"
"(1/write-byte"
"(if(hash-eq?"
" v_1)"
"(let-values()"
" fasl-hash-eq-variant)"
"(if(hash-eqv?"
" v_1)"
"(let-values()"
" fasl-hash-eqv-variant)"
"(let-values()"
" fasl-hash-equal-variant)))"
" o_1)"
"(write-fasl-integer"
"(hash-count"
" v_1)"
" o_1)"
"(hash-for-each"
" v_1"
"(lambda(k_0"
" v_2)"
"(begin"
"(loop_0"
" k_0)"
"(loop_0"
" v_2)))"
" #t)))"
"(if(regexp?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
"(if(pregexp?"
" v_1)"
" fasl-pregexp-type"
" fasl-regexp-type)"
" o_1)"
"(write-fasl-string"
"(object-name"
" v_1)"
" o_1)))"
"(if(byte-regexp?"
" v_1)"
"(let-values()"
"(begin"
"(1/write-byte"
"(if(byte-pregexp?"
" v_1)"
" fasl-byte-pregexp-type"
" fasl-byte-regexp-type)"
" o_1)"
"(write-fasl-bytes"
"(object-name"
" v_1)"
" o_1)))"
"(let-values()"
"(raise-arguments-error"
" 'fasl-write"
"                                                                                                                               \"cannot write value\""
"                                                                                                                               \"value\""
" v_1)))))))))))))))))))))))))))))))))"
" loop_0)"
" v_0)"
"(get-output-bytes o_1 #t)))))"
"(begin"
"(write-fasl-integer shared-counter_0 o_0)"
"(write-fasl-integer(bytes-length bstr_0) o_0)"
"(1/write-bytes bstr_0 o_0)"
"(if orig-o_0(void)(get-output-bytes o_0)))))))))))))))))))"
"(define-values"
"(fasl->s-exp17.1)"
"(lambda(datum-intern?14_0 orig-i16_0)"
"(begin"
" 'fasl->s-exp17"
"(let-values(((orig-i_0) orig-i16_0))"
"(let-values(((intern?_0) datum-intern?14_0))"
"(let-values()"
"(let-values(((init-i_0)"
"(if(bytes? orig-i_0)"
"(let-values()(mcons orig-i_0 0))"
"(if(input-port? orig-i_0)"
"(let-values() orig-i_0)"
"(let-values()"
"                                (raise-argument-error 'fasl->s-exp \"(or/c bytes? input-port?)\" orig-i_0))))))"
"(let-values((()"
"(begin"
"(if(bytes=?(read-bytes/exactly fasl-prefix-length init-i_0) fasl-prefix)"
"(void)"
"                                (let-values () (read-error \"unrecognized prefix\")))"
"(values))))"
"(let-values(((shared-count_0)(read-fasl-integer init-i_0)))"
"(let-values(((shared_0)(make-vector shared-count_0)))"
"(let-values(((len_0)(read-fasl-integer init-i_0)))"
"(let-values(((i_0)"
"(if(mpair? init-i_0)"
" init-i_0"
"(let-values(((bstr_0)(read-bytes/exactly len_0 init-i_0)))(mcons bstr_0 0)))))"
"(let-values(((intern_0)"
"(lambda(v_0)(begin 'intern(if intern?_0(datum-intern-literal v_0) v_0)))))"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((type_0)(read-byte/no-eof i_0)))"
"(let-values(((tmp_0) type_0))"
"(let-values(((index_0)"
"(if(fixnum? tmp_0)"
"(if(if(unsafe-fx>= tmp_0 1)"
"(unsafe-fx< tmp_0 40)"
" #f)"
"(let-values(((tbl_0)"
" '#(1"
" 2"
" 3"
" 4"
" 5"
" 6"
" 7"
" 8"
" 9"
" 10"
" 12"
" 13"
" 14"
" 15"
" 16"
" 17"
" 18"
" 19"
" 20"
" 21"
" 22"
" 23"
" 24"
" 25"
" 26"
" 27"
" 28"
" 29"
" 31"
" 30"
" 32"
" 32"
" 33"
" 34"
" 35"
" 36"
" 37"
" 38"
" 11)))"
"(unsafe-vector*-ref tbl_0(unsafe-fx- tmp_0 1)))"
" 0)"
" 0)))"
"(if(unsafe-fx< index_0 19)"
"(if(unsafe-fx< index_0 9)"
"(if(unsafe-fx< index_0 4)"
"(if(unsafe-fx< index_0 1)"
"(let-values()"
"(if(>= type_0 fasl-small-integer-start)"
"(let-values()"
"(+"
"(- type_0 fasl-small-integer-start)"
" fasl-lowest-small-integer))"
"(let-values()"
"                                                                    (read-error \"unrecognized fasl tag\" \"tag\" type_0))))"
"(if(unsafe-fx< index_0 2)"
"(let-values()"
"(let-values(((pos_0)(read-fasl-integer i_0)))"
"(let-values(((v_0)(loop_0)))"
"(begin"
"(if(< pos_0 shared-count_0)"
"(void)"
"(let-values()"
"                                                                            (read-error \"bad graph index\")))"
"(vector-set! shared_0 pos_0 v_0)"
" v_0))))"
"(if(unsafe-fx< index_0 3)"
"(let-values()"
"(let-values(((pos_0)(read-fasl-integer i_0)))"
"(begin"
"(if(< pos_0 shared-count_0)"
"(void)"
"(let-values()"
"                                                                            (read-error \"bad graph index\")))"
"(vector-ref shared_0 pos_0))))"
"(let-values() #f))))"
"(if(unsafe-fx< index_0 6)"
"(if(unsafe-fx< index_0 5)"
"(let-values() #t)"
"(let-values() null))"
"(if(unsafe-fx< index_0 7)"
"(let-values()(void))"
"(if(unsafe-fx< index_0 8)"
"(let-values() eof)"
"(let-values()(intern_0(read-fasl-integer i_0)))))))"
"(if(unsafe-fx< index_0 13)"
"(if(unsafe-fx< index_0 10)"
"(let-values()"
"(floating-point-bytes->real"
"(read-bytes/exactly 8 i_0)"
" #f))"
"(if(unsafe-fx< index_0 11)"
"(let-values()"
"(real->single-flonum"
"(floating-point-bytes->real"
"(read-bytes/exactly 4 i_0)"
" #f)))"
"(if(unsafe-fx< index_0 12)"
"(let-values()"
"(let-values(((bstr_0)"
"(read-bytes/exactly"
"(read-fasl-integer i_0)"
" i_0)))"
"(1/string->number"
"(bytes->string/utf-8 bstr_0)"
" 10"
" 'read)))"
"(let-values()(intern_0(/(loop_0)(loop_0)))))))"
"(if(unsafe-fx< index_0 15)"
"(if(unsafe-fx< index_0 14)"
"(let-values()"
"(intern_0(make-rectangular(loop_0)(loop_0))))"
"(let-values()"
"(intern_0(integer->char(read-fasl-integer i_0)))))"
"(if(unsafe-fx< index_0 16)"
"(let-values()(string->symbol(read-fasl-string i_0)))"
"(if(unsafe-fx< index_0 17)"
"(let-values()"
"(string->unreadable-symbol(read-fasl-string i_0)))"
"(if(unsafe-fx< index_0 18)"
"(let-values()"
"(string->uninterned-symbol"
"(read-fasl-string i_0)))"
"(let-values()"
"(string->keyword(read-fasl-string i_0)))))))))"
"(if(unsafe-fx< index_0 28)"
"(if(unsafe-fx< index_0 23)"
"(if(unsafe-fx< index_0 20)"
"(let-values()(read-fasl-string i_0))"
"(if(unsafe-fx< index_0 21)"
"(let-values()"
"(intern_0"
"(string->immutable-string(read-fasl-string i_0))))"
"(if(unsafe-fx< index_0 22)"
"(let-values()(read-fasl-bytes i_0))"
"(let-values()"
"(intern_0"
"(bytes->immutable-bytes(read-fasl-bytes i_0)))))))"
"(if(unsafe-fx< index_0 25)"
"(if(unsafe-fx< index_0 24)"
"(let-values()"
"(bytes->path(read-fasl-bytes i_0)(loop_0)))"
"(let-values()"
"(let-values(((wrt-dir_0)"
"(current-load-relative-directory)))"
"(let-values(((rel-elems_0)"
"(reverse$1"
"(let-values(((lst_0)(loop_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((p_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if(bytes?"
" p_0)"
"(bytes->path-element"
" p_0)"
" p_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(if wrt-dir_0"
"(let-values()"
"(apply build-path wrt-dir_0 rel-elems_0))"
"(if(null? rel-elems_0)"
"(let-values()(build-path 'same))"
"(let-values()"
"(apply build-path rel-elems_0))))))))"
"(if(unsafe-fx< index_0 26)"
"(let-values()"
"(intern_0(pregexp(read-fasl-string i_0))))"
"(if(unsafe-fx< index_0 27)"
"(let-values()"
"(intern_0(regexp(read-fasl-string i_0))))"
"(let-values()"
"(intern_0(byte-pregexp(read-fasl-bytes i_0))))))))"
"(if(unsafe-fx< index_0 33)"
"(if(unsafe-fx< index_0 30)"
"(if(unsafe-fx< index_0 29)"
"(let-values()"
"(intern_0(byte-regexp(read-fasl-bytes i_0))))"
"(let-values()"
"(let-values(((len_1)(read-fasl-integer i_0)))"
"(reverse$1"
"(let-values(((start_0) 0)"
"((end_0) len_1)"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values()"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
"(+ pos_0 inc_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" start_0)))))))"
"(if(unsafe-fx< index_0 31)"
"(let-values()(cons(loop_0)(loop_0)))"
"(if(unsafe-fx< index_0 32)"
"(let-values()"
"(let-values(((len_1)(read-fasl-integer i_0)))"
"((letrec-values(((ploop_0)"
"(lambda(len_2)"
"(begin"
" 'ploop"
"(if(zero? len_2)"
"(loop_0)"
"(cons"
"(loop_0)"
"(ploop_0"
"(sub1 len_2))))))))"
" ploop_0)"
" len_1)))"
"(let-values()"
"(let-values(((len_1)(read-fasl-integer i_0)))"
"(let-values(((vec_0)"
"(let-values(((len_2) len_1))"
"(begin"
"(if(exact-nonnegative-integer?"
" len_2)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'for/vector"
"                                                                                             \"exact-nonnegative-integer?\""
" len_2)))"
"(let-values(((v_0)"
"(make-vector"
" len_2"
" 0)))"
"(begin"
"(if(zero? len_2)"
"(void)"
"(let-values()"
"(let-values(((start_0)"
" 0)"
"((end_0)"
" len_1)"
"((inc_0)"
" 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_1"
" pos_0)"
"(begin"
" 'for-loop"
"(if(<"
" pos_0"
" end_0)"
"(let-values(((j_0)"
" pos_0))"
"(let-values(((i_2)"
"(let-values(((i_2)"
" i_1))"
"(let-values(((i_3)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_2"
"(let-values()"
"(loop_0)))"
"(unsafe-fx+"
" 1"
" i_2)))))"
"(values"
" i_3)))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_2"
" len_2))"
" j_0))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" i_2"
"(+"
" pos_0"
" inc_0))"
" i_2)))"
" i_1)))))"
" for-loop_0)"
" 0"
" start_0)))))"
" v_0))))))"
"(if(eqv? type_0 fasl-immutable-vector-type)"
"(vector->immutable-vector vec_0)"
" vec_0)))))))"
"(if(unsafe-fx< index_0 35)"
"(if(unsafe-fx< index_0 34)"
"(let-values()(box(loop_0)))"
"(let-values()(box-immutable(loop_0))))"
"(if(unsafe-fx< index_0 36)"
"(let-values()"
"(let-values(((key_0)(loop_0)))"
"(let-values(((len_1)(read-fasl-integer i_0)))"
"(apply"
" make-prefab-struct"
" key_0"
"(reverse$1"
"(let-values(((start_0) 0)"
"((end_0) len_1)"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values()"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
"(+"
" pos_0"
" inc_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" start_0))))))))"
"(if(unsafe-fx< index_0 37)"
"(let-values()"
"(let-values(((ht_0)"
"(let-values(((tmp_1)"
"(read-byte/no-eof i_0)))"
"(if(equal? tmp_1 0)"
"(let-values()(make-hasheq))"
"(if(equal? tmp_1 2)"
"(let-values()(make-hasheqv))"
"(let-values()(make-hash)))))))"
"(let-values(((len_1)(read-fasl-integer i_0)))"
"(begin"
"(let-values(((start_0) 0)"
"((end_0) len_1)"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values()"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(hash-set!"
" ht_0"
"(loop_0)"
"(loop_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
"(+"
" pos_0"
" inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0)))"
"(void)"
" ht_0))))"
"(if(unsafe-fx< index_0 38)"
"(let-values()"
"(let-values(((ht_0)"
"(let-values(((tmp_1)"
"(read-byte/no-eof"
" i_0)))"
"(if(equal? tmp_1 0)"
"(let-values() '#hasheq())"
"(if(equal? tmp_1 2)"
"(let-values() '#hasheqv())"
"(let-values() '#hash()))))))"
"(let-values(((len_1)(read-fasl-integer i_0)))"
"(let-values(((start_0) 0)"
"((end_0) len_1)"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_1 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values()"
"(let-values(((ht_2)"
"(let-values(((ht_2)"
" ht_1))"
"(let-values(((ht_3)"
"(let-values()"
"(hash-set"
" ht_2"
"(loop_0)"
"(loop_0)))))"
"(values"
" ht_3)))))"
"(if(not #f)"
"(for-loop_0"
" ht_2"
"(+"
" pos_0"
" inc_0))"
" ht_2)))"
" ht_1)))))"
" for-loop_0)"
" ht_0"
" start_0))))))"
"(let-values()"
"(srcloc"
"(loop_0)"
"(loop_0)"
"(loop_0)"
"(loop_0)"
"(loop_0)))))))))))))))))"
" loop_0)))))))))))))))"
"(define-values"
"(write-fasl-integer)"
"(lambda(i_0 o_0)"
"(begin"
"(if(<= -124 i_0 127)"
"(let-values()(if(negative? i_0)(1/write-byte(+ i_0 256) o_0)(1/write-byte i_0 o_0)))"
"(if(<= -32768 i_0 32767)"
"(let-values()(begin(1/write-byte 128 o_0)(1/write-bytes(integer->integer-bytes i_0 2 #t #f) o_0)))"
"(if(<= -2147483648 i_0 2147483647)"
"(let-values()(begin(1/write-byte 129 o_0)(1/write-bytes(integer->integer-bytes i_0 4 #t #f) o_0)))"
"(if(<= -9223372036854775808 i_0 9223372036854775807)"
"(let-values()(begin(1/write-byte 130 o_0)(1/write-bytes(integer->integer-bytes i_0 8 #t #f) o_0)))"
"(let-values()"
"(let-values((()(begin(1/write-byte 131 o_0)(values))))"
"                  (let-values (((s_0) (format \"~x\" i_0)))"
"(begin(write-fasl-integer(string-length s_0) o_0)(write-string s_0 o_0))))))))))))"
"(define-values"
"(write-fasl-string)"
"(lambda(v_0 o_0)"
"(begin"
"(let-values(((bstr_0)(string->bytes/utf-8 v_0)))"
"(begin(write-fasl-integer(bytes-length bstr_0) o_0)(1/write-bytes bstr_0 o_0))))))"
"(define-values"
"(write-fasl-bytes)"
"(lambda(v_0 o_0)(begin(begin(write-fasl-integer(bytes-length v_0) o_0)(1/write-bytes v_0 o_0)))))"
"(define-values"
"(read-error)"
"(lambda(s_0 . args_0)"
"    (begin (apply raise-arguments-error 'fasl-read (string-append \"error parsing fasl stream;\\n\" \" \" s_0) args_0))))"
"(define-values"
"(read-byte/no-eof)"
"(lambda(i_0)"
"(begin"
"(if(mpair? i_0)"
"(let-values()"
"(let-values(((pos_0)(mcdr i_0)))"
"(begin"
"              (if (< pos_0 (bytes-length (mcar i_0))) (void) (let-values () (read-error \"truncated stream\")))"
"(set-mcdr! i_0(add1 pos_0))"
"(bytes-ref(mcar i_0) pos_0))))"
"(let-values()"
"(let-values(((b_0)(read-byte i_0)))"
"            (begin (if (eof-object? b_0) (let-values () (read-error \"truncated stream\")) (void)) b_0)))))))"
"(define-values"
"(read-bytes/exactly)"
"(lambda(n_0 i_0)"
"(begin"
"(if(mpair? i_0)"
"(let-values()"
"(let-values(((pos_0)(mcdr i_0)))"
"(begin"
"              (if (<= (+ pos_0 n_0) (bytes-length (mcar i_0))) (void) (let-values () (read-error \"truncated stream\")))"
"(set-mcdr! i_0(+ pos_0 n_0))"
"(subbytes(mcar i_0) pos_0(+ pos_0 n_0)))))"
"(let-values()"
"(let-values(((bstr_0)(read-bytes n_0 i_0)))"
"(begin"
"(if(if(bytes? bstr_0)(= n_0(bytes-length bstr_0)) #f)"
"(void)"
"                (let-values () (read-error \"truncated stream\")))"
" bstr_0)))))))"
"(define-values"
"(read-fasl-integer)"
"(lambda(i_0)"
"(begin"
"(let-values(((b_0)(read-byte/no-eof i_0)))"
"(if(<= b_0 127)"
"(let-values() b_0)"
"(if(>= b_0 132)"
"(let-values()(- b_0 256))"
"(if(eqv? b_0 128)"
"(let-values()(integer-bytes->integer(read-bytes/exactly 2 i_0) #t #f))"
"(if(eqv? b_0 129)"
"(let-values()(integer-bytes->integer(read-bytes/exactly 4 i_0) #t #f))"
"(if(eqv? b_0 130)"
"(let-values()(integer-bytes->integer(read-bytes/exactly 8 i_0) #t #f))"
"(if(eqv? b_0 131)"
"(let-values()"
"(let-values(((len_0)(read-fasl-integer i_0)))"
"(let-values(((str_0)(read-fasl-string i_0 len_0)))"
"(begin"
"(if(if(string? str_0)(= len_0(string-length str_0)) #f)"
"(void)"
"                              (let-values () (read-error \"truncated stream at number\")))"
"(1/string->number str_0 16)))))"
"                    (let-values () (read-error \"internal error on integer mode\"))))))))))))"
"(define-values"
"(read-fasl-string)"
"(let-values(((read-fasl-string22_0)"
"(lambda(i21_0 len20_0)"
"(begin"
" 'read-fasl-string22"
"(let-values(((i_0) i21_0))"
"(let-values(((len_0)(if(eq? len20_0 unsafe-undefined)(read-fasl-integer i_0) len20_0)))"
"(let-values()"
"(let-values(((bstr_0)(read-bytes/exactly len_0 i_0)))(bytes->string/utf-8 bstr_0)))))))))"
"(case-lambda"
"((i_0)(begin(read-fasl-string22_0 i_0 unsafe-undefined)))"
"((i_0 len20_0)(read-fasl-string22_0 i_0 len20_0)))))"
"(define-values"
"(read-fasl-bytes)"
"(lambda(i_0)(begin(let-values(((len_0)(read-fasl-integer i_0)))(read-bytes/exactly len_0 i_0)))))"
"(define-values"
"(1/fasl->s-exp/intern)"
"(lambda(s_0)(begin 'fasl->s-exp/intern(let-values(((s1_0) s_0)((temp2_0) #t))(fasl->s-exp17.1 temp2_0 s1_0)))))"
"(define-values(start-atomic)(lambda()(begin(unsafe-start-atomic))))"
"(define-values(end-atomic)(lambda()(begin(unsafe-end-atomic))))"
"(define-values(start-breakable-atomic)(lambda()(begin(unsafe-start-breakable-atomic))))"
"(define-values(end-breakable-atomic)(lambda()(begin(unsafe-end-breakable-atomic))))"
"(define-values(cell.1$8)(unsafe-make-place-local #f))"
"(define-values"
"(entered-err-string-handler)"
"(lambda(s_0 n_0)(begin(call-as-nonatomic(lambda()((error-value->string-handler) s_0 n_0))))))"
"(define-values(cell.2$5)(unsafe-make-place-local #f))"
"(define-values(cell.3$2)(unsafe-make-place-local #f))"
"(define-values(cell.4$2)(unsafe-make-place-local 0))"
"(define-values(exited-key)(gensym 'as-exit))"
"(define-values(lock-tag)(make-continuation-prompt-tag 'lock))"
"(define-values"
"(call-as-atomic)"
"(lambda(f_0)"
"(begin"
"(begin"
"(if(if(procedure? f_0)(procedure-arity-includes? f_0 0) #f)"
"(void)"
"          (let-values () (raise-type-error 'call-as-atomic \"procedure (arity 0)\" f_0)))"
"(if(eq?(unsafe-place-local-ref cell.1$8)(current-thread))"
"(let-values()"
"(dynamic-wind"
"(lambda()"
"(begin"
"(start-breakable-atomic)"
"(unsafe-place-local-set! cell.4$2(add1(unsafe-place-local-ref cell.4$2)))))"
" f_0"
"(lambda()"
"(begin"
"(unsafe-place-local-set! cell.4$2(sub1(unsafe-place-local-ref cell.4$2)))"
"(end-breakable-atomic)))))"
"(let-values()"
"(with-continuation-mark"
" exited-key"
" #f"
"(call-with-continuation-prompt"
"(lambda()"
"(dynamic-wind"
"(lambda()(begin(start-breakable-atomic)(unsafe-place-local-set! cell.1$8(current-thread))))"
"(lambda()"
"(begin"
"(unsafe-place-local-set! cell.2$5(current-parameterization))"
"(unsafe-place-local-set! cell.3$2(current-break-parameterization))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" error-value->string-handler"
" entered-err-string-handler)"
"(let-values()"
"(with-continuation-mark"
" break-enabled-key"
"(make-thread-cell #f)"
"(begin"
"(check-for-break)"
"(let-values()"
"(call-with-exception-handler"
"(lambda(exn_0)"
"(if(continuation-mark-set-first #f exited-key)"
" exn_0"
"(abort-current-continuation lock-tag(lambda()(raise exn_0)))))"
" f_0))))))))"
"(lambda()"
"(begin"
"(unsafe-place-local-set! cell.1$8 #f)"
"(unsafe-place-local-set! cell.2$5 #f)"
"(unsafe-place-local-set! cell.3$2 #f)"
"(end-breakable-atomic)))))"
" lock-tag"
"(lambda(t_0)(t_0))))))))))"
"(define-values"
"(call-as-nonatomic)"
"(lambda(f_0)"
"(begin"
"(begin"
"(if(if(procedure? f_0)(procedure-arity-includes? f_0 0) #f)"
"(void)"
"          (let-values () (raise-type-error 'call-as-nonatomic \"procedure (arity 0)\" f_0)))"
"(if(eq?(unsafe-place-local-ref cell.1$8)(current-thread))"
"(void)"
"          (let-values () (error 'call-as-nonatomic \"not in atomic area for ~e\" f_0)))"
"(let-values(((paramz_0)(unsafe-place-local-ref cell.2$5))"
"((break-paramz_0)(unsafe-place-local-ref cell.3$2))"
"((extra-depth_0)(unsafe-place-local-ref cell.4$2)))"
"(with-continuation-mark"
" exited-key"
" #t"
"(call-with-parameterization"
" paramz_0"
"(lambda()"
"(call-with-break-parameterization"
" break-paramz_0"
"(lambda()"
"(dynamic-wind"
"(lambda()"
"(begin"
"(unsafe-place-local-set! cell.1$8 #f)"
"(unsafe-place-local-set! cell.4$2 0)"
"(end-breakable-atomic)"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(zero? i_0)"
"(void)"
"(let-values()(begin(end-breakable-atomic)(loop_0(sub1 i_0)))))))))"
" loop_0)"
" extra-depth_0)))"
" f_0"
"(lambda()"
"(begin"
"(start-breakable-atomic)"
"(unsafe-place-local-set! cell.2$5 paramz_0)"
"(unsafe-place-local-set! cell.3$2 break-paramz_0)"
"((letrec-values(((loop_0)"
"(lambda(i_0)"
"(begin"
" 'loop"
"(if(zero? i_0)"
"(void)"
"(let-values()(begin(start-breakable-atomic)(loop_0(sub1 i_0)))))))))"
" loop_0)"
" extra-depth_0)"
"(unsafe-place-local-set! cell.4$2 extra-depth_0)"
"(unsafe-place-local-set! cell.1$8(current-thread)))))))))))))))"
"(define-values(prop:serialize serialize? serialize-ref)(make-struct-type-property 'serialize))"
"(define-values"
"(prop:serialize-fill! serialize-fill!? serialize-fill!-ref)"
"(make-struct-type-property 'serialize-fill!))"
"(define-values(prop:reach-scopes reach-scopes? reach-scopes-ref)(make-struct-type-property 'reach-scopes))"
"(define-values"
"(prop:scope-with-bindings scope-with-bindings? scope-with-bindings-ref)"
"(make-struct-type-property 'scope-with-bindings))"
"(define-values"
"(prop:binding-reach-scopes binding-reach-scopes? binding-reach-scopes-ref)"
"(make-struct-type-property 'binding-reach-scopes))"
"(define-values"
"(1/module-path?)"
"(lambda(v_0)"
"(begin"
" 'module-path?"
"(let-values(((or-part_0)(if(pair? v_0)(if(eq?(car v_0) 'submod)(submodule-module-path? v_0) #f) #f)))"
"(if or-part_0 or-part_0(root-module-path? v_0))))))"
"(define-values"
"(root-module-path?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(path? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(if(string? v_0)(string-module-path? v_0) #f)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(if(symbol? v_0)(symbol-module-path? v_0) #f)))"
"(if or-part_2"
" or-part_2"
"(if(pair? v_0)"
"(let-values(((tmp_0)(car v_0)))"
"(if(equal? tmp_0 'quote)"
"(let-values()(if(pair?(cdr v_0))(if(symbol?(cadr v_0))(null?(cddr v_0)) #f) #f))"
"(if(equal? tmp_0 'lib)"
"(let-values()(lib-module-path? v_0))"
"(if(equal? tmp_0 'file)"
"(let-values()"
"(if(pair?(cdr v_0))"
"(if(string?(cadr v_0))(if(path-string?(cadr v_0))(null?(cddr v_0)) #f) #f)"
" #f))"
"(if(equal? tmp_0 'planet)(let-values()(planet-module-path? v_0))(let-values() #f))))))"
" #f))))))))))"
"(define-values"
"(submodule-module-path?)"
"(lambda(v_0)"
"(begin"
"(if(pair?(cdr v_0))"
"(if(list? v_0)"
"          (if (let-values (((or-part_0) (equal? (cadr v_0) \"..\")))"
"(if or-part_0"
" or-part_0"
"                  (let-values (((or-part_1) (equal? (cadr v_0) \".\")))"
"(if or-part_1 or-part_1(root-module-path?(cadr v_0))))))"
"(let-values(((lst_0)(cddr v_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(let-values(((or-part_0)"
"                                                                                          (equal? e_0 \"..\")))"
"(if or-part_0"
" or-part_0"
"(symbol? e_0)))))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) e_0))(not #f) #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
" #f)"
" #f)"
" #f))))"
"(define-values"
"(string-module-path?)"
"(lambda(v_0)"
"(begin"
"(let-values(((v13_0) v_0)((temp14_0) #t)((temp15_0) #t)((temp16_0) #t))"
"(module-path-string?10.1 temp14_0 temp16_0 #f temp15_0 v13_0)))))"
"(define-values"
"(symbol-module-path?)"
"(lambda(v_0)"
"(begin(let-values(((temp17_0)(symbol->string v_0)))(module-path-string?10.1 #f #f #f #f temp17_0)))))"
"(define-values"
"(lib-module-path?)"
"(lambda(v_0)"
"(begin"
"(if(list? v_0)"
"(if(pair?(cdr v_0))"
"((letrec-values(((loop_0)"
"(lambda(v_1 first?_0)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(null? v_1)))"
"(if or-part_0"
" or-part_0"
"(if(string?(car v_1))"
"(if(let-values(((temp18_0)(car v_1))"
"((first?19_0) first?_0)"
"((first?20_0) first?_0))"
"(module-path-string?10.1 #f first?20_0 #f first?19_0 temp18_0))"
"(loop_0(cdr v_1) #f)"
" #f)"
" #f)))))))"
" loop_0)"
"(cdr v_0)"
" #t)"
" #f)"
" #f))))"
"(define-values"
"(planet-module-path?)"
"(lambda(v_0)"
"(begin"
"(if(list? v_0)"
"(let-values(((tmp_0)(length v_0)))"
"(if(equal? tmp_0 1)"
"(let-values() #f)"
"(if(equal? tmp_0 2)"
"(let-values()"
"(let-values(((e_0)(cadr v_0)))"
"(if(string? e_0)"
"(let-values()"
"(let-values(((e21_0) e_0)((temp22_0) #t)((temp23_0) #t))"
"(module-path-string?10.1 #f temp23_0 temp22_0 #f e21_0)))"
"(if(symbol? e_0)"
"(let-values()"
"(let-values(((temp24_0)(symbol->string e_0))((temp25_0) #t))"
"(module-path-string?10.1 #f #f temp25_0 #f temp24_0)))"
"(let-values() #f)))))"
"(let-values()"
"(let-values(((file_0)(cadr v_0)))"
"(let-values(((pkg_0)(caddr v_0)))"
"(let-values(((subs_0)(cdddr v_0)))"
"(if file_0"
"(if(let-values(((file26_0) file_0)((temp27_0) #t)((temp28_0) #t))"
"(module-path-string?10.1 #f temp28_0 #f temp27_0 file26_0))"
"(if(if(list? pkg_0)"
"(if(<= 2(length pkg_0) 4)"
"(if(planet-user/pkg-string?(car pkg_0))"
"(if(planet-user/pkg-string?(cadr pkg_0))"
"(let-values(((or-part_0)(null?(cddr pkg_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(planet-version-number?(caddr pkg_0))))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(null?(cddr pkg_0))))"
"(if or-part_2"
" or-part_2"
"(planet-version-minor-spec?(cadddr pkg_0))))))))"
" #f)"
" #f)"
" #f)"
" #f)"
"(let-values(((lst_0) subs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((sub_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(let-values(((sub29_0)"
" sub_0))"
"(module-path-string?10.1"
" #f"
" #f"
" #f"
" #f"
" sub29_0))))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) sub_0))"
"(not #f)"
" #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
" #f)"
" #f)"
" #f))))))))"
" #f))))"
"(define-values(planet-version-number?)(lambda(v_0)(begin(exact-nonnegative-integer? v_0))))"
"(define-values"
"(planet-version-minor-spec?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(planet-version-number? v_0)))"
"(if or-part_0"
" or-part_0"
"(if(pair? v_0)"
"(if(list? v_0)"
"(if(= 2(length v_0))"
"(let-values(((tmp_0)(car v_0)))"
"(if(if(equal? tmp_0 '=) #t(if(equal? tmp_0 '+) #t(equal? tmp_0 '-)))"
"(let-values()(planet-version-number?(cadr v_0)))"
"(let-values()(if(planet-version-number?(car v_0))(planet-version-number?(cadr v_0)) #f))))"
" #f)"
" #f)"
" #f))))))"
"(define-values"
"(module-path-string?10.1)"
"(lambda(dots-dir-ok?2_0 file-end-ok?4_0 for-planet?1_0 just-file-ok?3_0 v9_0)"
"(begin"
" 'module-path-string?10"
"(let-values(((v_0) v9_0))"
"(let-values(((for-planet?_0) for-planet?1_0))"
"(let-values(((dots-dir-ok?_0) dots-dir-ok?2_0))"
"(let-values(((just-file-ok?_0) just-file-ok?3_0))"
"(let-values(((file-end-ok?_0) file-end-ok?4_0))"
"(let-values()"
"(let-values(((len_0)(string-length v_0)))"
"(if(positive? len_0)"
"(if(not(char=? '#\\/(string-ref v_0 0)))"
"(if(not(char=? '#\\/(string-ref v_0(sub1 len_0))))"
"(let-values(((start-package-version-pos_0 end-package-version-pos_0)"
"(if for-planet?_0(check-planet-part v_0 len_0)(values 0 0))))"
"(if start-package-version-pos_0"
"((letrec-values(((loop_0)"
"(lambda(i_0 prev-was-slash?_0 saw-slash?_0 saw-dot?_0)"
"(begin"
" 'loop"
"(if(not(negative? i_0))"
"(let-values()"
"(let-values(((c_0)(string-ref v_0 i_0)))"
"(if(char=? c_0 '#\\/)"
"(let-values()"
"(if(not prev-was-slash?_0)"
"(loop_0(sub1 i_0) #t #t saw-dot?_0)"
" #f))"
"(if(char=? c_0 '#\\.)"
"(let-values()"
"(if(if(<(add1 i_0) len_0)"
"(if(not"
"(char=?(string-ref v_0(add1 i_0)) '#\\/))"
"(not(char=?(string-ref v_0(add1 i_0)) '#\\.))"
" #f)"
" #f)"
"(if(not saw-slash?_0)"
"(loop_0(sub1 i_0) #f saw-slash?_0 #t)"
" #f)"
"(loop_0(sub1 i_0) #f saw-slash?_0 saw-dot?_0)))"
"(if(let-values(((or-part_0)(plain-char? c_0)))"
"(if or-part_0"
" or-part_0"
"(if(char=? c_0 '#\\%)"
"(if(<(+ i_0 2) len_0)"
"(hex-sequence? v_0(add1 i_0))"
" #f)"
" #f)))"
"(let-values()"
"(loop_0(sub1 i_0) #f saw-slash?_0 saw-dot?_0))"
"(if(if(>= i_0 start-package-version-pos_0)"
"(< i_0 end-package-version-pos_0)"
" #f)"
"(let-values()"
"(loop_0(sub1 i_0) #f saw-slash?_0 saw-dot?_0))"
"(let-values() #f)))))))"
"(let-values()"
"(if(not"
"(if(not just-file-ok?_0)"
"(if saw-dot?_0(not saw-slash?_0) #f)"
" #f))"
"(let-values(((or-part_0) dots-dir-ok?_0))"
"(if or-part_0"
" or-part_0"
"((letrec-values(((loop_1)"
"(lambda(i_1)"
"(begin"
" 'loop"
"(if(= i_1 len_0)"
"(let-values() #t)"
"(if(char=?"
"(string-ref v_0 i_1)"
" '#\\.)"
"(let-values()"
"(if(not"
"(let-values(((or-part_1)"
"(="
" len_0"
"(add1"
" i_1))))"
"(if or-part_1"
" or-part_1"
"(char=?"
"(string-ref"
" v_0"
"(add1 i_1))"
" '#\\/))))"
"(if(not"
"(if(char=?"
"(string-ref"
" v_0"
"(add1 i_1))"
" '#\\.)"
"(let-values(((or-part_1)"
"(="
" len_0"
"(+"
" i_1"
" 2))))"
"(if or-part_1"
" or-part_1"
"(char=?"
"(string-ref"
" v_0"
"(+ i_1 2))"
" '#\\/)))"
" #f))"
"(loop_1"
"((letrec-values(((loop_2)"
"(lambda(i_2)"
"(begin"
" 'loop"
"(if(char=?"
" '#\\."
"(string-ref"
" v_0"
" i_2))"
"(loop_2"
"(add1"
" i_2))"
" i_2)))))"
" loop_2)"
" i_1))"
" #f)"
" #f))"
"(let-values()"
"(loop_1(add1 i_1)))))))))"
" loop_1)"
" 0)))"
" #f)))))))"
" loop_0)"
"(sub1 len_0)"
" #f"
"(not file-end-ok?_0)"
" #f)"
" #f))"
" #f)"
" #f)"
" #f)))))))))))"
"(define-values"
"(planet-user/pkg-string?)"
"(lambda(v_0)"
"(begin"
"(if(string? v_0)"
"(let-values(((len_0)(string-length v_0)))"
"(if(positive? len_0)"
"(let-values(((vec_0 len_1)"
"(let-values(((vec_0) v_0))"
"(begin(check-string vec_0)(values vec_0(unsafe-string-length vec_0)))))"
"((start_0) 0))"
"(begin"
" #f"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 pos_0 pos_1)"
"(begin"
" 'for-loop"
"(if(if(unsafe-fx< pos_0 len_1) #t #f)"
"(let-values(((c_0)(string-ref vec_0 pos_0))((i_0) pos_1))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(let-values(((or-part_0)"
"(plain-char? c_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(char=? '#\\. c_0)))"
"(if or-part_1"
" or-part_1"
"(if(char=? '#\\% c_0)"
"(if(< i_0(- len_0 2))"
"(hex-sequence? v_0(add1 i_0))"
" #f)"
" #f)))))))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) c_0))"
"(if(not((lambda x_0(not result_1)) i_0))(not #f) #f)"
" #f)"
"(for-loop_0 result_1(unsafe-fx+ 1 pos_0)(+ pos_1 1))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" 0"
" start_0)))"
" #f))"
" #f))))"
"(define-values"
"(plain-char?)"
"(lambda(c_0)"
"(begin"
"(let-values(((or-part_0)(char<=? '#\\a c_0 '#\\z)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(char<=? '#\\A c_0 '#\\Z)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(char<=? '#\\0 c_0 '#\\9)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(char=? '#\\- c_0)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(char=? '#\\_ c_0)))"
"(if or-part_4 or-part_4(char=? '#\\+ c_0))))))))))))))"
"(define-values"
"(hex-sequence?)"
"(lambda(s_0 i_0)"
"(begin"
"(let-values(((c1_0)(string-ref s_0 i_0)))"
"(let-values(((c2_0)(string-ref s_0(add1 i_0))))"
"(if(hex-char? c1_0)"
"(if(hex-char? c2_0)"
"(let-values(((c_0)(integer->char(+(*(hex-char->integer c1_0) 16)(hex-char->integer c2_0)))))"
"(not(plain-char? c_0)))"
" #f)"
" #f))))))"
"(define-values"
"(hex-char?)"
"(lambda(c_0)"
"(begin(let-values(((or-part_0)(char<=? '#\\a c_0 '#\\f)))(if or-part_0 or-part_0(char<=? '#\\0 c_0 '#\\9))))))"
"(define-values"
"(hex-char->integer)"
"(lambda(c_0)"
"(begin"
"(if(char<=? '#\\a c_0 '#\\f)"
"(let-values()(-(char->integer c_0)(+ 10(char->integer '#\\a))))"
"(if(char<=? '#\\A c_0 '#\\F)"
"(let-values()(-(char->integer c_0)(+ 10(char->integer '#\\A))))"
"(let-values()(-(char->integer c_0)(char->integer '#\\0))))))))"
"(define-values"
"(check-planet-part)"
"(lambda(v_0 len_0)"
"(begin"
"(let-values(((start-package-version-pos_0 end-package-version-pos_0 colon1-pos_0 colon2-pos_0)"
"((letrec-values(((loop_0)"
"(lambda(j_0"
" start-package-version-pos_0"
" end-package-version-pos_0"
" colon1-pos_0"
" colon2-pos_0)"
"(begin"
" 'loop"
"(if(= j_0 len_0)"
"(let-values()"
"(values"
" start-package-version-pos_0"
"(let-values(((or-part_0) end-package-version-pos_0))"
"(if or-part_0 or-part_0 j_0))"
" colon1-pos_0"
" colon2-pos_0))"
"(let-values()"
"(let-values(((tmp_0)(string-ref v_0 j_0)))"
"(if(equal? tmp_0 '#\\/)"
"(let-values()"
"(loop_0"
"(add1 j_0)"
"(let-values(((or-part_0) start-package-version-pos_0))"
"(if or-part_0 or-part_0(add1 j_0)))"
"(if start-package-version-pos_0"
"(let-values(((or-part_0) end-package-version-pos_0))"
"(if or-part_0 or-part_0 j_0))"
" #f)"
" colon1-pos_0"
" colon2-pos_0))"
"(if(equal? tmp_0 '#\\:)"
"(let-values()"
"(if colon2-pos_0"
"(let-values()(values #f #f #f #f))"
"(if colon1-pos_0"
"(let-values()"
"(loop_0"
"(add1 j_0)"
" start-package-version-pos_0"
" end-package-version-pos_0"
" colon1-pos_0"
" j_0))"
"(let-values()"
"(loop_0"
"(add1 j_0)"
" start-package-version-pos_0"
" end-package-version-pos_0"
" j_0"
" #f)))))"
"(let-values()"
"(loop_0"
"(add1 j_0)"
" start-package-version-pos_0"
" end-package-version-pos_0"
" colon1-pos_0"
" colon2-pos_0)))))))))))"
" loop_0)"
" 0"
" #f"
" #f"
" #f"
" #f)))"
"(if(if start-package-version-pos_0"
"(if(> end-package-version-pos_0 start-package-version-pos_0)"
"(let-values(((or-part_0)(not colon2-pos_0)))"
"(if or-part_0 or-part_0(<(add1 colon2-pos_0) end-package-version-pos_0)))"
" #f)"
" #f)"
"(let-values()"
"(if colon1-pos_0"
"(let-values()"
"(let-values(((colon1-end_0)"
"(let-values(((or-part_0) colon2-pos_0))"
"(if or-part_0 or-part_0 end-package-version-pos_0))))"
"(if(if(integer-sequence? v_0(add1 colon1-pos_0) colon1-end_0)"
"(let-values(((or-part_0)(not colon2-pos_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((tmp_0)(string-ref v_0(add1 colon2-pos_0))))"
"(if(equal? tmp_0 '#\\=)"
"(let-values()(integer-sequence? v_0(+ 2 colon2-pos_0) end-package-version-pos_0))"
"(if(if(equal? tmp_0 '#\\>) #t(equal? tmp_0 '#\\<))"
"(let-values()"
"(if(if(<(+ 2 colon2-pos_0) end-package-version-pos_0)"
"(char=? '#\\=(string-ref v_0(+ colon2-pos_0 2)))"
" #f)"
"(let-values()"
"(integer-sequence? v_0(+ 3 colon2-pos_0) end-package-version-pos_0))"
"(let-values()"
"(integer-sequence? v_0(+ 2 colon2-pos_0) end-package-version-pos_0))))"
"(let-values()"
"(integer-range-sequence? v_0(add1 colon2-pos_0) end-package-version-pos_0)))))))"
" #f)"
"(let-values()(values colon1-pos_0 end-package-version-pos_0))"
"(let-values()(values #f #f)))))"
"(let-values()(values 0 0))))"
"(let-values()(values #f #f)))))))"
"(define-values"
"(integer-sequence?)"
"(lambda(s_0 start_0 end_0)"
"(begin"
"(if(< start_0 end_0)"
"(let-values(((start_1) start_0)((end_1) end_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_1 end_1 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_1)"
"(let-values(((i_0) pos_0))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(char<=? '#\\0(string-ref s_0 i_0) '#\\9)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) i_0))(not #f) #f)"
"(for-loop_0 result_1(+ pos_0 inc_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" start_1)))"
" #f))))"
"(define-values"
"(integer-range-sequence?)"
"(lambda(s_0 start_0 end_0)"
"(begin"
"(if(< start_0 end_0)"
"(if(let-values(((start_1) start_0)((end_1) end_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_1 end_1 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_1)"
"(let-values(((i_0) pos_0))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(let-values(((c_0)(string-ref s_0 i_0)))"
"(let-values(((or-part_0)"
"(char=? c_0 '#\\-)))"
"(if or-part_0"
" or-part_0"
"(char<=? '#\\0 c_0 '#\\9))))))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) i_0))(not #f) #f)"
"(for-loop_0 result_1(+ pos_0 inc_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" start_1)))"
"(>="
" 1"
"(let-values(((start_1) start_0)((end_1) end_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_1 end_1 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_1)"
"(let-values(((i_0) pos_0))"
"(let-values(((result_1)"
"(let-values(((result_1) result_0))"
"(let-values(((result_2)"
"(let-values()"
"(+"
" result_1"
"(let-values()"
"(if(char=?(string-ref s_0 i_0) '#\\-)"
" 1"
" 0))))))"
"(values result_2)))))"
"(if(not #f)(for-loop_0 result_1(+ pos_0 inc_0)) result_1)))"
" result_0)))))"
" for-loop_0)"
" 0"
" start_1))))"
" #f)"
" #f))))"
"(define-values"
"(struct:weak-intern-table weak-intern-table1.1 weak-intern-table? weak-intern-table-box)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'weak-intern-table"
" #f"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'weak-intern-table)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'box))))"
"(define-values"
"(struct:table table2.1 table? table-ht table-count table-prune-at)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'table"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'table)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'ht)"
"(make-struct-field-accessor -ref_0 1 'count)"
"(make-struct-field-accessor -ref_0 2 'prune-at))))"
"(define-values(make-weak-intern-table)(lambda()(begin(weak-intern-table1.1(box(table2.1(hasheqv) 0 128))))))"
"(define-values"
"(weak-intern!)"
"(lambda(tt_0 v_0)"
"(begin"
"(let-values(((b_0)(weak-intern-table-box tt_0)))"
"(let-values(((t_0)(unbox b_0)))"
"(let-values(((code_0)(equal-hash-code v_0)))"
"(let-values(((vals_0)(hash-ref(table-ht t_0) code_0 null)))"
"(let-values(((or-part_0)"
"(let-values(((lst_0) vals_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((b_1)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(let-values(((bv_0)"
"(weak-box-value"
" b_1)))"
"(if(equal? bv_0 v_0)"
" bv_0"
" #f))))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) b_1))(not #f) #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" lst_0)))))"
"(if or-part_0"
" or-part_0"
"(let-values(((pruned-t_0)(if(=(table-count t_0)(table-prune-at t_0))(prune-table t_0) t_0)))"
"(let-values(((ht_0)(table-ht pruned-t_0)))"
"(let-values(((new-t_0)"
"(table2.1"
"(hash-set ht_0 code_0(cons(make-weak-box v_0)(hash-ref ht_0 code_0 null)))"
"(add1(table-count pruned-t_0))"
"(table-prune-at pruned-t_0))))"
"(let-values(((or-part_1)(if(box-cas! b_0 t_0 new-t_0) v_0 #f)))"
"(if or-part_1 or-part_1(weak-intern! tt_0 v_0)))))))))))))))"
"(define-values"
"(prune-table)"
"(lambda(t_0)"
"(begin"
"(let-values(((new-ht_0)"
"(let-values(((ht_0)(table-ht t_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 vals_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((new-vals_0)"
"(reverse$1"
"(let-values(((lst_0) vals_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((b_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(if(weak-box-value"
" b_0)"
"(let-values(((fold-var_2)"
" fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
" b_0)"
" fold-var_2))))"
"(values"
" fold-var_3)))"
" fold-var_1))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_1)"
" null"
" lst_0))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(table_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((table_2)"
"(let-values(((table_2)"
" table_1))"
"(if(pair?"
" new-vals_0)"
"(let-values(((table_3)"
" table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" k_0"
" new-vals_0))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4)))"
" table_2))))"
" table_2))))))"
" for-loop_1)"
" table_0)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first ht_0))))))"
"(let-values(((count_0)"
"(let-values(((ht_0) new-ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 vals_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((result_1)"
"(let-values(((result_1) result_0))"
"(let-values(((result_2)"
"(let-values()"
"(+"
" result_1"
"(let-values()(length vals_0))))))"
"(values result_2)))))"
"(if(not #f)"
"(for-loop_0 result_1(hash-iterate-next ht_0 i_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" 0"
"(hash-iterate-first ht_0))))))"
"(table2.1 new-ht_0 count_0(max 128(* 2 count_0))))))))"
"(define-values"
"(struct:resolved-module-path resolved-module-path1.1 1/resolved-module-path? 1/resolved-module-path-name)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'resolved-module-path"
" #f"
" 1"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(r_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:resolved-module-path)"
"(ser-push!_0(1/resolved-module-path-name r_0)))))"
"(cons"
" prop:custom-write"
"(lambda(r_0 port_0 mode_0)"
"(begin"
"                           (if mode_0 (let-values () (write-string \"#<resolved-module-path:\" port_0)) (void))"
"                           (fprintf port_0 \"~a\" (format-resolved-module-path-name (1/resolved-module-path-name r_0)))"
"                           (if mode_0 (let-values () (write-string \">\" port_0)) (void)))))"
"(cons"
" prop:equal+hash"
"(list"
"(lambda(a_0 b_0 eql?_0)"
"(eql?_0(1/resolved-module-path-name a_0)(1/resolved-module-path-name b_0)))"
"(lambda(a_0 hash-code_0)(hash-code_0(1/resolved-module-path-name a_0)))"
"(lambda(a_0 hash-code_0)(hash-code_0(1/resolved-module-path-name a_0))))))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'resolved-module-path)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'name))))"
"(define-values"
"(format-resolved-module-path-name)"
"(lambda(p_0)"
"(begin"
"(if(path? p_0)"
"        (let-values () (string-append \"\\\"\" (path->string p_0) \"\\\"\"))"
"(if(symbol? p_0)"
"(let-values()(format-symbol p_0))"
"(let-values()(format-submod(format-resolved-module-path-name(car p_0))(cdr p_0))))))))"
"(define-values"
"(format-symbol)"
"  (lambda (p_0) (begin (format \"'~s~a\" p_0 (if (symbol-interned? p_0) \"\" (format \"[~a]\" (eq-hash-code p_0)))))))"
"(define-values"
"(format-submod)"
"(lambda(base_0 syms_0)"
"(begin"
"(format"
"       \"(submod ~a~a)\""
" base_0"
"(apply"
" string-append"
"(reverse$1"
"(let-values(((lst_0) syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"                                                                        (let-values () (format \" ~s\" i_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))))"
"(define-values"
"(resolved-module-path-root-name)"
"(lambda(r_0)"
"(begin(let-values(((name_0)(1/resolved-module-path-name r_0)))(if(pair? name_0)(car name_0) name_0)))))"
"(define-values(resolved-module-paths)(make-weak-intern-table))"
"(define-values"
"(1/make-resolved-module-path)"
"(lambda(p_0)"
"(begin"
" 'make-resolved-module-path"
"(begin"
"(if(let-values(((or-part_0)(symbol? p_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(if(path? p_0)(complete-path? p_0) #f)))"
"(if or-part_1"
" or-part_1"
"(if(pair? p_0)"
"(if(pair?(cdr p_0))"
"(if(list? p_0)"
"(if(let-values(((or-part_2)(symbol?(car p_0))))"
"(if or-part_2 or-part_2(if(path?(car p_0))(complete-path?(car p_0)) #f)))"
"(let-values(((lst_0)(cdr p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(symbol? s_0)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) s_0))(not #f) #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
" #f)"
" #f)"
" #f)"
" #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-resolved-module-path"
"(string-append"
"              \"(or/c symbol?\\n\""
"              \"      (and/c path? complete-path?)\\n\""
"              \"      (cons/c (or/c symbol?\\n\""
"              \"                    (and/c path? complete-path?))\\n\""
"              \"              (non-empty-listof symbol?)))\")"
" p_0)))"
"(weak-intern! resolved-module-paths(resolved-module-path1.1 p_0))))))"
"(define-values"
"(resolved-module-path->module-path)"
"(lambda(r_0)"
"(begin"
"(let-values(((name_0)(1/resolved-module-path-name r_0)))"
"(let-values(((root-name_0)(if(pair? name_0)(car name_0) name_0)))"
"(let-values(((root-mod-path_0)(if(path? root-name_0) root-name_0(list 'quote root-name_0))))"
"(if(pair? name_0)(list* 'submod root-mod-path_0(cdr name_0)) root-mod-path_0)))))))"
"(define-values"
"(struct:module-path-index"
" module-path-index2.1"
" 1/module-path-index?"
" module-path-index-path"
" module-path-index-base"
" module-path-index-resolved"
" module-path-index-shift-cache"
" set-module-path-index-resolved!"
" set-module-path-index-shift-cache!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-path-index"
" #f"
" 4"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:custom-write"
"(lambda(r_0 port_0 mode_0)"
"(begin"
"                           (write-string \"#<module-path-index\" port_0)"
"(if(top-level-module-path-index? r_0)"
"                             (let-values () (fprintf port_0 \":top-level\"))"
"(if(module-path-index-path r_0)"
"(let-values()"
"(let-values(((l_0)"
"((letrec-values(((loop_0)"
"(lambda(r_1)"
"(begin"
" 'loop"
"(if(not r_1)"
"(let-values() null)"
"(if(1/resolved-module-path? r_1)"
"                                                                         (let-values () (list \"+\" (format \"~a\" r_1)))"
"(if(module-path-index-path r_1)"
"(let-values()"
"(cons"
"((letrec-values(((loop_1)"
"(lambda(v_0)"
"(begin"
" 'loop"
"(if(if(pair? v_0)"
"(if(eq?"
" 'quote"
"(car"
" v_0))"
"(null?"
"(cddr v_0))"
" #f)"
" #f)"
"(let-values()"
"(format-symbol"
"(cadr v_0)))"
"(if(if(pair?"
" v_0)"
"(eq?"
" 'submod"
"(car v_0))"
" #f)"
"(let-values()"
"(format-submod"
"(loop_1"
"(cadr v_0))"
"(cddr v_0)))"
"(let-values()"
"(format"
"                                                                                                           \"~.s\""
" v_0))))))))"
" loop_1)"
"(module-path-index-path r_1))"
"(loop_0(module-path-index-base r_1))))"
"(if(module-path-index-resolved r_1)"
"(let-values()"
"(list"
"                                                                                \"+\""
"(format"
"                                                                                 \"~a\""
"(module-path-index-resolved r_1))))"
"(let-values() null)))))))))"
" loop_0)"
" r_0)))"
"(fprintf"
" port_0"
"                                    \":~.a\""
"(apply"
" string-append"
"(car l_0)"
"(reverse$1"
"(let-values(((lst_0)(cdr l_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(format"
"                                                                                                        \" ~a\""
" i_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))"
"(if(module-path-index-resolved r_0)"
"                                 (let-values () (fprintf port_0 \"=~a\" (module-path-index-resolved r_0)))"
"(void))))"
"                           (write-string \">\" port_0))))"
"(cons"
" prop:equal+hash"
"(list"
"(lambda(a_0 b_0 eql?_0)"
"(if(eql?_0(module-path-index-path a_0)(module-path-index-path b_0))"
"(eql?_0(module-path-index-base a_0)(module-path-index-base b_0))"
" #f))"
"(lambda(a_0 hash-code_0)"
"(+(hash-code_0(module-path-index-path a_0))(hash-code_0(module-path-index-base a_0))))"
"(lambda(a_0 hash-code_0)"
"(+(hash-code_0(module-path-index-path a_0))(hash-code_0(module-path-index-base a_0)))))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'module-path-index)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'path)"
"(make-struct-field-accessor -ref_0 1 'base)"
"(make-struct-field-accessor -ref_0 2 'resolved)"
"(make-struct-field-accessor -ref_0 3 'shift-cache)"
"(make-struct-field-mutator -set!_0 2 'resolved)"
"(make-struct-field-mutator -set!_0 3 'shift-cache))))"
"(define-values"
"(deserialize-module-path-index)"
"(case-lambda"
"((path_0 base_0)(begin(1/module-path-index-join path_0 base_0)))"
"((name_0)(make-self-module-path-index(1/make-resolved-module-path name_0)))"
"(() top-level-module-path-index)))"
"(define-values"
"(1/module-path-index-resolve)"
"(let-values(((module-path-index-resolve5_0)"
"(lambda(mpi4_0 load?3_0)"
"(begin"
" 'module-path-index-resolve5"
"(let-values(((mpi_0) mpi4_0))"
"(let-values(((load?_0) load?3_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/module-path-index? mpi_0)"
"(void)"
"(let-values()"
"                                    (raise-argument-error 'module-path-index-resolve \"module-path-index?\" mpi_0)))"
"(let-values(((or-part_0)(module-path-index-resolved mpi_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((mod-name_0)"
"((1/current-module-name-resolver)"
"(module-path-index-path mpi_0)"
"(module-path-index-resolve/maybe"
"(module-path-index-base mpi_0)"
" load?_0)"
" #f"
" load?_0)))"
"(begin"
"(if(1/resolved-module-path? mod-name_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'module-path-index-resolve"
"                                             \"current module name resolver's result is not a resolved module path\""
"                                             \"result\""
" mod-name_0)))"
"(set-module-path-index-resolved! mpi_0 mod-name_0)"
" mod-name_0))))))))))))))"
"(case-lambda"
"((mpi_0)(begin 'module-path-index-resolve(module-path-index-resolve5_0 mpi_0 #f)))"
"((mpi_0 load?3_0)(module-path-index-resolve5_0 mpi_0 load?3_0)))))"
"(define-values"
"(module-path-index-unresolve)"
"(lambda(mpi_0)"
"(begin"
"(if(module-path-index-resolved mpi_0)"
"(let-values()"
"(let-values(((path_0 base_0)(1/module-path-index-split mpi_0)))(1/module-path-index-join path_0 base_0)))"
"(let-values() mpi_0)))))"
"(define-values"
"(1/module-path-index-join)"
"(let-values(((module-path-index-join10_0)"
"(lambda(mod-path8_0 base9_0 submod7_0)"
"(begin"
" 'module-path-index-join10"
"(let-values(((mod-path_0) mod-path8_0))"
"(let-values(((base_0) base9_0))"
"(let-values(((submod_0) submod7_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(1/module-path? x_0))))"
" mod-path_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-path-index-join"
"                                       \"(or/c #f module-path?)\""
" mod-path_0)))"
"(if(let-values(((or-part_0)(not base_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(1/resolved-module-path? base_0)))"
"(if or-part_1 or-part_1(1/module-path-index? base_0)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-path-index-join"
"                                       \"(or/c #f resolved-module-path? module-path-index?)\""
" base_0)))"
"(if(let-values(((or-part_0)(not submod_0)))"
"(if or-part_0"
" or-part_0"
"(if(pair? submod_0)(if(list? submod_0)(andmap2 symbol? submod_0) #f) #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-path-index-join"
"                                       \"(or/c #f (non-empty-listof symbol?))\""
" submod_0)))"
"(if(if(not mod-path_0) base_0 #f)"
"(let-values()"
"(raise-arguments-error"
" 'module-path-index-join"
"                                       \"cannot combine #f path with non-#f base\""
"                                       \"given base\""
" base_0))"
"(void))"
"(if(if submod_0 mod-path_0 #f)"
"(let-values()"
"(raise-arguments-error"
" 'module-path-index-join"
"                                       \"cannot combine #f submodule list with non-#f module path\""
"                                       \"given module path\""
" mod-path_0"
"                                       \"given submodule list\""
" submod_0))"
"(void))"
"(if submod_0"
"(let-values()"
"(make-self-module-path-index"
"(1/make-resolved-module-path(cons generic-module-name submod_0))))"
"(let-values()"
"(let-values(((keep-base_0)"
"((letrec-values(((loop_0)"
"(lambda(mod-path_1)"
"(begin"
" 'loop"
"(if(path? mod-path_1)"
"(let-values() #f)"
"(if(if(pair? mod-path_1)"
"(eq? 'quote(car mod-path_1))"
" #f)"
"(let-values() #f)"
"(if(symbol? mod-path_1)"
"(let-values() #f)"
"(if(if(pair? mod-path_1)"
"(eq? 'submod(car mod-path_1))"
" #f)"
"(let-values()"
"(loop_0(cadr mod-path_1)))"
"(let-values() base_0)))))))))"
" loop_0)"
" mod-path_0)))"
"(module-path-index2.1 mod-path_0 keep-base_0 #f #f)))))))))))))))"
"(case-lambda"
"((mod-path_0 base_0)(begin 'module-path-index-join(module-path-index-join10_0 mod-path_0 base_0 #f)))"
"((mod-path_0 base_0 submod7_0)(module-path-index-join10_0 mod-path_0 base_0 submod7_0)))))"
"(define-values"
"(module-path-index-resolve/maybe)"
"(lambda(base_0 load?_0)"
"(begin(if(1/module-path-index? base_0)(1/module-path-index-resolve base_0 load?_0) base_0))))"
"(define-values"
"(1/module-path-index-split)"
"(lambda(mpi_0)"
"(begin"
" 'module-path-index-split"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/module-path-index? mpi_0)"
"(void)"
"              (let-values () (raise-argument-error 'module-path-index-split \"module-path-index?\" mpi_0)))"
"(values(module-path-index-path mpi_0)(module-path-index-base mpi_0))))))))"
"(define-values"
"(1/module-path-index-submodule)"
"(lambda(mpi_0)"
"(begin"
" 'module-path-index-submodule"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/module-path-index? mpi_0)"
"(void)"
"              (let-values () (raise-argument-error 'module-path-index-submodule \"module-path-index?\" mpi_0)))"
"(if(not(module-path-index-path mpi_0))"
"(let-values(((r_0)(module-path-index-resolved mpi_0)))"
"(if r_0(let-values(((p_0)(1/resolved-module-path-name r_0)))(if(pair? p_0)(cdr p_0) #f)) #f))"
" #f)))))))"
"(define-values"
"(make-self-module-path-index)"
"(case-lambda"
"((name_0)(begin(module-path-index2.1 #f #f name_0 #f)))"
"((name_0 enclosing_0)"
"(make-self-module-path-index"
"(let-values(((name25_0) name_0)((temp26_0)(if enclosing_0(1/module-path-index-resolve enclosing_0) #f)))"
"(build-module-name16.1 unsafe-undefined name25_0 temp26_0))))))"
"(define-values(cell.1$7)(unsafe-make-place-local(make-weak-hash)))"
"(define-values(generic-module-name) '|expanded module|)"
"(define-values(module-path-place-init!)(lambda()(begin(unsafe-place-local-set! cell.1$7(make-weak-hash)))))"
"(define-values"
"(make-generic-self-module-path-index)"
"(lambda(self_0)"
"(begin"
"(let-values(((r_0)(resolved-module-path-to-generic-resolved-module-path(module-path-index-resolved self_0))))"
"(begin"
"(start-atomic)"
"(begin0"
"(let-values(((or-part_0)"
"(let-values(((e_0)(hash-ref(unsafe-place-local-ref cell.1$7) r_0 #f)))"
"(if e_0(ephemeron-value e_0) #f))))"
"(if or-part_0"
" or-part_0"
"(let-values(((mpi_0)(module-path-index2.1 #f #f r_0 #f)))"
"(begin(hash-set!(unsafe-place-local-ref cell.1$7) r_0(make-ephemeron r_0 mpi_0)) mpi_0))))"
"(end-atomic)))))))"
"(define-values"
"(resolved-module-path-to-generic-resolved-module-path)"
"(lambda(r_0)"
"(begin"
"(let-values(((name_0)(1/resolved-module-path-name r_0)))"
"(1/make-resolved-module-path"
"(if(symbol? name_0) generic-module-name(cons generic-module-name(cdr name_0))))))))"
"(define-values"
"(imitate-generic-module-path-index!)"
"(lambda(mpi_0)"
"(begin"
"(let-values(((r_0)(module-path-index-resolved mpi_0)))"
"(if r_0"
"(let-values()"
"(set-module-path-index-resolved! mpi_0(resolved-module-path-to-generic-resolved-module-path r_0)))"
"(void))))))"
"(define-values"
"(module-path-index-shift)"
"(lambda(mpi_0 from-mpi_0 to-mpi_0)"
"(begin"
"(if(eq? mpi_0 from-mpi_0)"
"(let-values() to-mpi_0)"
"(let-values()"
"(let-values(((base_0)(module-path-index-base mpi_0)))"
"(if(not base_0)"
"(let-values() mpi_0)"
"(let-values()"
"(let-values(((shifted-base_0)(module-path-index-shift base_0 from-mpi_0 to-mpi_0)))"
"(if(eq? shifted-base_0 base_0)"
"(let-values() mpi_0)"
"(let-values(((c1_0)(shift-cache-ref(module-path-index-shift-cache shifted-base_0) mpi_0)))"
"(if c1_0"
" c1_0"
"(let-values()"
"(let-values(((shifted-mpi_0)"
"(module-path-index2.1(module-path-index-path mpi_0) shifted-base_0 #f #f)))"
"(begin"
"(shift-cache-set!(module-path-index-shift-cache! shifted-base_0) mpi_0 shifted-mpi_0)"
" shifted-mpi_0)))))))))))))))"
"(define-values"
"(module-path-index-shift-cache!)"
"(lambda(mpi_0)"
"(begin"
"(let-values(((or-part_0)"
"(let-values(((cache_0)(module-path-index-shift-cache mpi_0)))"
"(if cache_0(if(weak-box-value cache_0) cache_0 #f) #f))))"
"(if or-part_0"
" or-part_0"
"(let-values(((cache_0)(make-weak-box(box '#hasheq()))))"
"(begin(set-module-path-index-shift-cache! mpi_0 cache_0) cache_0)))))))"
"(define-values"
"(shift-cache-ref)"
"(lambda(cache_0 v_0)"
"(begin(if cache_0(let-values(((b_0)(weak-box-value cache_0)))(if b_0(hash-ref(unbox b_0) v_0 #f) #f)) #f))))"
"(define-values"
"(shift-cache-set!)"
"(lambda(cache_0 v_0 r_0)"
"(begin"
"(let-values(((b_0)(weak-box-value cache_0)))"
"(if b_0(let-values()(set-box! b_0(hash-set(unbox b_0) v_0 r_0)))(void))))))"
"(define-values(top-level-module-path-index)(make-self-module-path-index(1/make-resolved-module-path 'top-level)))"
"(define-values(top-level-module-path-index?)(lambda(mpi_0)(begin(eq? top-level-module-path-index mpi_0))))"
"(define-values(non-self-module-path-index?)(lambda(mpi_0)(begin(if(module-path-index-path mpi_0) #t #f))))"
"(define-values"
"(inside-module-context?)"
"(lambda(mpi_0 inside-mpi_0)"
"(begin"
"(let-values(((or-part_0)(eq? mpi_0 inside-mpi_0)))"
"(if or-part_0"
" or-part_0"
"(if(1/module-path-index? mpi_0)"
"(if(1/module-path-index? inside-mpi_0)"
"(if(module-path-index-resolved mpi_0)"
"(eq?(module-path-index-resolved mpi_0)(module-path-index-resolved inside-mpi_0))"
" #f)"
" #f)"
" #f))))))"
"(define-values"
"(core-module-name-resolver)"
"(case-lambda"
"((name_0 from-namespace_0)(begin(void)))"
"((p_0 enclosing_0 source-stx-stx_0 load?_0)"
"(begin"
"(if(1/module-path? p_0)"
"(void)"
"        (let-values () (raise-argument-error 'core-module-name-resolver \"module-path?\" p_0)))"
"(if(let-values(((or-part_0)(not enclosing_0)))(if or-part_0 or-part_0(1/resolved-module-path? enclosing_0)))"
"(void)"
"        (let-values () (raise-argument-error 'core-module-name-resolver \"resolved-module-path?\" enclosing_0)))"
"(if(if(list? p_0)(if(=(length p_0) 2)(if(eq? 'quote(car p_0))(symbol?(cadr p_0)) #f) #f) #f)"
"(let-values()(1/make-resolved-module-path(cadr p_0)))"
"        (if (if (list? p_0) (if (eq? 'submod (car p_0)) (equal? \"..\" (cadr p_0)) #f) #f)"
"(let-values()"
"(let-values(((lst_0)(cdr p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(enclosing_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((enclosing_2)"
"(let-values(((enclosing_2) enclosing_1))"
"(let-values(((enclosing_3)"
"(let-values()"
"(let-values(((s27_0) s_0)"
"((enclosing28_0) enclosing_2)"
"((p29_0) p_0))"
"(build-module-name16.1"
" p29_0"
" s27_0"
" enclosing28_0)))))"
"(values enclosing_3)))))"
"(if(not #f)(for-loop_0 enclosing_2 rest_0) enclosing_2)))"
" enclosing_1)))))"
" for-loop_0)"
" enclosing_0"
" lst_0))))"
"          (if (if (list? p_0) (if (eq? 'submod (car p_0)) (equal? \".\" (cadr p_0)) #f) #f)"
"(let-values()"
"(let-values(((lst_0)(cddr p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(enclosing_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((enclosing_2)"
"(let-values(((enclosing_2) enclosing_1))"
"(let-values(((enclosing_3)"
"(let-values()"
"(let-values(((s30_0) s_0)"
"((enclosing31_0) enclosing_2)"
"((p32_0) p_0))"
"(build-module-name16.1"
" p32_0"
" s30_0"
" enclosing31_0)))))"
"(values enclosing_3)))))"
"(if(not #f)(for-loop_0 enclosing_2 rest_0) enclosing_2)))"
" enclosing_1)))))"
" for-loop_0)"
" enclosing_0"
" lst_0))))"
"(if(if(list? p_0)(eq? 'submod(car p_0)) #f)"
"(let-values()"
"(let-values(((base_0)((1/current-module-name-resolver)(cadr p_0) enclosing_0 #f #f)))"
"(let-values(((lst_0)(cddr p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(enclosing_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((enclosing_2)"
"(let-values(((enclosing_2) enclosing_1))"
"(let-values(((enclosing_3)"
"(let-values()"
"(let-values(((s33_0) s_0)"
"((enclosing34_0)"
" enclosing_2)"
"((p35_0) p_0))"
"(build-module-name16.1"
" p35_0"
" s33_0"
" enclosing34_0)))))"
"(values enclosing_3)))))"
"(if(not #f)(for-loop_0 enclosing_2 rest_0) enclosing_2)))"
" enclosing_1)))))"
" for-loop_0)"
" base_0"
" lst_0)))))"
"              (let-values () (error 'core-module-name-resolver \"not a supported module path: ~v\" p_0))))))))))"
"(define-values"
"(build-module-name16.1)"
"(lambda(original12_0 name14_0 enclosing15_0)"
"(begin"
" 'build-module-name16"
"(let-values(((name_0) name14_0))"
"(let-values(((enclosing_0) enclosing15_0))"
"(let-values(((orig-name_0)(if(eq? original12_0 unsafe-undefined) name_0 original12_0)))"
"(let-values()"
"(let-values(((enclosing-module-name_0)(if enclosing_0(1/resolved-module-path-name enclosing_0) #f)))"
"(1/make-resolved-module-path"
"(if(not enclosing-module-name_0)"
"(let-values() name_0)"
"(if(symbol? enclosing-module-name_0)"
"(let-values()(list enclosing-module-name_0 name_0))"
"                     (if (equal? name_0 \"..\")"
"(let-values()"
"(if(symbol? enclosing-module-name_0)"
"                           (let-values () (error \"too many \\\"..\\\"s:\" orig-name_0))"
"(if(= 2(length enclosing-module-name_0))"
"(let-values()(car enclosing-module-name_0))"
"(let-values()(reverse$1(cdr(reverse$1 enclosing-module-name_0)))))))"
"(let-values()(append enclosing-module-name_0(list name_0)))))))))))))))"
"(define-values"
"(1/current-module-name-resolver)"
"(make-parameter"
" core-module-name-resolver"
"(lambda(v_0)"
"(begin"
"(if(if(procedure? v_0)(if(procedure-arity-includes? v_0 2)(procedure-arity-includes? v_0 4) #f) #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'current-module-name-resolver"
"            \"(and/c (procedure-arity-includes/c 2) (procedure-arity-includes/c 4))\""
" v_0)))"
" v_0))))"
"(define-values"
"(1/current-module-declare-name)"
"(make-parameter"
" #f"
"(lambda(r_0)"
"(begin"
"(if(let-values(((or-part_0)(not r_0)))(if or-part_0 or-part_0(1/resolved-module-path? r_0)))"
"(void)"
"         (let-values () (raise-argument-error 'current-module-declare-name \"(or/c #f resolved-module-path?)\" r_0)))"
" r_0))))"
"(define-values"
"(1/current-module-declare-source)"
"(make-parameter"
" #f"
"(lambda(s_0)"
"(begin"
"(if(let-values(((or-part_0)(not s_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(symbol? s_0)))"
"(if or-part_1 or-part_1(if(path? s_0)(complete-path? s_0) #f)))))"
"(void)"
"(let-values()"
"           (raise-argument-error 'current-module-declare-source \"(or/c #f symbol? (and/c path? complete-path?))\" s_0)))"
" s_0))))"
"(define-values"
"(substitute-module-declare-name)"
"(lambda(default-name_0)"
"(begin"
"(let-values(((current-name_0)(1/current-module-declare-name)))"
"(let-values(((root-name_0)"
"(if current-name_0"
"(resolved-module-path-root-name current-name_0)"
"(if(pair? default-name_0)(car default-name_0) default-name_0))))"
"(1/make-resolved-module-path"
"(if(pair? default-name_0)(cons root-name_0(cdr default-name_0)) root-name_0)))))))"
"(define-values"
"(struct:promise promise1.1 promise? promise-val promise-status set-promise-val! set-promise-status!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'promise"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'promise)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'val)"
"(make-struct-field-accessor -ref_0 1 'status)"
"(make-struct-field-mutator -set!_0 0 'val)"
"(make-struct-field-mutator -set!_0 1 'status))))"
"(define-values"
"(force)"
"(lambda(v_0)"
"(begin"
"(if(promise? v_0)"
"(let-values()"
"(let-values(((s_0)(promise-status v_0)))"
"(if(not s_0)"
"(let-values()"
"(let-values(((result_0)((promise-val v_0))))"
"(begin(set-promise-val! v_0 result_0)(set-promise-status! v_0 #t) result_0)))"
"(let-values()(promise-val v_0)))))"
"(let-values() v_0)))))"
"(define-values"
"(phase?)"
"(lambda(v_0)(begin(let-values(((or-part_0)(not v_0)))(if or-part_0 or-part_0(exact-integer? v_0))))))"
"(define-values(phase+)(lambda(a_0 b_0)(begin(if a_0(if b_0(+ a_0 b_0) #f) #f))))"
"(define-values(phase-)(lambda(a_0 b_0)(begin(if a_0(if b_0(- a_0 b_0) #f) #f))))"
"(define-values"
"(phase<?)"
"(lambda(a_0 b_0)"
"(begin(if(not b_0)(let-values() #f)(if(not a_0)(let-values() #t)(let-values()(< a_0 b_0)))))))"
"(define-values(zero-phase?)(lambda(a_0)(begin(eq? a_0 0))))"
"(define-values(label-phase?)(lambda(a_0)(begin(not a_0))))"
" (define-values (phase?-string) \"(or/c exact-integer? #f)\")"
"(define-values(make-small-hasheq)(lambda()(begin(box '#hasheq()))))"
"(define-values(make-small-hasheqv)(lambda()(begin(box '#hasheqv()))))"
"(define-values"
"(small-hash-ref)"
"(lambda(small-ht_0 key_0 default_0)(begin(hash-ref(unbox small-ht_0) key_0 default_0))))"
"(define-values"
"(small-hash-set!)"
"(lambda(small-ht_0 key_0 val_0)(begin(set-box! small-ht_0(hash-set(unbox small-ht_0) key_0 val_0)))))"
"(define-values(small-hash-keys)(lambda(small-ht_0)(begin(hash-keys(unbox small-ht_0)))))"
"(define-values"
"(struct:serialize-state"
" serialize-state1.1"
" serialize-state?"
" serialize-state-reachable-scopes"
" serialize-state-bindings-intern"
" serialize-state-bulk-bindings-intern"
" serialize-state-scopes"
" serialize-state-shifted-multi-scopes"
" serialize-state-multi-scope-tables"
" serialize-state-mpi-shifts"
" serialize-state-context-triples"
" serialize-state-props"
" serialize-state-interned-props"
" serialize-state-syntax-context"
" serialize-state-sharing-syntaxes)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'serialize-state"
" #f"
" 12"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10 11)"
" #f"
" 'serialize-state)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'reachable-scopes)"
"(make-struct-field-accessor -ref_0 1 'bindings-intern)"
"(make-struct-field-accessor -ref_0 2 'bulk-bindings-intern)"
"(make-struct-field-accessor -ref_0 3 'scopes)"
"(make-struct-field-accessor -ref_0 4 'shifted-multi-scopes)"
"(make-struct-field-accessor -ref_0 5 'multi-scope-tables)"
"(make-struct-field-accessor -ref_0 6 'mpi-shifts)"
"(make-struct-field-accessor -ref_0 7 'context-triples)"
"(make-struct-field-accessor -ref_0 8 'props)"
"(make-struct-field-accessor -ref_0 9 'interned-props)"
"(make-struct-field-accessor -ref_0 10 'syntax-context)"
"(make-struct-field-accessor -ref_0 11 'sharing-syntaxes))))"
"(define-values"
"(make-serialize-state)"
"(lambda(reachable-scopes_0)"
"(begin"
"(let-values(((state_0)"
"(serialize-state1.1"
" reachable-scopes_0"
"(make-hasheq)"
"(make-hasheq)"
"(make-hash)"
"(make-hash)"
"(make-hasheq)"
"(make-hasheq)"
"(make-hasheq)"
"(make-hasheq)"
"(make-hash)"
"(box null)"
"(make-hasheq))))"
"(let-values(((empty-seteq_0)(seteq)))"
"(begin"
"(hash-set!(serialize-state-scopes state_0) empty-seteq_0 empty-seteq_0)"
"(hash-set!(serialize-state-shifted-multi-scopes state_0) empty-seteq_0 empty-seteq_0)"
"(hash-set!(serialize-state-interned-props state_0) empty-seteq_0 empty-seteq_0)"
" state_0))))))"
"(define-values"
"(intern-scopes)"
"(lambda(scs_0 state_0)"
"(begin"
"(let-values(((or-part_0)(hash-ref(serialize-state-scopes state_0) scs_0 #f)))"
"(if or-part_0 or-part_0(begin(hash-set!(serialize-state-scopes state_0) scs_0 scs_0) scs_0))))))"
"(define-values"
"(intern-shifted-multi-scopes)"
"(lambda(sms_0 state_0)"
"(begin"
"(let-values(((or-part_0)(hash-ref(serialize-state-shifted-multi-scopes state_0) sms_0 #f)))"
"(if or-part_0"
" or-part_0"
"(begin(hash-set!(serialize-state-shifted-multi-scopes state_0) sms_0 sms_0) sms_0))))))"
"(define-values"
"(intern-mpi-shifts)"
"(lambda(mpi-shifts_0 state_0)"
"(begin"
"(if(null? mpi-shifts_0)"
"(let-values() null)"
"(let-values()"
"(let-values(((tail_0)(intern-mpi-shifts(cdr mpi-shifts_0) state_0)))"
"(let-values(((tail-table_0)"
"(let-values(((or-part_0)(hash-ref(serialize-state-mpi-shifts state_0) tail_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheq)))"
"(begin(hash-set!(serialize-state-mpi-shifts state_0) tail_0 ht_0) ht_0))))))"
"(let-values(((or-part_0)(hash-ref tail-table_0(car mpi-shifts_0) #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((v_0)(cons(car mpi-shifts_0) tail_0)))"
"(begin(hash-set! tail-table_0(car mpi-shifts_0) v_0) v_0)))))))))))"
"(define-values"
"(intern-context-triple)"
"(lambda(scs_0 sms_0 mpi-shifts_0 state_0)"
"(begin"
"(let-values(((scs-ht_0)"
"(let-values(((or-part_0)(hash-ref(serialize-state-context-triples state_0) scs_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheq)))"
"(begin(hash-set!(serialize-state-context-triples state_0) scs_0 ht_0) ht_0))))))"
"(let-values(((sms-ht_0)"
"(let-values(((or-part_0)(hash-ref scs-ht_0 sms_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheq)))(begin(hash-set! scs-ht_0 sms_0 ht_0) ht_0))))))"
"(let-values(((or-part_0)(hash-ref sms-ht_0 mpi-shifts_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((vec_0)(vector-immutable scs_0 sms_0 mpi-shifts_0)))"
"(begin(hash-set! sms-ht_0 mpi-shifts_0 vec_0) vec_0)))))))))"
"(define-values"
"(intern-properties)"
"(lambda(all-props_0 get-preserved-props_0 state_0)"
"(begin"
"(let-values(((v_0)(hash-ref(serialize-state-props state_0) all-props_0 'no)))"
"(if(eq? v_0 'no)"
"(let-values()"
"(let-values(((preserved-props_0)(get-preserved-props_0)))"
"(let-values(((p_0)"
"(if(zero?(hash-count preserved-props_0))"
"(let-values() #f)"
"(let-values(((c1_0)"
"(hash-ref(serialize-state-interned-props state_0) preserved-props_0 #f)))"
"(if c1_0"
"((lambda(p_0) p_0) c1_0)"
"(let-values()"
"(begin"
"(hash-set!"
"(serialize-state-interned-props state_0)"
" preserved-props_0"
" preserved-props_0)"
" preserved-props_0)))))))"
"(begin(hash-set!(serialize-state-props state_0) all-props_0 p_0) p_0))))"
"(let-values() v_0))))))"
"(define-values"
"(push-syntax-context!)"
"(lambda(state_0 v_0)"
"(begin(let-values(((b_0)(serialize-state-syntax-context state_0)))(set-box! b_0(cons v_0(unbox b_0)))))))"
"(define-values"
"(get-syntax-context)"
"(lambda(state_0)"
"(begin"
"(let-values(((b_0)(serialize-state-syntax-context state_0)))(if(null?(unbox b_0)) #f(car(unbox b_0)))))))"
"(define-values"
"(pop-syntax-context!)"
"(lambda(state_0)"
"(begin(let-values(((b_0)(serialize-state-syntax-context state_0)))(set-box! b_0(cdr(unbox b_0)))))))"
"(define-values"
"(immutable-prefab-struct-key)"
"(lambda(v_0)"
"(begin(let-values(((k_0)(prefab-struct-key v_0)))(if k_0(if(all-fields-immutable?$1 k_0) k_0 #f) #f)))))"
"(define-values"
"(prefab-key-all-fields-immutable?)"
"(lambda(k_0)"
"(begin"
"(begin"
"(if(prefab-key? k_0)"
"(void)"
"          (let-values () (raise-argument-error 'prefab-key-all-fields-immutable? \"prefab-key?\" k_0)))"
"(all-fields-immutable?$1 k_0)))))"
"(define-values"
"(all-fields-immutable?$1)"
"(lambda(k_0)"
"(begin"
" 'all-fields-immutable?"
"(let-values(((or-part_0)(symbol? k_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(null? k_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((rk_0)(cdr k_0)))"
"(let-values(((rk_1)(if(if(pair? rk_0)(exact-integer?(car rk_0)) #f)(cdr rk_0) rk_0)))"
"(let-values(((rk_2)"
"(if(if(pair? rk_1)(pair?(car rk_1)) #f)"
"(if(zero?(caar rk_1))(cdr rk_1)(cons '#(1)(cdr rk_1)))"
" rk_1)))"
"(if(if(pair? rk_2)(vector?(car rk_2)) #f)"
"(if(zero?(vector-length(car rk_2)))(all-fields-immutable?$1(cdr rk_2)) #f)"
"(all-fields-immutable?$1 rk_2))))))))))))"
"(define-values(all-fields-immutable?)(lambda(k_0)(begin(prefab-key-all-fields-immutable? k_0))))"
" (define-values (not-an-fX.1) (lambda (who_0 v_0) (begin 'not-an-fX (raise-argument-error who_0 \"fixnum?\" v_0))))"
"(define-values"
"(datum-map-slow)"
"(lambda(tail?_0 s_0 f_0 seen_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(tail?_1 s_1 prev-seen_0)"
"(begin"
" 'loop"
"(let-values(((seen_1)"
"(if(if prev-seen_0(datum-has-elements? s_1) #f)"
"(let-values()"
"(if(hash-ref prev-seen_0 s_1 #f)"
"(let-values()((hash-ref prev-seen_0 'cycle-fail) s_1))"
"(let-values()(hash-set prev-seen_0 s_1 #t))))"
"(let-values() prev-seen_0))))"
"(if(null? s_1)"
"(let-values()(f_0 tail?_1 s_1))"
"(if(pair? s_1)"
"(let-values()"
"(f_0 tail?_1(cons(loop_0 #f(car s_1) seen_1)(loop_0 #t(cdr s_1) seen_1))))"
"(if(let-values(((or-part_0)(symbol? s_1)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(boolean? s_1)))"
"(if or-part_1 or-part_1(number? s_1)))))"
"(let-values()(f_0 #f s_1))"
"(if(vector? s_1)"
"(let-values()"
"(f_0"
" #f"
"(vector->immutable-vector"
"(let-values(((len_0)(vector-length s_1)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'for/vector"
"                                                   \"exact-nonnegative-integer?\""
" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((vec_0 len_1)"
"(let-values(((vec_0) s_1))"
"(begin"
"(check-vector vec_0)"
"(values vec_0(unsafe-vector-length vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(i_0 pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_0 len_1)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values(((i_1)"
"(let-values(((i_1)"
" i_0))"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_1"
"(let-values()"
"(loop_0"
" #f"
" e_0"
" seen_1)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values i_2)))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_1"
" len_0))"
" e_0))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_1"
"(unsafe-fx+ 1 pos_0))"
" i_1)))"
" i_0)))))"
" for-loop_0)"
" 0"
" 0)))))"
" v_0)))))))"
"(if(box? s_1)"
"(let-values()(f_0 #f(box-immutable(loop_0 #f(unbox s_1) seen_1))))"
"(let-values(((c1_0)(immutable-prefab-struct-key s_1)))"
"(if c1_0"
"((lambda(key_0)"
"(f_0"
" #f"
"(apply"
" make-prefab-struct"
" key_0"
"(reverse$1"
"(let-values(((v*_0 start*_0 stop*_0 step*_0)"
"(normalise-inputs"
" 'in-vector"
"                                                                 \"vector\""
"(lambda(x_0)(vector? x_0))"
"(lambda(x_0)(unsafe-vector-length x_0))"
"(struct->vector s_1)"
" 1"
" #f"
" 1)))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< idx_0 stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0"
" #f"
" e_0"
" seen_1))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
"(unsafe-fx+ idx_0 1))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" start*_0)))))))"
" c1_0)"
"(if(if(hash? s_1)(immutable? s_1) #f)"
"(let-values()"
"(if(hash-eq? s_1)"
"(let-values()"
"(f_0"
" #f"
"(let-values(((ht_0) s_1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" k_0"
"(loop_0"
" #f"
" v_0"
" seen_1)))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first ht_0))))))"
"(if(hash-eqv? s_1)"
"(let-values()"
"(f_0"
" #f"
"(let-values(((ht_0) s_1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" k_0"
"(loop_0"
" #f"
" v_0"
" seen_1)))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
"(hash-iterate-first ht_0))))))"
"(let-values()"
"(f_0"
" #f"
"(let-values(((ht_0) s_1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" k_0"
"(loop_0"
" #f"
" v_0"
" seen_1)))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first ht_0)))))))))"
"(let-values()(f_0 #f s_1)))))))))))))))"
" loop_0)"
" tail?_0"
" s_0"
" seen_0))))"
"(define-values"
"(datum-has-elements?)"
"(lambda(d_0)"
"(begin"
"(let-values(((or-part_0)(pair? d_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(vector? d_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(box? d_0)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(immutable-prefab-struct-key d_0)))"
"(if or-part_3"
" or-part_3"
"(if(hash? d_0)(if(immutable? d_0)(positive?(hash-count d_0)) #f) #f))))))))))))"
"(define-values"
"(struct:preserved-property-value"
" preserved-property-value1.1"
" preserved-property-value?"
" preserved-property-value-content)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'preserved-property-value"
" #f"
" 1"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'preserved-property-value)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'content))))"
"(define-values"
"(plain-property-value)"
"(lambda(v_0)(begin(if(preserved-property-value? v_0)(preserved-property-value-content v_0) v_0))))"
"(define-values"
"(check-value-to-preserve)"
"(lambda(v_0 syntax?_0)"
"(begin"
"(let-values(((check-preserve_0)"
"(lambda(tail?_0 v_1)"
"(begin"
" 'check-preserve"
"(begin"
"(if(let-values(((or-part_0)(null? v_1)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(boolean? v_1)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(symbol? v_1)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(number? v_1)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(char? v_1)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(string? v_1)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(bytes? v_1)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(regexp? v_1)))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(syntax?_0 v_1)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(pair? v_1)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(vector? v_1)))"
"(if or-part_10"
" or-part_10"
"(let-values(((or-part_11)(box? v_1)))"
"(if or-part_11"
" or-part_11"
"(let-values(((or-part_12)(hash? v_1)))"
"(if or-part_12"
" or-part_12"
"(immutable-prefab-struct-key"
" v_1)))))))))))))))))))))))))))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'write"
"                               \"disallowed value in preserved syntax property\""
"                               \"value\""
" v_1)))"
" v_1)))))"
"(let-values(((s_0) v_0)((f_0) check-preserve_0)((gf_0) check-preserve_0)((seen_0) disallow-cycles$1))"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 s_1 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_0(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow tail?_0 s_1(lambda(tail?_1 s_2)(gf_0 tail?_1 s_2)) seen_0))"
"(if(null? s_1)"
"(let-values()(f_0 tail?_0 s_1))"
"(if(pair? s_1)"
"(let-values()"
"(f_0"
" tail?_0"
"(cons(loop_0 #f(car s_1) depth_0)(loop_0 #t(cdr s_1) depth_0))))"
"(if(symbol? s_1)"
"(let-values()(f_0 #f s_1))"
"(if(boolean? s_1)"
"(let-values()(f_0 #f s_1))"
"(if(number? s_1)"
"(let-values()(f_0 #f s_1))"
"(if(let-values(((or-part_0)(vector? s_1)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(box? s_1)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(prefab-struct-key s_1)))"
"(if or-part_2 or-part_2(hash? s_1)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_1"
"(lambda(tail?_1 s_2)(gf_0 tail?_1 s_2))"
" seen_0))"
"(let-values()(gf_0 #f s_1))))))))))))))"
" loop_0)"
" #f"
" s_0"
" 0))))))"
"(define-values"
"(disallow-cycles$1)"
"(hash"
" 'cycle-fail"
"   (lambda (v_0) (raise-arguments-error 'write \"disallowed cycle in preserved syntax property\" \"at\" v_0))))"
"(define-values"
"(tamper?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(not v_0)))"
"(if or-part_0 or-part_0(let-values(((or-part_1)(symbol? v_0)))(if or-part_1 or-part_1(set? v_0))))))))"
"(define-values(tamper-tainted?)(lambda(v_0)(begin(symbol? v_0))))"
"(define-values(tamper-armed?)(lambda(v_0)(begin(set? v_0))))"
"(define-values(tamper-clean?)(lambda(v_0)(begin(not v_0))))"
"(define-values"
"(tamper-tainted-for-content)"
"(lambda(v_0)(begin(if(datum-has-elements? v_0) 'tainted/need-propagate 'tainted))))"
"(define-values(tamper-needs-propagate?)(lambda(t_0)(begin(eq? t_0 'tainted/need-propagate))))"
"(define-values(tamper-propagated)(lambda(t_0)(begin(if(eq? t_0 'tainted/need-propagate) 'tainted t_0))))"
"(define-values(serialize-tamper)(lambda(t_0)(begin(if(tamper-armed? t_0) 'armed t_0))))"
"(define-values(current-arm-inspectors)(make-parameter(seteq)))"
"(define-values(deserialize-tamper)(lambda(t_0)(begin(if(eq? t_0 'armed)(current-arm-inspectors) t_0))))"
"(define-values"
"(struct:syntax"
" syntax1.1"
" syntax?$1"
" syntax-content"
" syntax-scopes"
" syntax-shifted-multi-scopes"
" syntax-scope-propagations+tamper"
" syntax-mpi-shifts"
" syntax-srcloc"
" syntax-props"
" syntax-inspector"
" set-syntax-content!"
" set-syntax-scope-propagations+tamper!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'syntax"
" #f"
" 8"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:reach-scopes"
"(lambda(s_0 reach_0)"
"(let-values(((prop_0)(syntax-scope-propagations+tamper s_0)))"
"(begin"
"(reach_0(if(propagation?$1 prop_0)((propagation-ref prop_0) s_0)(syntax-content s_0)))"
"(reach_0(syntax-scopes s_0))"
"(reach_0(syntax-shifted-multi-scopes s_0))"
"(let-values(((ht_0)(syntax-props s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values()"
"(if(preserved-property-value? v_0)"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(reach_0"
"(plain-property-value"
" v_0)))"
"(values)))))"
"(values)))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(unsafe-immutable-hash-iterate-first ht_0))))"
"(void)"
"(reach_0(syntax-srcloc s_0))))))"
"(cons"
" prop:serialize"
"(lambda(s_0 ser-push!_0 state_0)"
"(let-values(((prop_0)(syntax-scope-propagations+tamper s_0)))"
"(let-values(((content_0)"
"(if(propagation?$1 prop_0)"
"((propagation-ref prop_0) s_0)"
"(syntax-content s_0))))"
"(let-values(((properties_0)"
"(intern-properties"
"(syntax-props s_0)"
"(lambda()"
"(let-values(((ht_0)(syntax-props s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(if(preserved-property-value?"
" v_0)"
"(let-values(((table_2)"
" table_1))"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" k_0"
"(check-value-to-preserve"
"(plain-property-value"
" v_0)"
" syntax?$1)))))"
"(hash-set"
" table_2"
" key_0"
" val_0)))))"
"(values table_3)))"
" table_1))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first ht_0)))))"
" state_0)))"
"(let-values(((tamper_0)(serialize-tamper(syntax-tamper s_0))))"
"(let-values(((context-triple_0)"
"(intern-context-triple"
"(intern-scopes(syntax-scopes s_0) state_0)"
"(intern-shifted-multi-scopes(syntax-shifted-multi-scopes s_0) state_0)"
"(intern-mpi-shifts(syntax-mpi-shifts s_0) state_0)"
" state_0)))"
"(let-values(((stx-state_0)(get-syntax-context state_0)))"
"(if(let-values(((or-part_0) properties_0))(if or-part_0 or-part_0 tamper_0))"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:syntax+props)"
"(push-syntax-context! state_0 #f)"
"(ser-push!_0 content_0)"
"(pop-syntax-context! state_0)"
"(ser-push!_0 'reference context-triple_0)"
"(ser-push!_0 'reference(syntax-srcloc s_0))"
"(ser-push!_0 properties_0)"
"(ser-push!_0 tamper_0)"
"(if stx-state_0"
"(let-values()(set-syntax-state-all-sharing?! stx-state_0 #f))"
"(void))))"
"(let-values()"
"(let-values(((sharing-mode_0)"
"(hash-ref"
"(serialize-state-sharing-syntaxes state_0)"
" s_0"
" 'unknown)))"
"(begin"
"(if(eq? sharing-mode_0 'share)"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:datum->syntax)"
"(ser-push!_0(syntax->datum$1 s_0))))"
"(if(eq? sharing-mode_0 'unknown)"
"(let-values()"
"(let-values((()(begin(ser-push!_0 'tag '#:syntax)(values))))"
"(let-values(((this-state_0)"
"(if(no-pair-syntax-in-cdr? content_0)"
"(syntax-state17.1"
" #t"
" context-triple_0"
"(syntax-srcloc s_0))"
" #f)))"
"(let-values((()"
"(begin"
"(push-syntax-context! state_0 this-state_0)"
"(values))))"
"(let-values((()(begin(ser-push!_0 content_0)(values))))"
"(let-values((()"
"(begin"
"(pop-syntax-context! state_0)"
"(values))))"
"(let-values(((new-sharing-mode_0)"
"(if(if this-state_0"
"(syntax-state-all-sharing?"
" this-state_0)"
" #f)"
" 'share"
" 'none)))"
"(begin"
"(hash-set!"
"(serialize-state-sharing-syntaxes state_0)"
" s_0"
"(if(datum-has-elements? content_0)"
" new-sharing-mode_0"
" 'none))"
"(if(if stx-state_0(eq? new-sharing-mode_0 'none) #f)"
"(let-values()"
"(set-syntax-state-all-sharing?! stx-state_0 #f))"
"(void))))))))))"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:syntax)"
"(push-syntax-context! state_0 #f)"
"(ser-push!_0 content_0)"
"(pop-syntax-context! state_0)))))"
"(ser-push!_0 'reference context-triple_0)"
"(ser-push!_0 'reference(syntax-srcloc s_0))"
"(if stx-state_0"
"(let-values()"
"(if(if(eq?"
" context-triple_0"
"(syntax-state-context-triple stx-state_0))"
"(equal?(syntax-srcloc s_0)(syntax-state-srcloc stx-state_0))"
" #f)"
"(void)"
"(let-values()(set-syntax-state-all-sharing?! stx-state_0 #f))))"
"(void))))))))))))))"
"(cons"
" prop:custom-write"
"(lambda(s_0 port_0 mode_0)"
"                         (let-values ((() (begin (write-string \"#<syntax\" port_0) (values))))"
"(let-values(((srcloc_0)(syntax-srcloc s_0)))"
"(begin"
"(if srcloc_0"
"(let-values()"
"(let-values(((srcloc-str_0)(srcloc->string srcloc_0)))"
"                                     (if srcloc-str_0 (let-values () (fprintf port_0 \":~a\" srcloc-str_0)) (void))))"
"(void))"
"                               (fprintf port_0 \" ~.s\" (syntax->datum$1 s_0))"
"                               (write-string \">\" port_0)))))))"
"(current-inspector)"
" #f"
" '(1 2 4 5 6 7)"
" #f"
" 'syntax)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'content)"
"(make-struct-field-accessor -ref_0 1 'scopes)"
"(make-struct-field-accessor -ref_0 2 'shifted-multi-scopes)"
"(make-struct-field-accessor -ref_0 3 'scope-propagations+tamper)"
"(make-struct-field-accessor -ref_0 4 'mpi-shifts)"
"(make-struct-field-accessor -ref_0 5 'srcloc)"
"(make-struct-field-accessor -ref_0 6 'props)"
"(make-struct-field-accessor -ref_0 7 'inspector)"
"(make-struct-field-mutator -set!_0 0 'content)"
"(make-struct-field-mutator -set!_0 3 'scope-propagations+tamper))))"
"(define-values(prop:propagation propagation?$1 propagation-ref)(make-struct-type-property 'propagation))"
"(define-values"
"(prop:propagation-tamper propagation-tamper? propagation-tamper-ref)"
"(make-struct-type-property 'propagation-tamper))"
"(define-values"
"(prop:propagation-set-tamper propagation-set-tamper? propagation-set-tamper-ref)"
"(make-struct-type-property 'propagation-set-tamper))"
"(define-values"
"(syntax-tamper)"
"(lambda(s_0)"
"(begin"
"(let-values(((v_0)(syntax-scope-propagations+tamper s_0)))"
"(if(tamper? v_0) v_0((propagation-tamper-ref v_0) v_0))))))"
"(define-values(empty-scopes)(seteq))"
"(define-values(empty-shifted-multi-scopes)(seteq))"
"(define-values(empty-mpi-shifts) null)"
"(define-values(empty-props) '#hasheq())"
"(define-values"
"(empty-syntax)"
"(syntax1.1 #f empty-scopes empty-shifted-multi-scopes #f empty-mpi-shifts #f empty-props #f))"
"(define-values(identifier?)(lambda(s_0)(begin(if(syntax?$1 s_0)(symbol?(syntax-content s_0)) #f))))"
"(define-values(syntax-identifier?)(lambda(s_0)(begin(symbol?(syntax-content s_0)))))"
"(define-values"
"(syntax->datum$1)"
"(lambda(s_0)"
"(begin"
" 'syntax->datum"
"(let-values(((s_1) s_0)"
"((f_0)(lambda(tail?_0 x_0)(begin 'f x_0)))"
"((d->s_0)(lambda(s_1 d_0)(begin 'd->s d_0)))"
"((s-e_0) syntax-content)"
"((seen_0) #f))"
"((letrec-values(((loop_0)"
"(lambda(s_2)"
"(begin"
" 'loop"
"(let-values(((s_3) s_2)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(d->s_0 v_0(loop_0(s-e_0 v_0))))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0))"
"((letrec-values(((loop_1)"
"(lambda(tail?_0 s_4 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1))"
"(if(null? s_4)"
"(let-values()(f_1 tail?_0 s_4))"
"(if(pair? s_4)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_1 #f(car s_4) depth_0)"
"(loop_1 #t(cdr s_4) depth_0))))"
"(if(symbol? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(boolean? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(number? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(let-values(((or-part_0)(vector? s_4)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(box? s_4)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key s_4)))"
"(if or-part_2"
" or-part_2"
"(hash? s_4)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1))"
"(let-values()(gf_0 #f s_4))))))))))))))"
" loop_1)"
" #f"
" s_3"
" 0))))))"
" loop_0)"
" s_1)))))"
"(define-values"
"(datum->syntax$1)"
"(let-values(((datum->syntax6_0)"
"(lambda(stx-c4_0 s5_0 stx-l2_0 stx-p3_0)"
"(begin"
" 'datum->syntax6"
"(let-values(((stx-c_0) stx-c4_0))"
"(let-values(((s_0) s5_0))"
"(let-values(((stx-l_0) stx-l2_0))"
"(let-values(((stx-p_0) stx-p3_0))"
"(let-values()"
"(if(syntax?$1 s_0)"
"(let-values() s_0)"
"(let-values()"
"(let-values(((wrap_0)"
"(lambda(content_0)"
"(begin"
" 'wrap"
"(syntax1.1"
" content_0"
"(if stx-c_0(syntax-scopes stx-c_0) empty-scopes)"
"(if stx-c_0"
"(syntax-shifted-multi-scopes stx-c_0)"
" empty-shifted-multi-scopes)"
"(if stx-c_0"
"(if(syntax-tamper stx-c_0)"
"(tamper-tainted-for-content content_0)"
" #f)"
" #f)"
"(if stx-c_0(syntax-mpi-shifts stx-c_0) empty-mpi-shifts)"
"(if stx-l_0(syntax-srcloc stx-l_0) #f)"
" empty-props"
"(if stx-c_0(syntax-inspector stx-c_0) #f))))))"
"(let-values(((result-s_0)"
"(let-values(((s_1) s_0)"
"((f_0)"
"(lambda(tail?_0 x_0)"
"(begin 'f(if tail?_0 x_0(wrap_0 x_0)))))"
"((s->_0)(lambda(s_1)(begin 's-> s_1)))"
"((seen_0) disallow-cycles))"
"(let-values(((s_2) s_1)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(s->_0 v_0))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0))"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 s_3 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)"
"(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_3"
"(lambda(tail?_1 s_4)"
"(gf_0 tail?_1 s_4))"
" seen_1))"
"(if(null? s_3)"
"(let-values()(f_1 tail?_0 s_3))"
"(if(pair? s_3)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_0 #f(car s_3) depth_0)"
"(loop_0 #t(cdr s_3) depth_0))))"
"(if(symbol? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(boolean? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(number? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(let-values(((or-part_0)"
"(vector?"
" s_3)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(box?"
" s_3)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_3)))"
"(if or-part_2"
" or-part_2"
"(hash?"
" s_3)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_3"
"(lambda(tail?_1 s_4)"
"(gf_0 tail?_1 s_4))"
" seen_1))"
"(let-values()"
"(gf_0 #f s_3))))))))))))))"
" loop_0)"
" #f"
" s_2"
" 0)))))"
"(if(if stx-p_0(not(eq?(syntax-props stx-p_0) empty-props)) #f)"
"(let-values(((the-struct_0) result-s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props19_0)(syntax-props stx-p_0)))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
" props19_0"
"(syntax-inspector the-struct_0)))"
"                                            (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
" result-s_0))))))))))))))"
"(case-lambda"
"((stx-c_0 s_0)(begin 'datum->syntax(datum->syntax6_0 stx-c_0 s_0 #f #f)))"
"((stx-c_0 s_0 stx-l_0 stx-p3_0)(datum->syntax6_0 stx-c_0 s_0 stx-l_0 stx-p3_0))"
"((stx-c_0 s_0 stx-l2_0)(datum->syntax6_0 stx-c_0 s_0 stx-l2_0 #f)))))"
"(define-values"
"(disallow-cycles)"
"(hasheq"
" 'cycle-fail"
"   (lambda (s_0) (raise-arguments-error 'datum->syntax \"cannot create syntax from cyclic datum\" \"datum\" s_0))))"
"(define-values"
"(struct:syntax-state"
" syntax-state17.1"
" syntax-state?"
" syntax-state-all-sharing?"
" syntax-state-context-triple"
" syntax-state-srcloc"
" set-syntax-state-all-sharing?!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'syntax-state #f 3 0 #f null(current-inspector) #f '(1 2) #f 'syntax-state)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'all-sharing?)"
"(make-struct-field-accessor -ref_0 1 'context-triple)"
"(make-struct-field-accessor -ref_0 2 'srcloc)"
"(make-struct-field-mutator -set!_0 0 'all-sharing?))))"
"(define-values"
"(no-pair-syntax-in-cdr?)"
"(lambda(content_0)"
"(begin"
"(if(pair? content_0)"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(content_1)"
"(begin"
" 'loop"
"(if(if(syntax?$1 content_1)(pair?(syntax-content content_1)) #f)"
"(let-values() #f)"
"(if(pair? content_1)"
"(let-values()(loop_0(cdr content_1)))"
"(let-values() #t)))))))"
" loop_0)"
"(cdr content_0)))"
"(let-values() #t)))))"
"(define-values"
"(deserialize-syntax)"
"(lambda(content_0 context-triple_0 srcloc_0 props_0 tamper_0 inspector_0)"
"(begin"
"(syntax1.1"
" content_0"
"(vector*-ref context-triple_0 0)"
"(vector*-ref context-triple_0 1)"
"(deserialize-tamper tamper_0)"
"(vector*-ref context-triple_0 2)"
" srcloc_0"
"(if props_0"
"(let-values(((ht_0) props_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" k_0"
"(preserved-property-value1.1"
" v_0)))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(unsafe-immutable-hash-iterate-first ht_0))))"
" empty-props)"
" inspector_0))))"
"(define-values"
"(deserialize-datum->syntax)"
"(lambda(content_0 context-triple_0 srcloc_0 inspector_0)"
"(begin"
"(let-values(((s_0)(deserialize-syntax #f context-triple_0 srcloc_0 #f #f inspector_0)))"
"(datum->syntax$1 s_0 content_0 s_0 s_0)))))"
"(define-values"
"(struct:full-binding full-binding1.1 full-binding? full-binding-frame-id full-binding-free=id)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'full-binding"
" #f"
" 2"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons prop:binding-reach-scopes(lambda(b_0)(binding-free=id b_0))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'full-binding)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'frame-id)"
"(make-struct-field-accessor -ref_0 1 'free=id))))"
"(define-values(binding-frame-id)(lambda(b_0)(begin(if(full-binding? b_0)(full-binding-frame-id b_0) #f))))"
"(define-values(binding-free=id)(lambda(b_0)(begin(if(full-binding? b_0)(full-binding-free=id b_0) #f))))"
"(define-values"
"(make-module-binding20.1)"
"(lambda(extra-inspector7_0"
" extra-nominal-bindings8_0"
" frame-id5_0"
" free=id6_0"
" nominal-module1_0"
" nominal-phase2_0"
" nominal-require-phase4_0"
" nominal-sym3_0"
" module17_0"
" phase18_0"
" sym19_0)"
"(begin"
" 'make-module-binding20"
"(let-values(((module_0) module17_0))"
"(let-values(((phase_0) phase18_0))"
"(let-values(((sym_0) sym19_0))"
"(let-values(((nominal-module_0)(if(eq? nominal-module1_0 unsafe-undefined) module_0 nominal-module1_0)))"
"(let-values(((nominal-phase_0)(if(eq? nominal-phase2_0 unsafe-undefined) phase_0 nominal-phase2_0)))"
"(let-values(((nominal-sym_0)(if(eq? nominal-sym3_0 unsafe-undefined) sym_0 nominal-sym3_0)))"
"(let-values(((nominal-require-phase_0) nominal-require-phase4_0))"
"(let-values(((frame-id_0) frame-id5_0))"
"(let-values(((free=id_0) free=id6_0))"
"(let-values(((extra-inspector_0) extra-inspector7_0))"
"(let-values(((extra-nominal-bindings_0) extra-nominal-bindings8_0))"
"(let-values()"
"(if(let-values(((or-part_0) frame-id_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1) free=id_0))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2) extra-inspector_0))"
"(if or-part_2"
" or-part_2"
"(not"
"(if(eqv? nominal-phase_0 phase_0)"
"(if(eq? nominal-sym_0 sym_0)"
"(if(eqv? nominal-require-phase_0 0)"
"(null? extra-nominal-bindings_0)"
" #f)"
" #f)"
" #f))))))))"
"(let-values()"
"(full-module-binding49.1"
" frame-id_0"
" free=id_0"
" module_0"
" phase_0"
" sym_0"
" nominal-module_0"
" nominal-phase_0"
" nominal-sym_0"
" nominal-require-phase_0"
" extra-inspector_0"
" extra-nominal-bindings_0))"
"(let-values()"
"(simple-module-binding50.1 module_0 phase_0 sym_0 nominal-module_0))))))))))))))))))"
"(define-values"
"(module-binding-update46.1)"
"(lambda(extra-inspector32_0"
" extra-nominal-bindings33_0"
" frame-id30_0"
" free=id31_0"
" module23_0"
" nominal-module26_0"
" nominal-phase27_0"
" nominal-require-phase29_0"
" nominal-sym28_0"
" phase24_0"
" sym25_0"
" b45_0)"
"(begin"
" 'module-binding-update46"
"(let-values(((b_0) b45_0))"
"(let-values(((module_0)(if(eq? module23_0 unsafe-undefined)(module-binding-module b_0) module23_0)))"
"(let-values(((phase_0)(if(eq? phase24_0 unsafe-undefined)(module-binding-phase b_0) phase24_0)))"
"(let-values(((sym_0)(if(eq? sym25_0 unsafe-undefined)(module-binding-sym b_0) sym25_0)))"
"(let-values(((nominal-module_0)"
"(if(eq? nominal-module26_0 unsafe-undefined)"
"(module-binding-nominal-module b_0)"
" nominal-module26_0)))"
"(let-values(((nominal-phase_0)"
"(if(eq? nominal-phase27_0 unsafe-undefined)"
"(module-binding-nominal-phase b_0)"
" nominal-phase27_0)))"
"(let-values(((nominal-sym_0)"
"(if(eq? nominal-sym28_0 unsafe-undefined)"
"(module-binding-nominal-sym b_0)"
" nominal-sym28_0)))"
"(let-values(((nominal-require-phase_0)"
"(if(eq? nominal-require-phase29_0 unsafe-undefined)"
"(module-binding-nominal-require-phase b_0)"
" nominal-require-phase29_0)))"
"(let-values(((frame-id_0)"
"(if(eq? frame-id30_0 unsafe-undefined)(binding-frame-id b_0) frame-id30_0)))"
"(let-values(((free=id_0)"
"(if(eq? free=id31_0 unsafe-undefined)(binding-free=id b_0) free=id31_0)))"
"(let-values(((extra-inspector_0)"
"(if(eq? extra-inspector32_0 unsafe-undefined)"
"(module-binding-extra-inspector b_0)"
" extra-inspector32_0)))"
"(let-values(((extra-nominal-bindings_0)"
"(if(eq? extra-nominal-bindings33_0 unsafe-undefined)"
"(module-binding-extra-nominal-bindings b_0)"
" extra-nominal-bindings33_0)))"
"(let-values()"
"(let-values(((module51_0) module_0)"
"((phase52_0) phase_0)"
"((sym53_0) sym_0)"
"((nominal-module54_0) nominal-module_0)"
"((nominal-phase55_0) nominal-phase_0)"
"((nominal-sym56_0) nominal-sym_0)"
"((nominal-require-phase57_0) nominal-require-phase_0)"
"((frame-id58_0) frame-id_0)"
"((free=id59_0) free=id_0)"
"((extra-inspector60_0) extra-inspector_0)"
"((extra-nominal-bindings61_0) extra-nominal-bindings_0))"
"(make-module-binding20.1"
" extra-inspector60_0"
" extra-nominal-bindings61_0"
" frame-id58_0"
" free=id59_0"
" nominal-module54_0"
" nominal-phase55_0"
" nominal-require-phase57_0"
" nominal-sym56_0"
" module51_0"
" phase52_0"
" sym53_0))))))))))))))))))"
"(define-values"
"(module-binding?)"
"(lambda(b_0)"
"(begin"
"(let-values(((or-part_0)(simple-module-binding? b_0)))(if or-part_0 or-part_0(full-module-binding? b_0))))))"
"(define-values"
"(struct:full-module-binding"
" full-module-binding49.1"
" full-module-binding?"
" full-module-binding-module"
" full-module-binding-phase"
" full-module-binding-sym"
" full-module-binding-nominal-module"
" full-module-binding-nominal-phase"
" full-module-binding-nominal-sym"
" full-module-binding-nominal-require-phase"
" full-module-binding-extra-inspector"
" full-module-binding-extra-nominal-bindings)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'full-module-binding"
" struct:full-binding"
" 9"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(b_0 ser-push!_0 state_0)"
"(let-values(((simplified-b_0)"
"(if(full-binding-frame-id b_0)"
"(let-values(((b63_0) b_0)((temp64_0) #f))"
"(module-binding-update46.1"
" unsafe-undefined"
" unsafe-undefined"
" temp64_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" b63_0))"
" b_0)))"
"(if(full-module-binding? simplified-b_0)"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:module-binding)"
"(ser-push!_0(full-module-binding-module b_0))"
"(ser-push!_0(full-module-binding-sym b_0))"
"(ser-push!_0(full-module-binding-phase b_0))"
"(ser-push!_0(full-module-binding-nominal-module b_0))"
"(ser-push!_0(full-module-binding-nominal-phase b_0))"
"(ser-push!_0(full-module-binding-nominal-sym b_0))"
"(ser-push!_0(full-module-binding-nominal-require-phase b_0))"
"(ser-push!_0(full-binding-free=id b_0))"
"(if(full-module-binding-extra-inspector b_0)"
"(ser-push!_0 'tag '#:inspector)"
"(ser-push!_0 #f))"
"(ser-push!_0(full-module-binding-extra-nominal-bindings b_0))))"
"(let-values()(ser-push!_0 simplified-b_0)))))))"
" #f"
" #f"
" '(0 1 2 3 4 5 6 7 8)"
" #f"
" 'full-module-binding)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'module)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'sym)"
"(make-struct-field-accessor -ref_0 3 'nominal-module)"
"(make-struct-field-accessor -ref_0 4 'nominal-phase)"
"(make-struct-field-accessor -ref_0 5 'nominal-sym)"
"(make-struct-field-accessor -ref_0 6 'nominal-require-phase)"
"(make-struct-field-accessor -ref_0 7 'extra-inspector)"
"(make-struct-field-accessor -ref_0 8 'extra-nominal-bindings))))"
"(define-values"
"(struct:simple-module-binding"
" simple-module-binding50.1"
" simple-module-binding?"
" simple-module-binding-module"
" simple-module-binding-phase"
" simple-module-binding-sym"
" simple-module-binding-nominal-module)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'simple-module-binding"
" #f"
" 4"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(b_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:simple-module-binding)"
"(ser-push!_0(simple-module-binding-module b_0))"
"(ser-push!_0(simple-module-binding-sym b_0))"
"(ser-push!_0(simple-module-binding-phase b_0))"
"(ser-push!_0(simple-module-binding-nominal-module b_0))))))"
" #f"
" #f"
" '(0 1 2 3)"
" #f"
" 'simple-module-binding)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'module)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'sym)"
"(make-struct-field-accessor -ref_0 3 'nominal-module))))"
"(define-values"
"(deserialize-full-module-binding)"
"(lambda(module_0"
" sym_0"
" phase_0"
" nominal-module_0"
" nominal-phase_0"
" nominal-sym_0"
" nominal-require-phase_0"
" free=id_0"
" extra-inspector_0"
" extra-nominal-bindings_0)"
"(begin"
"(let-values(((module66_0) module_0)"
"((phase67_0) phase_0)"
"((sym68_0) sym_0)"
"((nominal-module69_0) nominal-module_0)"
"((nominal-phase70_0) nominal-phase_0)"
"((nominal-sym71_0) nominal-sym_0)"
"((nominal-require-phase72_0) nominal-require-phase_0)"
"((free=id73_0) free=id_0)"
"((extra-inspector74_0) extra-inspector_0)"
"((extra-nominal-bindings75_0) extra-nominal-bindings_0))"
"(make-module-binding20.1"
" extra-inspector74_0"
" extra-nominal-bindings75_0"
" #f"
" free=id73_0"
" nominal-module69_0"
" nominal-phase70_0"
" nominal-require-phase72_0"
" nominal-sym71_0"
" module66_0"
" phase67_0"
" sym68_0)))))"
"(define-values"
"(deserialize-simple-module-binding)"
"(lambda(module_0 sym_0 phase_0 nominal-module_0)"
"(begin(simple-module-binding50.1 module_0 phase_0 sym_0 nominal-module_0))))"
"(define-values"
"(module-binding-module)"
"(lambda(b_0)"
"(begin(if(simple-module-binding? b_0)(simple-module-binding-module b_0)(full-module-binding-module b_0)))))"
"(define-values"
"(module-binding-phase)"
"(lambda(b_0)"
"(begin(if(simple-module-binding? b_0)(simple-module-binding-phase b_0)(full-module-binding-phase b_0)))))"
"(define-values"
"(module-binding-sym)"
"(lambda(b_0)"
"(begin(if(simple-module-binding? b_0)(simple-module-binding-sym b_0)(full-module-binding-sym b_0)))))"
"(define-values"
"(module-binding-nominal-module)"
"(lambda(b_0)"
"(begin"
"(if(simple-module-binding? b_0)"
"(simple-module-binding-nominal-module b_0)"
"(full-module-binding-nominal-module b_0)))))"
"(define-values"
"(module-binding-nominal-phase)"
"(lambda(b_0)"
"(begin"
"(if(simple-module-binding? b_0)(simple-module-binding-phase b_0)(full-module-binding-nominal-phase b_0)))))"
"(define-values"
"(module-binding-nominal-sym)"
"(lambda(b_0)"
"(begin(if(simple-module-binding? b_0)(simple-module-binding-sym b_0)(full-module-binding-nominal-sym b_0)))))"
"(define-values"
"(module-binding-nominal-require-phase)"
"(lambda(b_0)(begin(if(simple-module-binding? b_0) 0(full-module-binding-nominal-require-phase b_0)))))"
"(define-values"
"(module-binding-extra-inspector)"
"(lambda(b_0)(begin(if(simple-module-binding? b_0) #f(full-module-binding-extra-inspector b_0)))))"
"(define-values"
"(module-binding-extra-nominal-bindings)"
"(lambda(b_0)(begin(if(simple-module-binding? b_0) null(full-module-binding-extra-nominal-bindings b_0)))))"
"(define-values(empty-binding-table) '#hasheq())"
"(define-values"
"(struct:table-with-bulk-bindings"
" table-with-bulk-bindings1.1"
" table-with-bulk-bindings?"
" table-with-bulk-bindings-syms"
" table-with-bulk-bindings-syms/serialize"
" table-with-bulk-bindings-bulk-bindings)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'table-with-bulk-bindings"
" #f"
" 3"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(twbb_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:table-with-bulk-bindings)"
"(ser-push!_0(table-with-bulk-bindings-syms/serialize twbb_0))"
"(ser-push!_0(table-with-bulk-bindings-bulk-bindings twbb_0))))))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'table-with-bulk-bindings)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'syms)"
"(make-struct-field-accessor -ref_0 1 'syms/serialize)"
"(make-struct-field-accessor -ref_0 2 'bulk-bindings))))"
"(define-values"
"(deserialize-table-with-bulk-bindings)"
"(lambda(syms_0 bulk-bindings_0)(begin(table-with-bulk-bindings1.1 syms_0 syms_0 bulk-bindings_0))))"
"(define-values"
"(struct:bulk-binding-at bulk-binding-at2.1 bulk-binding-at? bulk-binding-at-scopes bulk-binding-at-bulk)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'bulk-binding-at"
" #f"
" 2"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"                      (cons prop:reach-scopes (lambda (sms_0 reach_0) (error \"shouldn't get here\")))"
"(cons"
" prop:serialize"
"(lambda(bba_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:bulk-binding-at)"
"(ser-push!_0(bulk-binding-at-scopes bba_0))"
"(ser-push!_0(bulk-binding-at-bulk bba_0))))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'bulk-binding-at)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'scopes)"
"(make-struct-field-accessor -ref_0 1 'bulk))))"
"(define-values(deserialize-bulk-binding-at)(lambda(scopes_0 bulk_0)(begin(bulk-binding-at2.1 scopes_0 bulk_0))))"
"(define-values(prop:bulk-binding bulk-binding?$1 bulk-binding-ref)(make-struct-type-property 'bulk-binding))"
"(define-values"
"(struct:bulk-binding-class"
" bulk-binding-class3.1"
" bulk-binding-class?"
" bulk-binding-class-get-symbols"
" bulk-binding-class-create)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'bulk-binding-class"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'bulk-binding-class)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'get-symbols)"
"(make-struct-field-accessor -ref_0 1 'create))))"
"(define-values"
"(bulk-binding-symbols)"
"(lambda(b_0 s_0 extra-shifts_0)"
"(begin"
"((bulk-binding-class-get-symbols(bulk-binding-ref b_0))"
" b_0"
"(append extra-shifts_0(if s_0(syntax-mpi-shifts s_0) null))))))"
"(define-values(bulk-binding-create)(lambda(b_0)(begin(bulk-binding-class-create(bulk-binding-ref b_0)))))"
"(define-values(binding-table-empty?)(lambda(bt_0)(begin(if(hash? bt_0)(zero?(hash-count bt_0)) #f))))"
"(define-values"
"(binding-table-add)"
"(lambda(bt_0 scopes_0 sym_0 binding_0 just-for-nominal?_0)"
"(begin"
"(if(hash? bt_0)"
"(let-values()(hash-set bt_0 sym_0(hash-set(hash-ref bt_0 sym_0 '#hash()) scopes_0 binding_0)))"
"(let-values()"
"(let-values(((new-syms_0)"
"(binding-table-add"
"(table-with-bulk-bindings-syms bt_0)"
" scopes_0"
" sym_0"
" binding_0"
" just-for-nominal?_0)))"
"(let-values(((new-syms/serialize_0)"
"(if just-for-nominal?_0"
"(let-values()(table-with-bulk-bindings-syms/serialize bt_0))"
"(if(eq?"
"(table-with-bulk-bindings-syms bt_0)"
"(table-with-bulk-bindings-syms/serialize bt_0))"
"(let-values() new-syms_0)"
"(let-values()"
"(binding-table-add"
"(table-with-bulk-bindings-syms/serialize bt_0)"
" scopes_0"
" sym_0"
" binding_0"
" #f))))))"
"(let-values(((the-struct_0) bt_0))"
"(if(table-with-bulk-bindings? the-struct_0)"
"(let-values(((syms32_0) new-syms_0)((syms/serialize33_0) new-syms/serialize_0))"
"(table-with-bulk-bindings1.1"
" syms32_0"
" syms/serialize33_0"
"(table-with-bulk-bindings-bulk-bindings the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"table-with-bulk-bindings?\" the-struct_0))))))))))"
"(define-values"
"(prop:implicitly-reachable implicitly-reachable? implicitly-reachable-ref)"
"(make-struct-type-property 'implicitly-reachable))"
"(define-values"
"(binding-table-add-bulk9.1)"
"(lambda(shadow-except4_0 bt6_0 scopes7_0 bulk8_0)"
"(begin"
" 'binding-table-add-bulk9"
"(let-values(((bt_0) bt6_0))"
"(let-values(((scopes_0) scopes7_0))"
"(let-values(((bulk_0) bulk8_0))"
"(let-values(((shadow-except_0) shadow-except4_0))"
"(let-values()"
"(if(table-with-bulk-bindings? bt_0)"
"(let-values()"
"(let-values(((new-syms_0)"
"(let-values(((temp34_0)(table-with-bulk-bindings-syms bt_0))"
"((scopes35_0) scopes_0)"
"((bulk36_0) bulk_0)"
"((shadow-except37_0) shadow-except_0))"
"(remove-matching-bindings17.1 shadow-except37_0 temp34_0 scopes35_0 bulk36_0))))"
"(let-values(((new-syms/serialize_0)"
"(if(eq?"
"(table-with-bulk-bindings-syms bt_0)"
"(table-with-bulk-bindings-syms/serialize bt_0))"
" new-syms_0"
"(let-values(((temp38_0)(table-with-bulk-bindings-syms/serialize bt_0))"
"((scopes39_0) scopes_0)"
"((bulk40_0) bulk_0)"
"((shadow-except41_0) shadow-except_0))"
"(remove-matching-bindings17.1"
" shadow-except41_0"
" temp38_0"
" scopes39_0"
" bulk40_0)))))"
"(table-with-bulk-bindings1.1"
" new-syms_0"
" new-syms/serialize_0"
"(cons(bulk-binding-at2.1 scopes_0 bulk_0)(table-with-bulk-bindings-bulk-bindings bt_0))))))"
"(let-values()"
"(let-values(((temp42_0)(table-with-bulk-bindings1.1 bt_0 bt_0 null))"
"((scopes43_0) scopes_0)"
"((bulk44_0) bulk_0))"
"(binding-table-add-bulk9.1 #f temp42_0 scopes43_0 bulk44_0))))))))))))"
"(define-values"
"(remove-matching-bindings17.1)"
"(lambda(except12_0 syms14_0 scopes15_0 bulk16_0)"
"(begin"
" 'remove-matching-bindings17"
"(let-values(((syms_0) syms14_0))"
"(let-values(((scopes_0) scopes15_0))"
"(let-values(((bulk_0) bulk16_0))"
"(let-values(((except_0) except12_0))"
"(let-values()"
"(let-values(((bulk-symbols_0)(bulk-binding-symbols bulk_0 #f null)))"
"(if(<(hash-count syms_0)(hash-count bulk-symbols_0))"
"(let-values()"
"(let-values(((ht_0) syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(syms_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 sym-bindings_0)"
"(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values(((syms_2)"
"(let-values(((syms_2) syms_1))"
"(let-values(((syms_3)"
"(let-values()"
"(if(hash-ref"
" bulk-symbols_0"
" sym_0"
" #f)"
"(let-values(((syms45_0) syms_2)"
"((sym46_0) sym_0)"
"((sym-bindings47_0)"
" sym-bindings_0)"
"((scopes48_0)"
" scopes_0)"
"((except49_0)"
" except_0))"
"(remove-matching-binding26.1"
" except49_0"
" syms45_0"
" sym46_0"
" sym-bindings47_0"
" scopes48_0))"
" syms_2))))"
"(values syms_3)))))"
"(if(not #f)"
"(for-loop_0"
" syms_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" syms_2)))"
" syms_1)))))"
" for-loop_0)"
" syms_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))"
"(let-values()"
"(let-values(((ht_0) bulk-symbols_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(syms_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((syms_2)"
"(let-values(((syms_2) syms_1))"
"(let-values(((syms_3)"
"(let-values()"
"(let-values(((sym-bindings_0)"
"(hash-ref"
" syms_2"
" sym_0"
" #f)))"
"(if sym-bindings_0"
"(let-values(((syms50_0) syms_2)"
"((sym51_0) sym_0)"
"((sym-bindings52_0)"
" sym-bindings_0)"
"((scopes53_0)"
" scopes_0)"
"((except54_0)"
" except_0))"
"(remove-matching-binding26.1"
" except54_0"
" syms50_0"
" sym51_0"
" sym-bindings52_0"
" scopes53_0))"
" syms_2)))))"
"(values syms_3)))))"
"(if(not #f)"
"(for-loop_0"
" syms_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" syms_2)))"
" syms_1)))))"
" for-loop_0)"
" syms_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))))))))))))"
"(define-values"
"(remove-matching-binding26.1)"
"(lambda(except20_0 syms22_0 sym23_0 sym-bindings24_0 scopes25_0)"
"(begin"
" 'remove-matching-binding26"
"(let-values(((syms_0) syms22_0))"
"(let-values(((sym_0) sym23_0))"
"(let-values(((sym-bindings_0) sym-bindings24_0))"
"(let-values(((scopes_0) scopes25_0))"
"(let-values(((except_0) except20_0))"
"(let-values()"
"(if(if except_0"
"(let-values(((b_0)(hash-ref sym-bindings_0 scopes_0 #f)))"
"(if(module-binding? b_0)(eq? except_0(module-binding-module b_0)) #f))"
" #f)"
"(let-values() syms_0)"
"(let-values()(hash-set syms_0 sym_0(hash-remove sym-bindings_0 scopes_0)))))))))))))"
"(define-values"
"(next-state-in-full-binding-table)"
"(lambda(sym-ht_0 sym-i_0)"
"(begin"
"(if sym-i_0"
"(let-values(((ht_0)(hash-iterate-value sym-ht_0 sym-i_0)))"
"(let-values(((i_0)(hash-iterate-first ht_0)))"
"(if i_0"
"(cons(vector sym-i_0(hash-iterate-key sym-ht_0 sym-i_0) ht_0) i_0)"
"(next-state-in-full-binding-table sym-ht_0(hash-iterate-next sym-ht_0 sym-i_0)))))"
" '(#f . #f)))))"
"(define-values"
"(binding-table-symbols)"
"(lambda(table_0 scs_0 s_0 extra-shifts_0)"
"(begin"
"(let-values(((ht_0 bulk-bindings_0)"
"(if(hash? table_0)"
"(values table_0 null)"
"(values"
"(table-with-bulk-bindings-syms table_0)"
"(table-with-bulk-bindings-bulk-bindings table_0)))))"
"(set-union"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 at-sym_0)(hash-iterate-key+value ht_1 i_0)))"
"(let-values(((table_2)"
"(let-values(((table_2) table_1))"
"(if(let-values(((ht_2) at-sym_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(result_0 i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((an-scs_0)"
"(hash-iterate-key"
" ht_2"
" i_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(subset?"
" an-scs_0"
" scs_0)))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
" result_1)"
" an-scs_0))"
"(not #f)"
" #f)"
"(for-loop_1"
" result_1"
"(hash-iterate-next"
" ht_2"
" i_1))"
" result_1)))"
" result_0)))))"
" for-loop_1)"
" #f"
"(hash-iterate-first ht_2))))"
"(let-values(((table_3) table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values() sym_0)"
" #t))))"
"(hash-set table_3 key_0 val_0)))))"
"(values table_4)))"
" table_2))))"
"(if(not #f)(for-loop_0 table_2(hash-iterate-next ht_1 i_0)) table_2)))"
" table_1)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first ht_1))))"
"(let-values(((lst_0) bulk-bindings_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((bba_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_2)"
"(let-values(((table_2) table_1))"
"(if(subset?(bulk-binding-at-scopes bba_0) scs_0)"
"(let-values(((ht_1)"
"(bulk-binding-symbols"
"(bulk-binding-at-bulk bba_0)"
" s_0"
" extra-shifts_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_3 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0)"
"(hash-iterate-key"
" ht_1"
" i_0)))"
"(let-values(((table_4)"
"(let-values(((table_4)"
" table_3))"
"(let-values(((table_5)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(let-values()"
" sym_0)"
" #t))))"
"(hash-set"
" table_4"
" key_0"
" val_0)))))"
"(values"
" table_5)))))"
"(if(not #f)"
"(for-loop_1"
" table_4"
"(hash-iterate-next"
" ht_1"
" i_0))"
" table_4)))"
" table_3)))))"
" for-loop_1)"
" table_2"
"(hash-iterate-first ht_1))))"
" table_2))))"
"(if(not #f)(for-loop_0 table_2 rest_0) table_2)))"
" table_1)))))"
" for-loop_0)"
" '#hasheq()"
" lst_0))))))))"
"(define-values"
"(binding-table-prune-to-reachable)"
"(lambda(bt_0 state_0)"
"(begin"
"(let-values(((or-part_0)(hash-ref(serialize-state-bindings-intern state_0) bt_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((reachable-scopes_0)(serialize-state-reachable-scopes state_0)))"
"(let-values(((new-syms_0)"
"(let-values(((ht_0)(if(hash? bt_0) bt_0(table-with-bulk-bindings-syms/serialize bt_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 bindings-for-sym_0)"
"(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((new-bindings-for-sym_0)"
"(let-values(((ht_1)"
" bindings-for-sym_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_1"
" i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((scopes_0"
" binding_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((table_2)"
"(let-values(((table_2)"
" table_1))"
"(if(subset?"
" scopes_0"
" reachable-scopes_0)"
"(let-values(((table_3)"
" table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(intern-scopes"
" scopes_0"
" state_0)"
" binding_0))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4)))"
" table_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" table_2"
"(unsafe-immutable-hash-iterate-next"
" ht_1"
" i_1))"
" table_2)))"
" table_1)))))"
" for-loop_1)"
" '#hash()"
"(unsafe-immutable-hash-iterate-first"
" ht_1))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(table_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((table_2)"
"(let-values(((table_2)"
" table_1))"
"(if(positive?"
"(hash-count"
" new-bindings-for-sym_0))"
"(let-values(((table_3)"
" table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" sym_0"
" new-bindings-for-sym_0))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4)))"
" table_2))))"
" table_2))))))"
" for-loop_1)"
" table_0)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(unsafe-immutable-hash-iterate-first ht_0))))))"
"(let-values(((new-bulk-bindings_0)"
"(if(hash? bt_0)"
" null"
"(reverse$1"
"(let-values(((lst_0)(table-with-bulk-bindings-bulk-bindings bt_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((bba_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(if(subset?"
"(bulk-binding-at-scopes bba_0)"
" reachable-scopes_0)"
"(let-values(((fold-var_2) fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((the-struct_0)"
" bba_0))"
"(if(bulk-binding-at?"
" the-struct_0)"
"(let-values(((scopes55_0)"
"(intern-scopes"
"(bulk-binding-at-scopes"
" bba_0)"
" state_0)))"
"(bulk-binding-at2.1"
" scopes55_0"
"(bulk-binding-at-bulk"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                         \"bulk-binding-at?\""
" the-struct_0))))"
" fold-var_2))))"
"(values fold-var_3)))"
" fold-var_1))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(let-values(((new-bt_0)"
"(if(pair? new-bulk-bindings_0)"
"(table-with-bulk-bindings1.1 new-syms_0 new-syms_0 new-bulk-bindings_0)"
" new-syms_0)))"
"(begin(hash-set!(serialize-state-bulk-bindings-intern state_0) bt_0 new-bt_0) new-bt_0))))))))))"
"(define-values"
"(binding-table-register-reachable)"
"(lambda(bt_0 get-reachable-scopes_0 reach_0 register-trigger_0)"
"(begin"
"(begin"
"(let-values(((ht_0)(if(hash? bt_0) bt_0(table-with-bulk-bindings-syms/serialize bt_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 bindings-for-sym_0)"
"(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values((()"
"(let-values(((ht_1) bindings-for-sym_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((scopes_0 binding_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((v_0)"
"(if(binding-reach-scopes?"
" binding_0)"
"((binding-reach-scopes-ref"
" binding_0)"
" binding_0)"
" #f)))"
"(scopes-register-reachable"
" scopes_0"
" v_0"
" get-reachable-scopes_0"
" reach_0"
" register-trigger_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_1"
"(unsafe-immutable-hash-iterate-next"
" ht_1"
" i_1))"
"(values))))"
"(values))))))"
" for-loop_1)"
"(unsafe-immutable-hash-iterate-first ht_1))))))"
"(if(not #f)"
"(for-loop_0(unsafe-immutable-hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(unsafe-immutable-hash-iterate-first ht_0))))"
"(void)"
"(if(table-with-bulk-bindings? bt_0)"
"(let-values()"
"(begin"
"(let-values(((lst_0)(table-with-bulk-bindings-bulk-bindings bt_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((bba_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(scopes-register-reachable"
"(bulk-binding-at-scopes bba_0)"
" #f"
" get-reachable-scopes_0"
" reach_0"
" register-trigger_0))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))"
"(void))))))"
"(define-values"
"(scopes-register-reachable)"
"(lambda(scopes_0 v_0 get-reachable-scopes_0 reach_0 register-trigger_0)"
"(begin"
"(let-values(((reachable-scopes_0)(get-reachable-scopes_0)))"
"(if(subset? scopes_0 reachable-scopes_0)"
"(let-values()(reach_0 v_0))"
"(let-values()"
"(let-values(((pending-scopes_0)"
"(let-values(((ht_0) scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(if(let-values(((or-part_0)"
"(set-member?"
" reachable-scopes_0"
" sc_0)))"
"(if or-part_0"
" or-part_0"
"(implicitly-reachable? sc_0)))"
" table_1"
"(let-values(((table_2) table_1))"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
" sc_0)"
" #t))))"
"(hash-set"
" table_2"
" key_0"
" val_0)))))"
"(values table_3)))))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(unsafe-immutable-hash-iterate-first ht_0))))))"
"(let-values(((check-trigger_0)"
"(lambda(reach_1)"
"(begin"
" 'check-trigger"
"(if(zero?(hash-count pending-scopes_0))"
"(let-values()"
"(begin"
"(reach_1 v_0)"
"(let-values(((ht_0) scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(implicitly-reachable?"
" sc_0)"
"(let-values()"
"(reach_1"
" sc_0))"
"(void)))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(unsafe-immutable-hash-iterate-first ht_0))))"
"(void)))"
"(void))))))"
"(begin"
"(let-values(((ht_0) pending-scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(register-trigger_0"
" sc_0"
"(lambda(reach_1)"
"(begin"
"(set! pending-scopes_0"
"(hash-remove"
" pending-scopes_0"
" sc_0))"
"(check-trigger_0 reach_1)))))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(unsafe-immutable-hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(unsafe-immutable-hash-iterate-first ht_0))))"
"(void)"
"(check-trigger_0 reach_0))))))))))"
"(define-values"
"(syntax-property$1)"
"(let-values()"
"(let-values()"
"(case-lambda"
"((s_0 key_0)"
"(begin"
" 'syntax-property"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                            (let-values () (raise-argument-error 'syntax-property \"syntax?\" s_0)))"
"(values))))"
"(let-values(((v_0)(hash-ref(syntax-props s_0) key_0 #f)))(plain-property-value v_0)))))"
"((s_0 key_0 val_0)"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                          (let-values () (raise-argument-error 'syntax-property \"syntax?\" s_0)))"
"(values))))"
"(let-values(((pval_0)(if(eq? key_0 'paren-shape)(preserved-property-value1.1 val_0) val_0)))"
"(let-values(((the-struct_0) s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props2_0)(hash-set(syntax-props s_0) key_0 pval_0)))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
" props2_0"
"(syntax-inspector the-struct_0)))"
"                (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"((s_0 key_0 val_0 preserved?_0)"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                          (let-values () (raise-argument-error 'syntax-property \"syntax?\" s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if preserved?_0"
"(let-values()"
"(if(if(symbol? key_0)(symbol-interned? key_0) #f)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'syntax-property"
"                                   \"key for a perserved property must be an interned symbol\""
"                                   \"given key\""
" key_0"
"                                   \"given value\""
" val_0))))"
"(void))"
"(values))))"
"(let-values(((pval_0)(if preserved?_0(preserved-property-value1.1 val_0) val_0)))"
"(let-values(((the-struct_0) s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props3_0)(hash-set(syntax-props s_0) key_0 pval_0)))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
" props3_0"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))))))))"
"(define-values"
"(1/syntax-property-preserved?)"
"(lambda(s_0 key_0)"
"(begin"
" 'syntax-property-preserved?"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-property-preserved? \"syntax?\" s_0)))"
"(if(if(symbol? key_0)(symbol-interned? key_0) #f)"
"(void)"
"(let-values()"
"                (raise-argument-error 'syntax-property-preserved? \"(and/c symbol? symbol-interned?)\" key_0)))"
"(preserved-property-value?(hash-ref(syntax-props s_0) key_0 #f))))))))"
"(define-values"
"(1/syntax-property-symbol-keys)"
"(lambda(s_0)"
"(begin"
" 'syntax-property-symbol-keys"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-property-symbol-keys \"syntax\" s_0)))"
"(reverse$1"
"(let-values(((ht_0)(syntax-props s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(if(if(symbol? k_0)(symbol-interned? k_0) #f)"
"(let-values(((fold-var_2) fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons(let-values() k_0) fold-var_2))))"
"(values fold-var_3)))"
" fold-var_1))))"
"(if(not #f)"
"(for-loop_0 fold-var_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(unsafe-immutable-hash-iterate-first ht_0)))))))))))"
"(define-values"
"(1/syntax-property-remove)"
"(lambda(s_0 key_0)"
"(begin"
" 'syntax-property-remove"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-property-remove \"syntax?\" s_0)))"
"(if(hash-ref(syntax-props s_0) key_0 #f)"
"(let-values(((the-struct_0) s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props7_0)(hash-remove(syntax-props s_0) key_0)))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
" props7_0"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
" s_0)))))))"
"(define-values"
"(taint-content)"
"(lambda(d_0)"
"(begin"
"(let-values(((s_0) d_0)"
"((f_0)(lambda(tail?_0 x_0)(begin 'f x_0)))"
"((s->_0)"
"(lambda(sub-s_0)"
"(begin"
" 's->"
"(if(tamper-tainted?(syntax-tamper sub-s_0))"
"(let-values() sub-s_0)"
"(let-values()"
"(let-values(((stx_0) sub-s_0))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scope-propagations+tamper5_0)"
"(let-values(((t_0)"
"(tamper-tainted-for-content(syntax-content sub-s_0)))"
"((p_0)(syntax-scope-propagations+tamper stx_0)))"
"(if(tamper? p_0) t_0((propagation-set-tamper-ref p_0) p_0 t_0)))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper5_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))))))"
"((seen_0) #f))"
"(let-values(((s_1) s_0)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin 'gf(if(syntax?$1 v_0)(let-values()(s->_0 v_0))(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0))"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 s_2 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow tail?_0 s_2(lambda(tail?_1 s_3)(gf_0 tail?_1 s_3)) seen_1))"
"(if(null? s_2)"
"(let-values()(f_1 tail?_0 s_2))"
"(if(pair? s_2)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons(loop_0 #f(car s_2) depth_0)(loop_0 #t(cdr s_2) depth_0))))"
"(if(symbol? s_2)"
"(let-values()(f_1 #f s_2))"
"(if(boolean? s_2)"
"(let-values()(f_1 #f s_2))"
"(if(number? s_2)"
"(let-values()(f_1 #f s_2))"
"(if(let-values(((or-part_0)(vector? s_2)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(box? s_2)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(prefab-struct-key s_2)))"
"(if or-part_2 or-part_2(hash? s_2)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_2"
"(lambda(tail?_1 s_3)(gf_0 tail?_1 s_3))"
" seen_1))"
"(let-values()(gf_0 #f s_2))))))))))))))"
" loop_0)"
" #f"
" s_1"
" 0))))))"
"(define-values(syntax-tainted?$1)(lambda(s_0)(begin 'syntax-tainted?(tamper-tainted?(syntax-tamper s_0)))))"
"(define-values(syntax-clean?)(lambda(s_0)(begin(tamper-clean?(syntax-tamper s_0)))))"
"(define-values"
"(syntax-arm$1)"
"(lambda(s_0 insp_0)"
"(begin"
" 'syntax-arm"
"(let-values(((t_0)(syntax-tamper s_0)))"
"(if(tamper-tainted? t_0)"
"(let-values() s_0)"
"(if(if t_0"
"(let-values(((or-part_0)(set-member? t_0 insp_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0) t_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((already-insp_0)"
"(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(inspector-superior-or-same?"
" already-insp_0"
" insp_0)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) already-insp_0))(not #f) #f)"
"(for-loop_0"
" result_1"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
"(unsafe-immutable-hash-iterate-first ht_0))))))"
" #f)"
"(let-values() s_0)"
"(let-values()"
"(let-values(((stx_0) s_0))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scope-propagations+tamper6_0)"
"(let-values(((t_1)(set-add(if t_0(remove-inferior t_0 insp_0)(seteq)) insp_0))"
"((p_0)(syntax-scope-propagations+tamper stx_0)))"
"(if(tamper? p_0) t_1((propagation-set-tamper-ref p_0) p_0 t_1)))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper6_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                    (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))))))))"
"(define-values"
"(remove-inferior)"
"(lambda(t_0 insp_0)"
"(begin"
"(let-values(((ht_0) t_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((already-insp_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(if(inspector-superior-or-same? insp_0 already-insp_0)"
" table_1"
"(let-values(((table_2) table_1))"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values() already-insp_0)"
" #t))))"
"(hash-set table_2 key_0 val_0)))))"
"(values table_3)))))))"
"(if(not #f)"
"(for-loop_0 table_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(define-values"
"(syntax-disarm$1)"
"(let-values(((syntax-disarm3_0)"
"(lambda(s2_0 insp1_0)"
"(begin"
" 'syntax-disarm3"
"(let-values(((s_0) s2_0))"
"(let-values(((insp_0) insp1_0))"
"(let-values()"
"(let-values(((t_0)(syntax-tamper s_0)))"
"(if(not(tamper-armed? t_0))"
"(let-values() s_0)"
"(if(not insp_0)"
"(let-values()"
"(let-values(((stx_0) s_0))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scope-propagations+tamper7_0)"
"(let-values(((t_1) #f)"
"((p_0)(syntax-scope-propagations+tamper stx_0)))"
"(if(tamper? p_0)"
" t_1"
"((propagation-set-tamper-ref p_0) p_0 t_1)))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper7_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                                        (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))"
"(let-values()"
"(let-values(((new-t_0)(remove-inferior t_0 insp_0)))"
"(let-values(((stx_0) s_0))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scope-propagations+tamper8_0)"
"(let-values(((t_1)(if(not(set-empty? new-t_0)) new-t_0 #f))"
"((p_0)(syntax-scope-propagations+tamper stx_0)))"
"(if(tamper? p_0)"
" t_1"
"((propagation-set-tamper-ref p_0) p_0 t_1)))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper8_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                                          (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))))))))))))"
"(case-lambda"
"((s_0)(begin 'syntax-disarm(syntax-disarm3_0 s_0 #f)))"
"((s_0 insp1_0)(syntax-disarm3_0 s_0 insp1_0)))))"
"(define-values"
"(syntax-rearm$1)"
"(lambda(s_0 from-s_0)"
"(begin"
" 'syntax-rearm"
"(let-values(((t_0)(syntax-tamper s_0)))"
"(if(tamper-tainted? t_0)"
"(let-values() s_0)"
"(let-values()"
"(let-values(((from-t_0)(syntax-tamper from-s_0)))"
"(if(tamper-clean? from-t_0)"
"(let-values() s_0)"
"(if(tamper-tainted? from-t_0)"
"(let-values()"
"(let-values(((stx_0) s_0))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scope-propagations+tamper9_0)"
"(let-values(((t_1)(tamper-tainted-for-content(syntax-content s_0)))"
"((p_0)(syntax-scope-propagations+tamper stx_0)))"
"(if(tamper? p_0) t_1((propagation-set-tamper-ref p_0) p_0 t_1)))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper9_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                          (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))"
"(if(tamper-clean? t_0)"
"(let-values()"
"(let-values(((stx_0) s_0))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scope-propagations+tamper10_0)"
"(let-values(((t_1) from-t_0)"
"((p_0)(syntax-scope-propagations+tamper stx_0)))"
"(if(tamper? p_0) t_1((propagation-set-tamper-ref p_0) p_0 t_1)))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper10_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                            (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))"
"(let-values()"
"(let-values(((stx_0) s_0))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scope-propagations+tamper11_0)"
"(let-values(((t_1)"
"(let-values(((ht_0) from-t_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(t_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((from-i_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((t_2)"
"(let-values(((t_2)"
" t_1))"
"(let-values(((t_3)"
"(let-values()"
"(if(set-member?"
" t_2"
" from-i_0)"
"(let-values()"
" t_2)"
"(if(any-superior?"
" t_2"
" from-i_0)"
"(let-values()"
" t_2)"
"(let-values()"
"(set-add"
"(remove-inferior"
" t_2"
" from-i_0)"
" from-i_0)))))))"
"(values t_3)))))"
"(if(not #f)"
"(for-loop_0"
" t_2"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
" t_2)))"
" t_1)))))"
" for-loop_0)"
" t_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))"
"((p_0)(syntax-scope-propagations+tamper stx_0)))"
"(if(tamper? p_0) t_1((propagation-set-tamper-ref p_0) p_0 t_1)))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper11_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                            (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))))))))))))"
"(define-values"
"(syntax-taint$1)"
"(lambda(s_0)"
"(begin"
" 'syntax-taint"
"(if(tamper-tainted?(syntax-tamper s_0))"
" s_0"
"(let-values(((stx_0) s_0))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scope-propagations+tamper12_0)"
"(let-values(((t_0)(tamper-tainted-for-content(syntax-content s_0)))"
"((p_0)(syntax-scope-propagations+tamper stx_0)))"
"(if(tamper? p_0) t_0((propagation-set-tamper-ref p_0) p_0 t_0)))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper12_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))))"
"(define-values"
"(any-superior?)"
"(lambda(t_0 from-i_0)"
"(begin"
"(let-values(((ht_0) t_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((i_1)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(inspector-superior-or-same? i_1 from-i_0)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) i_1))(not #f) #f)"
"(for-loop_0 result_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(define-values"
"(inspector-superior-or-same?)"
"(lambda(sup-i_0 i_0)"
"(begin(let-values(((or-part_0)(eq? sup-i_0 i_0)))(if or-part_0 or-part_0(inspector-superior? sup-i_0 i_0))))))"
"(define-values"
"(struct:fallback fallback1.1 fallback? fallback-search-list)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'fallback #f 1 0 #f null 'prefab #f '(0) #f 'fallback)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'search-list))))"
"(define-values"
"(fallback-first)"
"(lambda(smss_0)(begin(if(fallback? smss_0)(car(fallback-search-list smss_0)) smss_0))))"
"(define-values"
"(fallback-rest)"
"(lambda(smss_0)"
"(begin"
"(let-values(((l_0)(cdr(fallback-search-list smss_0))))(if(null?(cdr l_0))(car l_0)(fallback1.1 l_0))))))"
"(define-values"
"(fallback-push)"
"(lambda(smss_0 smss/maybe-fallback_0)"
"(begin"
"(fallback1.1"
"(cons"
" smss_0"
"(if(fallback? smss/maybe-fallback_0)"
"(fallback-search-list smss/maybe-fallback_0)"
"(list smss/maybe-fallback_0)))))))"
"(define-values"
"(fallback-update-first)"
"(lambda(smss_0 f_0)"
"(begin"
"(if(fallback? smss_0)"
"(let-values(((l_0)(fallback-search-list smss_0)))(fallback1.1(cons(f_0(car l_0))(cdr l_0))))"
"(f_0 smss_0)))))"
"(define-values"
"(fallback-map)"
"(lambda(smss_0 f_0)"
"(begin"
"(if(fallback? smss_0)"
"(fallback1.1"
"(reverse$1"
"(let-values(((lst_0)(fallback-search-list smss_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((smss_1)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()(f_0 smss_1))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"(f_0 smss_0)))))"
"(define-values"
"(fallback->list)"
"(lambda(smss_0)(begin(if(fallback? smss_0)(fallback-search-list smss_0)(list smss_0)))))"
"(define-values(make-cache)(lambda()(begin(box(make-weak-box #f)))))"
"(define-values(cell.1$6)(unsafe-make-place-local(make-cache)))"
"(define-values(resolve-cache-place-init!)(lambda()(begin(unsafe-place-local-set! cell.1$6(make-cache)))))"
"(define-values"
"(clear-resolve-cache!)"
"(case-lambda"
"((sym_0)"
"(begin"
"(let-values(((c_0)(weak-box-value(unbox*(unsafe-place-local-ref cell.1$6)))))"
"(begin"
"(if c_0(let-values()(hash-remove! c_0 sym_0))(void))"
"(set-box*!(unsafe-place-local-ref cell.2$4) #f)))))"
"(()"
"(let-values(((c_0)(weak-box-value(unbox*(unsafe-place-local-ref cell.1$6)))))"
"(begin(if c_0(let-values()(hash-clear! c_0))(void))(set-box*!(unsafe-place-local-ref cell.2$4) #f))))))"
"(define-values"
"(struct:entry entry1.1 entry? entry-scs entry-smss entry-phase entry-binding)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'entry"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'entry)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'scs)"
"(make-struct-field-accessor -ref_0 1 'smss)"
"(make-struct-field-accessor -ref_0 2 'phase)"
"(make-struct-field-accessor -ref_0 3 'binding))))"
"(define-values"
"(resolve-cache-get)"
"(lambda(sym_0 phase_0 scs_0 smss_0)"
"(begin"
"(let-values(((c_0)(weak-box-value(unbox*(unsafe-place-local-ref cell.1$6)))))"
"(if c_0"
"(let-values(((v_0)(hash-ref c_0 sym_0 #f)))"
"(if v_0"
"(if(eqv? phase_0(entry-phase v_0))"
"(if(set=? scs_0(entry-scs v_0))(if(set=? smss_0(entry-smss v_0))(entry-binding v_0) #f) #f)"
" #f)"
" #f))"
" #f)))))"
"(define-values"
"(resolve-cache-set!)"
"(lambda(sym_0 phase_0 scs_0 smss_0 b_0)"
"(begin"
"(let-values(((wb_0)(unbox*(unsafe-place-local-ref cell.1$6))))"
"(let-values(((c_0)(weak-box-value wb_0)))"
"(if(not c_0)"
"(let-values()"
"(begin"
"(box-cas!(unsafe-place-local-ref cell.1$6) wb_0(make-weak-box(make-hasheq)))"
"(resolve-cache-set! sym_0 phase_0 scs_0 smss_0 b_0)))"
"(let-values()(hash-set! c_0 sym_0(entry1.1 scs_0 smss_0 phase_0 b_0)))))))))"
"(define-values(SHIFTED-CACHE-SIZE) 16)"
"(define-values(cell.2$4)(unsafe-make-place-local(box #f)))"
"(define-values(cell.3$1)(unsafe-make-place-local 0))"
"(define-values"
"(struct:shifted-entry shifted-entry2.1 shifted-entry? shifted-entry-s shifted-entry-phase shifted-entry-binding)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'shifted-entry"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'shifted-entry)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 's)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'binding))))"
"(define-values"
"(shifted-cache-vector)"
"(lambda()"
"(begin"
"(let-values(((wb_0)(unbox*(unsafe-place-local-ref cell.2$4))))"
"(let-values(((c1_0)(if wb_0(weak-box-value wb_0) #f)))"
"(if c1_0"
"((lambda(vec_0) vec_0) c1_0)"
"(let-values()"
"(let-values(((vec_0)(make-vector SHIFTED-CACHE-SIZE #f)))"
"(begin(set-box*!(unsafe-place-local-ref cell.2$4)(make-weak-box vec_0)) vec_0)))))))))"
"(define-values"
"(resolve+shift-cache-get)"
"(lambda(s_0 phase_0)"
"(begin"
"(let-values(((vec_0)(shifted-cache-vector)))"
"(let-values(((vec_1 len_0)"
"(let-values(((vec_1) vec_0))"
"(begin(check-vector vec_1)(values vec_1(unsafe-vector-length vec_1))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((e_0)(unsafe-vector-ref vec_1 pos_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(if e_0"
"(if(eq? s_0(shifted-entry-s e_0))"
"(if(eqv? phase_0(shifted-entry-phase e_0))"
"(shifted-entry-binding e_0)"
" #f)"
" #f)"
" #f)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) e_0))(not #f) #f)"
"(for-loop_0 result_1(unsafe-fx+ 1 pos_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" 0)))))))"
"(define-values"
"(resolve+shift-cache-set!)"
"(lambda(s_0 phase_0 b_0)"
"(begin"
"(let-values(((vec_0)(shifted-cache-vector)))"
"(let-values(((p_0)(unsafe-place-local-ref cell.3$1)))"
"(begin"
"(vector*-set! vec_0 p_0(shifted-entry2.1 s_0 phase_0 b_0))"
"(unsafe-place-local-set! cell.3$1(fxand(fx+ 1 p_0)(fx- SHIFTED-CACHE-SIZE 1)))))))))"
"(define-values(NUM-CACHE-SLOTS) 8)"
"(define-values(make-cached-sets)(lambda()(begin(make-weak-box(make-vector NUM-CACHE-SLOTS #f)))))"
"(define-values(cell.4$1)(unsafe-make-place-local(make-cached-sets)))"
"(define-values(cell.5$1)(unsafe-make-place-local 0))"
"(define-values(make-cached-hashes)(lambda()(begin(make-weak-box(make-vector NUM-CACHE-SLOTS #f)))))"
"(define-values(cell.6$1)(unsafe-make-place-local(make-cached-hashes)))"
"(define-values(cell.7)(unsafe-make-place-local 0))"
"(define-values"
"(sets-place-init!)"
"(lambda()"
"(begin"
"(begin"
"(unsafe-place-local-set! cell.4$1(make-cached-sets))"
"(unsafe-place-local-set! cell.6$1(make-cached-hashes))))))"
"(define-values"
"(cache-or-reuse-set)"
"(lambda(s_0)"
"(begin"
"(let-values(((vec_0)"
"(let-values(((or-part_0)(weak-box-value(unsafe-place-local-ref cell.4$1))))"
"(if or-part_0"
" or-part_0"
"(let-values(((vec_0)(make-vector NUM-CACHE-SLOTS #f)))"
"(begin(unsafe-place-local-set! cell.4$1(make-weak-box vec_0)) vec_0))))))"
"(let-values(((or-part_0)"
"(let-values(((vec_1 len_0)"
"(let-values(((vec_1) vec_0))"
"(begin(check-vector vec_1)(values vec_1(unsafe-vector-length vec_1))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((s2_0)(unsafe-vector-ref vec_1 pos_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(if s2_0"
"(if(set=? s_0 s2_0) s2_0 #f)"
" #f)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) s2_0))(not #f) #f)"
"(for-loop_0 result_1(unsafe-fx+ 1 pos_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" 0)))))"
"(if or-part_0"
" or-part_0"
"(begin"
"(vector*-set! vec_0(unsafe-place-local-ref cell.5$1) s_0)"
"(unsafe-place-local-set!"
" cell.5$1"
"(fxand(fx+ 1(unsafe-place-local-ref cell.5$1))(fx- NUM-CACHE-SLOTS 1)))"
" s_0)))))))"
"(define-values"
"(cache-or-reuse-hash)"
"(lambda(s_0)"
"(begin"
"(let-values(((vec_0)"
"(let-values(((or-part_0)(weak-box-value(unsafe-place-local-ref cell.6$1))))"
"(if or-part_0"
" or-part_0"
"(let-values(((vec_0)(make-vector NUM-CACHE-SLOTS #f)))"
"(begin(unsafe-place-local-set! cell.6$1(make-weak-box vec_0)) vec_0))))))"
"(let-values(((or-part_0)"
"(let-values(((vec_1 len_0)"
"(let-values(((vec_1) vec_0))"
"(begin(check-vector vec_1)(values vec_1(unsafe-vector-length vec_1))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((s2_0)(unsafe-vector-ref vec_1 pos_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(if s2_0"
"(if(equal? s_0 s2_0) s2_0 #f)"
" #f)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) s2_0))(not #f) #f)"
"(for-loop_0 result_1(unsafe-fx+ 1 pos_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" 0)))))"
"(if or-part_0"
" or-part_0"
"(begin"
"(vector*-set! vec_0(unsafe-place-local-ref cell.7) s_0)"
"(unsafe-place-local-set! cell.7(fxand(fx+ 1(unsafe-place-local-ref cell.7))(fx- NUM-CACHE-SLOTS 1)))"
" s_0)))))))"
"(define-values(cache-place-init!)(lambda()(begin(begin(resolve-cache-place-init!)(sets-place-init!)))))"
"(define-values"
"(struct:scope scope1.1 scope? scope-id scope-kind scope-binding-table set-scope-binding-table!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'scope"
" #f"
" 3"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:scope-with-bindings"
"(lambda(s_0 get-reachable-scopes_0 reach_0 register-trigger_0)"
"(binding-table-register-reachable"
"(scope-binding-table s_0)"
" get-reachable-scopes_0"
" reach_0"
" register-trigger_0)))"
"(cons prop:reach-scopes(lambda(s_0 reach_0)(void)))"
"(cons"
" prop:serialize-fill!"
"(lambda(s_0 ser-push!_0 state_0)"
"(if(binding-table-empty?(scope-binding-table s_0))"
"(let-values()(ser-push!_0 'tag #f))"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:scope-fill!)"
"(ser-push!_0(binding-table-prune-to-reachable(scope-binding-table s_0) state_0)))))))"
"(cons"
" prop:serialize"
"(lambda(s_0 ser-push!_0 state_0)"
"(begin"
"(if(set-member?(serialize-state-reachable-scopes state_0) s_0)"
"(void)"
"                             (let-values () (error \"internal error: found supposedly unreachable scope\")))"
"(if(eq? s_0 top-level-common-scope)"
"(let-values()(ser-push!_0 'tag '#:scope))"
"(let-values()(begin(ser-push!_0 'tag '#:scope+kind)(ser-push!_0(scope-kind s_0))))))))"
"(cons"
" prop:custom-write"
"(lambda(sc_0 port_0 mode_0)"
"(begin"
"                           (write-string \"#<scope:\" port_0)"
"(display(scope-id sc_0) port_0)"
"                           (write-string \":\" port_0)"
"(display(scope-kind sc_0) port_0)"
"                           (write-string \">\" port_0)))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'scope)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'id)"
"(make-struct-field-accessor -ref_0 1 'kind)"
"(make-struct-field-accessor -ref_0 2 'binding-table)"
"(make-struct-field-mutator -set!_0 2 'binding-table))))"
"(define-values"
"(deserialize-scope)"
"(case-lambda"
"(()(begin top-level-common-scope))"
"((kind_0)(scope1.1(new-deserialize-scope-id!) kind_0 empty-binding-table))))"
"(define-values(deserialize-scope-fill!)(lambda(s_0 bt_0)(begin(set-scope-binding-table! s_0 bt_0))))"
"(define-values"
"(struct:interned-scope interned-scope2.1 interned-scope? interned-scope-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'interned-scope"
" struct:scope"
" 1"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(s_0 ser-push!_0 state_0)"
"(begin"
"(if(set-member?(serialize-state-reachable-scopes state_0) s_0)"
"(void)"
"                             (let-values () (error \"internal error: found supposedly unreachable scope\")))"
"(ser-push!_0 'tag '#:interned-scope)"
"(ser-push!_0(interned-scope-key s_0)))))"
"(cons"
" prop:custom-write"
"(lambda(sc_0 port_0 mode_0)"
"(begin"
"                           (write-string \"#<scope:\" port_0)"
"(display(scope-id sc_0) port_0)"
"                           (write-string \":\" port_0)"
"(display(scope-kind sc_0) port_0)"
"                           (write-string \" \" port_0)"
"(display(interned-scope-key sc_0) port_0)"
"                           (write-string \">\" port_0)))))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'interned-scope)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'key))))"
"(define-values"
"(struct:multi-scope"
" multi-scope3.1"
" multi-scope?"
" multi-scope-id"
" multi-scope-name"
" multi-scope-scopes"
" multi-scope-shifted"
" multi-scope-label-shifted)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'multi-scope"
" #f"
" 5"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:scope-with-bindings"
"(lambda(ms_0 get-reachable-scopes_0 reach_0 register-trigger_0)"
"(begin"
"(let-values(((ht_0)(multi-scope-scopes ms_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-values ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)(hash-iterate-value ht_0 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(binding-table-empty?"
"(scope-binding-table"
" sc_0))"
"(void)"
"(let-values()"
"(reach_0 sc_0))))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(void))))"
"(cons prop:reach-scopes(lambda(s_0 reach_0)(void)))"
"(cons"
" prop:serialize"
"(lambda(ms_0 ser-push!_0 state_0)"
"(let-values((()(begin(ser-push!_0 'tag '#:multi-scope)(values))))"
"(let-values((()(begin(ser-push!_0(multi-scope-name ms_0))(values))))"
"(let-values(((multi-scope-tables_0)(serialize-state-multi-scope-tables state_0)))"
"(ser-push!_0"
"(let-values(((or-part_0)(hash-ref multi-scope-tables_0(multi-scope-scopes ms_0) #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheqv)))"
"(begin"
"(let-values(((ht_1)(multi-scope-scopes ms_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 sc_0)"
"(hash-iterate-key+value ht_1 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(set-member?"
"(serialize-state-reachable-scopes"
" state_0)"
" sc_0)"
"(let-values()"
"(hash-set!"
" ht_0"
" phase_0"
" sc_0))"
"(void)))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_1 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_1))))"
"(void)"
"(hash-set! multi-scope-tables_0(multi-scope-scopes ms_0) ht_0)"
" ht_0)))))))))))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4)"
" #f"
" 'multi-scope)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'id)"
"(make-struct-field-accessor -ref_0 1 'name)"
"(make-struct-field-accessor -ref_0 2 'scopes)"
"(make-struct-field-accessor -ref_0 3 'shifted)"
"(make-struct-field-accessor -ref_0 4 'label-shifted))))"
"(define-values"
"(deserialize-multi-scope)"
"(lambda(name_0 scopes_0)"
"(begin(multi-scope3.1(new-deserialize-scope-id!) name_0 scopes_0(box(hasheqv))(box(hash))))))"
"(define-values"
"(struct:representative-scope"
" representative-scope4.1"
" representative-scope?"
" representative-scope-owner"
" representative-scope-phase"
" set-representative-scope-owner!"
" set-representative-scope-phase!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'representative-scope"
" struct:scope"
" 2"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons prop:implicitly-reachable #t)"
"(cons prop:reach-scopes(lambda(s_0 reach_0)(reach_0(representative-scope-owner s_0))))"
"(cons"
" prop:serialize-fill!"
"(lambda(s_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:representative-scope-fill!)"
"(ser-push!_0(binding-table-prune-to-reachable(scope-binding-table s_0) state_0))"
"(ser-push!_0(representative-scope-owner s_0)))))"
"(cons"
" prop:serialize"
"(lambda(s_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:representative-scope)"
"(ser-push!_0(scope-kind s_0))"
"(ser-push!_0(representative-scope-phase s_0)))))"
"(cons"
" prop:custom-write"
"(lambda(sc_0 port_0 mode_0)"
"(begin"
"                           (write-string \"#<scope:\" port_0)"
"(display(scope-id sc_0) port_0)"
"(if(representative-scope-owner sc_0)"
"(let-values()"
"(begin"
"                                 (write-string \"=\" port_0)"
"(display(multi-scope-id(representative-scope-owner sc_0)) port_0)))"
"(void))"
"                           (write-string \"@\" port_0)"
"(display(representative-scope-phase sc_0) port_0)"
"                           (write-string \">\" port_0)))))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'representative-scope)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'owner)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-mutator -set!_0 0 'owner)"
"(make-struct-field-mutator -set!_0 1 'phase))))"
"(define-values"
"(deserialize-representative-scope)"
"(lambda(kind_0 phase_0)"
"(begin(let-values(((v_0)(representative-scope4.1(new-deserialize-scope-id!) kind_0 #f #f phase_0))) v_0))))"
"(define-values"
"(deserialize-representative-scope-fill!)"
"(lambda(s_0 bt_0 owner_0)"
"(begin(begin(deserialize-scope-fill! s_0 bt_0)(set-representative-scope-owner! s_0 owner_0)))))"
"(define-values"
"(struct:shifted-multi-scope"
" shifted-multi-scope5.1"
" shifted-multi-scope?"
" shifted-multi-scope-phase"
" shifted-multi-scope-multi-scope)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'shifted-multi-scope"
" #f"
" 2"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:reach-scopes"
"(lambda(sms_0 reach_0)(reach_0(shifted-multi-scope-multi-scope sms_0))))"
"(cons"
" prop:serialize"
"(lambda(sms_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:shifted-multi-scope)"
"(ser-push!_0(shifted-multi-scope-phase sms_0))"
"(ser-push!_0(shifted-multi-scope-multi-scope sms_0)))))"
"(cons"
" prop:custom-write"
"(lambda(sms_0 port_0 mode_0)"
"(begin"
"                           (write-string \"#<scope:\" port_0)"
"(display(multi-scope-id(shifted-multi-scope-multi-scope sms_0)) port_0)"
"                           (write-string \"@\" port_0)"
"(display(shifted-multi-scope-phase sms_0) port_0)"
"                           (write-string \">\" port_0)))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'shifted-multi-scope)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'phase)"
"(make-struct-field-accessor -ref_0 1 'multi-scope))))"
"(define-values"
"(deserialize-shifted-multi-scope)"
"(lambda(phase_0 multi-scope_0)(begin(intern-shifted-multi-scope phase_0 multi-scope_0))))"
"(define-values"
"(intern-shifted-multi-scope)"
"(lambda(phase_0 multi-scope_0)"
"(begin"
"(letrec-values(((transaction-loop_0)"
"(lambda(boxed-table_0 key_0 make_0)"
"(begin"
" 'transaction-loop"
"(let-values(((or-part_0)(hash-ref(unbox boxed-table_0) phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((val_0)(make_0)))"
"(let-values(((current_0)(unbox boxed-table_0)))"
"(let-values(((next_0)(hash-set current_0 key_0 val_0)))"
"(if(box-cas! boxed-table_0 current_0 next_0)"
" val_0"
"(transaction-loop_0 boxed-table_0 key_0 make_0)))))))))))"
"(if(phase? phase_0)"
"(let-values()"
"(let-values(((or-part_0)(hash-ref(unbox(multi-scope-shifted multi-scope_0)) phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(transaction-loop_0"
"(multi-scope-shifted multi-scope_0)"
" phase_0"
"(lambda()(shifted-multi-scope5.1 phase_0 multi-scope_0))))))"
"(let-values()"
"(let-values(((or-part_0)(hash-ref(unbox(multi-scope-label-shifted multi-scope_0)) phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(transaction-loop_0"
"(multi-scope-label-shifted multi-scope_0)"
" phase_0"
"(lambda()(shifted-multi-scope5.1 phase_0 multi-scope_0)))))))))))"
"(define-values"
"(struct:shifted-to-label-phase shifted-to-label-phase6.1 shifted-to-label-phase? shifted-to-label-phase-from)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'shifted-to-label-phase"
" #f"
" 1"
" 0"
" #f"
" null"
" 'prefab"
" #f"
" '(0)"
" #f"
" 'shifted-to-label-phase)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'from))))"
"(define-values(cell.1$5)(unsafe-make-place-local 0))"
"(define-values"
"(new-scope-id!)"
"(lambda()"
"(begin"
"(begin"
"(unsafe-place-local-set! cell.1$5(add1(unsafe-place-local-ref cell.1$5)))"
"(unsafe-place-local-ref cell.1$5)))))"
"(define-values(new-deserialize-scope-id!)(lambda()(begin(-(new-scope-id!)))))"
"(define-values(deserialized-scope-id?)(lambda(scope-id_0)(begin(negative? scope-id_0))))"
"(define-values(top-level-common-scope)(scope1.1 0 'module empty-binding-table))"
"(define-values(new-scope)(lambda(kind_0)(begin(scope1.1(new-scope-id!) kind_0 empty-binding-table))))"
"(define-values(cell.2$3)(unsafe-make-place-local(make-weak-hasheq)))"
"(define-values(scope-place-init!)(lambda()(begin(unsafe-place-local-set! cell.2$3(make-weak-hasheq)))))"
"(define-values"
"(make-interned-scope)"
"(lambda(sym_0)"
"(begin"
"(let-values(((make_0)"
"(lambda()"
"(begin"
" 'make"
"(make-ephemeron"
" sym_0"
"(interned-scope2.1(-(new-scope-id!)) 'interned empty-binding-table sym_0))))))"
"(call-as-atomic"
"(lambda()"
"(let-values(((or-part_0)(ephemeron-value(hash-ref!(unsafe-place-local-ref cell.2$3) sym_0 make_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((new_0)(make_0)))"
"(begin(hash-set!(unsafe-place-local-ref cell.2$3) sym_0 new_0)(ephemeron-value new_0)))))))))))"
"(define-values"
"(new-multi-scope)"
"(let-values(((new-multi-scope8_0)"
"(lambda(name7_0)"
"(begin"
" 'new-multi-scope8"
"(let-values(((name_0) name7_0))"
"(let-values()"
"(intern-shifted-multi-scope"
" 0"
"(multi-scope3.1(new-scope-id!) name_0(make-hasheqv)(box(hasheqv))(box(hash))))))))))"
"(case-lambda(()(begin(new-multi-scope8_0 #f)))((name7_0)(new-multi-scope8_0 name7_0)))))"
"(define-values"
"(multi-scope-to-scope-at-phase)"
"(lambda(ms_0 phase_0)"
"(begin"
"(let-values(((or-part_0)(hash-ref(multi-scope-scopes ms_0) phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((s_0)"
"(representative-scope4.1"
"(if(deserialized-scope-id?(multi-scope-id ms_0))(new-deserialize-scope-id!)(new-scope-id!))"
" 'module"
" empty-binding-table"
" ms_0"
" phase_0)))"
"(begin(hash-set!(multi-scope-scopes ms_0) phase_0 s_0) s_0)))))))"
"(define-values(scope>?)(lambda(sc1_0 sc2_0)(begin(>(scope-id sc1_0)(scope-id sc2_0)))))"
"(define-values(scope<?)(lambda(sc1_0 sc2_0)(begin(<(scope-id sc1_0)(scope-id sc2_0)))))"
"(define-values"
"(shifted-multi-scope<?)"
"(lambda(sms1_0 sms2_0)"
"(begin"
"(let-values(((ms1_0)(shifted-multi-scope-multi-scope sms1_0)))"
"(let-values(((ms2_0)(shifted-multi-scope-multi-scope sms2_0)))"
"(if(eq? ms1_0 ms2_0)"
"(let-values(((p1_0)(shifted-multi-scope-phase sms1_0))((p2_0)(shifted-multi-scope-phase sms2_0)))"
"(if(shifted-to-label-phase? p1_0)"
"(let-values()"
"(if(shifted-to-label-phase? p2_0)"
"(let-values()(phase<?(shifted-to-label-phase-from p1_0)(shifted-to-label-phase-from p2_0)))"
"(let-values() #f)))"
"(if(shifted-to-label-phase? p2_0)(let-values() #t)(let-values()(phase<? p1_0 p2_0)))))"
"(<(multi-scope-id ms1_0)(multi-scope-id ms2_0))))))))"
"(define-values"
"(syntax-e/no-taint)"
"(lambda(s_0)"
"(begin"
"(let-values(((prop_0)(syntax-scope-propagations+tamper s_0)))"
"(if(let-values(((or-part_0)(propagation? prop_0)))(if or-part_0 or-part_0(tamper-needs-propagate? prop_0)))"
"(let-values(((new-content_0)"
"(let-values(((s_1)(syntax-content s_0))"
"((f_0)(lambda(tail?_0 x_0)(begin 'f x_0)))"
"((s->_0)"
"(lambda(sub-s_0)"
"(begin"
" 's->"
"(if(propagation? prop_0)"
"(let-values(((the-struct_0) sub-s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scopes49_0)"
"(propagation-apply prop_0(syntax-scopes sub-s_0) s_0))"
"((shifted-multi-scopes50_0)"
"(propagation-apply-shifted"
" prop_0"
"(syntax-shifted-multi-scopes sub-s_0)"
" s_0))"
"((mpi-shifts51_0)"
"(propagation-apply-mpi-shifts"
" prop_0"
"(syntax-mpi-shifts sub-s_0)"
" s_0))"
"((inspector52_0)"
"(propagation-apply-inspector"
" prop_0"
"(syntax-inspector sub-s_0)))"
"((scope-propagations+tamper53_0)"
"(propagation-merge"
"(syntax-content sub-s_0)"
" prop_0"
"(syntax-scope-propagations+tamper sub-s_0)"
"(syntax-scopes sub-s_0)"
"(syntax-shifted-multi-scopes sub-s_0)"
"(syntax-mpi-shifts sub-s_0))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
" scopes49_0"
" shifted-multi-scopes50_0"
" scope-propagations+tamper53_0"
" mpi-shifts51_0"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
" inspector52_0))"
"                                                (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
"(let-values(((stx_0) sub-s_0))"
"(let-values(((the-struct_0) stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scope-propagations+tamper54_0)"
"(let-values(((t_0)"
"(tamper-tainted-for-content"
"(syntax-content sub-s_0)))"
"((p_0)"
"(syntax-scope-propagations+tamper stx_0)))"
"(if(tamper? p_0)"
" t_0"
"((propagation-set-tamper-ref p_0) p_0 t_0)))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper54_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                                                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))))"
"((seen_0) #f))"
"(let-values(((s_2) s_1)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(s->_0 v_0))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0))"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 s_3 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_3"
"(lambda(tail?_1 s_4)(gf_0 tail?_1 s_4))"
" seen_1))"
"(if(null? s_3)"
"(let-values()(f_1 tail?_0 s_3))"
"(if(pair? s_3)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_0 #f(car s_3) depth_0)"
"(loop_0 #t(cdr s_3) depth_0))))"
"(if(symbol? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(boolean? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(number? s_3)"
"(let-values()(f_1 #f s_3))"
"(if(let-values(((or-part_0)(vector? s_3)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(box? s_3)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key s_3)))"
"(if or-part_2 or-part_2(hash? s_3)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_3"
"(lambda(tail?_1 s_4)(gf_0 tail?_1 s_4))"
" seen_1))"
"(let-values()(gf_0 #f s_3))))))))))))))"
" loop_0)"
" #f"
" s_2"
" 0)))))"
"(begin"
"(set-syntax-content! s_0 new-content_0)"
"(set-syntax-scope-propagations+tamper!"
" s_0"
"(tamper-propagated(if(propagation? prop_0)(propagation-tamper prop_0) prop_0)))"
" new-content_0))"
"(syntax-content s_0))))))"
"(define-values"
"(syntax-e$1)"
"(lambda(s_0)"
"(begin"
" 'syntax-e"
"(let-values(((e_0)(syntax-content s_0)))"
"(if(symbol? e_0)"
"(let-values() e_0)"
"(let-values()"
"(let-values(((content_0)(syntax-e/no-taint s_0)))"
"(if(not(tamper-armed?(syntax-scope-propagations+tamper s_0)))"
"(let-values() content_0)"
"(if(datum-has-elements? content_0)"
"(let-values()(taint-content content_0))"
"(let-values() content_0))))))))))"
"(define-values"
"(generalize-scope)"
"(lambda(sc_0)"
"(begin"
"(if(representative-scope? sc_0)"
"(intern-shifted-multi-scope(representative-scope-phase sc_0)(representative-scope-owner sc_0))"
" sc_0))))"
"(define-values"
"(add-scope)"
"(lambda(s_0 sc_0)"
"(begin"
"(let-values(((s_1) s_0)((sc_1)(generalize-scope sc_0))((op_0) set-add)((prop-op_0) propagation-add))"
"(if(shifted-multi-scope? sc_1)"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((shifted-multi-scopes55_0)"
"(fallback-update-first"
"(syntax-shifted-multi-scopes s_1)"
"(lambda(smss_0)(op_0(fallback-first smss_0) sc_1))))"
"((scope-propagations+tamper56_0)"
"(if(datum-has-elements?(syntax-content s_1))"
"(prop-op_0"
"(syntax-scope-propagations+tamper s_1)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))"
"(syntax-scope-propagations+tamper s_1))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
" shifted-multi-scopes55_0"
" scope-propagations+tamper56_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scopes57_0)(op_0(syntax-scopes s_1) sc_1))"
"((scope-propagations+tamper58_0)"
"(if(datum-has-elements?(syntax-content s_1))"
"(prop-op_0"
"(syntax-scope-propagations+tamper s_1)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))"
"(syntax-scope-propagations+tamper s_1))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
" scopes57_0"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper58_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))))"
"(define-values"
"(add-scopes)"
"(lambda(s_0 scs_0)"
"(begin"
"(let-values(((lst_0) scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((sc_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_2)"
"(let-values(((s_2) s_1))"
"(let-values(((s_3)(let-values()(add-scope s_2 sc_0))))"
"(values s_3)))))"
"(if(not #f)(for-loop_0 s_2 rest_0) s_2)))"
" s_1)))))"
" for-loop_0)"
" s_0"
" lst_0))))))"
"(define-values"
"(remove-scope)"
"(lambda(s_0 sc_0)"
"(begin"
"(let-values(((s_1) s_0)((sc_1)(generalize-scope sc_0))((op_0) set-remove)((prop-op_0) propagation-remove))"
"(if(shifted-multi-scope? sc_1)"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((shifted-multi-scopes59_0)"
"(fallback-update-first"
"(syntax-shifted-multi-scopes s_1)"
"(lambda(smss_0)(op_0(fallback-first smss_0) sc_1))))"
"((scope-propagations+tamper60_0)"
"(if(datum-has-elements?(syntax-content s_1))"
"(prop-op_0"
"(syntax-scope-propagations+tamper s_1)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))"
"(syntax-scope-propagations+tamper s_1))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
" shifted-multi-scopes59_0"
" scope-propagations+tamper60_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scopes61_0)(op_0(syntax-scopes s_1) sc_1))"
"((scope-propagations+tamper62_0)"
"(if(datum-has-elements?(syntax-content s_1))"
"(prop-op_0"
"(syntax-scope-propagations+tamper s_1)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))"
"(syntax-scope-propagations+tamper s_1))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
" scopes61_0"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper62_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))))"
"(define-values"
"(remove-scopes)"
"(lambda(s_0 scs_0)"
"(begin"
"(let-values(((lst_0) scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((sc_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_2)"
"(let-values(((s_2) s_1))"
"(let-values(((s_3)(let-values()(remove-scope s_2 sc_0))))"
"(values s_3)))))"
"(if(not #f)(for-loop_0 s_2 rest_0) s_2)))"
" s_1)))))"
" for-loop_0)"
" s_0"
" lst_0))))))"
"(define-values(set-flip)(lambda(s_0 e_0)(begin(if(set-member? s_0 e_0)(set-remove s_0 e_0)(set-add s_0 e_0)))))"
"(define-values"
"(flip-scope)"
"(lambda(s_0 sc_0)"
"(begin"
"(let-values(((s_1) s_0)((sc_1)(generalize-scope sc_0))((op_0) set-flip)((prop-op_0) propagation-flip))"
"(if(shifted-multi-scope? sc_1)"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((shifted-multi-scopes63_0)"
"(fallback-update-first"
"(syntax-shifted-multi-scopes s_1)"
"(lambda(smss_0)(op_0(fallback-first smss_0) sc_1))))"
"((scope-propagations+tamper64_0)"
"(if(datum-has-elements?(syntax-content s_1))"
"(prop-op_0"
"(syntax-scope-propagations+tamper s_1)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))"
"(syntax-scope-propagations+tamper s_1))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
" shifted-multi-scopes63_0"
" scope-propagations+tamper64_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((scopes65_0)(op_0(syntax-scopes s_1) sc_1))"
"((scope-propagations+tamper66_0)"
"(if(datum-has-elements?(syntax-content s_1))"
"(prop-op_0"
"(syntax-scope-propagations+tamper s_1)"
" sc_1"
"(syntax-scopes s_1)"
"(syntax-shifted-multi-scopes s_1)"
"(syntax-mpi-shifts s_1))"
"(syntax-scope-propagations+tamper s_1))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
" scopes65_0"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper66_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))))"
"(define-values"
"(flip-scopes)"
"(lambda(s_0 scs_0)"
"(begin"
"(let-values(((lst_0) scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((sc_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_2)"
"(let-values(((s_2) s_1))"
"(let-values(((s_3)(let-values()(flip-scope s_2 sc_0))))"
"(values s_3)))))"
"(if(not #f)(for-loop_0 s_2 rest_0) s_2)))"
" s_1)))))"
" for-loop_0)"
" s_0"
" lst_0))))))"
"(define-values"
"(push-scope)"
"(lambda(s_0 sms_0)"
"(begin"
"(let-values(((smss/maybe-fallbacks67_0) #f))"
"(let-values(((prev-result_0) #f))"
"(let-values(((push_0)"
"(lambda(smss/maybe-fallbacks_0)"
"(begin"
" 'push"
"(if(eq? smss/maybe-fallbacks67_0 smss/maybe-fallbacks_0)"
"(let-values() prev-result_0)"
"(let-values()"
"(let-values(((r_0)"
"(let-values()"
"(let-values(((smss_0)(fallback-first smss/maybe-fallbacks_0)))"
"(if(set-empty? smss_0)"
"(let-values()(set-add smss_0 sms_0))"
"(if(set-member? smss_0 sms_0)"
"(let-values() smss/maybe-fallbacks_0)"
"(let-values()"
"(fallback-push"
"(set-add smss_0 sms_0)"
" smss/maybe-fallbacks_0))))))))"
"(begin"
"(set! smss/maybe-fallbacks67_0 smss/maybe-fallbacks_0)"
"(set! prev-result_0 r_0)"
" r_0))))))))"
"(let-values(((s_1) s_0)"
"((f_0)(lambda(tail?_0 x_0)(begin 'f x_0)))"
"((d->s_0)"
"(lambda(s_1 d_0)"
"(begin"
" 'd->s"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((content68_0) d_0)"
"((shifted-multi-scopes69_0)(push_0(syntax-shifted-multi-scopes s_1))))"
"(syntax1.1"
" content68_0"
"(syntax-scopes the-struct_0)"
" shifted-multi-scopes69_0"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"((s-e_0) syntax-e/no-taint)"
"((seen_0) #f))"
"((letrec-values(((loop_0)"
"(lambda(s_2)"
"(begin"
" 'loop"
"(let-values(((s_3) s_2)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(d->s_0 v_0(loop_0(s-e_0 v_0))))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0))"
"((letrec-values(((loop_1)"
"(lambda(tail?_0 s_4 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1))"
"(if(null? s_4)"
"(let-values()(f_1 tail?_0 s_4))"
"(if(pair? s_4)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_1 #f(car s_4) depth_0)"
"(loop_1 #t(cdr s_4) depth_0))))"
"(if(symbol? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(boolean? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(number? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(let-values(((or-part_0)(vector? s_4)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(box? s_4)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_4)))"
"(if or-part_2"
" or-part_2"
"(hash? s_4)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1))"
"(let-values()(gf_0 #f s_4))))))))))))))"
" loop_1)"
" #f"
" s_3"
" 0))))))"
" loop_0)"
" s_1))))))))"
"(define-values"
"(struct:propagation"
" propagation14.1"
" propagation?"
" propagation-prev-scs"
" propagation-prev-smss"
" propagation-scope-ops"
" propagation-prev-mss"
" propagation-add-mpi-shifts"
" propagation-inspector"
" propagation-tamper)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'propagation"
" #f"
" 7"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons prop:propagation-set-tamper(lambda(p_0 v_0)(propagation-set-tamper p_0 v_0)))"
"(cons prop:propagation-tamper(lambda(p_0)(propagation-tamper p_0)))"
"(cons prop:propagation syntax-e$1))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'propagation)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'prev-scs)"
"(make-struct-field-accessor -ref_0 1 'prev-smss)"
"(make-struct-field-accessor -ref_0 2 'scope-ops)"
"(make-struct-field-accessor -ref_0 3 'prev-mss)"
"(make-struct-field-accessor -ref_0 4 'add-mpi-shifts)"
"(make-struct-field-accessor -ref_0 5 'inspector)"
"(make-struct-field-accessor -ref_0 6 'tamper))))"
"(define-values"
"(propagation-add)"
"(lambda(prop_0 sc_0 prev-scs_0 prev-smss_0 prev-mss_0)"
"(begin"
"(if(propagation? prop_0)"
"(let-values(((the-struct_0) prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((scope-ops71_0)(hash-set(propagation-scope-ops prop_0) sc_0 'add)))"
"(propagation14.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
" scope-ops71_0"
"(propagation-prev-mss the-struct_0)"
"(propagation-add-mpi-shifts the-struct_0)"
"(propagation-inspector the-struct_0)"
"(propagation-tamper the-struct_0)))"
"            (raise-argument-error 'struct-copy \"propagation?\" the-struct_0)))"
"(propagation14.1 prev-scs_0 prev-smss_0(hasheq sc_0 'add) prev-mss_0 #f #f prop_0)))))"
"(define-values"
"(propagation-remove)"
"(lambda(prop_0 sc_0 prev-scs_0 prev-smss_0 prev-mss_0)"
"(begin"
"(if(propagation? prop_0)"
"(let-values(((the-struct_0) prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((scope-ops72_0)(hash-set(propagation-scope-ops prop_0) sc_0 'remove)))"
"(propagation14.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
" scope-ops72_0"
"(propagation-prev-mss the-struct_0)"
"(propagation-add-mpi-shifts the-struct_0)"
"(propagation-inspector the-struct_0)"
"(propagation-tamper the-struct_0)))"
"            (raise-argument-error 'struct-copy \"propagation?\" the-struct_0)))"
"(propagation14.1 prev-scs_0 prev-smss_0(hasheq sc_0 'remove) prev-mss_0 #f #f prop_0)))))"
"(define-values"
"(propagation-flip)"
"(lambda(prop_0 sc_0 prev-scs_0 prev-smss_0 prev-mss_0)"
"(begin"
"(if(propagation? prop_0)"
"(let-values(((ops_0)(propagation-scope-ops prop_0)))"
"(let-values(((current-op_0)(hash-ref ops_0 sc_0 #f)))"
"(if(if(eq? current-op_0 'flip)"
"(if(= 1(hash-count ops_0))"
"(if(not(propagation-inspector prop_0))(not(propagation-add-mpi-shifts prop_0)) #f)"
" #f)"
" #f)"
"(let-values() #f)"
"(let-values()"
"(let-values(((the-struct_0) prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((scope-ops73_0)"
"(if(eq? current-op_0 'flip)"
"(hash-remove ops_0 sc_0)"
"(hash-set"
" ops_0"
" sc_0"
"(let-values(((tmp_0) current-op_0))"
"(if(equal? tmp_0 'add)"
"(let-values() 'remove)"
"(if(equal? tmp_0 'remove)(let-values() 'add)(let-values() 'flip))))))))"
"(propagation14.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
" scope-ops73_0"
"(propagation-prev-mss the-struct_0)"
"(propagation-add-mpi-shifts the-struct_0)"
"(propagation-inspector the-struct_0)"
"(propagation-tamper the-struct_0)))"
"                    (raise-argument-error 'struct-copy \"propagation?\" the-struct_0)))))))"
"(propagation14.1 prev-scs_0 prev-smss_0(hasheq sc_0 'flip) prev-mss_0 #f #f prop_0)))))"
"(define-values"
"(propagation-mpi-shift)"
"(lambda(prop_0 add_0 inspector_0 prev-scs_0 prev-smss_0 prev-mss_0)"
"(begin"
"(if(propagation? prop_0)"
"(let-values(((the-struct_0) prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((add-mpi-shifts74_0)"
"(let-values(((base-add_0)(propagation-add-mpi-shifts prop_0)))"
"(if(if add_0 base-add_0 #f)"
"(lambda(mss_0)(begin 'add-mpi-shifts74(add_0(base-add_0 mss_0))))"
"(let-values(((or-part_0) add_0))(if or-part_0 or-part_0 base-add_0)))))"
"((inspector75_0)"
"(let-values(((or-part_0)(propagation-inspector prop_0)))"
"(if or-part_0 or-part_0 inspector_0))))"
"(propagation14.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
"(propagation-scope-ops the-struct_0)"
"(propagation-prev-mss the-struct_0)"
" add-mpi-shifts74_0"
" inspector75_0"
"(propagation-tamper the-struct_0)))"
"            (raise-argument-error 'struct-copy \"propagation?\" the-struct_0)))"
"(propagation14.1 prev-scs_0 prev-smss_0 '#hasheq() prev-mss_0 add_0 inspector_0 prop_0)))))"
"(define-values"
"(propagation-apply)"
"(lambda(prop_0 scs_0 parent-s_0)"
"(begin"
"(if(eq?(propagation-prev-scs prop_0) scs_0)"
"(let-values()(syntax-scopes parent-s_0))"
"(let-values()"
"(let-values(((new-scs_0)"
"(let-values(((ht_0)(propagation-scope-ops prop_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(scs_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0 op_0)"
"(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values(((scs_2)"
"(let-values(((scs_2) scs_1))"
"(if(not(shifted-multi-scope? sc_0))"
"(let-values(((scs_3) scs_2))"
"(let-values(((scs_4)"
"(let-values()"
"(let-values(((tmp_0) op_0))"
"(if(equal? tmp_0 'add)"
"(let-values()"
"(set-add scs_3 sc_0))"
"(if(equal? tmp_0 'remove)"
"(let-values()"
"(set-remove"
" scs_3"
" sc_0))"
"(let-values()"
"(set-flip"
" scs_3"
" sc_0))))))))"
"(values scs_4)))"
" scs_2))))"
"(if(not #f)"
"(for-loop_0"
" scs_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" scs_2)))"
" scs_1)))))"
" for-loop_0)"
" scs_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))"
"(if(set=? new-scs_0(syntax-scopes parent-s_0))"
"(syntax-scopes parent-s_0)"
"(cache-or-reuse-set new-scs_0))))))))"
"(define-values"
"(propagation-apply-shifted)"
"(lambda(prop_0 smss_0 parent-s_0)"
"(begin"
"(if(eq?(propagation-prev-smss prop_0) smss_0)"
"(let-values()(syntax-shifted-multi-scopes parent-s_0))"
"(let-values()"
"(let-values(((new-smss_0)"
"(let-values(((ht_0)(propagation-scope-ops prop_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(smss_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sms_0 op_0)"
"(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values(((smss_2)"
"(let-values(((smss_2) smss_1))"
"(if(shifted-multi-scope? sms_0)"
"(let-values(((smss_3) smss_2))"
"(let-values(((smss_4)"
"(let-values()"
"(fallback-update-first"
" smss_3"
"(lambda(smss_4)"
"(let-values(((tmp_0)"
" op_0))"
"(if(equal? tmp_0 'add)"
"(let-values()"
"(set-add"
" smss_4"
" sms_0))"
"(if(equal?"
" tmp_0"
" 'remove)"
"(let-values()"
"(set-remove"
" smss_4"
" sms_0))"
"(let-values()"
"(set-flip"
" smss_4"
" sms_0))))))))))"
"(values smss_4)))"
" smss_2))))"
"(if(not #f)"
"(for-loop_0"
" smss_2"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" smss_2)))"
" smss_1)))))"
" for-loop_0)"
" smss_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))"
"(let-values(((parent-smss_0)(syntax-shifted-multi-scopes parent-s_0)))"
"(if(if(set? new-smss_0)(if(set? parent-smss_0)(set=? new-smss_0 parent-smss_0) #f) #f)"
" parent-smss_0"
"(cache-or-reuse-hash new-smss_0)))))))))"
"(define-values"
"(propagation-apply-mpi-shifts)"
"(lambda(prop_0 mss_0 parent-s_0)"
"(begin"
"(if(eq?(propagation-prev-mss prop_0) mss_0)"
"(let-values()(syntax-mpi-shifts parent-s_0))"
"(let-values()(let-values(((add_0)(propagation-add-mpi-shifts prop_0)))(if add_0(add_0 mss_0) mss_0)))))))"
"(define-values"
"(propagation-apply-inspector)"
"(lambda(prop_0 i_0)"
"(begin(let-values(((or-part_0) i_0))(if or-part_0 or-part_0(propagation-inspector prop_0))))))"
"(define-values"
"(propagation-set-tamper)"
"(lambda(prop_0 t_0)"
"(begin"
"(if(propagation? prop_0)"
"(let-values(((the-struct_0) prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((tamper76_0) t_0))"
"(propagation14.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
"(propagation-scope-ops the-struct_0)"
"(propagation-prev-mss the-struct_0)"
"(propagation-add-mpi-shifts the-struct_0)"
"(propagation-inspector the-struct_0)"
" tamper76_0))"
"            (raise-argument-error 'struct-copy \"propagation?\" the-struct_0)))"
" t_0))))"
"(define-values"
"(propagation-merge)"
"(lambda(content_0 prop_0 base-prop_0 prev-scs_0 prev-smss_0 prev-mss_0)"
"(begin"
"(if(not(datum-has-elements? content_0))"
"(let-values()(if(tamper-tainted?(propagation-tamper prop_0)) 'tainted base-prop_0))"
"(if(not(propagation? base-prop_0))"
"(let-values()"
"(if(if(eq?(propagation-prev-scs prop_0) prev-scs_0)"
"(if(eq?(propagation-prev-smss prop_0) prev-smss_0)"
"(if(eq?(propagation-prev-mss prop_0) prev-mss_0)(eq?(propagation-tamper prop_0) base-prop_0) #f)"
" #f)"
" #f)"
"(let-values() prop_0)"
"(let-values()"
"(propagation14.1"
" prev-scs_0"
" prev-smss_0"
"(propagation-scope-ops prop_0)"
" prev-mss_0"
"(propagation-add-mpi-shifts prop_0)"
"(propagation-inspector prop_0)"
"(if(tamper-tainted?(propagation-tamper prop_0)) 'tainted/need-propagate base-prop_0)))))"
"(let-values()"
"(let-values(((new-ops_0)"
"(let-values(((ht_0)(propagation-scope-ops prop_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ops_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0 op_0)"
"(unsafe-immutable-hash-iterate-key+value ht_0 i_0)))"
"(let-values(((ops_1)"
"(let-values(((ops_1) ops_0))"
"(let-values(((ops_2)"
"(let-values()"
"(let-values(((tmp_0) op_0))"
"(if(equal? tmp_0 'add)"
"(let-values()"
"(hash-set"
" ops_1"
" sc_0"
" 'add))"
"(if(equal? tmp_0 'remove)"
"(let-values()"
"(hash-set"
" ops_1"
" sc_0"
" 'remove))"
"(let-values()"
"(let-values(((current-op_0)"
"(hash-ref"
" ops_1"
" sc_0"
" #f)))"
"(let-values(((tmp_1)"
" current-op_0))"
"(if(equal?"
" tmp_1"
" 'add)"
"(let-values()"
"(hash-set"
" ops_1"
" sc_0"
" 'remove))"
"(if(equal?"
" tmp_1"
" 'remove)"
"(let-values()"
"(hash-set"
" ops_1"
" sc_0"
" 'add))"
"(if(equal?"
" tmp_1"
" 'flip)"
"(let-values()"
"(hash-remove"
" ops_1"
" sc_0))"
"(let-values()"
"(hash-set"
" ops_1"
" sc_0"
" 'flip))))))))))))))"
"(values ops_2)))))"
"(if(not #f)"
"(for-loop_0"
" ops_1"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" ops_1)))"
" ops_0)))))"
" for-loop_0)"
"(propagation-scope-ops base-prop_0)"
"(unsafe-immutable-hash-iterate-first ht_0))))))"
"(let-values(((add_0)(propagation-add-mpi-shifts prop_0)))"
"(let-values(((base-add_0)(propagation-add-mpi-shifts base-prop_0)))"
"(let-values(((new-tamper_0)"
"(if(let-values(((or-part_0)(tamper-tainted?(propagation-tamper prop_0))))"
"(if or-part_0 or-part_0(tamper-tainted?(propagation-tamper base-prop_0))))"
" 'tainted/need-propagate"
"(propagation-tamper base-prop_0))))"
"(if(if(zero?(hash-count new-ops_0))"
"(if(not add_0)"
"(if(not base-add_0)"
"(if(not(propagation-inspector prop_0))(not(propagation-inspector base-prop_0)) #f)"
" #f)"
" #f)"
" #f)"
" new-tamper_0"
"(let-values(((the-struct_0) base-prop_0))"
"(if(propagation? the-struct_0)"
"(let-values(((scope-ops77_0) new-ops_0)"
"((add-mpi-shifts78_0)"
"(if(if add_0 base-add_0 #f)"
"(lambda(mss_0)(begin 'add-mpi-shifts78(add_0(base-add_0 mss_0))))"
"(let-values(((or-part_0) add_0))(if or-part_0 or-part_0 base-add_0))))"
"((inspector79_0)"
"(let-values(((or-part_0)(propagation-inspector base-prop_0)))"
"(if or-part_0 or-part_0(propagation-inspector prop_0))))"
"((tamper80_0) new-tamper_0))"
"(propagation14.1"
"(propagation-prev-scs the-struct_0)"
"(propagation-prev-smss the-struct_0)"
" scope-ops77_0"
"(propagation-prev-mss the-struct_0)"
" add-mpi-shifts78_0"
" inspector79_0"
" tamper80_0))"
"                          (raise-argument-error 'struct-copy \"propagation?\" the-struct_0))))))))))))))"
"(define-values"
"(shift-multi-scope)"
"(lambda(sms_0 delta_0)"
"(begin"
"(if(zero-phase? delta_0)"
"(let-values() sms_0)"
"(if(label-phase? delta_0)"
"(let-values()"
"(if(shifted-to-label-phase?(shifted-multi-scope-phase sms_0))"
"(let-values() #f)"
"(let-values()"
"(intern-shifted-multi-scope"
"(shifted-to-label-phase6.1(phase- 0(shifted-multi-scope-phase sms_0)))"
"(shifted-multi-scope-multi-scope sms_0)))))"
"(if(shifted-to-label-phase?(shifted-multi-scope-phase sms_0))"
"(let-values() sms_0)"
"(let-values()"
"(intern-shifted-multi-scope"
"(phase+ delta_0(shifted-multi-scope-phase sms_0))"
"(shifted-multi-scope-multi-scope sms_0)))))))))"
"(define-values"
"(syntax-shift-phase-level$1)"
"(lambda(s_0 phase_0)"
"(begin"
" 'syntax-shift-phase-level"
"(if(eqv? phase_0 0)"
" s_0"
"(let-values()"
"(let-values(((smss81_0) #f))"
"(let-values(((prev-result_0) #f))"
"(let-values(((shift-all_0)"
"(lambda(smss_0)"
"(begin"
" 'shift-all"
"(if(eq? smss81_0 smss_0)"
"(let-values() prev-result_0)"
"(let-values()"
"(let-values(((r_0)"
"(let-values()"
"(fallback-map"
" smss_0"
"(lambda(smss_1)"
"(let-values(((ht_0) smss_1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sms_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((new-sms_0)"
"(shift-multi-scope"
" sms_0"
" phase_0)))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(table_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((table_2)"
"(let-values(((table_2)"
" table_1))"
"(if new-sms_0"
"(let-values(((table_3)"
" table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(let-values()"
" new-sms_0)"
" #t))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4)))"
" table_2))))"
" table_2))))))"
" for-loop_1)"
" table_0)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(unsafe-immutable-hash-iterate-first ht_0)))))))))"
"(begin(set! smss81_0 smss_0)(set! prev-result_0 r_0) r_0))))))))"
"(let-values(((s_1) s_0)"
"((f_0)(lambda(tail?_0 d_0)(begin 'f d_0)))"
"((d->s_0)"
"(lambda(s_1 d_0)"
"(begin"
" 'd->s"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((content82_0) d_0)"
"((shifted-multi-scopes83_0)"
"(shift-all_0(syntax-shifted-multi-scopes s_1))))"
"(syntax1.1"
" content82_0"
"(syntax-scopes the-struct_0)"
" shifted-multi-scopes83_0"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                                      (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"((s-e_0) syntax-e/no-taint)"
"((seen_0) #f))"
"((letrec-values(((loop_0)"
"(lambda(s_2)"
"(begin"
" 'loop"
"(let-values(((s_3) s_2)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(d->s_0 v_0(loop_0(s-e_0 v_0))))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0))"
"((letrec-values(((loop_1)"
"(lambda(tail?_0 s_4 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1))"
"(if(null? s_4)"
"(let-values()(f_1 tail?_0 s_4))"
"(if(pair? s_4)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_1 #f(car s_4) depth_0)"
"(loop_1 #t(cdr s_4) depth_0))))"
"(if(symbol? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(boolean? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(number? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(let-values(((or-part_0)"
"(vector? s_4)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(box? s_4)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_4)))"
"(if or-part_2"
" or-part_2"
"(hash? s_4)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)"
"(gf_0 tail?_1 s_5))"
" seen_1))"
"(let-values()"
"(gf_0 #f s_4))))))))))))))"
" loop_1)"
" #f"
" s_3"
" 0))))))"
" loop_0)"
" s_1))))))))))"
"(define-values"
"(syntax-swap-scopes)"
"(lambda(s_0 src-scopes_0 dest-scopes_0)"
"(begin"
"(if(equal? src-scopes_0 dest-scopes_0)"
" s_0"
"(let-values(((src-smss_0 src-scs_0)"
"(set-partition"
"(let-values(((ht_0) src-scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
"(generalize-scope"
" sc_0))"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(unsafe-immutable-hash-iterate-first ht_0))))"
" shifted-multi-scope?"
"(seteq)"
"(seteq)))"
"((dest-smss_0 dest-scs_0)"
"(set-partition"
"(let-values(((ht_0) dest-scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
"(generalize-scope"
" sc_0))"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(unsafe-immutable-hash-iterate-first ht_0))))"
" shifted-multi-scope?"
"(seteq)"
"(seteq))))"
"(let-values(((scs84_0) #f))"
"(let-values(((prev-result_0) #f))"
"(let-values(((swap-scs_0)"
"(lambda(scs_0)"
"(begin"
" 'swap-scs"
"(if(eq? scs84_0 scs_0)"
"(let-values() prev-result_0)"
"(let-values()"
"(let-values(((r_0)"
"(let-values()"
"(if(subset? src-scs_0 scs_0)"
"(set-union(set-subtract scs_0 src-scs_0) dest-scs_0)"
" scs_0))))"
"(begin(set! scs84_0 scs_0)(set! prev-result_0 r_0) r_0))))))))"
"(let-values(((smss85_0) #f))"
"(let-values(((prev-result_1) #f))"
"(let-values(((swap-smss_0)"
"(lambda(smss_0)"
"(begin"
" 'swap-smss"
"(if(eq? smss85_0 smss_0)"
"(let-values() prev-result_1)"
"(let-values()"
"(let-values(((r_0)"
"(let-values()"
"(fallback-update-first"
" smss_0"
"(lambda(smss_1)"
"(if(subset? src-smss_0 smss_1)"
"(set-union(set-subtract smss_1 src-smss_0) dest-smss_0)"
" smss_1))))))"
"(begin(set! smss85_0 smss_0)(set! prev-result_1 r_0) r_0))))))))"
"(let-values(((s_1) s_0)"
"((f_0)(lambda(tail?_0 d_0)(begin 'f d_0)))"
"((d->s_0)"
"(lambda(s_1 d_0)"
"(begin"
" 'd->s"
"(let-values(((the-struct_0) s_1))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((content86_0) d_0)"
"((scopes87_0)(swap-scs_0(syntax-scopes s_1)))"
"((shifted-multi-scopes88_0)"
"(swap-smss_0(syntax-shifted-multi-scopes s_1))))"
"(syntax1.1"
" content86_0"
" scopes87_0"
" shifted-multi-scopes88_0"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                                            (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"((s-e_0) syntax-e/no-taint)"
"((seen_0) #f))"
"((letrec-values(((loop_0)"
"(lambda(s_2)"
"(begin"
" 'loop"
"(let-values(((s_3) s_2)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(d->s_0 v_0(loop_0(s-e_0 v_0))))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0))"
"((letrec-values(((loop_1)"
"(lambda(tail?_0 s_4 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)(gf_0 tail?_1 s_5))"
" seen_1))"
"(if(null? s_4)"
"(let-values()(f_1 tail?_0 s_4))"
"(if(pair? s_4)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_1 #f(car s_4) depth_0)"
"(loop_1 #t(cdr s_4) depth_0))))"
"(if(symbol? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(boolean? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(number? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(let-values(((or-part_0)"
"(vector? s_4)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(box? s_4)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_4)))"
"(if or-part_2"
" or-part_2"
"(hash? s_4)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)"
"(gf_0 tail?_1 s_5))"
" seen_1))"
"(let-values()"
"(gf_0 #f s_4))))))))))))))"
" loop_1)"
" #f"
" s_3"
" 0))))))"
" loop_0)"
" s_1)))))))))))))"
"(define-values"
"(syntax-scope-set)"
"(lambda(s_0 phase_0)(begin(scope-set-at-fallback s_0(fallback-first(syntax-shifted-multi-scopes s_0)) phase_0))))"
"(define-values"
"(scope-set-at-fallback)"
"(lambda(s_0 smss_0 phase_0)"
"(begin"
"(let-values(((ht_0) smss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(scopes_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sms_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((scopes_1)"
"(let-values(((scopes_1) scopes_0))"
"(if(let-values(((or-part_0)(label-phase? phase_0)))"
"(if or-part_0"
" or-part_0"
"(not"
"(shifted-to-label-phase?"
"(shifted-multi-scope-phase sms_0)))))"
"(let-values(((scopes_2) scopes_1))"
"(let-values(((scopes_3)"
"(let-values()"
"(set-add"
" scopes_2"
"(multi-scope-to-scope-at-phase"
"(shifted-multi-scope-multi-scope sms_0)"
"(let-values(((ph_0)"
"(shifted-multi-scope-phase"
" sms_0)))"
"(if(shifted-to-label-phase? ph_0)"
"(shifted-to-label-phase-from ph_0)"
"(phase- ph_0 phase_0))))))))"
"(values scopes_3)))"
" scopes_1))))"
"(if(not #f)"
"(for-loop_0 scopes_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" scopes_1)))"
" scopes_0)))))"
" for-loop_0)"
"(syntax-scopes s_0)"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(define-values"
"(find-max-scope)"
"(lambda(scopes_0)"
"(begin"
"(begin"
"        (if (set-empty? scopes_0) (let-values () (error \"cannot bind in empty scope set\")) (void))"
"(let-values(((ht_0) scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(max-sc_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((max-sc_1)"
"(let-values(((max-sc_1) max-sc_0))"
"(let-values(((max-sc_2)"
"(let-values()"
"(if(scope>? sc_0 max-sc_1) sc_0 max-sc_1))))"
"(values max-sc_2)))))"
"(if(not #f)"
"(for-loop_0 max-sc_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" max-sc_1)))"
" max-sc_0)))))"
" for-loop_0)"
"(set-first scopes_0)"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(define-values"
"(add-binding-in-scopes!20.1)"
"(lambda(just-for-nominal?15_0 scopes17_0 sym18_0 binding19_0)"
"(begin"
" 'add-binding-in-scopes!20"
"(let-values(((scopes_0) scopes17_0))"
"(let-values(((sym_0) sym18_0))"
"(let-values(((binding_0) binding19_0))"
"(let-values(((just-for-nominal?_0) just-for-nominal?15_0))"
"(let-values()"
"(let-values(((max-sc_0)(find-max-scope scopes_0)))"
"(let-values(((bt_0)"
"(binding-table-add"
"(scope-binding-table max-sc_0)"
" scopes_0"
" sym_0"
" binding_0"
" just-for-nominal?_0)))"
"(begin(set-scope-binding-table! max-sc_0 bt_0)(clear-resolve-cache! sym_0))))))))))))"
"(define-values"
"(add-bulk-binding-in-scopes!27.1)"
"(lambda(shadow-except23_0 scopes25_0 bulk-binding26_0)"
"(begin"
" 'add-bulk-binding-in-scopes!27"
"(let-values(((scopes_0) scopes25_0))"
"(let-values(((bulk-binding_0) bulk-binding26_0))"
"(let-values(((shadow-except_0) shadow-except23_0))"
"(let-values()"
"(let-values(((max-sc_0)(find-max-scope scopes_0)))"
"(let-values(((bt_0)"
"(let-values(((temp89_0)(scope-binding-table max-sc_0))"
"((scopes90_0) scopes_0)"
"((bulk-binding91_0) bulk-binding_0)"
"((shadow-except92_0) shadow-except_0))"
"(binding-table-add-bulk9.1 shadow-except92_0 temp89_0 scopes90_0 bulk-binding91_0))))"
"(begin(set-scope-binding-table! max-sc_0 bt_0)(clear-resolve-cache!)))))))))))"
"(define-values"
"(syntax-any-macro-scopes?)"
"(lambda(s_0)"
"(begin"
"(let-values(((ht_0)(syntax-scopes s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()(eq?(scope-kind sc_0) 'macro)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) sc_0))(not #f) #f)"
"(for-loop_0 result_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(define-values"
"(resolve40.1)"
"(lambda(ambiguous-value30_0 exactly?31_0 extra-shifts33_0 get-scopes?32_0 s38_0 phase39_0)"
"(begin"
" 'resolve40"
"(let-values(((s_0) s38_0))"
"(let-values(((phase_0) phase39_0))"
"(let-values(((ambiguous-value_0) ambiguous-value30_0))"
"(let-values(((exactly?_0) exactly?31_0))"
"(let-values(((get-scopes?_0) get-scopes?32_0))"
"(let-values(((extra-shifts_0) extra-shifts33_0))"
"(let-values()"
"(let-values(((sym_0)(syntax-content s_0)))"
"((letrec-values(((fallback-loop_0)"
"(lambda(smss_0)"
"(begin"
" 'fallback-loop"
"(let-values(((c1_0)"
"(if(not exactly?_0)"
"(if(not get-scopes?_0)"
"(resolve-cache-get"
" sym_0"
" phase_0"
"(syntax-scopes s_0)"
"(fallback-first smss_0))"
" #f)"
" #f)))"
"(if c1_0"
"((lambda(b_0)"
"(if(eq? b_0 '#:none)"
"(let-values()"
"(if(fallback? smss_0)"
"(fallback-loop_0(fallback-rest smss_0))"
" #f))"
"(let-values() b_0)))"
" c1_0)"
"(let-values()"
"(let-values(((scopes_0)"
"(scope-set-at-fallback"
" s_0"
"(fallback-first smss_0)"
" phase_0)))"
"(let-values(((best-scopes_0 best-binding_0)"
"(let-values(((ht_0) scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(best-scopes_0"
" best-binding_0"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((best-scopes_1"
" best-binding_1)"
"(let-values(((ht_1"
" bulk-bindings_0)"
"(let-values(((table_0)"
"(scope-binding-table"
" sc_0)))"
"(if(hash?"
" table_0)"
"(values"
"(hash-ref"
" table_0"
" sym_0"
" '#hash())"
" null)"
"(values"
"(hash-ref"
"(table-with-bulk-bindings-syms"
" table_0)"
" sym_0"
" '#hash())"
"(table-with-bulk-bindings-bulk-bindings"
" table_0)))))"
"((s_1)"
" s_0)"
"((extra-shifts_1)"
" extra-shifts_0))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(best-scopes_1"
" best-binding_1"
" i_1)"
"(begin"
" 'for-loop"
"(if(not"
"(null?"
" i_1))"
"(let-values(((b-scopes_0)"
"(if(pair?"
" i_1)"
"(let-values()"
"(bulk-binding-at-scopes"
"(car"
" i_1)))"
"(let-values()"
"(hash-iterate-key"
" ht_1"
" i_1))))"
"((binding_0)"
"(if(pair?"
" i_1)"
"(let-values()"
"(let-values(((bulk_0)"
"(bulk-binding-at-bulk"
"(car"
" i_1))))"
"(let-values(((b-info_0)"
"(if(symbol-interned?"
" sym_0)"
"(hash-ref"
"(bulk-binding-symbols"
" bulk_0"
" s_1"
" extra-shifts_1)"
" sym_0"
" #f)"
" #f)))"
"(if b-info_0"
"((bulk-binding-create"
" bulk_0)"
" bulk_0"
" b-info_0"
" sym_0)"
" #f))))"
"(let-values()"
"(hash-iterate-value"
" ht_1"
" i_1)))))"
"(let-values(((best-scopes_2"
" best-binding_2)"
"(let-values(((best-scopes_2)"
" best-scopes_1)"
"((best-binding_2)"
" best-binding_1))"
"(if(if b-scopes_0"
"(if binding_0"
"(subset?"
" b-scopes_0"
" scopes_0)"
" #f)"
" #f)"
"(let-values(((best-scopes_3)"
" best-scopes_2)"
"((best-binding_3)"
" best-binding_2))"
"(let-values(((best-scopes_4"
" best-binding_4)"
"(let-values()"
"(if(pair?"
" best-scopes_3)"
"(let-values()"
"(if(let-values(((lst_0)"
" best-scopes_3))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_2)"
"(lambda(result_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((amb-scopes_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(subset?"
" amb-scopes_0"
" b-scopes_0)))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_1))"
" amb-scopes_0))"
"(not"
" #f)"
" #f)"
"(for-loop_2"
" result_1"
" rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_2)"
" #t"
" lst_0)))"
"(let-values()"
"(values"
" b-scopes_0"
" binding_0))"
"(let-values()"
"(values"
"(cons"
" b-scopes_0"
" best-scopes_3)"
" #f))))"
"(if(not"
" best-scopes_3)"
"(let-values()"
"(values"
" b-scopes_0"
" binding_0))"
"(if(subset?"
" b-scopes_0"
" best-scopes_3)"
"(let-values()"
"(values"
" best-scopes_3"
" best-binding_3))"
"(if(subset?"
" best-scopes_3"
" b-scopes_0)"
"(let-values()"
"(values"
" b-scopes_0"
" binding_0))"
"(let-values()"
"(values"
"(list"
" best-scopes_3"
" b-scopes_0)"
" #f)))))))))"
"(values"
" best-scopes_4"
" best-binding_4)))"
"(values"
" best-scopes_2"
" best-binding_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" best-scopes_2"
" best-binding_2"
"(if(pair?"
" i_1)"
"(let-values()"
"(cdr"
" i_1))"
"(let-values()"
"(let-values(((or-part_0)"
"(hash-iterate-next"
" ht_1"
" i_1)))"
"(if or-part_0"
" or-part_0"
" bulk-bindings_0)))))"
"(values"
" best-scopes_2"
" best-binding_2))))"
"(values"
" best-scopes_1"
" best-binding_1))))))"
" for-loop_1)"
" best-scopes_0"
" best-binding_0"
"(let-values(((or-part_0)"
"(hash-iterate-first"
" ht_1)))"
"(if or-part_0"
" or-part_0"
" bulk-bindings_0)))))))"
"(if(not #f)"
"(for-loop_0"
" best-scopes_1"
" best-binding_1"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
"(values"
" best-scopes_1"
" best-binding_1))))"
"(values"
" best-scopes_0"
" best-binding_0))))))"
" for-loop_0)"
" #f"
" #f"
"(unsafe-immutable-hash-iterate-first ht_0))))))"
"(if(pair? best-scopes_0)"
"(let-values()"
"(if(fallback? smss_0)"
"(fallback-loop_0(fallback-rest smss_0))"
" ambiguous-value_0))"
"(if best-scopes_0"
"(let-values()"
"(begin"
"(resolve-cache-set!"
" sym_0"
" phase_0"
"(syntax-scopes s_0)"
"(fallback-first smss_0)"
" best-binding_0)"
"(if(let-values(((or-part_0)(not exactly?_0)))"
"(if or-part_0"
" or-part_0"
"(eqv?"
"(set-count scopes_0)"
"(set-count best-scopes_0))))"
"(if get-scopes?_0 best-scopes_0 best-binding_0)"
" #f)))"
"(let-values()"
"(begin"
"(resolve-cache-set!"
" sym_0"
" phase_0"
"(syntax-scopes s_0)"
"(fallback-first smss_0)"
" '#:none)"
"(if(fallback? smss_0)"
"(fallback-loop_0(fallback-rest smss_0))"
" #f))))))))))))))"
" fallback-loop_0)"
"(syntax-shifted-multi-scopes s_0)))))))))))))"
"(define-values"
"(bound-identifier=?$1)"
"(lambda(a_0 b_0 phase_0)"
"(begin"
" 'bound-identifier=?"
"(if(eq?(syntax-e$1 a_0)(syntax-e$1 b_0))"
"(equal?(syntax-scope-set a_0 phase_0)(syntax-scope-set b_0 phase_0))"
" #f))))"
"(define-values"
"(local-binding?)"
"(lambda(b_0)(begin(let-values(((or-part_0)(full-local-binding? b_0)))(if or-part_0 or-part_0(symbol? b_0))))))"
"(define-values"
"(struct:full-local-binding full-local-binding1.1 full-local-binding? full-local-binding-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'full-local-binding"
" struct:full-binding"
" 1"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(b_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:local-binding)"
"(ser-push!_0(full-local-binding-key b_0))"
"(ser-push!_0(full-binding-free=id b_0))))))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'full-local-binding)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'key))))"
"(define-values"
"(deserialize-full-local-binding)"
"(lambda(key_0 free=id_0)(begin(full-local-binding1.1 #f free=id_0 key_0))))"
"(define-values"
"(make-local-binding7.1)"
"(lambda(frame-id2_0 free=id3_0 key6_0)"
"(begin"
" 'make-local-binding7"
"(let-values(((key_0) key6_0))"
"(let-values(((frame-id_0) frame-id2_0))"
"(let-values(((free=id_0) free=id3_0))"
"(let-values()"
"(if(if(not frame-id_0)(not free=id_0) #f)"
"(let-values() key_0)"
"(let-values()(full-local-binding1.1 frame-id_0 free=id_0 key_0))))))))))"
"(define-values"
"(local-binding-update17.1)"
"(lambda(frame-id11_0 free=id12_0 key10_0 b16_0)"
"(begin"
" 'local-binding-update17"
"(let-values(((b_0) b16_0))"
"(let-values(((key_0)(if(eq? key10_0 unsafe-undefined)(local-binding-key b_0) key10_0)))"
"(let-values(((frame-id_0)(if(eq? frame-id11_0 unsafe-undefined)(binding-frame-id b_0) frame-id11_0)))"
"(let-values(((free=id_0)(if(eq? free=id12_0 unsafe-undefined)(binding-free=id b_0) free=id12_0)))"
"(let-values()"
"(let-values(((key21_0) key_0)((frame-id22_0) frame-id_0)((free=id23_0) free=id_0))"
"(make-local-binding7.1 frame-id22_0 free=id23_0 key21_0))))))))))"
"(define-values"
"(local-binding-key)"
"(lambda(b_0)(begin(if(full-local-binding? b_0)(full-local-binding-key b_0) b_0))))"
"(define-values"
"(1/prop:rename-transformer 1/rename-transformer? rename-transformer-value)"
"(make-struct-type-property"
" 'rename-transformer"
"(lambda(v_0 info_0)"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(exact-nonnegative-integer? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(identifier? v_0)))"
"(if or-part_1 or-part_1(if(procedure? v_0)(procedure-arity-includes? v_0 1) #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'guard-for-prop:rename-transformer"
"(string-append"
"                           \"(or/c exact-nonnegative-integer?\\n\""
"                           \"      identifier?\\n\""
"                           \"      (procedure-arity-includes? proc 1))\")"
" v_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(exact-nonnegative-integer? v_0)"
"(let-values()"
"(begin"
"(if(<= v_0(list-ref info_0 1))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'guard-for-prop:rename-transformer"
"                                  \"field index >= initialized-field count for structure type\""
"                                  \"field index\""
" v_0"
"                                  \"initialized-field count\""
"(list-ref info_0 1))))"
"(if(member v_0(list-ref info_0 5))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'guard-for-prop:rename-transformer"
"                                  \"field index not declared immutable\""
"                                  \"field index\""
" v_0)))))"
"(void))"
"(values))))"
"(let-values(((ref_0)(list-ref info_0 3)))"
"(if(identifier? v_0)"
"(let-values()(lambda(t_0) v_0))"
"(if(integer? v_0)"
"(let-values()"
"(lambda(t_0)"
"(let-values(((val_0)(ref_0 t_0 v_0)))(if(identifier? val_0) val_0(datum->syntax$1 #f '?)))))"
"(let-values()"
"(lambda(t_0)"
"(let-values(((id_0)(call-with-continuation-prompt(lambda()(v_0 t_0)))))"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'prop:rename-transformer"
"                            \"contract violation for given value; expected an identifier\""
"                            \"given\""
" id_0)))"
" id_0))))))))))))"
"(define-values"
"(struct:id-rename-transformer id-rename-transformer1.1 id-rename-transformer? id-rename-transformer-id)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'rename-transformer"
" #f"
" 1"
" 0"
" #f"
"(list(cons 1/prop:rename-transformer 0))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'id-rename-transformer)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'id))))"
"(define-values"
"(1/make-rename-transformer)"
"(lambda(id_0)"
"(begin"
" 'make-rename-transformer"
"(begin"
"(if(identifier? id_0)"
"(void)"
"          (let-values () (raise-argument-error 'make-rename-transformer \"identifier?\" id_0)))"
"(id-rename-transformer1.1 id_0)))))"
"(define-values"
"(1/rename-transformer-target)"
"(lambda(t_0)(begin 'rename-transformer-target((rename-transformer-value t_0) t_0))))"
"(define-values"
"(free-identifier=?$1)"
"(lambda(a_0 b_0 a-phase_0 b-phase_0)"
"(begin"
" 'free-identifier=?"
"(let-values(((ab_0)"
"(toplevel-as-symbol"
"(let-values(((a51_0) a_0)((a-phase52_0) a-phase_0)((temp53_0) #t))"
"(resolve+shift28.1 #f #f null unsafe-undefined temp53_0 a51_0 a-phase52_0)))))"
"(let-values(((bb_0)"
"(toplevel-as-symbol"
"(let-values(((b54_0) b_0)((b-phase55_0) b-phase_0)((temp56_0) #t))"
"(resolve+shift28.1 #f #f null unsafe-undefined temp56_0 b54_0 b-phase55_0)))))"
"(if(let-values(((or-part_0)(symbol? ab_0)))(if or-part_0 or-part_0(symbol? bb_0)))"
"(let-values()(eq? ab_0 bb_0))"
"(let-values()(same-binding? ab_0 bb_0))))))))"
"(define-values"
"(toplevel-as-symbol)"
"(lambda(b_0)"
"(begin"
"(if(if(module-binding? b_0)(top-level-module-path-index?(module-binding-module b_0)) #f)"
"(module-binding-sym b_0)"
" b_0))))"
"(define-values"
"(same-binding?)"
"(lambda(ab_0 bb_0)"
"(begin"
"(if(module-binding? ab_0)"
"(let-values()"
"(if(module-binding? bb_0)"
"(if(eq?(module-binding-sym ab_0)(module-binding-sym bb_0))"
"(if(eqv?(module-binding-phase ab_0)(module-binding-phase bb_0))"
"(eq?"
"(1/module-path-index-resolve(module-binding-module ab_0))"
"(1/module-path-index-resolve(module-binding-module bb_0)))"
" #f)"
" #f)"
" #f))"
"(if(local-binding? ab_0)"
"(let-values()(if(local-binding? bb_0)(eq?(local-binding-key ab_0)(local-binding-key bb_0)) #f))"
"          (let-values () (error \"bad binding\" ab_0)))))))"
"(define-values"
"(same-binding-nominals?)"
"(lambda(ab_0 bb_0)"
"(begin"
"(if(eq?"
"(1/module-path-index-resolve(module-binding-nominal-module ab_0))"
"(1/module-path-index-resolve(module-binding-nominal-module bb_0)))"
"(if(eqv?(module-binding-nominal-require-phase ab_0)(module-binding-nominal-require-phase bb_0))"
"(eqv?(module-binding-nominal-sym ab_0)(module-binding-nominal-sym bb_0))"
" #f)"
" #f))))"
"(define-values"
"(identifier-binding-symbol$1)"
"(lambda(id_0 phase_0)"
"(begin"
" 'identifier-binding-symbol"
"(let-values(((b_0)"
"(let-values(((id57_0) id_0)((phase58_0) phase_0)((temp59_0) #t))"
"(resolve+shift28.1 #f #f null unsafe-undefined temp59_0 id57_0 phase58_0))))"
"(if(symbol? b_0)"
"(let-values() b_0)"
"(if(module-binding? b_0)"
"(let-values()(module-binding-sym b_0))"
"(if(local-binding? b_0)(let-values()(local-binding-key b_0))(let-values()(syntax-e$1 id_0)))))))))"
"(define-values"
"(identifier-binding$1)"
"(let-values(((identifier-binding4_0)"
"(lambda(id2_0 phase3_0 top-level-symbol?1_0)"
"(begin"
" 'identifier-binding4"
"(let-values(((id_0) id2_0))"
"(let-values(((phase_0) phase3_0))"
"(let-values(((top-level-symbol?_0) top-level-symbol?1_0))"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((id60_0) id_0)((phase61_0) phase_0))"
"(resolve+shift28.1 #f #f null unsafe-undefined #f id60_0 phase61_0))))"
"(if(module-binding? b_0)"
"(let-values()"
"(if(top-level-module-path-index?(module-binding-module b_0))"
"(if top-level-symbol?_0(list(module-binding-nominal-sym b_0)) #f)"
"(list"
"(module-binding-module b_0)"
"(module-binding-sym b_0)"
"(module-binding-nominal-module b_0)"
"(module-binding-nominal-sym b_0)"
"(module-binding-phase b_0)"
"(module-binding-nominal-require-phase b_0)"
"(module-binding-nominal-phase b_0))))"
"(if(local-binding? b_0)(let-values() 'lexical)(let-values() #f))))))))))))"
"(case-lambda"
"((id_0 phase_0)(begin 'identifier-binding(identifier-binding4_0 id_0 phase_0 #f)))"
"((id_0 phase_0 top-level-symbol?1_0)(identifier-binding4_0 id_0 phase_0 top-level-symbol?1_0)))))"
"(define-values"
"(maybe-install-free=id!)"
"(lambda(val_0 id_0 phase_0)"
"(begin"
"(if(1/rename-transformer? val_0)"
"(let-values()"
"(let-values(((free=id_0)(1/rename-transformer-target val_0)))"
"(if(syntax-property$1 free=id_0 'not-free-identifier=?)"
"(void)"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((id65_0) id_0)((phase66_0) phase_0)((temp67_0) #t)((temp68_0) #t))"
"(resolve+shift28.1 #f temp67_0 null temp68_0 #f id65_0 phase66_0))))"
"(let-values(((temp62_0)(syntax-scope-set id_0 phase_0))"
"((temp63_0)(syntax-e$1 id_0))"
"((temp64_0)(binding-set-free=id b_0 free=id_0)))"
"(add-binding-in-scopes!20.1 #f temp62_0 temp63_0 temp64_0)))))))"
"(void)))))"
"(define-values"
"(binding-set-free=id)"
"(lambda(b_0 free=id_0)"
"(begin"
"(if(module-binding? b_0)"
"(let-values()"
"(let-values(((b69_0) b_0)((free=id70_0) free=id_0))"
"(module-binding-update46.1"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" free=id70_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" b69_0)))"
"(if(local-binding? b_0)"
"(let-values()"
"(let-values(((b71_0) b_0)((free=id72_0) free=id_0))"
"(local-binding-update17.1 unsafe-undefined free=id72_0 unsafe-undefined b71_0)))"
"          (let-values () (error \"bad binding for free=id:\" b_0)))))))"
"(define-values"
"(struct:non-source-shift non-source-shift6.1 non-source-shift? non-source-shift-from non-source-shift-to)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'non-source-shift #f 2 0 #f null 'prefab #f '(0 1) #f 'non-source-shift)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'from)"
"(make-struct-field-accessor -ref_0 1 'to))))"
"(define-values(shift-from)(lambda(s_0)(begin(if(pair? s_0)(car s_0)(non-source-shift-from s_0)))))"
"(define-values(shift-to)(lambda(s_0)(begin(if(pair? s_0)(cdr s_0)(non-source-shift-to s_0)))))"
"(define-values"
"(syntax-module-path-index-shift13.1)"
"(lambda(non-source?7_0 s10_0 from-mpi11_0 to-mpi12_0 inspector9_0)"
"(begin"
" 'syntax-module-path-index-shift13"
"(let-values(((s_0) s10_0))"
"(let-values(((from-mpi_0) from-mpi11_0))"
"(let-values(((to-mpi_0) to-mpi12_0))"
"(let-values(((inspector_0) inspector9_0))"
"(let-values(((non-source?_0) non-source?7_0))"
"(let-values()"
"(if(eq? from-mpi_0 to-mpi_0)"
"(let-values()(if inspector_0(syntax-set-inspector s_0 inspector_0) s_0))"
"(let-values()"
"(let-values(((shift_0)"
"(if non-source?_0"
"(non-source-shift6.1 from-mpi_0 to-mpi_0)"
"(cons from-mpi_0 to-mpi_0))))"
"(let-values(((the-struct_0) s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((mpi-shifts74_0)(shift-cons shift_0(syntax-mpi-shifts s_0)))"
"((inspector75_0)"
"(let-values(((or-part_0)(syntax-inspector s_0)))"
"(if or-part_0 or-part_0 inspector_0)))"
"((scope-propagations+tamper76_0)"
"(if(datum-has-elements?(syntax-content s_0))"
"(propagation-mpi-shift"
"(syntax-scope-propagations+tamper s_0)"
"(lambda(s_1)(shift-cons shift_0 s_1))"
" inspector_0"
"(syntax-scopes s_0)"
"(syntax-shifted-multi-scopes s_0)"
"(syntax-mpi-shifts s_0))"
"(syntax-scope-propagations+tamper s_0))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper76_0"
" mpi-shifts74_0"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
" inspector75_0))"
"                            (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))))))))))))"
"(define-values"
"(shift-cons)"
"(lambda(shift_0 shifts_0)"
"(begin"
"(if(if(pair? shifts_0)(eq?(shift-from shift_0)(shift-from(car shifts_0))) #f)"
"(let-values() shifts_0)"
"(let-values()(cons shift_0 shifts_0))))))"
"(define-values"
"(resolve+shift28.1)"
"(lambda(ambiguous-value16_0 exactly?17_0 extra-shifts20_0 immediate?18_0 unbound-sym?19_0 s26_0 phase27_0)"
"(begin"
" 'resolve+shift28"
"(let-values(((s_0) s26_0))"
"(let-values(((phase_0) phase27_0))"
"(let-values(((ambiguous-value_0) ambiguous-value16_0))"
"(let-values(((exactly?_0) exactly?17_0))"
"(let-values(((immediate?_0)(if(eq? immediate?18_0 unsafe-undefined) exactly?_0 immediate?18_0)))"
"(let-values(((unbound-sym?_0) unbound-sym?19_0))"
"(let-values(((extra-shifts_0) extra-shifts20_0))"
"(let-values()"
"(let-values(((can-cache?_0)"
"(if(not exactly?_0)(if(not immediate?_0)(null? extra-shifts_0) #f) #f)))"
"(let-values(((c1_0)(if can-cache?_0(resolve+shift-cache-get s_0 phase_0) #f)))"
"(if c1_0"
"((lambda(b_0)(if(eq? b_0 '#:none)(if unbound-sym?_0(syntax-content s_0) #f) b_0)) c1_0)"
"(let-values()"
"(let-values(((immediate-b_0)"
"(let-values(((s77_0) s_0)"
"((phase78_0) phase_0)"
"((ambiguous-value79_0) ambiguous-value_0)"
"((exactly?80_0) exactly?_0)"
"((extra-shifts81_0) extra-shifts_0))"
"(resolve40.1"
" ambiguous-value79_0"
" exactly?80_0"
" extra-shifts81_0"
" #f"
" s77_0"
" phase78_0))))"
"(let-values(((b_0)"
"(if(if immediate-b_0"
"(if(not immediate?_0)(binding-free=id immediate-b_0) #f)"
" #f)"
"(let-values(((temp82_0)(binding-free=id immediate-b_0))"
"((phase83_0) phase_0)"
"((temp84_0)"
"(append extra-shifts_0(syntax-mpi-shifts s_0)))"
"((ambiguous-value85_0) ambiguous-value_0)"
"((exactly?86_0) exactly?_0)"
"((unbound-sym?87_0) unbound-sym?_0))"
"(resolve+shift28.1"
" ambiguous-value85_0"
" exactly?86_0"
" temp84_0"
" unsafe-undefined"
" unbound-sym?87_0"
" temp82_0"
" phase83_0))"
" immediate-b_0)))"
"(if(module-binding? b_0)"
"(let-values()"
"(let-values(((mpi-shifts_0)(syntax-mpi-shifts s_0)))"
"(if(null? mpi-shifts_0)"
"(let-values() b_0)"
"(let-values()"
"(let-values(((mod_0)(module-binding-module b_0)))"
"(let-values(((shifted-mod_0)(apply-syntax-shifts mod_0 mpi-shifts_0)))"
"(let-values(((nominal-mod_0)(module-binding-nominal-module b_0)))"
"(let-values(((shifted-nominal-mod_0)"
"(if(eq? mod_0 nominal-mod_0)"
" shifted-mod_0"
"(apply-syntax-shifts nominal-mod_0 mpi-shifts_0))))"
"(let-values(((result-b_0)"
"(if(if(eq? mod_0 shifted-mod_0)"
"(if(eq? nominal-mod_0 shifted-nominal-mod_0)"
"(if(not(binding-free=id b_0))"
"(null?"
"(module-binding-extra-nominal-bindings"
" b_0))"
" #f)"
" #f)"
" #f)"
" b_0"
"(let-values(((b88_0) b_0)"
"((shifted-mod89_0) shifted-mod_0)"
"((shifted-nominal-mod90_0)"
" shifted-nominal-mod_0)"
"((temp91_0)"
"(if(binding-free=id b_0)"
"(let-values(((temp93_0)"
"(binding-free=id b_0))"
"((s94_0) s_0))"
"(syntax-transfer-shifts36.1"
" #f"
" temp93_0"
" s94_0"
" #f))"
" #f))"
"((temp92_0)"
"(reverse$1"
"(let-values(((lst_0)"
"(module-binding-extra-nominal-bindings"
" b_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((b_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(apply-syntax-shifts-to-binding"
" b_1"
" mpi-shifts_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(module-binding-update46.1"
" unsafe-undefined"
" temp92_0"
" unsafe-undefined"
" temp91_0"
" shifted-mod89_0"
" shifted-nominal-mod90_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" b88_0)))))"
"(begin"
"(if can-cache?_0"
"(let-values()"
"(resolve+shift-cache-set! s_0 phase_0 result-b_0))"
"(void))"
" result-b_0))))))))))"
"(let-values()"
"(begin"
"(if can-cache?_0"
"(let-values()"
"(resolve+shift-cache-set!"
" s_0"
" phase_0"
"(let-values(((or-part_0) b_0))(if or-part_0 or-part_0 '#:none))))"
"(void))"
"(let-values(((or-part_0) b_0))"
"(if or-part_0"
" or-part_0"
"(if unbound-sym?_0(syntax-content s_0) #f)))))))))))))))))))))))"
"(define-values"
"(apply-syntax-shifts)"
"(lambda(mpi_0 shifts_0)"
"(begin"
"(if(null? shifts_0)"
"(let-values() mpi_0)"
"(let-values()"
"(let-values(((shifted-mpi_0)(apply-syntax-shifts mpi_0(cdr shifts_0))))"
"(let-values(((shift_0)(car shifts_0)))"
"(module-path-index-shift shifted-mpi_0(shift-from shift_0)(shift-to shift_0)))))))))"
"(define-values"
"(apply-syntax-shifts-to-binding)"
"(lambda(b_0 shifts_0)"
"(begin"
"(if(null? shifts_0)"
"(let-values() b_0)"
"(let-values()"
"(let-values(((shifted-b_0)(apply-syntax-shifts-to-binding b_0(cdr shifts_0))))"
"(let-values(((shift_0)(car shifts_0)))"
"(binding-module-path-index-shift shifted-b_0(shift-from shift_0)(shift-to shift_0)))))))))"
"(define-values"
"(binding-module-path-index-shift)"
"(lambda(b_0 from-mpi_0 to-mpi_0)"
"(begin"
"(if(module-binding? b_0)"
"(let-values()"
"(let-values(((b95_0) b_0)"
"((temp96_0)(module-path-index-shift(module-binding-module b_0) from-mpi_0 to-mpi_0))"
"((temp97_0)(module-path-index-shift(module-binding-nominal-module b_0) from-mpi_0 to-mpi_0))"
"((temp98_0)"
"(reverse$1"
"(let-values(((lst_0)(module-binding-extra-nominal-bindings b_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((b_1)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(binding-module-path-index-shift"
" b_1"
" from-mpi_0"
" to-mpi_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(module-binding-update46.1"
" unsafe-undefined"
" temp98_0"
" unsafe-undefined"
" unsafe-undefined"
" temp96_0"
" temp97_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" b95_0)))"
"(let-values() b_0)))))"
"(define-values"
"(syntax-transfer-shifts36.1)"
"(lambda(non-source?31_0 to-s34_0 from-s35_0 inspector33_0)"
"(begin"
" 'syntax-transfer-shifts36"
"(let-values(((to-s_0) to-s34_0))"
"(let-values(((from-s_0) from-s35_0))"
"(let-values(((inspector_0) inspector33_0))"
"(let-values(((non-source?_0) non-source?31_0))"
"(let-values()"
"(let-values(((to-s99_0) to-s_0)"
"((temp100_0)(syntax-mpi-shifts from-s_0))"
"((inspector101_0) inspector_0)"
"((non-source?102_0) non-source?_0))"
"(syntax-add-shifts44.1 non-source?102_0 to-s99_0 temp100_0 inspector101_0))))))))))"
"(define-values"
"(syntax-add-shifts44.1)"
"(lambda(non-source?39_0 to-s42_0 shifts43_0 inspector41_0)"
"(begin"
" 'syntax-add-shifts44"
"(let-values(((to-s_0) to-s42_0))"
"(let-values(((shifts_0) shifts43_0))"
"(let-values(((inspector_0) inspector41_0))"
"(let-values(((non-source?_0) non-source?39_0))"
"(let-values()"
"(if(if(null? shifts_0) inspector_0 #f)"
"(let-values()(syntax-set-inspector to-s_0 inspector_0))"
"(let-values()"
"(let-values(((lst_0)(reverse$1 shifts_0))((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_0 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((shift_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((i_0) pos_0))"
"(let-values(((s_1)"
"(let-values(((s_1) s_0))"
"(let-values(((s_2)"
"(let-values()"
"(let-values(((s103_0) s_1)"
"((temp104_0)"
"(shift-from shift_0))"
"((temp105_0)"
"(shift-to shift_0))"
"((temp106_0)"
"(if(zero? i_0)"
" inspector_0"
" #f))"
"((non-source?107_0)"
" non-source?_0))"
"(syntax-module-path-index-shift13.1"
" non-source?107_0"
" s103_0"
" temp104_0"
" temp105_0"
" temp106_0)))))"
"(values s_2)))))"
"(if(not #f)(for-loop_0 s_1 rest_0(+ pos_0 1)) s_1)))"
" s_0)))))"
" for-loop_0)"
" to-s_0"
" lst_0"
" start_0)))))))))))))"
"(define-values"
"(syntax-set-inspector)"
"(lambda(s_0 insp_0)"
"(begin"
"(let-values(((the-struct_0) s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((inspector108_0)"
"(let-values(((or-part_0)(syntax-inspector s_0)))(if or-part_0 or-part_0 insp_0)))"
"((scope-propagations+tamper109_0)"
"(if(datum-has-elements?(syntax-content s_0))"
"(propagation-mpi-shift"
"(syntax-scope-propagations+tamper s_0)"
" #f"
" insp_0"
"(syntax-scopes s_0)"
"(syntax-shifted-multi-scopes s_0)"
"(syntax-mpi-shifts s_0))"
"(syntax-scope-propagations+tamper s_0))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
" scope-propagations+tamper109_0"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
" inspector108_0))"
"          (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"(define-values"
"(1/syntax-source-module)"
"(let-values(((syntax-source-module49_0)"
"(lambda(s48_0 source?47_0)"
"(begin"
" 'syntax-source-module49"
"(let-values(((s_0) s48_0))"
"(let-values(((source?_0) source?47_0))"
"(let-values()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                              (let-values () (raise-argument-error 'syntax-track-origin \"syntax?\" s_0)))"
"(let-values(((lst_0)(reverse$1(syntax-mpi-shifts s_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((shift_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values(((result_1) result_0))"
"(if(non-source-shift? shift_0)"
" result_1"
"(let-values()"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(let-values(((from-mpi_0)"
"(car"
" shift_0)))"
"(let-values(((path_0"
" base_0)"
"(1/module-path-index-split"
" from-mpi_0)))"
"(if(not path_0)"
"(if(module-path-index-resolved"
" from-mpi_0)"
"(let-values(((mpi_0)"
"(apply-syntax-shifts"
" from-mpi_0"
"(syntax-mpi-shifts"
" s_0))))"
"(if source?_0"
"(1/resolved-module-path-name"
"(1/module-path-index-resolve"
" mpi_0"
" #f))"
" mpi_0))"
" #f)"
" #f)))))))"
"(values result_2)))))))"
"(if(if(not((lambda x_0 result_1) shift_0))(not #f) #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" lst_0)))))))))))"
"(case-lambda"
"((s_0)(begin 'syntax-source-module(syntax-source-module49_0 s_0 #f)))"
"((s_0 source?47_0)(syntax-source-module49_0 s_0 source?47_0)))))"
"(define-values"
"(1/identifier-prune-to-source-module)"
"(lambda(id_0)"
"(begin"
" 'identifier-prune-to-source-module"
"(begin"
"(if(identifier? id_0)"
"(void)"
"          (let-values () (raise-argument-error 'identifier-prune-to-source-module \"identifier?\" id_0)))"
"(let-values(((the-struct_0)(datum->syntax$1 #f(syntax-e$1 id_0) id_0 id_0)))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((mpi-shifts110_0)(syntax-mpi-shifts id_0)))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
" mpi-shifts110_0"
"(syntax-srcloc the-struct_0)"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"            (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))))))"
"(define-values"
"(struct:provided provided1.1 provided? provided-binding provided-protected? provided-syntax?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'provided"
" #f"
" 3"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:serialize"
"(lambda(p_0 ser-push!_0 state_0)"
"(begin"
"(ser-push!_0 'tag '#:provided)"
"(ser-push!_0(provided-binding p_0))"
"(ser-push!_0(provided-protected? p_0))"
"(ser-push!_0(provided-syntax? p_0))))))"
" #f"
" #f"
" '(0 1 2)"
" #f"
" 'provided)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'binding)"
"(make-struct-field-accessor -ref_0 1 'protected?)"
"(make-struct-field-accessor -ref_0 2 'syntax?))))"
"(define-values(provided-as-binding)(lambda(v_0)(begin(if(provided? v_0)(provided-binding v_0) v_0))))"
"(define-values(provided-as-protected?)(lambda(v_0)(begin(if(provided? v_0)(provided-protected? v_0) #f))))"
"(define-values(provided-as-transformer?)(lambda(v_0)(begin(if(provided? v_0)(provided-syntax? v_0) #f))))"
"(define-values"
"(deserialize-provided)"
"(lambda(binding_0 protected?_0 syntax?_0)(begin(provided1.1 binding_0 protected?_0 syntax?_0))))"
"(define-values"
"(provide-binding-to-require-binding11.1)"
"(lambda(mpi2_0 phase-shift4_0 provide-phase-level3_0 self1_0 binding/p9_0 sym10_0)"
"(begin"
" 'provide-binding-to-require-binding11"
"(let-values(((binding/p_0) binding/p9_0))"
"(let-values(((sym_0) sym10_0))"
"(let-values(((self_0) self1_0))"
"(let-values(((mpi_0) mpi2_0))"
"(let-values(((provide-phase-level_0) provide-phase-level3_0))"
"(let-values(((phase-shift_0) phase-shift4_0))"
"(let-values()"
"(let-values(((binding_0)(provided-as-binding binding/p_0)))"
"(let-values(((from-mod_0)(module-binding-module binding_0)))"
"(let-values(((binding17_0) binding_0)"
"((temp18_0)(module-path-index-shift from-mod_0 self_0 mpi_0))"
"((mpi19_0) mpi_0)"
"((provide-phase-level20_0) provide-phase-level_0)"
"((sym21_0) sym_0)"
"((phase-shift22_0) phase-shift_0)"
"((temp23_0) #f)"
"((temp24_0)"
"(if(not(provided-as-protected? binding/p_0))"
"(module-binding-extra-inspector binding_0)"
" #f))"
"((null25_0) null))"
"(module-binding-update46.1"
" temp24_0"
" null25_0"
" temp23_0"
" unsafe-undefined"
" temp18_0"
" mpi19_0"
" provide-phase-level20_0"
" phase-shift22_0"
" sym21_0"
" unsafe-undefined"
" unsafe-undefined"
" binding17_0))))))))))))))"
"(define-values"
"(struct:bulk-binding"
" bulk-binding14.1"
" bulk-binding?"
" bulk-binding-provides"
" bulk-binding-prefix"
" bulk-binding-excepts"
" bulk-binding-self"
" bulk-binding-mpi"
" bulk-binding-provide-phase-level"
" bulk-binding-phase-shift"
" bulk-binding-bulk-binding-registry"
" set-bulk-binding-provides!"
" set-bulk-binding-self!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'bulk-binding"
" #f"
" 8"
" 0"
" #f"
"(list"
"(cons"
" prop:serialize"
"(lambda(b_0 ser-push!_0 reachable-scopes_0)"
"(begin"
"(ser-push!_0 'tag '#:bulk-binding)"
"(ser-push!_0(bulk-binding-prefix b_0))"
"(ser-push!_0(bulk-binding-excepts b_0))"
"(ser-push!_0(bulk-binding-mpi b_0))"
"(ser-push!_0(bulk-binding-provide-phase-level b_0))"
"(ser-push!_0(bulk-binding-phase-shift b_0))"
"(ser-push!_0 'tag '#:bulk-binding-registry))))"
"(cons"
" prop:bulk-binding"
"(bulk-binding-class3.1"
"(lambda(b_0 mpi-shifts_0)"
"(let-values(((or-part_0)(bulk-binding-provides b_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((mod-name_0)"
"(1/module-path-index-resolve"
"(apply-syntax-shifts(bulk-binding-mpi b_0) mpi-shifts_0))))"
"(let-values((()"
"(begin"
"(if(bulk-binding-bulk-binding-registry b_0)"
"(void)"
"(let-values()"
"(error"
"                                                     \"namespace mismatch: no bulk-binding registry available:\""
" mod-name_0)))"
"(values))))"
"(let-values(((table_0)"
"(bulk-binding-registry-table(bulk-binding-bulk-binding-registry b_0))))"
"(let-values(((bulk-provide_0)(hash-ref table_0 mod-name_0 #f)))"
"(let-values((()"
"(begin"
"(if bulk-provide_0"
"(void)"
"(let-values()"
"(error"
"                                                           \"namespace mismatch: bulk bindings not found in registry for module:\""
" mod-name_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(set-bulk-binding-self! b_0(bulk-provide-self bulk-provide_0))"
"(values))))"
"(let-values(((provides_0)"
"(hash-ref"
"(bulk-provide-provides bulk-provide_0)"
"(bulk-binding-provide-phase-level b_0))))"
"(let-values(((excepts_0)(bulk-binding-excepts b_0)))"
"(let-values(((prefix_0)(bulk-binding-prefix b_0)))"
"(let-values(((adjusted-provides_0)"
"(if(let-values(((or-part_1) prefix_0))"
"(if or-part_1"
" or-part_1"
"(positive?(hash-count excepts_0))))"
"(let-values()"
"(bulk-provides-add-prefix-remove-exceptions"
" provides_0"
" prefix_0"
" excepts_0))"
"(let-values() provides_0))))"
"(begin"
"(set-bulk-binding-provides! b_0 adjusted-provides_0)"
" adjusted-provides_0))))))))))))))"
"(lambda(b_0 binding_0 sym_0)"
"(let-values(((binding27_0) binding_0)"
"((temp28_0)"
"(if(bulk-binding-prefix b_0)"
"(string->symbol"
"(substring"
"(symbol->string sym_0)"
"(string-length(symbol->string(bulk-binding-prefix b_0)))))"
" sym_0))"
"((temp29_0)(bulk-binding-self b_0))"
"((temp30_0)(bulk-binding-mpi b_0))"
"((temp31_0)(bulk-binding-provide-phase-level b_0))"
"((temp32_0)(bulk-binding-phase-shift b_0)))"
"(provide-binding-to-require-binding11.1"
" temp30_0"
" temp32_0"
" temp31_0"
" temp29_0"
" binding27_0"
" temp28_0))))))"
"(current-inspector)"
" #f"
" '(1 2 4 5 6 7)"
" #f"
" 'bulk-binding)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'provides)"
"(make-struct-field-accessor -ref_0 1 'prefix)"
"(make-struct-field-accessor -ref_0 2 'excepts)"
"(make-struct-field-accessor -ref_0 3 'self)"
"(make-struct-field-accessor -ref_0 4 'mpi)"
"(make-struct-field-accessor -ref_0 5 'provide-phase-level)"
"(make-struct-field-accessor -ref_0 6 'phase-shift)"
"(make-struct-field-accessor -ref_0 7 'bulk-binding-registry)"
"(make-struct-field-mutator -set!_0 0 'provides)"
"(make-struct-field-mutator -set!_0 3 'self))))"
"(define-values"
"(deserialize-bulk-binding)"
"(lambda(prefix_0 excepts_0 mpi_0 provide-phase-level_0 phase-shift_0 bulk-binding-registry_0)"
"(begin"
"(bulk-binding14.1 #f prefix_0 excepts_0 #f mpi_0 provide-phase-level_0 phase-shift_0 bulk-binding-registry_0))))"
"(define-values"
"(bulk-provides-add-prefix-remove-exceptions)"
"(lambda(provides_0 prefix_0 excepts_0)"
"(begin"
"(let-values(((ht_0) provides_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 val_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(if(hash-ref excepts_0 sym_0 #f)"
" table_1"
"(let-values(((table_2) table_1))"
"(if(symbol-interned? sym_0)"
"(let-values(((table_3) table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0 val_1)"
"(let-values()"
"(values"
"(if prefix_0"
"(string->symbol"
"(format"
"                                                                                                 \"~a~a\""
" prefix_0"
" sym_0))"
" sym_0)"
" val_0))))"
"(hash-set table_3 key_0 val_1)))))"
"(values table_4)))"
" table_2))))))"
"(if(not #f)(for-loop_0 table_1(hash-iterate-next ht_0 i_0)) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first ht_0)))))))"
"(define-values"
"(struct:bulk-provide bulk-provide15.1 bulk-provide? bulk-provide-self bulk-provide-provides)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'bulk-provide #f 2 0 #f null(current-inspector) #f '(0 1) #f 'bulk-provide)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'self)"
"(make-struct-field-accessor -ref_0 1 'provides))))"
"(define-values"
"(struct:bulk-binding-registry bulk-binding-registry16.1 bulk-binding-registry? bulk-binding-registry-table)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'bulk-binding-registry"
" #f"
" 1"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'bulk-binding-registry)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'table))))"
"(define-values(make-bulk-binding-registry)(lambda()(begin(bulk-binding-registry16.1(make-hasheq)))))"
"(define-values"
"(register-bulk-provide!)"
"(lambda(bulk-binding-registry_0 mod-name_0 self_0 provides_0)"
"(begin"
"(hash-set!"
"(bulk-binding-registry-table bulk-binding-registry_0)"
" mod-name_0"
"(bulk-provide15.1 self_0 provides_0)))))"
"(define-values"
"(registered-bulk-provide?)"
"(lambda(bulk-binding-registry_0 mod-name_0)"
"(begin(if(hash-ref(bulk-binding-registry-table bulk-binding-registry_0) mod-name_0 #f) #t #f))))"
"(define-values(generate-lift-key)(lambda()(begin(gensym 'lift))))"
"(define-values"
"(struct:root-expand-context/outer"
" root-expand-context/outer1.1"
" root-expand-context/outer?"
" root-expand-context/outer-inner"
" root-expand-context/outer-post-expansion"
" root-expand-context/outer-use-site-scopes"
" root-expand-context/outer-frame-id)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'root-expand-context"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'root-expand-context/outer)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'inner)"
"(make-struct-field-accessor -ref_0 1 'post-expansion)"
"(make-struct-field-accessor -ref_0 2 'use-site-scopes)"
"(make-struct-field-accessor -ref_0 3 'frame-id))))"
"(define-values"
"(struct:root-expand-context/inner"
" root-expand-context/inner2.1"
" root-expand-context/inner?"
" root-expand-context/inner-self-mpi"
" root-expand-context/inner-module-scopes"
" root-expand-context/inner-top-level-bind-scope"
" root-expand-context/inner-all-scopes-stx"
" root-expand-context/inner-defined-syms"
" root-expand-context/inner-counter"
" root-expand-context/inner-lift-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'root-expand-context/inner"
" #f"
" 7"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'root-expand-context/inner)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'self-mpi)"
"(make-struct-field-accessor -ref_0 1 'module-scopes)"
"(make-struct-field-accessor -ref_0 2 'top-level-bind-scope)"
"(make-struct-field-accessor -ref_0 3 'all-scopes-stx)"
"(make-struct-field-accessor -ref_0 4 'defined-syms)"
"(make-struct-field-accessor -ref_0 5 'counter)"
"(make-struct-field-accessor -ref_0 6 'lift-key))))"
"(define-values"
"(root-expand-context/make)"
"(lambda(self-mpi_0"
" module-scopes_0"
" post-expansion_0"
" top-level-bind-scope_0"
" all-scopes-stx_0"
" use-site-scopes_0"
" defined-syms_0"
" frame-id_0"
" counter_0"
" lift-key_0)"
"(begin"
"(root-expand-context/outer1.1"
"(root-expand-context/inner2.1"
" self-mpi_0"
" module-scopes_0"
" top-level-bind-scope_0"
" all-scopes-stx_0"
" defined-syms_0"
" counter_0"
" lift-key_0)"
" post-expansion_0"
" use-site-scopes_0"
" frame-id_0))))"
"(define-values"
"(root-expand-context-post-expansion)"
"(lambda(v_0)(begin(root-expand-context/outer-post-expansion v_0))))"
"(define-values"
"(root-expand-context-use-site-scopes)"
"(lambda(v_0)(begin(root-expand-context/outer-use-site-scopes v_0))))"
"(define-values(root-expand-context-frame-id)(lambda(v_0)(begin(root-expand-context/outer-frame-id v_0))))"
"(define-values"
"(root-expand-context-self-mpi)"
"(lambda(v_0)(begin(root-expand-context/inner-self-mpi(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-module-scopes)"
"(lambda(v_0)(begin(root-expand-context/inner-module-scopes(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-top-level-bind-scope)"
"(lambda(v_0)(begin(root-expand-context/inner-top-level-bind-scope(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-all-scopes-stx)"
"(lambda(v_0)(begin(root-expand-context/inner-all-scopes-stx(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-defined-syms)"
"(lambda(v_0)(begin(root-expand-context/inner-defined-syms(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-counter)"
"(lambda(v_0)(begin(root-expand-context/inner-counter(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(root-expand-context-lift-key)"
"(lambda(v_0)(begin(root-expand-context/inner-lift-key(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(make-root-expand-context13.1)"
"(lambda(all-scopes-stx7_0 initial-scopes4_0 outside-scope5_0 post-expansion-scope6_0 self-mpi3_0)"
"(begin"
" 'make-root-expand-context13"
"(let-values(((self-mpi_0) self-mpi3_0))"
"(let-values(((initial-scopes_0) initial-scopes4_0))"
"(let-values(((outside-scope_0)"
"(if(eq? outside-scope5_0 unsafe-undefined) top-level-common-scope outside-scope5_0)))"
"(let-values(((post-expansion-scope_0)"
"(if(eq? post-expansion-scope6_0 unsafe-undefined)"
"(new-multi-scope 'top-level)"
" post-expansion-scope6_0)))"
"(let-values(((all-scopes-stx_0) all-scopes-stx7_0))"
"(let-values()"
"(let-values(((module-scopes_0)(list* post-expansion-scope_0 outside-scope_0 initial-scopes_0)))"
"(root-expand-context/make"
" self-mpi_0"
" module-scopes_0"
" post-expansion-scope_0"
"(new-scope 'module)"
"(let-values(((or-part_0) all-scopes-stx_0))"
"(if or-part_0 or-part_0(add-scopes empty-syntax module-scopes_0)))"
"(box null)"
"(make-hasheqv)"
"                     (string->uninterned-symbol \"root-frame\")"
"(box 0)"
"(generate-lift-key))))))))))))"
"(define-values"
"(apply-post-expansion)"
"(lambda(pe_0 s_0)"
"(begin"
"(if(not pe_0)"
"(let-values() s_0)"
"(if(shifted-multi-scope? pe_0)"
"(let-values()(push-scope s_0 pe_0))"
"(if(pair? pe_0)"
"(let-values()"
"(let-values(((temp18_0)(push-scope s_0(car pe_0)))((temp19_0)(cdr pe_0)))"
"(syntax-add-shifts44.1 #f temp18_0 temp19_0 #f)))"
"(let-values()(pe_0 s_0))))))))"
"(define-values"
"(post-expansion-scope)"
"(lambda(pe_0)"
"(begin"
"(if(shifted-multi-scope? pe_0)"
"(let-values() pe_0)"
"(if(pair? pe_0)"
"(let-values()(car pe_0))"
"          (let-values () (error 'post-expansion-scope \"internal error: cannot extract scope from ~s\" pe_0)))))))"
"(define-values"
"(root-expand-context-encode-for-module)"
"(lambda(ctx_0 orig-self_0 new-self_0)"
"(begin"
"(datum->syntax$1"
" #f"
"(vector"
"(add-scopes empty-syntax(root-expand-context-module-scopes ctx_0))"
"(apply-post-expansion(root-expand-context-post-expansion ctx_0) empty-syntax)"
"(let-values(((temp20_0)(root-expand-context-all-scopes-stx ctx_0))"
"((orig-self21_0) orig-self_0)"
"((new-self22_0) new-self_0))"
"(syntax-module-path-index-shift13.1 #f temp20_0 orig-self21_0 new-self22_0 #f))"
"(add-scopes empty-syntax(unbox(root-expand-context-use-site-scopes ctx_0)))"
"(let-values(((ht_0)(root-expand-context-defined-syms ctx_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 ht_1)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values phase_0 ht_1))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1(hash-iterate-next ht_0 i_0)) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
"(hash-iterate-first ht_0))))"
"(root-expand-context-frame-id ctx_0)"
"(unbox(root-expand-context-counter ctx_0)))))))"
"(define-values"
"(root-expand-context-decode-for-module)"
"(lambda(vec-s_0 self_0)"
"(begin"
"(let-values(((vec_0)(if(syntax?$1 vec-s_0)(syntax-e$1 vec-s_0) #f)))"
"(begin"
"(if(if(vector? vec_0)"
"(if(=(vector-length vec_0) 7)"
"(if(syntax?$1(vector-ref vec_0 0))"
"(if(syntax-with-one-scope?(vector-ref vec_0 1))"
"(if(syntax?$1(vector-ref vec_0 2))"
"(if(syntax?$1(vector-ref vec_0 3))"
"(if(defined-syms-hash?(syntax-e$1(vector-ref vec_0 4)))"
"(if(symbol?(syntax-e$1(vector-ref vec_0 5)))"
"(exact-nonnegative-integer?(syntax-e$1(vector-ref vec_0 6)))"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
"(void)"
"            (let-values () (error 'root-expand-context-decode-for-module \"bad encoding: ~s\" vec-s_0)))"
"(root-expand-context/make"
" self_0"
"(extract-scope-list(vector-ref vec_0 0))"
"(cons(extract-scope(vector-ref vec_0 1))(extract-shifts(vector-ref vec_0 1)))"
"(new-scope 'module)"
"(vector-ref vec_0 2)"
"(box(extract-scope-list(vector-ref vec_0 3)))"
"(unpack-defined-syms(vector-ref vec_0 4))"
"(syntax-e$1(vector-ref vec_0 5))"
"(box(syntax-e$1(vector-ref vec_0 6)))"
"(generate-lift-key)))))))"
"(define-values"
"(defined-syms-hash?)"
"(lambda(v_0)"
"(begin"
"(let-values(((ht_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 ht-s_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(if(phase? phase_0)"
"(if(hash?(syntax-e$1 ht-s_0))"
"(let-values(((ht_1)(syntax-e$1 ht-s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(result_1 i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((sym_0"
" id_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((result_2)"
"(let-values()"
"(let-values(((result_2)"
"(let-values()"
"(let-values()"
"(if(symbol?"
" sym_0)"
"(identifier?"
" id_0)"
" #f)))))"
"(values"
" result_2)))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_2))"
" sym_0"
" id_0))"
"(not #f)"
" #f)"
"(for-loop_1"
" result_2"
"(hash-iterate-next"
" ht_1"
" i_1))"
" result_2)))"
" result_1)))))"
" for-loop_1)"
" #t"
"(hash-iterate-first ht_1))))"
" #f)"
" #f)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) phase_0 ht-s_0))(not #f) #f)"
"(for-loop_0 result_1(hash-iterate-next ht_0 i_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
"(hash-iterate-first ht_0)))))))"
"(define-values"
"(extract-scope-list)"
"(lambda(stx_0)(begin(map2 generalize-scope(set->list(syntax-scope-set stx_0 0))))))"
"(define-values"
"(syntax-with-one-scope?)"
"(lambda(stx_0)(begin(if(syntax?$1 stx_0)(= 1(set-count(syntax-scope-set stx_0 0))) #f))))"
"(define-values"
"(extract-scope)"
"(lambda(stx_0)(begin(let-values(((s_0)(syntax-scope-set stx_0 0)))(generalize-scope(set-first s_0))))))"
"(define-values(extract-shifts)(lambda(stx_0)(begin(syntax-mpi-shifts stx_0))))"
"(define-values"
"(unpack-defined-syms)"
"(lambda(v_0)"
"(begin"
"(hash-copy"
"(let-values(((ht_0)(syntax-e$1 v_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 ht-s_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" phase_0"
"(hash-copy"
"(let-values(((ht_1)"
"(syntax-e$1"
" ht-s_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_2"
" i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((sym_0"
" id_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((table_3)"
"(let-values(((table_3)"
" table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" sym_0"
" id_0))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" table_3"
"(hash-iterate-next"
" ht_1"
" i_1))"
" table_3)))"
" table_2)))))"
" for-loop_1)"
" '#hash()"
"(hash-iterate-first"
" ht_1)))))))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1(hash-iterate-next ht_0 i_0)) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
"(hash-iterate-first ht_0))))))))"
"(define-values(1/primitive-table) primitive-table)"
"(define-values(1/primitive->compiled-position) primitive->compiled-position)"
"(define-values(1/compiled-position->primitive) compiled-position->primitive)"
"(define-values(1/primitive-in-category?) primitive-in-category?)"
"(define-values(1/linklet?) linklet?)"
"(define-values(1/compile-linklet) compile-linklet)"
"(define-values(1/recompile-linklet) recompile-linklet)"
"(define-values(1/eval-linklet) eval-linklet)"
"(define-values(1/instantiate-linklet) instantiate-linklet)"
"(define-values(1/linklet-import-variables) linklet-import-variables)"
"(define-values(1/linklet-export-variables) linklet-export-variables)"
"(define-values(1/instance?) instance?)"
"(define-values(1/make-instance) make-instance)"
"(define-values(1/instance-name) instance-name)"
"(define-values(1/instance-data) instance-data)"
"(define-values(1/instance-variable-names) instance-variable-names)"
"(define-values(1/instance-variable-value) instance-variable-value)"
"(define-values(1/instance-set-variable-value!) instance-set-variable-value!)"
"(define-values(1/instance-unset-variable!) instance-unset-variable!)"
"(define-values(1/instance-describe-variable!) instance-describe-variable!)"
"(define-values(1/linklet-virtual-machine-bytes) linklet-virtual-machine-bytes)"
"(define-values(1/write-linklet-bundle-hash) write-linklet-bundle-hash)"
"(define-values(1/read-linklet-bundle-hash) read-linklet-bundle-hash)"
"(define-values(1/variable-reference?) variable-reference?)"
"(define-values(1/variable-reference->instance) variable-reference->instance)"
"(define-values(1/variable-reference-constant?) variable-reference-constant?)"
"(define-values(1/variable-reference-from-unsafe?) variable-reference-from-unsafe?)"
"(void"
"(if 1/variable-reference-constant?"
"(void)"
"    (let-values () (error \"broken '#%linklet primitive table; maybe you need to use \\\"bootstrap-run.rkt\\\"\"))))"
"(define-values"
"(struct:module-registry module-registry1.1 module-registry? module-registry-declarations module-registry-lock-box)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-registry"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'module-registry)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'declarations)"
"(make-struct-field-accessor -ref_0 1 'lock-box))))"
"(define-values(make-module-registry)(lambda()(begin(module-registry1.1(make-hasheq)(box #f)))))"
"(define-values"
"(registry-call-with-lock)"
"(lambda(r_0 proc_0)"
"(begin"
"(let-values(((lock-box_0)(module-registry-lock-box r_0)))"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((v_0)(unbox lock-box_0)))"
"(if(let-values(((or-part_0)(not v_0)))"
"(if or-part_0 or-part_0(sync/timeout 0(car v_0)(cdr v_0))))"
"(let-values()"
"(let-values(((sema_0)(make-semaphore)))"
"(let-values(((lock_0)(cons(semaphore-peek-evt sema_0)(current-thread))))"
"((dynamic-wind"
" void"
"(lambda()"
"(if(box-cas! lock-box_0 v_0 lock_0)"
"(let-values()(begin(proc_0) void))"
"(let-values()(lambda()(loop_0)))))"
"(lambda()(semaphore-post sema_0)))))))"
"(if(eq?(current-thread)(cdr v_0))"
"(let-values()(proc_0))"
"(let-values()(begin(sync(car v_0)(cdr v_0))(loop_0))))))))))"
" loop_0))))))"
"(define-values"
"(struct:namespace"
" namespace1.1"
" 1/namespace?"
" namespace-mpi"
" namespace-source-name"
" namespace-root-expand-ctx"
" namespace-phase"
" namespace-0-phase"
" namespace-phase-to-namespace"
" namespace-phase-level-to-definitions"
" namespace-module-registry$1"
" namespace-bulk-binding-registry"
" namespace-submodule-declarations"
" namespace-root-namespace"
" namespace-declaration-inspector"
" namespace-inspector"
" namespace-available-module-instances"
" namespace-module-instances"
" set-namespace-inspector!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'namespace"
" #f"
" 15"
" 0"
" #f"
"(list"
"(cons prop:authentic #t)"
"(cons"
" prop:custom-write"
"(lambda(ns_0 port_0 mode_0)"
"                         (let-values ((() (begin (write-string \"#<namespace\" port_0) (values))))"
"(let-values(((n_0)(namespace-source-name ns_0)))"
"(let-values((()"
"(begin"
"(if n_0"
"                                               (let-values () (fprintf port_0 \":~a\" (namespace->name ns_0)))"
"(void))"
"(values))))"
"(let-values(((0-phase_0)(namespace-0-phase ns_0)))"
"(let-values(((phase-level_0)(phase-(namespace-phase ns_0) 0-phase_0)))"
"(begin"
"(if(zero-phase? phase-level_0)"
"(void)"
"                                       (let-values () (fprintf port_0 \":~s\" phase-level_0)))"
"(if(zero-phase? 0-phase_0)"
"(void)"
"(let-values()"
"                                         (fprintf port_0 \"~a~s\" (if (positive? 0-phase_0) \"+\" \"\") 0-phase_0)))"
"                                     (write-string \">\" port_0))))))))))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10 11 13 14)"
" #f"
" 'namespace)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'mpi)"
"(make-struct-field-accessor -ref_0 1 'source-name)"
"(make-struct-field-accessor -ref_0 2 'root-expand-ctx)"
"(make-struct-field-accessor -ref_0 3 'phase)"
"(make-struct-field-accessor -ref_0 4 '0-phase)"
"(make-struct-field-accessor -ref_0 5 'phase-to-namespace)"
"(make-struct-field-accessor -ref_0 6 'phase-level-to-definitions)"
"(make-struct-field-accessor -ref_0 7 'module-registry)"
"(make-struct-field-accessor -ref_0 8 'bulk-binding-registry)"
"(make-struct-field-accessor -ref_0 9 'submodule-declarations)"
"(make-struct-field-accessor -ref_0 10 'root-namespace)"
"(make-struct-field-accessor -ref_0 11 'declaration-inspector)"
"(make-struct-field-accessor -ref_0 12 'inspector)"
"(make-struct-field-accessor -ref_0 13 'available-module-instances)"
"(make-struct-field-accessor -ref_0 14 'module-instances)"
"(make-struct-field-mutator -set!_0 12 'inspector))))"
"(define-values"
"(struct:definitions definitions2.1 definitions? definitions-variables definitions-transformers)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'definitions"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'definitions)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'variables)"
"(make-struct-field-accessor -ref_0 1 'transformers))))"
"(define-values(make-namespace)(lambda()(begin(let-values()(new-namespace8.1 #t unsafe-undefined #f)))))"
"(define-values"
"(new-namespace8.1)"
"(lambda(register?4_0 root-expand-ctx3_0 share-from-ns7_0)"
"(begin"
" 'new-namespace8"
"(let-values(((share-from-ns_0) share-from-ns7_0))"
"(let-values(((root-expand-ctx_0)"
"(if(eq? root-expand-ctx3_0 unsafe-undefined)"
"(let-values(((top-level-module-path-index20_0) top-level-module-path-index))"
"(make-root-expand-context13.1"
" #f"
" null"
" unsafe-undefined"
" unsafe-undefined"
" top-level-module-path-index20_0))"
" root-expand-ctx3_0)))"
"(let-values(((register?_0) register?4_0))"
"(let-values()"
"(let-values(((phase_0)(if share-from-ns_0(namespace-phase share-from-ns_0) 0)))"
"(let-values(((ns_0)"
"(namespace1.1"
" top-level-module-path-index"
" #f"
"(box root-expand-ctx_0)"
" phase_0"
" phase_0"
"(make-small-hasheqv)"
"(make-small-hasheqv)"
"(if share-from-ns_0(namespace-module-registry$1 share-from-ns_0)(make-module-registry))"
"(if share-from-ns_0"
"(namespace-bulk-binding-registry share-from-ns_0)"
"(make-bulk-binding-registry))"
"(make-small-hasheq)"
"(if share-from-ns_0"
"(let-values(((or-part_0)(namespace-root-namespace share-from-ns_0)))"
"(if or-part_0 or-part_0 share-from-ns_0))"
" #f)"
" #f"
"(make-inspector(current-code-inspector))"
"(if share-from-ns_0"
"(namespace-available-module-instances share-from-ns_0)"
"(make-hasheqv))"
"(if share-from-ns_0(namespace-module-instances share-from-ns_0)(make-hasheqv)))))"
"(begin"
"(if register?_0"
"(let-values()(small-hash-set!(namespace-phase-to-namespace ns_0) phase_0 ns_0))"
"(void))"
" ns_0))))))))))"
"(define-values"
"(1/current-namespace)"
"(make-parameter"
"(make-namespace)"
"(lambda(v_0)"
"(begin"
"       (if (1/namespace? v_0) (void) (let-values () (raise-argument-error 'current-namespace \"namespace?\" v_0)))"
" v_0))))"
"(define-values"
"(namespace-get-root-expand-ctx)"
"(lambda(ns_0)(begin(force(unbox(namespace-root-expand-ctx ns_0))))))"
"(define-values"
"(namespace-set-root-expand-ctx!)"
"(lambda(ns_0 root-ctx_0)(begin(set-box!(namespace-root-expand-ctx ns_0) root-ctx_0))))"
"(define-values"
"(namespace-self-mpi)"
"(lambda(ns_0)(begin(root-expand-context-self-mpi(namespace-get-root-expand-ctx ns_0)))))"
"(define-values"
"(namespace->module)"
"(lambda(ns_0 name_0)"
"(begin"
"(let-values(((or-part_0)(small-hash-ref(namespace-submodule-declarations ns_0) name_0 #f)))"
"(if or-part_0"
" or-part_0"
"(hash-ref(module-registry-declarations(namespace-module-registry$1 ns_0)) name_0 #f))))))"
"(define-values"
"(namespace->namespace-at-phase)"
"(lambda(ns_0 phase_0)"
"(begin"
"(let-values(((or-part_0)(small-hash-ref(namespace-phase-to-namespace ns_0) phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((p-ns_0)"
"(let-values(((the-struct_0) ns_0))"
"(if(1/namespace? the-struct_0)"
"(let-values(((phase21_0) phase_0)"
"((root-namespace22_0)"
"(let-values(((or-part_1)(namespace-root-namespace ns_0)))"
"(if or-part_1 or-part_1 ns_0))))"
"(namespace1.1"
"(namespace-mpi the-struct_0)"
"(namespace-source-name the-struct_0)"
"(namespace-root-expand-ctx the-struct_0)"
" phase21_0"
"(namespace-0-phase the-struct_0)"
"(namespace-phase-to-namespace the-struct_0)"
"(namespace-phase-level-to-definitions the-struct_0)"
"(namespace-module-registry$1 the-struct_0)"
"(namespace-bulk-binding-registry the-struct_0)"
"(namespace-submodule-declarations the-struct_0)"
" root-namespace22_0"
"(namespace-declaration-inspector the-struct_0)"
"(namespace-inspector the-struct_0)"
"(namespace-available-module-instances the-struct_0)"
"(namespace-module-instances the-struct_0)))"
"                            (raise-argument-error 'struct-copy \"namespace?\" the-struct_0)))))"
"(begin(small-hash-set!(namespace-phase-to-namespace ns_0) phase_0 p-ns_0) p-ns_0)))))))"
"(define-values"
"(namespace->name)"
"(lambda(ns_0)"
"(begin"
"(let-values(((n_0)(namespace-source-name ns_0)))"
"(let-values(((s_0)"
"(if(not n_0)"
"(let-values() 'top-level)"
"(if(symbol? n_0)"
"                          (let-values () (format \"'~s\" n_0))"
"                          (let-values () (string-append \"\\\"\" (path->string n_0) \"\\\"\"))))))"
"(let-values(((r_0)(1/resolved-module-path-name(1/module-path-index-resolve(namespace-mpi ns_0)))))"
"            (if (pair? r_0) (string-append \"(submod \" s_0 \" \" (substring (format \"~s\" (cdr r_0)) 1)) s_0)))))))"
"(define-values"
"(namespace->definitions)"
"(lambda(ns_0 phase-level_0)"
"(begin"
"(let-values(((d_0)(small-hash-ref(namespace-phase-level-to-definitions ns_0) phase-level_0 #f)))"
"(let-values(((or-part_0) d_0))"
"(if or-part_0"
" or-part_0"
"(let-values()"
"(let-values(((p-ns_0)"
"(namespace->namespace-at-phase ns_0(phase+(namespace-0-phase ns_0) phase-level_0))))"
"(let-values(((d_1)(definitions2.1(1/make-instance(namespace->name p-ns_0) p-ns_0)(make-hasheq))))"
"(begin(small-hash-set!(namespace-phase-level-to-definitions ns_0) phase-level_0 d_1) d_1))))))))))"
"(define-values"
"(namespace-set-variable!)"
"(let-values(((namespace-set-variable!16_0)"
"(lambda(ns12_0 phase-level13_0 name14_0 val15_0 as-constant?11_0)"
"(begin"
" 'namespace-set-variable!16"
"(let-values(((ns_0) ns12_0))"
"(let-values(((phase-level_0) phase-level13_0))"
"(let-values(((name_0) name14_0))"
"(let-values(((val_0) val15_0))"
"(let-values(((as-constant?_0) as-constant?11_0))"
"(let-values()"
"(let-values(((d_0)(namespace->definitions ns_0 phase-level_0)))"
"(1/instance-set-variable-value!"
"(definitions-variables d_0)"
" name_0"
" val_0"
"(if as-constant?_0 'constant #f)))))))))))))"
"(case-lambda"
"((ns_0 phase-level_0 name_0 val_0)(begin(namespace-set-variable!16_0 ns_0 phase-level_0 name_0 val_0 #f)))"
"((ns_0 phase-level_0 name_0 val_0 as-constant?11_0)"
"(namespace-set-variable!16_0 ns_0 phase-level_0 name_0 val_0 as-constant?11_0)))))"
"(define-values"
"(namespace-set-consistent!)"
"(lambda(ns_0 phase-level_0 name_0 val_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0 phase-level_0)))"
"(1/instance-set-variable-value!(definitions-variables d_0) name_0 val_0 'consistent)))))"
"(define-values"
"(namespace-unset-variable!)"
"(lambda(ns_0 phase-level_0 name_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0 phase-level_0)))"
"(1/instance-unset-variable!(definitions-variables d_0) name_0)))))"
"(define-values"
"(namespace-set-transformer!)"
"(lambda(ns_0 phase-level_0 name_0 val_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0(add1 phase-level_0))))"
"(hash-set!(definitions-transformers d_0) name_0 val_0)))))"
"(define-values"
"(namespace-unset-transformer!)"
"(lambda(ns_0 phase-level_0 name_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0(add1 phase-level_0))))"
"(hash-remove!(definitions-transformers d_0) name_0)))))"
"(define-values"
"(namespace-get-variable)"
"(lambda(ns_0 phase-level_0 name_0 fail-k_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0 phase-level_0)))"
"(1/instance-variable-value(definitions-variables d_0) name_0 fail-k_0)))))"
"(define-values"
"(namespace-get-transformer)"
"(lambda(ns_0 phase-level_0 name_0 fail-k_0)"
"(begin"
"(let-values(((d_0)(namespace->definitions ns_0(add1 phase-level_0))))"
"(hash-ref(definitions-transformers d_0) name_0 fail-k_0)))))"
"(define-values"
"(namespace->instance)"
"(lambda(ns_0 phase-shift_0)(begin(definitions-variables(namespace->definitions ns_0 phase-shift_0)))))"
"(define-values"
"(namespace-same-instance?)"
"(lambda(a-ns_0 b-ns_0)"
"(begin"
"(eq?"
"(small-hash-ref(namespace-phase-level-to-definitions a-ns_0) 0 'no-a)"
"(small-hash-ref(namespace-phase-level-to-definitions b-ns_0) 0 'no-b)))))"
"(define-values(original-property-sym)(gensym 'original))"
"(define-values"
"(syntax->list$1)"
"(lambda(s_0)"
"(begin"
" 'syntax->list"
"(let-values(((l_0)"
"((letrec-values(((loop_0)"
"(lambda(s_1)"
"(begin"
" 'loop"
"(if(pair? s_1)"
"(let-values()(cons(car s_1)(loop_0(cdr s_1))))"
"(if(syntax?$1 s_1)"
"(let-values()(loop_0(syntax-e$1 s_1)))"
"(let-values() s_1)))))))"
" loop_0)"
" s_0)))"
"(if(list? l_0) l_0 #f)))))"
"(define-values(missing$1)(gensym))"
"(define-values"
"(syntax-track-origin$1)"
"(let-values(((syntax-track-origin4_0)"
"(lambda(new-stx2_0 old-stx3_0 id1_0)"
"(begin"
" 'syntax-track-origin4"
"(let-values(((new-stx_0) new-stx2_0))"
"(let-values(((old-stx_0) old-stx3_0))"
"(let-values(((id_0)"
"(if(eq? id1_0 unsafe-undefined)"
"(if(identifier? old-stx_0)"
" old-stx_0"
"(let-values(((v_0)(syntax-e/no-taint old-stx_0)))"
"(if(pair? v_0)(car v_0) #f)))"
" id1_0)))"
"(let-values()"
"(let-values(((old-props_0)(syntax-props old-stx_0)))"
"(if(zero?(hash-count old-props_0))"
"(let-values()"
"(if id_0"
"(syntax-property$1"
" new-stx_0"
" 'origin"
"(cons id_0(hash-ref(syntax-props new-stx_0) 'origin null)))"
" new-stx_0))"
"(let-values()"
"(let-values(((new-props_0)(syntax-props new-stx_0)))"
"(if(zero?(hash-count new-props_0))"
"(let-values()"
"(if id_0"
"(let-values()"
"(let-values(((old-origin_0)"
"(plain-property-value"
"(hash-ref old-props_0 'origin missing$1))))"
"(let-values(((origin_0)"
"(if(eq? old-origin_0 missing$1)"
"(list id_0)"
"(cons id_0 old-origin_0))))"
"(let-values(((the-struct_0) new-stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props6_0)(hash-set old-props_0 'origin origin_0)))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
" props6_0"
"(syntax-inspector the-struct_0)))"
"                                                    (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"(let-values()"
"(let-values(((the-struct_0) new-stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props7_0) old-props_0))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
" props7_0"
"(syntax-inspector the-struct_0)))"
"                                                (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"(let-values()"
"(let-values(((old-props-with-origin_0)"
"(if id_0"
"(hash-set"
" old-props_0"
" 'origin"
"(cons id_0(hash-ref old-props_0 'origin null)))"
" old-props_0)))"
"(let-values(((updated-props_0)"
"(if(<"
"(hash-count old-props-with-origin_0)"
"(hash-count new-props_0))"
"(let-values()"
"(let-values(((ht_0) old-props-with-origin_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(new-props_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((new-props_2)"
"(let-values(((new-props_2)"
" new-props_1))"
"(let-values(((new-props_3)"
"(let-values()"
"(let-values(((new-v_0)"
"(hash-ref"
" new-props_2"
" k_0"
" missing$1)))"
"(hash-set"
" new-props_2"
" k_0"
"(if(eq?"
" new-v_0"
" missing$1)"
" v_0"
"(cons/preserve"
" new-v_0"
" v_0)))))))"
"(values"
" new-props_3)))))"
"(if(not #f)"
"(for-loop_0"
" new-props_2"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
" new-props_2)))"
" new-props_1)))))"
" for-loop_0)"
" new-props_0"
"(unsafe-immutable-hash-iterate-first ht_0)))))"
"(let-values()"
"(let-values(((ht_0) new-props_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(old-props_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)"
"(unsafe-immutable-hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((old-props_2)"
"(let-values(((old-props_2)"
" old-props_1))"
"(let-values(((old-props_3)"
"(let-values()"
"(let-values(((old-v_0)"
"(hash-ref"
" old-props_2"
" k_0"
" missing$1)))"
"(hash-set"
" old-props_2"
" k_0"
"(if(eq?"
" old-v_0"
" missing$1)"
" v_0"
"(cons/preserve"
" v_0"
" old-v_0)))))))"
"(values"
" old-props_3)))))"
"(if(not #f)"
"(for-loop_0"
" old-props_2"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
" old-props_2)))"
" old-props_1)))))"
" for-loop_0)"
" old-props-with-origin_0"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(let-values(((the-struct_0) new-stx_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((props8_0) updated-props_0))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
"(syntax-srcloc the-struct_0)"
" props8_0"
"(syntax-inspector the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                 \"syntax?\""
" the-struct_0)))))))))))))))))))"
"(case-lambda"
"((new-stx_0 old-stx_0)(begin 'syntax-track-origin(syntax-track-origin4_0 new-stx_0 old-stx_0 unsafe-undefined)))"
"((new-stx_0 old-stx_0 id1_0)(syntax-track-origin4_0 new-stx_0 old-stx_0 id1_0)))))"
"(define-values"
"(cons/preserve)"
"(lambda(a_0 b_0)"
"(begin"
"(if(let-values(((or-part_0)(preserved-property-value? a_0)))"
"(if or-part_0 or-part_0(preserved-property-value? b_0)))"
"(preserved-property-value1.1(cons(plain-property-value a_0)(plain-property-value b_0)))"
"(cons a_0 b_0)))))"
"(define-values"
"(syntax-track-origin*)"
"(lambda(old-stxes_0 new-stx_0)"
"(begin"
"(let-values(((lst_0) old-stxes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(new-stx_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((old-stx_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((new-stx_2)"
"(let-values(((new-stx_2) new-stx_1))"
"(let-values(((new-stx_3)"
"(let-values()"
"(syntax-track-origin$1 new-stx_2 old-stx_0))))"
"(values new-stx_3)))))"
"(if(not #f)(for-loop_0 new-stx_2 rest_0) new-stx_2)))"
" new-stx_1)))))"
" for-loop_0)"
" new-stx_0"
" lst_0))))))"
"(define-values"
"(struct:syntax-binding-set syntax-binding-set1.1 1/syntax-binding-set? syntax-binding-set-binds)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'syntax-binding-set"
" #f"
" 1"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'syntax-binding-set)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'binds))))"
"(define-values"
"(struct:bind bind2.1 bind? bind-sym bind-phase bind-binding)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'bind #f 3 0 #f null(current-inspector) #f '(0 1 2) #f 'bind)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'sym)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'binding))))"
"(define-values"
"(syntax-binding-set-extend$1)"
"(lambda(bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase_0"
" nominal-sym_0"
" nominal-require-phase_0"
" inspector_0)"
"(begin"
" 'syntax-binding-set-extend"
"(let-values(((the-struct_0) bs_0))"
"(if(1/syntax-binding-set? the-struct_0)"
"(let-values(((binds5_0)"
"(cons"
"(bind2.1"
" as-sym_0"
" as-phase_0"
"(let-values(((mpi6_0) mpi_0)"
"((phase7_0) phase_0)"
"((sym8_0) sym_0)"
"((inspector9_0) inspector_0)"
"((nominal-mpi10_0) nominal-mpi_0)"
"((nominal-phase11_0) nominal-phase_0)"
"((nominal-sym12_0) nominal-sym_0)"
"((nominal-require-phase13_0) nominal-require-phase_0))"
"(make-module-binding20.1"
" inspector9_0"
" null"
" #f"
" #f"
" nominal-mpi10_0"
" nominal-phase11_0"
" nominal-require-phase13_0"
" nominal-sym12_0"
" mpi6_0"
" phase7_0"
" sym8_0)))"
"(syntax-binding-set-binds bs_0))))"
"(syntax-binding-set1.1 binds5_0))"
"          (raise-argument-error 'struct-copy \"syntax-binding-set?\" the-struct_0))))))"
"(define-values"
"(syntax-binding-set->syntax$1)"
"(lambda(bs_0 datum_0)"
"(begin"
" 'syntax-binding-set->syntax"
"(let-values(((s_0)(add-scope(datum->syntax$1 #f datum_0)(new-multi-scope 'binding-set))))"
"(begin"
"(let-values(((lst_0)(syntax-binding-set-binds bs_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((bind_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((temp14_0)"
"(syntax-scope-set"
" s_0"
"(bind-phase bind_0)))"
"((temp15_0)(bind-sym bind_0))"
"((temp16_0)"
"(bind-binding bind_0)))"
"(add-binding-in-scopes!20.1"
" #f"
" temp14_0"
" temp15_0"
" temp16_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
" s_0)))))"
"(define-values"
"(1/struct:exn:fail:syntax make-exn:fail:syntax$1 1/exn:fail:syntax? 1/exn:fail:syntax-exprs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'exn:fail:syntax"
" struct:exn:fail"
" 1"
" 0"
" #f"
"(list"
"(cons"
" prop:exn:srclocs"
"(lambda(e_0)(filter values(map2 syntax-srcloc(1/exn:fail:syntax-exprs e_0))))))"
" #f"
" #f"
" '(0)"
"(lambda(str_0 cm_0 exprs_0 info_0)"
"(begin"
"(if(if(list? exprs_0)(andmap2 syntax?$1 exprs_0) #f)"
"(void)"
"                           (let-values () (raise-argument-error 'exn:fail:syntax \"(listof syntax?)\" exprs_0)))"
"(values str_0 cm_0 exprs_0)))"
" 'exn:fail:syntax)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'exprs))))"
"(define-values"
"(1/struct:exn:fail:syntax:unbound make-exn:fail:syntax:unbound$1 1/exn:fail:syntax:unbound?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'exn:fail:syntax:unbound"
" 1/struct:exn:fail:syntax"
" 0"
" 0"
" #f"
" null"
" #f"
" #f"
" '()"
" #f"
" 'exn:fail:syntax:unbound)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(raise-syntax-error$1)"
"(let-values(((raise-syntax-error7_0)"
"(lambda(given-name5_0 message6_0 expr1_0 sub-expr2_0 extra-sources3_0 message-suffix4_0)"
"(begin"
" 'raise-syntax-error7"
"(let-values(((given-name_0) given-name5_0))"
"(let-values(((message_0) message6_0))"
"(let-values(((expr_0) expr1_0))"
"(let-values(((sub-expr_0) sub-expr2_0))"
"(let-values(((extra-sources_0) extra-sources3_0))"
"(let-values(((message-suffix_0) message-suffix4_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(do-raise-syntax-error"
" 'raise-syntax-error"
" make-exn:fail:syntax$1"
" given-name_0"
" message_0"
" expr_0"
" sub-expr_0"
" extra-sources_0"
" message-suffix_0))))))))))))))"
"(case-lambda"
"     ((given-name_0 message_0) (begin 'raise-syntax-error (raise-syntax-error7_0 given-name_0 message_0 #f #f null \"\")))"
"((given-name_0 message_0 expr_0 sub-expr_0 extra-sources_0 message-suffix4_0)"
"(raise-syntax-error7_0 given-name_0 message_0 expr_0 sub-expr_0 extra-sources_0 message-suffix4_0))"
"((given-name_0 message_0 expr_0 sub-expr_0 extra-sources3_0)"
"      (raise-syntax-error7_0 given-name_0 message_0 expr_0 sub-expr_0 extra-sources3_0 \"\"))"
"((given-name_0 message_0 expr_0 sub-expr2_0)"
"      (raise-syntax-error7_0 given-name_0 message_0 expr_0 sub-expr2_0 null \"\"))"
"     ((given-name_0 message_0 expr1_0) (raise-syntax-error7_0 given-name_0 message_0 expr1_0 #f null \"\")))))"
"(define-values"
"(raise-unbound-syntax-error)"
"(let-values(((raise-unbound-syntax-error15_0)"
"(lambda(given-name13_0 message14_0 expr9_0 sub-expr10_0 extra-sources11_0 message-suffix12_0)"
"(begin"
" 'raise-unbound-syntax-error15"
"(let-values(((given-name_0) given-name13_0))"
"(let-values(((message_0) message14_0))"
"(let-values(((expr_0) expr9_0))"
"(let-values(((sub-expr_0) sub-expr10_0))"
"(let-values(((extra-sources_0) extra-sources11_0))"
"(let-values(((message-suffix_0) message-suffix12_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(do-raise-syntax-error"
" 'raise-unbound-syntax-error"
" make-exn:fail:syntax:unbound$1"
" given-name_0"
" message_0"
" expr_0"
" sub-expr_0"
" extra-sources_0"
" message-suffix_0))))))))))))))"
"(case-lambda"
"     ((given-name_0 message_0) (begin (raise-unbound-syntax-error15_0 given-name_0 message_0 #f #f null \"\")))"
"((given-name_0 message_0 expr_0 sub-expr_0 extra-sources_0 message-suffix12_0)"
"(raise-unbound-syntax-error15_0 given-name_0 message_0 expr_0 sub-expr_0 extra-sources_0 message-suffix12_0))"
"((given-name_0 message_0 expr_0 sub-expr_0 extra-sources11_0)"
"      (raise-unbound-syntax-error15_0 given-name_0 message_0 expr_0 sub-expr_0 extra-sources11_0 \"\"))"
"((given-name_0 message_0 expr_0 sub-expr10_0)"
"      (raise-unbound-syntax-error15_0 given-name_0 message_0 expr_0 sub-expr10_0 null \"\"))"
"     ((given-name_0 message_0 expr9_0) (raise-unbound-syntax-error15_0 given-name_0 message_0 expr9_0 #f null \"\")))))"
"(define-values"
"(do-raise-syntax-error)"
"(lambda(who_0 exn:fail:syntax_0 given-name_0 message_0 expr_0 sub-expr_0 extra-sources_0 message-suffix_0)"
"(begin"
"(let-values((()"
"(begin"
"(if((lambda(x_0)(let-values(((or-part_0)(not x_0)))(if or-part_0 or-part_0(symbol? x_0))))"
" given-name_0)"
"(void)"
"                        (let-values () (raise-argument-error who_0 \"(or/c symbol? #f)\" given-name_0)))"
"(values))))"
"(let-values((()"
"(begin"
"                        (if (string? message_0) (void) (let-values () (raise-argument-error who_0 \"string?\" message_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(if(list? extra-sources_0)(andmap2 syntax?$1 extra-sources_0) #f)"
"(void)"
"                            (let-values () (raise-argument-error who_0 \"(listof syntax?)\" extra-sources_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(string? message-suffix_0)"
"(void)"
"                              (let-values () (raise-argument-error who_0 \"string?\" message-suffix_0)))"
"(values))))"
"(let-values(((name_0)"
"(format"
"                             \"~a\""
"(let-values(((or-part_0) given-name_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(extract-form-name expr_0)))"
"(if or-part_1 or-part_1 '?)))))))"
"(let-values(((unbound-message_0)"
"(let-values(((ids_0)(current-previously-unbound)))"
"(let-values(((or-part_0)"
"(if(pair? ids_0)"
"(format"
"                                                 \"\\n  after encountering unbound identifier~a (which is possibly the real problem):~a\""
"                                                 (if (null? (cdr ids_0)) \"\" \"s\")"
"(apply"
" string-append"
"(reverse$1"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(format"
"                                                                                                                     \"\\n   ~s\""
"(syntax-e$1"
" id_0)))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
" #f)))"
"                                  (if or-part_0 or-part_0 \"\")))))"
"(let-values(((at-message_0)"
"(let-values(((or-part_0)"
"(if sub-expr_0"
"(if(error-print-source-location)"
"(format"
"                                                   \"\\n  at: ~.s\""
"(syntax->datum$1(datum->syntax$1 #f sub-expr_0)))"
" #f)"
" #f)))"
"                                  (if or-part_0 or-part_0 \"\"))))"
"(let-values(((in-message_0)"
"(let-values(((or-part_0)"
"(if expr_0"
"(if(error-print-source-location)"
"                                                    (format \"\\n  in: ~.s\" (syntax->datum$1 (datum->syntax$1 #f expr_0)))"
" #f)"
" #f)))"
"                                    (if or-part_0 or-part_0 \"\"))))"
"(let-values(((src-loc-str_0)"
"(let-values(((or-part_0)"
"(if(error-print-source-location)"
"(let-values(((or-part_0)(extract-source-location sub-expr_0)))"
"(if or-part_0 or-part_0(extract-source-location expr_0)))"
" #f)))"
"                                      (if or-part_0 or-part_0 \"\"))))"
"(raise"
"(exn:fail:syntax_0"
"(string-append"
" src-loc-str_0"
" name_0"
"                           \": \""
" message_0"
" unbound-message_0"
" at-message_0"
" in-message_0"
" message-suffix_0)"
"(current-continuation-marks)"
"(map2"
" syntax-taint$1"
"(if(let-values(((or-part_0) sub-expr_0))(if or-part_0 or-part_0 expr_0))"
"(cons"
"(datum->syntax$1"
" #f"
"(let-values(((or-part_0) sub-expr_0))(if or-part_0 or-part_0 expr_0)))"
" extra-sources_0)"
" extra-sources_0))))))))))))))))"
"(define-values"
"(extract-form-name)"
"(lambda(s_0)"
"(begin"
"(if(syntax?$1 s_0)"
"(let-values()"
"(let-values(((e_0)(syntax-e$1 s_0)))"
"(if(symbol? e_0)"
"(let-values() e_0)"
"(if(if(pair? e_0)(identifier?(car e_0)) #f)"
"(let-values()(syntax-e$1(car e_0)))"
"(let-values() #f)))))"
"(let-values() #f)))))"
"(define-values"
"(extract-source-location)"
"(lambda(s_0)"
"(begin"
"(if(syntax?$1 s_0)"
"(if(syntax-srcloc s_0)"
"          (let-values (((str_0) (srcloc->string (syntax-srcloc s_0)))) (if str_0 (string-append str_0 \": \") #f))"
" #f)"
" #f))))"
"(define-values(current-previously-unbound)(lambda()(begin #f)))"
"(define-values(set-current-previously-unbound!)(lambda(proc_0)(begin(set! current-previously-unbound proc_0))))"
"(define-values"
"(log-performance?)"
"  (if (environment-variables-ref (current-environment-variables) #\"PLT_EXPANDER_TIMES\") #t #f))"
"(define-values(cell.1$4)(unsafe-make-place-local #f))"
"(define-values(cell.2$2)(unsafe-make-place-local(make-hasheq)))"
"(define-values(performance-place-init!)(lambda()(begin(unsafe-place-local-set! cell.2$2(make-hasheq)))))"
"(define-values"
"(struct:region"
" region1.1"
" region?"
" region-path"
" region-start"
" region-start-memory"
" region-as-nested"
" region-as-nested-memory"
" set-region-start!"
" set-region-start-memory!"
" set-region-as-nested!"
" set-region-as-nested-memory!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'region #f 5 0 #f null(current-inspector) #f '(0) #f 'region)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'path)"
"(make-struct-field-accessor -ref_0 1 'start)"
"(make-struct-field-accessor -ref_0 2 'start-memory)"
"(make-struct-field-accessor -ref_0 3 'as-nested)"
"(make-struct-field-accessor -ref_0 4 'as-nested-memory)"
"(make-struct-field-mutator -set!_0 1 'start)"
"(make-struct-field-mutator -set!_0 2 'start-memory)"
"(make-struct-field-mutator -set!_0 3 'as-nested)"
"(make-struct-field-mutator -set!_0 4 'as-nested-memory))))"
"(define-values"
"(struct:stat stat2.1 stat? stat-msecs stat-memory stat-count set-stat-msecs! set-stat-memory! set-stat-count!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'stat #f 3 0 #f null(current-inspector) #f '() #f 'stat)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'msecs)"
"(make-struct-field-accessor -ref_0 1 'memory)"
"(make-struct-field-accessor -ref_0 2 'count)"
"(make-struct-field-mutator -set!_0 0 'msecs)"
"(make-struct-field-mutator -set!_0 1 'memory)"
"(make-struct-field-mutator -set!_0 2 'count))))"
"(define-values(stat-key)(gensym))"
"(define-values"
"(start-performance-region)"
"(lambda path_0"
"(begin"
"(unsafe-place-local-set!"
" cell.1$4"
"(cons"
"(region1.1"
"(if(unsafe-place-local-ref cell.1$4)"
"((letrec-values(((loop_0)"
"(lambda(path_1 enclosing-path_0)"
"(begin"
" 'loop"
"(if(null? path_1)"
" null"
"(cons"
"(if(if(eq? '_(car path_1))(pair? enclosing-path_0) #f)"
"(car enclosing-path_0)"
"(car path_1))"
"(loop_0"
"(cdr path_1)"
"(if(pair? enclosing-path_0)(cdr enclosing-path_0) null))))))))"
" loop_0)"
" path_0"
"(region-path(car(unsafe-place-local-ref cell.1$4))))"
" path_0)"
"(current-inexact-milliseconds)"
"(current-memory-use 'cumulative)"
" 0.0"
" 0)"
"(unsafe-place-local-ref cell.1$4))))))"
"(define-values"
"(end-performance-region)"
"(lambda()"
"(begin"
"(let-values(((now_0)(current-inexact-milliseconds)))"
"(let-values(((now-memory_0)(current-memory-use 'cumulative)))"
"(let-values(((r_0)(car(unsafe-place-local-ref cell.1$4))))"
"(let-values((()"
"(begin(unsafe-place-local-set! cell.1$4(cdr(unsafe-place-local-ref cell.1$4)))(values))))"
"(let-values(((full-delta_0)(- now_0(region-start r_0))))"
"(let-values(((delta_0)(- full-delta_0(region-as-nested r_0))))"
"(let-values(((full-delta-memory_0)(- now-memory_0(region-start-memory r_0))))"
"(let-values(((delta-memory_0)(- full-delta-memory_0(region-as-nested-memory r_0))))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(accums_0 path_0)"
"(begin"
" 'loop"
"(let-values(((key_0)(car path_0)))"
"(let-values(((accum_0)"
"(let-values(((or-part_0)(hash-ref accums_0 key_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((accum_0)(make-hasheq)))"
"(begin"
"(hash-set! accums_0 key_0 accum_0)"
" accum_0))))))"
"(let-values(((s_0)"
"(let-values(((or-part_0)"
"(hash-ref accum_0 stat-key #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((s_0)(stat2.1 0.0 0 0)))"
"(begin(hash-set! accum_0 stat-key s_0) s_0))))))"
"(begin"
"(set-stat-msecs! s_0(+ delta_0(stat-msecs s_0)))"
"(set-stat-memory! s_0(+ delta-memory_0(stat-memory s_0)))"
"(if(null?(cdr path_0))"
"(let-values()(set-stat-count! s_0(add1(stat-count s_0))))"
"(void))"
"(if(null?(cdr path_0))"
"(void)"
"(let-values()(loop_0 accum_0(cdr path_0))))))))))))"
" loop_0)"
"(unsafe-place-local-ref cell.2$2)"
"(region-path r_0))"
"(if(unsafe-place-local-ref cell.1$4)"
"(let-values()"
"(begin"
"(set-region-as-nested!"
"(car(unsafe-place-local-ref cell.1$4))"
"(+(region-as-nested(car(unsafe-place-local-ref cell.1$4))) full-delta_0))"
"(set-region-as-nested-memory!"
"(car(unsafe-place-local-ref cell.1$4))"
"(+"
"(region-as-nested-memory(car(unsafe-place-local-ref cell.1$4)))"
" full-delta-memory_0))))"
"(void))))))))))))))"
"(call-with-values"
"(lambda()"
"(if log-performance?"
"(let-values()"
"(void"
"(plumber-add-flush!"
"(current-plumber)"
"(lambda(h_0)"
"(let-values(((whole-len_0)"
"(lambda(s_0)"
"(begin"
" 'whole-len"
"(caar"
"                               (let-values (((or-part_0) (regexp-match-positions '#rx\"[.]\" s_0)))"
"(if or-part_0 or-part_0 '(0))))))))"
"(let-values(((kb_0)"
"(lambda(b_0)"
"(begin"
" 'kb"
"(let-values(((s_0)(number->string(quotient b_0 1024))))"
"(list->string"
"(let-values(((lst_0)(reverse$1(string->list s_0)))((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(l_0 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((c_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((i_0) pos_0))"
"(let-values(((l_1)"
"(let-values(((l_1) l_0))"
"(let-values(((l_2)"
"(let-values()"
"(if(if(positive? i_0)"
"(zero?"
"(modulo i_0 3))"
" #f)"
"(let-values()"
"(list*"
" c_0"
" '#\\,"
" l_1))"
"(let-values()"
"(cons c_0 l_1))))))"
"(values l_2)))))"
"(if(not #f)"
"(for-loop_0 l_1 rest_0(+ pos_0 1))"
" l_1)))"
" l_0)))))"
" for-loop_0)"
" null"
" lst_0"
" start_0)))))))))"
"(let-values(((label-max-len_0 value-max-len_0 memory-max-len_0 count-max-len_0)"
"((letrec-values(((loop_0)"
"(lambda(accums_0"
" label-len_0"
" value-len_0"
" memory-len_0"
" count-len_0"
" indent_0)"
"(begin"
" 'loop"
"(let-values(((ht_0) accums_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(label-len_1"
" value-len_1"
" memory-len_1"
" count-len_1"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((label-len_2"
" value-len_2"
" memory-len_2"
" count-len_2)"
"(let-values(((label-len_2)"
" label-len_1)"
"((value-len_2)"
" value-len_1)"
"((memory-len_2)"
" memory-len_1)"
"((count-len_2)"
" count-len_1))"
"(let-values(((label-len_3"
" value-len_3"
" memory-len_3"
" count-len_3)"
"(let-values()"
"(if(eq?"
" k_0"
" stat-key)"
"(let-values()"
"(values"
" label-len_2"
"(max"
" value-len_2"
"(whole-len_0"
"(format"
"                                                                                                                          \"~a\""
"(stat-msecs"
" v_0))))"
"(max"
" memory-len_2"
"(string-length"
"(format"
"                                                                                                                          \"~a\""
"(kb_0"
"(stat-memory"
" v_0)))))"
"(max"
" count-len_2"
"(string-length"
"(format"
"                                                                                                                          \"~a\""
"(stat-count"
" v_0))))))"
"(let-values()"
"(loop_0"
" v_0"
"(max"
" label-len_2"
"(+"
" indent_0"
"(string-length"
"(format"
"                                                                                                                           \"~a\""
" k_0))))"
" value-len_2"
" memory-len_2"
" count-len_2"
"(+"
" 2"
" indent_0)))))))"
"(values"
" label-len_3"
" value-len_3"
" memory-len_3"
" count-len_3)))))"
"(if(not #f)"
"(for-loop_0"
" label-len_2"
" value-len_2"
" memory-len_2"
" count-len_2"
"(hash-iterate-next ht_0 i_0))"
"(values"
" label-len_2"
" value-len_2"
" memory-len_2"
" count-len_2))))"
"(values"
" label-len_1"
" value-len_1"
" memory-len_1"
" count-len_1))))))"
" for-loop_0)"
" label-len_0"
" value-len_0"
" memory-len_0"
" count-len_0"
"(hash-iterate-first ht_0))))))))"
" loop_0)"
"(unsafe-place-local-ref cell.2$2)"
" 6"
" 5"
" 4"
" 5"
" 2)))"
"(begin"
"(let-values(((l_0)(current-logger)))"
"(if(log-level? l_0 'error(logger-name l_0))"
"(let-values()"
"(log-message"
" l_0"
" 'error"
"(format"
"                            \"REGION      ~aMSECS   ~aMEMK   ~aCOUNT\""
"(make-string(-(+ label-max-len_0 value-max-len_0) 11) '#\\space)"
"(make-string(- memory-max-len_0 4) '#\\space)"
"(make-string(- count-max-len_0 5) '#\\space))"
"(current-continuation-marks)))"
"(void)))"
"((letrec-values(((loop_0)"
"(lambda(name_0 accums_0 indent_0 newline?_0)"
"(begin"
" 'loop"
"(let-values((()"
"(begin"
"(if name_0"
"(let-values()"
"(let-values(((v_0)(hash-ref accums_0 stat-key)))"
"(let-values(((l_0)(current-logger)))"
"(if(log-level? l_0 'error(logger-name l_0))"
"(let-values()"
"(log-message"
" l_0"
" 'error"
"(format"
"                                                                        \"~a~a   ~a~a   ~a~a   ~a~a\""
" indent_0"
" name_0"
"(make-string"
"(+"
"(-"
" label-max-len_0"
"                                                                           (string-length (format \"~a\" name_0))"
"(string-length indent_0))"
"(-"
" value-max-len_0"
"(whole-len_0"
"                                                                            (format \"~a\" (stat-msecs v_0)))))"
" '#\\space)"
"(regexp-replace"
"                                                                         '#rx\"[.](..).*\""
"                                                                         (format \"~a00\" (stat-msecs v_0))"
"                                                                         \".\\\\1\")"
"(make-string"
"(-"
" memory-max-len_0"
"(string-length"
"                                                                           (format \"~a\" (kb_0 (stat-memory v_0)))))"
" '#\\space)"
"(kb_0(stat-memory v_0))"
"(make-string"
"(-"
" count-max-len_0"
"(string-length"
"                                                                           (format \"~a\" (stat-count v_0))))"
" '#\\space)"
"(stat-count v_0))"
"(current-continuation-marks)))"
"(void)))))"
"(void))"
"(values))))"
"(let-values(((keys_0)"
"(let-values(((temp5_0)"
"(reverse$1"
"(let-values(((ht_0) accums_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0)"
"(hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(if(not"
"(eq?"
" k_0"
" stat-key))"
"(let-values(((fold-var_2)"
" fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
" k_0)"
" fold-var_2))))"
"(values"
" fold-var_3)))"
" fold-var_1))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
"(hash-iterate-next"
" ht_0"
" i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(hash-iterate-first ht_0))))))"
"((>6_0) >)"
"((temp7_0)"
"(lambda(key_0)"
"(stat-msecs"
"(hash-ref"
"(hash-ref accums_0 key_0)"
" stat-key)))))"
"(sort7.1 #f temp7_0 temp5_0 >6_0))))"
"(begin"
"(let-values(((lst_0) keys_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((k_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((i_0) pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(if(if newline?_0"
"(positive?"
" i_0)"
" #f)"
"(let-values()"
"(let-values(((l_0)"
"(current-logger)))"
"(if(log-level?"
" l_0"
" 'error"
"(logger-name"
" l_0))"
"(let-values()"
"(log-message"
" l_0"
" 'error"
"                                                                                                                               \"\""
"(current-continuation-marks)))"
"(void))))"
"(void))"
"(loop_0"
" k_0"
"(hash-ref"
" accums_0"
" k_0)"
"(string-append"
" indent_0"
"                                                                                                                      \"  \")"
" #f)))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0 rest_0(+ pos_0 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" start_0)))"
"(void))))))))"
" loop_0)"
" #f"
"(unsafe-place-local-ref cell.2$2)"
"                     \"\""
" #t)))))))))"
"(void)))"
" print-values)"
"(define-values"
"(struct:module-use module-use1.1 module-use? module-use-module module-use-phase)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-use"
" #f"
" 2"
" 0"
" #f"
"(list"
"(cons"
" prop:equal+hash"
"(list"
"(lambda(a_0 b_0 eql?_0)"
"(let-values(((a-mod_0)(module-use-module a_0)))"
"(let-values(((b-mod_0)(module-use-module b_0)))"
"(if(eql?_0 a-mod_0 b-mod_0)"
"(if(eql?_0(module-use-phase a_0)(module-use-phase b_0))"
"(let-values(((a-path_0 a-base_0)(1/module-path-index-split a-mod_0))"
"((b-path_0 b-base_0)(1/module-path-index-split b-mod_0)))"
"(let-values(((or-part_0) a-path_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1) b-path_0))"
"(if or-part_1"
" or-part_1"
"(eq?"
"(module-path-index-resolved a-mod_0)"
"(module-path-index-resolved b-mod_0)))))))"
" #f)"
" #f))))"
"(lambda(a_0 hash-code_0)"
"(+(hash-code_0(module-use-module a_0))(hash-code_0(module-use-phase a_0))))"
"(lambda(a_0 hash-code_0)"
"(+(hash-code_0(module-use-module a_0))(hash-code_0(module-use-phase a_0)))))))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'module-use)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'module)"
"(make-struct-field-accessor -ref_0 1 'phase))))"
"(define-values"
"(struct:module"
" module1.1"
" module?"
" module-source-name"
" module-self"
" module-requires"
" module-provides"
" module-access"
" module-language-info"
" module-min-phase-level"
" module-max-phase-level"
" module-phase-level-linklet-info-callback"
" module-force-bulk-binding"
" module-prepare-instance"
" module-instantiate-phase"
" module-primitive?"
" module-is-predefined?"
" module-cross-phase-persistent?"
" module-no-protected?"
" module-inspector"
" module-submodule-names"
" module-supermodule-name"
" module-get-all-variables"
" set-module-access!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module"
" #f"
" 20"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19)"
" #f"
" 'module)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'source-name)"
"(make-struct-field-accessor -ref_0 1 'self)"
"(make-struct-field-accessor -ref_0 2 'requires)"
"(make-struct-field-accessor -ref_0 3 'provides)"
"(make-struct-field-accessor -ref_0 4 'access)"
"(make-struct-field-accessor -ref_0 5 'language-info)"
"(make-struct-field-accessor -ref_0 6 'min-phase-level)"
"(make-struct-field-accessor -ref_0 7 'max-phase-level)"
"(make-struct-field-accessor -ref_0 8 'phase-level-linklet-info-callback)"
"(make-struct-field-accessor -ref_0 9 'force-bulk-binding)"
"(make-struct-field-accessor -ref_0 10 'prepare-instance)"
"(make-struct-field-accessor -ref_0 11 'instantiate-phase)"
"(make-struct-field-accessor -ref_0 12 'primitive?)"
"(make-struct-field-accessor -ref_0 13 'is-predefined?)"
"(make-struct-field-accessor -ref_0 14 'cross-phase-persistent?)"
"(make-struct-field-accessor -ref_0 15 'no-protected?)"
"(make-struct-field-accessor -ref_0 16 'inspector)"
"(make-struct-field-accessor -ref_0 17 'submodule-names)"
"(make-struct-field-accessor -ref_0 18 'supermodule-name)"
"(make-struct-field-accessor -ref_0 19 'get-all-variables)"
"(make-struct-field-mutator -set!_0 4 'access))))"
"(define-values"
"(struct:module-linklet-info"
" module-linklet-info2.1"
" module-linklet-info?"
" module-linklet-info-linklet-or-instance"
" module-linklet-info-module-uses"
" module-linklet-info-self"
" module-linklet-info-inspector"
" module-linklet-info-extra-inspector"
" module-linklet-info-extra-inspectorsss)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-linklet-info"
" #f"
" 6"
" 0"
" #f"
"(list(cons prop:authentic #t))"
" #f"
" #f"
" '(0 1 2 3 4 5)"
" #f"
" 'module-linklet-info)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'linklet-or-instance)"
"(make-struct-field-accessor -ref_0 1 'module-uses)"
"(make-struct-field-accessor -ref_0 2 'self)"
"(make-struct-field-accessor -ref_0 3 'inspector)"
"(make-struct-field-accessor -ref_0 4 'extra-inspector)"
"(make-struct-field-accessor -ref_0 5 'extra-inspectorsss))))"
"(define-values"
"(make-module39.1)"
"(lambda(cross-phase-persistent?16_0"
" force-bulk-binding-callback10_0"
" get-all-variables20_0"
" instantiate-phase-callback9_0"
" language-info13_0"
" max-phase-level8_0"
" min-phase-level7_0"
" no-protected?17_0"
" phase-level-linklet-info-callback12_0"
" predefined?15_0"
" prepare-instance-callback11_0"
" primitive?14_0"
" provides6_0"
" requires5_0"
" self4_0"
" source-name3_0"
" submodule-names18_0"
" supermodule-name19_0)"
"(begin"
" 'make-module39"
"(let-values(((source-name_0) source-name3_0))"
"(let-values(((self_0) self4_0))"
"(let-values(((requires_0) requires5_0))"
"(let-values(((provides_0) provides6_0))"
"(let-values(((min-phase-level_0) min-phase-level7_0))"
"(let-values(((max-phase-level_0) max-phase-level8_0))"
"(let-values(((instantiate-phase_0) instantiate-phase-callback9_0))"
"(let-values(((force-bulk-binding_0)"
"(if(eq? force-bulk-binding-callback10_0 unsafe-undefined)"
" void"
" force-bulk-binding-callback10_0)))"
"(let-values(((prepare-instance_0)"
"(if(eq? prepare-instance-callback11_0 unsafe-undefined)"
" void"
" prepare-instance-callback11_0)))"
"(let-values(((phase-level-linklet-info-callback_0)"
"(if(eq? phase-level-linklet-info-callback12_0 unsafe-undefined)"
"(lambda(phase-level_0 ns_0 insp_0)"
"(begin 'phase-level-linklet-info-callback #f))"
" phase-level-linklet-info-callback12_0)))"
"(let-values(((language-info_0) language-info13_0))"
"(let-values(((primitive?_0) primitive?14_0))"
"(let-values(((predefined?_0) predefined?15_0))"
"(let-values(((cross-phase-persistent?_0)"
"(if(eq? cross-phase-persistent?16_0 unsafe-undefined)"
" primitive?_0"
" cross-phase-persistent?16_0)))"
"(let-values(((no-protected?_0) no-protected?17_0))"
"(let-values(((submodule-names_0) submodule-names18_0))"
"(let-values(((supermodule-name_0) supermodule-name19_0))"
"(let-values(((get-all-variables_0)"
"(if(eq? get-all-variables20_0 unsafe-undefined)"
"(lambda()(begin 'get-all-variables null))"
" get-all-variables20_0)))"
"(let-values()"
"(module1.1"
" source-name_0"
" self_0"
"(unresolve-requires requires_0)"
" provides_0"
" #f"
" language-info_0"
" min-phase-level_0"
" max-phase-level_0"
" phase-level-linklet-info-callback_0"
" force-bulk-binding_0"
" prepare-instance_0"
" instantiate-phase_0"
" primitive?_0"
" predefined?_0"
" cross-phase-persistent?_0"
" no-protected?_0"
"(current-code-inspector)"
" submodule-names_0"
" supermodule-name_0"
" get-all-variables_0)))))))))))))))))))))))"
"(define-values"
"(struct:module-instance"
" module-instance42.1"
" module-instance?"
" module-instance-namespace"
" module-instance-module"
" module-instance-shifted-requires"
" module-instance-phase-level-to-state"
" module-instance-made-available?"
" module-instance-attached?"
" module-instance-data-box"
" set-module-instance-shifted-requires!"
" set-module-instance-made-available?!"
" set-module-instance-attached?!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-instance"
" #f"
" 7"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 3 6)"
" #f"
" 'module-instance)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'namespace)"
"(make-struct-field-accessor -ref_0 1 'module)"
"(make-struct-field-accessor -ref_0 2 'shifted-requires)"
"(make-struct-field-accessor -ref_0 3 'phase-level-to-state)"
"(make-struct-field-accessor -ref_0 4 'made-available?)"
"(make-struct-field-accessor -ref_0 5 'attached?)"
"(make-struct-field-accessor -ref_0 6 'data-box)"
"(make-struct-field-mutator -set!_0 2 'shifted-requires)"
"(make-struct-field-mutator -set!_0 4 'made-available?)"
"(make-struct-field-mutator -set!_0 5 'attached?))))"
"(define-values"
"(make-module-instance)"
"(lambda(m-ns_0 m_0)(begin(module-instance42.1 m-ns_0 m_0 #f(make-small-hasheqv) #f #f(box #f)))))"
"(define-values"
"(make-module-namespace50.1)"
"(lambda(for-submodule?45_0 mpi43_0 root-expand-context44_0 ns49_0)"
"(begin"
" 'make-module-namespace50"
"(let-values(((ns_0) ns49_0))"
"(let-values(((name-mpi_0) mpi43_0))"
"(let-values(((root-expand-ctx_0) root-expand-context44_0))"
"(let-values(((for-submodule?_0) for-submodule?45_0))"
"(let-values()"
"(let-values(((phase_0) 0))"
"(let-values(((name_0)(1/module-path-index-resolve name-mpi_0)))"
"(let-values(((m-ns_0)"
"(let-values(((the-struct_0)"
"(let-values(((ns158_0) ns_0)"
"((root-expand-ctx159_0) root-expand-ctx_0)"
"((temp160_0) #f))"
"(new-namespace8.1 temp160_0 root-expand-ctx159_0 ns158_0))))"
"(if(1/namespace? the-struct_0)"
"(let-values(((mpi150_0) name-mpi_0)"
"((source-name151_0)(resolved-module-path-root-name name_0))"
"((phase152_0) phase_0)"
"((0-phase153_0) phase_0)"
"((submodule-declarations154_0)"
"(if for-submodule?_0"
"(namespace-submodule-declarations ns_0)"
"(make-small-hasheq)))"
"((available-module-instances155_0)(make-hasheqv))"
"((module-instances156_0)(make-hasheqv))"
"((declaration-inspector157_0)(current-code-inspector)))"
"(namespace1.1"
" mpi150_0"
" source-name151_0"
"(namespace-root-expand-ctx the-struct_0)"
" phase152_0"
" 0-phase153_0"
"(namespace-phase-to-namespace the-struct_0)"
"(namespace-phase-level-to-definitions the-struct_0)"
"(namespace-module-registry$1 the-struct_0)"
"(namespace-bulk-binding-registry the-struct_0)"
" submodule-declarations154_0"
"(namespace-root-namespace the-struct_0)"
" declaration-inspector157_0"
"(namespace-inspector the-struct_0)"
" available-module-instances155_0"
" module-instances156_0))"
"                                      (raise-argument-error 'struct-copy \"namespace?\" the-struct_0)))))"
"(let-values((()"
"(begin"
"(small-hash-set!(namespace-phase-to-namespace m-ns_0) phase_0 m-ns_0)"
"(values))))"
"(let-values(((at-phase_0)(make-hasheq)))"
"(begin"
"(hash-set!(namespace-module-instances m-ns_0) phase_0 at-phase_0)"
"(hash-set! at-phase_0 name_0(make-module-instance m-ns_0 #f))"
" m-ns_0))))))))))))))"
"(define-values"
"(declare-module!58.1)"
"(lambda(with-submodules?53_0 ns55_0 m56_0 mod-name57_0)"
"(begin"
" 'declare-module!58"
"(let-values(((ns_0) ns55_0))"
"(let-values(((m_0) m56_0))"
"(let-values(((mod-name_0) mod-name57_0))"
"(let-values(((with-submodules?_0) with-submodules?53_0))"
"(let-values()"
"(let-values(((prior-m_0)"
"(if with-submodules?_0"
"(hash-ref"
"(module-registry-declarations(namespace-module-registry$1 ns_0))"
" mod-name_0"
" #f)"
" #f)))"
"(let-values(((prior-mi_0)"
"(if prior-m_0"
"(if(not(eq? m_0 prior-m_0))"
"(let-values(((ns161_0) ns_0)"
"((mod-name162_0) mod-name_0)"
"((temp163_0)(namespace-phase ns_0)))"
"(namespace->module-instance70.1"
" #f"
" #f"
" unsafe-undefined"
" ns161_0"
" mod-name162_0"
" temp163_0))"
" #f)"
" #f)))"
"(begin"
"(if(if prior-m_0(not(eq? m_0 prior-m_0)) #f)"
"(let-values()(check-redeclaration-ok prior-m_0 prior-mi_0 mod-name_0))"
"(void))"
"(if with-submodules?_0"
"(hash-set!(module-registry-declarations(namespace-module-registry$1 ns_0)) mod-name_0 m_0)"
"(small-hash-set!(namespace-submodule-declarations ns_0) mod-name_0 m_0))"
"(if with-submodules?_0"
"(let-values()"
"(begin"
"(register-bulk-provide!"
"(namespace-bulk-binding-registry ns_0)"
" mod-name_0"
"(module-self m_0)"
"(module-provides m_0))"
"((1/current-module-name-resolver) mod-name_0 #f)))"
"(void))"
"(if prior-mi_0"
"(let-values()"
"(let-values(((m-ns_0)(module-instance-namespace prior-mi_0)))"
"(let-values(((states_0)(module-instance-phase-level-to-state prior-mi_0)))"
"(let-values(((phase_0)(namespace-phase ns_0)))"
"(let-values(((visit?_0)(eq? 'started(small-hash-ref states_0(add1 phase_0) #f))))"
"(let-values(((run?_0)(eq? 'started(small-hash-ref states_0 phase_0 #f))))"
"(let-values(((at-phase_0)(hash-ref(namespace-module-instances ns_0) phase_0)))"
"(begin"
"(hash-set! at-phase_0 mod-name_0(make-module-instance m-ns_0 m_0))"
"(if visit?_0"
"(let-values()"
"(let-values(((ns164_0) ns_0)"
"((temp165_0)(namespace-mpi m-ns_0))"
"((phase166_0) phase_0))"
"(namespace-module-visit!104.1"
" unsafe-undefined"
" ns164_0"
" temp165_0"
" phase166_0)))"
"(void))"
"(if run?_0"
"(let-values()"
"(let-values(((ns167_0) ns_0)"
"((temp168_0)(namespace-mpi m-ns_0))"
"((phase169_0) phase_0))"
"(namespace-module-instantiate!96.1"
" #t"
" unsafe-undefined"
" unsafe-undefined"
" #f"
" ns167_0"
" temp168_0"
" phase169_0)))"
"(void))))))))))"
"(void)))))))))))))"
"(define-values"
"(check-redeclaration-ok)"
"(lambda(prior-m_0 prior-mi_0 mod-name_0)"
"(begin"
"(begin"
"(if(module-cross-phase-persistent? prior-m_0)"
"(let-values()"
"            (raise-arguments-error 'module \"cannot redeclare cross-phase persistent module\" \"module name\" mod-name_0))"
"(void))"
"(if(if prior-mi_0"
"(let-values(((or-part_0)(module-instance-attached? prior-mi_0)))"
"(if or-part_0"
" or-part_0"
"(not"
"(inspector-superior?"
"(current-code-inspector)"
"(namespace-inspector(module-instance-namespace prior-mi_0))))))"
" #f)"
"(let-values()"
"            (raise-arguments-error 'module \"current code inspector cannot redeclare module\" \"module name\" mod-name_0))"
"(void))))))"
"(define-values"
"(raise-unknown-module-error)"
"  (lambda (who_0 mod-name_0) (begin (raise-arguments-error who_0 \"unknown module\" \"module name\" mod-name_0))))"
"(define-values"
"(namespace->module-linklet-info)"
"(lambda(ns_0 name_0 phase-level_0)"
"(begin"
"(let-values(((m_0)(namespace->module ns_0 name_0)))"
"(if m_0((module-phase-level-linklet-info-callback m_0) phase-level_0 ns_0(module-inspector m_0)) #f)))))"
"(define-values"
"(namespace->module-instance70.1)"
"(lambda(check-available-at-phase-level62_0"
" complain-on-failure?61_0"
" unavailable-callback63_0"
" ns67_0"
" name68_0"
" 0-phase69_0)"
"(begin"
" 'namespace->module-instance70"
"(let-values(((ns_0) ns67_0))"
"(let-values(((name_0) name68_0))"
"(let-values(((0-phase_0) 0-phase69_0))"
"(let-values(((complain-on-failure?_0) complain-on-failure?61_0))"
"(let-values(((check-available-at-phase-level_0) check-available-at-phase-level62_0))"
"(let-values(((unavailable-callback_0)"
"(if(eq? unavailable-callback63_0 unsafe-undefined) void unavailable-callback63_0)))"
"(let-values()"
"(let-values(((mi_0)"
"(let-values(((or-part_0)"
"(hash-ref"
"(hash-ref(namespace-module-instances ns_0) 0-phase_0 '#hasheq())"
" name_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(let-values(((c-ns_0)"
"(let-values(((or-part_1)"
"(namespace-root-namespace ns_0)))"
"(if or-part_1 or-part_1 ns_0))))"
"(hash-ref(namespace-module-instances c-ns_0) name_0 #f))))"
"(if or-part_1"
" or-part_1"
"(if complain-on-failure?_0"
"                                            (error \"no module instance found:\" name_0 0-phase_0)"
" #f)))))))"
"(if(if mi_0 check-available-at-phase-level_0 #f)"
"(check-availablilty mi_0 check-available-at-phase-level_0 unavailable-callback_0)"
" mi_0))))))))))))"
"(define-values"
"(namespace-install-module-namespace!)"
"(lambda(ns_0 name_0 0-phase_0 m_0 existing-m-ns_0)"
"(begin"
"(let-values(((m-ns_0)"
"(let-values(((the-struct_0) ns_0))"
"(if(1/namespace? the-struct_0)"
"(let-values(((mpi170_0)(namespace-mpi existing-m-ns_0))"
"((source-name171_0)(namespace-source-name existing-m-ns_0))"
"((root-expand-ctx172_0)(box(unbox(namespace-root-expand-ctx existing-m-ns_0))))"
"((phase173_0)(namespace-phase existing-m-ns_0))"
"((0-phase174_0)(namespace-0-phase existing-m-ns_0))"
"((phase-to-namespace175_0)(make-small-hasheqv))"
"((phase-level-to-definitions176_0)"
"(if(module-cross-phase-persistent? m_0)"
"(namespace-phase-level-to-definitions existing-m-ns_0)"
"(make-small-hasheqv)))"
"((declaration-inspector177_0)(module-inspector m_0))"
"((inspector178_0)(namespace-inspector existing-m-ns_0)))"
"(namespace1.1"
" mpi170_0"
" source-name171_0"
" root-expand-ctx172_0"
" phase173_0"
" 0-phase174_0"
" phase-to-namespace175_0"
" phase-level-to-definitions176_0"
"(namespace-module-registry$1 the-struct_0)"
"(namespace-bulk-binding-registry the-struct_0)"
"(namespace-submodule-declarations the-struct_0)"
"(namespace-root-namespace the-struct_0)"
" declaration-inspector177_0"
" inspector178_0"
"(namespace-available-module-instances the-struct_0)"
"(namespace-module-instances the-struct_0)))"
"                        (raise-argument-error 'struct-copy \"namespace?\" the-struct_0)))))"
"(let-values(((mi_0)(make-module-instance m-ns_0 m_0)))"
"(if(module-cross-phase-persistent? m_0)"
"(let-values()"
"(begin"
"(small-hash-set!(namespace-phase-to-namespace m-ns_0) 0 m-ns_0)"
"(small-hash-set!"
"(namespace-phase-level-to-definitions m-ns_0)"
" 0"
"(namespace->definitions existing-m-ns_0 0))"
"(small-hash-set!(namespace-phase-to-namespace m-ns_0) 1(namespace->namespace-at-phase m-ns_0 1))"
"(small-hash-set!"
"(namespace-phase-level-to-definitions m-ns_0)"
" 1"
"(namespace->definitions existing-m-ns_0 1))"
"(hash-set!"
"(namespace-module-instances"
"(let-values(((or-part_0)(namespace-root-namespace ns_0)))(if or-part_0 or-part_0 ns_0)))"
" name_0"
" mi_0)"
"(small-hash-set!(module-instance-phase-level-to-state mi_0) 0 'started)))"
"(let-values()"
"(let-values((()"
"(begin(small-hash-set!(namespace-phase-to-namespace m-ns_0) 0-phase_0 m-ns_0)(values))))"
"(let-values((()"
"(begin"
"(small-hash-set!"
"(namespace-phase-level-to-definitions m-ns_0)"
" 0"
"(namespace->definitions existing-m-ns_0 0))"
"(values))))"
"(let-values((()"
"(begin"
"(small-hash-set!(module-instance-phase-level-to-state mi_0) 0 'started)"
"(values))))"
"(let-values(((at-phase_0)"
"(let-values(((or-part_0)(hash-ref(namespace-module-instances ns_0) 0-phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((at-phase_0)(make-hasheq)))"
"(begin"
"(hash-set!(namespace-module-instances ns_0) 0-phase_0 at-phase_0)"
" at-phase_0))))))"
"(hash-set! at-phase_0 name_0 mi_0))))))))))))"
"(define-values"
"(namespace-create-module-instance!)"
"(lambda(ns_0 name_0 0-phase_0 m_0 mpi_0)"
"(begin"
"(let-values(((m-ns_0)"
"(let-values(((the-struct_0) ns_0))"
"(if(1/namespace? the-struct_0)"
"(let-values(((mpi179_0) mpi_0)"
"((source-name180_0)"
"(let-values(((or-part_0)(module-source-name m_0)))"
"(if or-part_0"
" or-part_0"
"(resolved-module-path-root-name(1/module-path-index-resolve mpi_0)))))"
"((root-expand-ctx181_0)(box #f))"
"((phase182_0) 0-phase_0)"
"((0-phase183_0) 0-phase_0)"
"((phase-to-namespace184_0)(make-small-hasheqv))"
"((phase-level-to-definitions185_0)(make-small-hasheqv))"
"((declaration-inspector186_0)(module-inspector m_0))"
"((inspector187_0)(make-inspector(module-inspector m_0))))"
"(namespace1.1"
" mpi179_0"
" source-name180_0"
" root-expand-ctx181_0"
" phase182_0"
" 0-phase183_0"
" phase-to-namespace184_0"
" phase-level-to-definitions185_0"
"(namespace-module-registry$1 the-struct_0)"
"(namespace-bulk-binding-registry the-struct_0)"
"(namespace-submodule-declarations the-struct_0)"
"(namespace-root-namespace the-struct_0)"
" declaration-inspector186_0"
" inspector187_0"
"(namespace-available-module-instances the-struct_0)"
"(namespace-module-instances the-struct_0)))"
"                        (raise-argument-error 'struct-copy \"namespace?\" the-struct_0)))))"
"(let-values((()(begin(small-hash-set!(namespace-phase-to-namespace m-ns_0) 0-phase_0 m-ns_0)(values))))"
"(let-values(((mi_0)(make-module-instance m-ns_0 m_0)))"
"(begin"
"(if(module-cross-phase-persistent? m_0)"
"(hash-set!(namespace-module-instances ns_0) name_0 mi_0)"
"(let-values(((at-phase_0)"
"(let-values(((or-part_0)(hash-ref(namespace-module-instances ns_0) 0-phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((at-phase_0)(make-hasheq)))"
"(begin"
"(hash-set!(namespace-module-instances ns_0) 0-phase_0 at-phase_0)"
" at-phase_0))))))"
"(hash-set! at-phase_0 name_0 mi_0)))"
" mi_0)))))))"
"(define-values"
"(check-availablilty)"
"(lambda(mi_0 check-available-at-phase-level_0 unavailable-callback_0)"
"(begin"
"(let-values(((m_0)(module-instance-module mi_0)))"
"(if(if m_0"
"(if(<=(module-min-phase-level m_0)(add1 check-available-at-phase-level_0)(module-max-phase-level m_0))"
"(not"
"(small-hash-ref"
"(module-instance-phase-level-to-state mi_0)"
"(add1 check-available-at-phase-level_0)"
" #f))"
" #f)"
" #f)"
"(unavailable-callback_0 mi_0)"
" mi_0)))))"
"(define-values"
"(namespace->module-namespace82.1)"
"(lambda(check-available-at-phase-level74_0"
" complain-on-failure?73_0"
" unavailable-callback75_0"
" ns79_0"
" name80_0"
" 0-phase81_0)"
"(begin"
" 'namespace->module-namespace82"
"(let-values(((ns_0) ns79_0))"
"(let-values(((name_0) name80_0))"
"(let-values(((0-phase_0) 0-phase81_0))"
"(let-values(((complain-on-failure?_0) complain-on-failure?73_0))"
"(let-values(((check-available-at-phase-level_0) check-available-at-phase-level74_0))"
"(let-values(((unavailable-callback_0)"
"(if(eq? unavailable-callback75_0 unsafe-undefined) void unavailable-callback75_0)))"
"(let-values()"
"(let-values(((mi_0)"
"(let-values(((ns188_0) ns_0)"
"((name189_0) name_0)"
"((0-phase190_0) 0-phase_0)"
"((complain-on-failure?191_0) complain-on-failure?_0)"
"((check-available-at-phase-level192_0) check-available-at-phase-level_0)"
"((unavailable-callback193_0) unavailable-callback_0))"
"(namespace->module-instance70.1"
" check-available-at-phase-level192_0"
" complain-on-failure?191_0"
" unavailable-callback193_0"
" ns188_0"
" name189_0"
" 0-phase190_0))))"
"(if mi_0(module-instance-namespace mi_0) #f))))))))))))"
"(define-values"
"(namespace-record-module-instance-attached!)"
"(lambda(ns_0 mod-name_0 phase_0)"
"(begin"
"(let-values(((mi_0)"
"(let-values(((ns194_0) ns_0)((mod-name195_0) mod-name_0)((phase196_0) phase_0))"
"(namespace->module-instance70.1 #f #f unsafe-undefined ns194_0 mod-name195_0 phase196_0))))"
"(set-module-instance-attached?! mi_0 #t)))))"
"(define-values"
"(module-force-bulk-binding!)"
"(lambda(m_0 ns_0)(begin((module-force-bulk-binding m_0)(namespace-bulk-binding-registry ns_0)))))"
"(define-values"
"(namespace-module-instantiate!96.1)"
"(lambda(otherwise-available?87_0 run-phase85_0 seen88_0 skip-run?86_0 ns93_0 mpi94_0 instance-phase95_0)"
"(begin"
" 'namespace-module-instantiate!96"
"(let-values(((ns_0) ns93_0))"
"(let-values(((mpi_0) mpi94_0))"
"(let-values(((instance-phase_0) instance-phase95_0))"
"(let-values(((run-phase_0)(if(eq? run-phase85_0 unsafe-undefined)(namespace-phase ns_0) run-phase85_0)))"
"(let-values(((skip-run?_0) skip-run?86_0))"
"(let-values(((otherwise-available?_0) otherwise-available?87_0))"
"(let-values(((seen_0)(if(eq? seen88_0 unsafe-undefined) '#hasheq() seen88_0)))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/module-path-index? mpi_0)"
"(void)"
"                                        (let-values () (error \"not a module path index:\" mpi_0)))"
"(values))))"
"(let-values(((name_0)"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'eval 'resolve))"
"(void))"
"(begin0"
"(let-values()(1/module-path-index-resolve mpi_0 #t))"
"(if log-performance?(let-values()(end-performance-region))(void))))))"
"(let-values(((m_0)(namespace->module ns_0 name_0)))"
"(let-values((()"
"(begin"
"(if m_0"
"(void)"
"(let-values()(raise-unknown-module-error 'instantiate name_0)))"
"(values))))"
"(let-values(((instantiate!_0)"
"(lambda(instance-phase_1 run-phase_1 ns_1)"
"(begin"
" 'instantiate!"
"(let-values(((mi_0)"
"(let-values(((or-part_0)"
"(let-values(((ns203_0) ns_1)"
"((name204_0) name_0)"
"((instance-phase205_0)"
" instance-phase_1))"
"(namespace->module-instance70.1"
" #f"
" #f"
" unsafe-undefined"
" ns203_0"
" name204_0"
" instance-phase205_0))))"
"(if or-part_0"
" or-part_0"
"(namespace-create-module-instance!"
" ns_1"
" name_0"
" instance-phase_1"
" m_0"
" mpi_0)))))"
"(let-values(((mi197_0) mi_0)"
"((ns198_0) ns_1)"
"((run-phase199_0) run-phase_1)"
"((skip-run?200_0) skip-run?_0)"
"((otherwise-available?201_0) otherwise-available?_0)"
"((seen202_0) seen_0))"
"(run-module-instance!125.1"
" otherwise-available?201_0"
" run-phase199_0"
" seen202_0"
" skip-run?200_0"
" mi197_0"
" ns198_0)))))))"
"(if(module-cross-phase-persistent? m_0)"
"(let-values()"
"(instantiate!_0"
" 0"
" 0"
"(let-values(((or-part_0)(namespace-root-namespace ns_0)))"
"(if or-part_0 or-part_0 ns_0))))"
"(let-values()(instantiate!_0 instance-phase_0 run-phase_0 ns_0)))))))))))))))))))"
"(define-values"
"(namespace-module-visit!104.1)"
"(lambda(visit-phase99_0 ns101_0 mpi102_0 instance-phase103_0)"
"(begin"
" 'namespace-module-visit!104"
"(let-values(((ns_0) ns101_0))"
"(let-values(((mpi_0) mpi102_0))"
"(let-values(((instance-phase_0) instance-phase103_0))"
"(let-values(((visit-phase_0)"
"(if(eq? visit-phase99_0 unsafe-undefined)(namespace-phase ns_0) visit-phase99_0)))"
"(let-values()"
"(let-values(((ns206_0) ns_0)"
"((mpi207_0) mpi_0)"
"((instance-phase208_0) instance-phase_0)"
"((temp209_0)(add1 visit-phase_0)))"
"(namespace-module-instantiate!96.1"
" #t"
" temp209_0"
" unsafe-undefined"
" #f"
" ns206_0"
" mpi207_0"
" instance-phase208_0))))))))))"
"(define-values"
"(namespace-module-make-available!112.1)"
"(lambda(visit-phase107_0 ns109_0 mpi110_0 instance-phase111_0)"
"(begin"
" 'namespace-module-make-available!112"
"(let-values(((ns_0) ns109_0))"
"(let-values(((mpi_0) mpi110_0))"
"(let-values(((instance-phase_0) instance-phase111_0))"
"(let-values(((visit-phase_0)"
"(if(eq? visit-phase107_0 unsafe-undefined)(namespace-phase ns_0) visit-phase107_0)))"
"(let-values()"
"(let-values(((ns210_0) ns_0)"
"((mpi211_0) mpi_0)"
"((instance-phase212_0) instance-phase_0)"
"((temp213_0)(add1 visit-phase_0))"
"((temp214_0) #t))"
"(namespace-module-instantiate!96.1"
" #t"
" temp213_0"
" unsafe-undefined"
" temp214_0"
" ns210_0"
" mpi211_0"
" instance-phase212_0))))))))))"
"(define-values"
"(run-module-instance!125.1)"
"(lambda(otherwise-available?117_0 run-phase115_0 seen118_0 skip-run?116_0 mi123_0 ns124_0)"
"(begin"
" 'run-module-instance!125"
"(let-values(((mi_0) mi123_0))"
"(let-values(((ns_0) ns124_0))"
"(let-values(((run-phase_0) run-phase115_0))"
"(let-values(((skip-run?_0) skip-run?116_0))"
"(let-values(((otherwise-available?_0) otherwise-available?117_0))"
"(let-values(((seen_0)(if(eq? seen118_0 unsafe-undefined) '#hasheq() seen118_0)))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'eval 'requires))(void))"
"(begin0"
"(let-values()"
"(let-values(((m-ns_0)(module-instance-namespace mi_0)))"
"(let-values(((instance-phase_0)(namespace-0-phase m-ns_0)))"
"(let-values(((run-phase-level_0)(phase- run-phase_0 instance-phase_0)))"
"(if(if(let-values(((or-part_0) skip-run?_0))"
"(if or-part_0"
" or-part_0"
"(eq?"
" 'started"
"(small-hash-ref"
"(module-instance-phase-level-to-state mi_0)"
" run-phase-level_0"
" #f))))"
"(let-values(((or-part_0)(not otherwise-available?_0)))"
"(if or-part_0 or-part_0(module-instance-made-available? mi_0)))"
" #f)"
"(void)"
"(let-values()"
"(let-values(((m_0)(module-instance-module mi_0)))"
"(let-values((()"
"(begin"
"(if m_0"
"(void)"
"(let-values()"
"(error"
" 'require"
"                                                           \"import cycle detected; trying to run module being expanded\")))"
"(values))))"
"(let-values(((mpi_0)(namespace-mpi m-ns_0)))"
"(let-values(((phase-shift_0) instance-phase_0))"
"(let-values(((bulk-binding-registry_0)"
"(namespace-bulk-binding-registry m-ns_0)))"
"(begin"
"(if(hash-ref seen_0 mi_0 #f)"
"(let-values()"
"(error"
" 'require"
"                                                     \"import cycle detected during module instantiation\"))"
"(void))"
"(if(module-instance-shifted-requires mi_0)"
"(void)"
"(let-values()"
"(set-module-instance-shifted-requires!"
" mi_0"
"(reverse$1"
"(let-values(((lst_0)(module-requires m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((phase+mpis_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
"(car"
" phase+mpis_0)"
"(reverse$1"
"(let-values(((lst_2)"
"(cdr"
" phase+mpis_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((req-mpi_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(module-path-index-shift"
" req-mpi_0"
"(module-self"
" m_0)"
" mpi_0))"
" fold-var_3))))"
"(values"
" fold-var_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_3"
" rest_1)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
" lst_2))))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(let-values(((lst_0)(module-instance-shifted-requires mi_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((phase+mpis_0)"
"(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((req-phase_0)"
"(car"
" phase+mpis_0)))"
"(begin"
"(let-values(((lst_2)"
"(cdr"
" phase+mpis_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((req-mpi_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((ns215_0)"
" ns_0)"
"((req-mpi216_0)"
" req-mpi_0)"
"((temp217_0)"
"(phase+"
" instance-phase_0"
" req-phase_0))"
"((run-phase218_0)"
" run-phase_0)"
"((skip-run?219_0)"
" skip-run?_0)"
"((otherwise-available?220_0)"
" otherwise-available?_0)"
"((temp221_0)"
"(hash-set"
" seen_0"
" mi_0"
" #t)))"
"(namespace-module-instantiate!96.1"
" otherwise-available?220_0"
" run-phase218_0"
" temp221_0"
" skip-run?219_0"
" ns215_0"
" req-mpi216_0"
" temp217_0)))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2)))"
"(void))))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0 rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(if(label-phase? instance-phase_0)"
"(void)"
"(let-values()"
"(begin"
"(let-values(((start_0)(module-max-phase-level m_0))"
"((end_0)(sub1(module-min-phase-level m_0)))"
"((inc_0) -1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(> pos_0 end_0)"
"(let-values(((phase-level_0) pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((phase_0)"
"(phase+"
" phase-level_0"
" phase-shift_0)))"
"(if(if(not"
" skip-run?_0)"
"(eqv?"
" phase_0"
" run-phase_0)"
" #f)"
"(let-values()"
"(if(eq?"
" 'started"
"(small-hash-ref"
"(module-instance-phase-level-to-state"
" mi_0)"
" phase-level_0"
" #f))"
"(void)"
"(let-values()"
"(let-values((()"
"(begin"
"(small-hash-set!"
"(module-instance-phase-level-to-state"
" mi_0)"
" phase-level_0"
" 'started)"
"(values))))"
"(let-values((()"
"(begin"
"(void"
"(namespace->definitions"
" m-ns_0"
" phase-level_0))"
"(values))))"
"(let-values(((p-ns_0)"
"(namespace->namespace-at-phase"
" m-ns_0"
" phase_0)))"
"(let-values(((insp_0)"
"(module-inspector"
" m_0)))"
"(let-values(((data-box_0)"
"(module-instance-data-box"
" mi_0)))"
"(let-values(((prep_0)"
"(module-prepare-instance"
" m_0)))"
"(let-values(((go_0)"
"(module-instantiate-phase"
" m_0)))"
"(begin"
"(prep_0"
" data-box_0"
" p-ns_0"
" phase-shift_0"
" mpi_0"
" bulk-binding-registry_0"
" insp_0)"
"(go_0"
" data-box_0"
" p-ns_0"
" phase-shift_0"
" phase-level_0"
" mpi_0"
" bulk-binding-registry_0"
" insp_0))))))))))))"
"(if(if otherwise-available?_0"
"(if(not"
"(negative?"
" run-phase_0))"
"(not"
"(small-hash-ref"
"(module-instance-phase-level-to-state"
" mi_0)"
" phase-level_0"
" #f))"
" #f)"
" #f)"
"(let-values()"
"(begin"
"(hash-update!"
"(namespace-available-module-instances"
" ns_0)"
" phase_0"
"(lambda(l_0)"
"(cons"
" mi_0"
" l_0))"
" null)"
"(small-hash-set!"
"(module-instance-phase-level-to-state"
" mi_0)"
" phase-level_0"
" 'available)))"
"(void)))))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(+ pos_0 inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0)))"
"(void))))"
"(if otherwise-available?_0"
"(let-values()(set-module-instance-made-available?! mi_0 #t))"
"(void))"
"(if skip-run?_0"
"(void)"
"(let-values()"
"(small-hash-set!"
"(module-instance-phase-level-to-state mi_0)"
" run-phase-level_0"
" 'started)))))))))))))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))))))))"
"(define-values"
"(namespace-visit-available-modules!)"
"(let-values(((namespace-visit-available-modules!130_0)"
"(lambda(ns129_0 run-phase128_0)"
"(begin"
" 'namespace-visit-available-modules!130"
"(let-values(((ns_0) ns129_0))"
"(let-values(((run-phase_0)"
"(if(eq? run-phase128_0 unsafe-undefined)(namespace-phase ns_0) run-phase128_0)))"
"(let-values()(namespace-run-available-modules! ns_0(add1 run-phase_0)))))))))"
"(case-lambda"
"((ns_0)(begin(namespace-visit-available-modules!130_0 ns_0 unsafe-undefined)))"
"((ns_0 run-phase128_0)(namespace-visit-available-modules!130_0 ns_0 run-phase128_0)))))"
"(define-values"
"(namespace-run-available-modules!)"
"(let-values(((namespace-run-available-modules!134_0)"
"(lambda(ns133_0 run-phase132_0)"
"(begin"
" 'namespace-run-available-modules!134"
"(let-values(((ns_0) ns133_0))"
"(let-values(((run-phase_0)"
"(if(eq? run-phase132_0 unsafe-undefined)(namespace-phase ns_0) run-phase132_0)))"
"(let-values()"
"(registry-call-with-lock"
"(namespace-module-registry$1 ns_0)"
"(lambda()"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((mis_0)"
"(hash-ref"
"(namespace-available-module-instances ns_0)"
" run-phase_0"
" null)))"
"(if(null? mis_0)"
"(void)"
"(let-values()"
"(begin"
"(hash-set!"
"(namespace-available-module-instances ns_0)"
" run-phase_0"
" null)"
"(let-values(((lst_0)(reverse$1 mis_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mi_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((mi222_0)"
" mi_0)"
"((ns223_0)"
" ns_0)"
"((run-phase224_0)"
" run-phase_0)"
"((temp225_0)"
" #f)"
"((temp226_0)"
" #f))"
"(run-module-instance!125.1"
" temp226_0"
" run-phase224_0"
" unsafe-undefined"
" temp225_0"
" mi222_0"
" ns223_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0 rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(loop_0)))))))))"
" loop_0)))))))))))"
"(case-lambda"
"((ns_0)(begin(namespace-run-available-modules!134_0 ns_0 unsafe-undefined)))"
"((ns_0 run-phase132_0)(namespace-run-available-modules!134_0 ns_0 run-phase132_0)))))"
"(define-values"
"(namespace-primitive-module-visit!)"
"(lambda(ns_0 name_0)"
"(begin"
"(let-values(((mi_0)(hash-ref(namespace-module-instances ns_0)(1/make-resolved-module-path name_0))))"
"(let-values(((mi227_0) mi_0)((ns228_0) ns_0)((temp229_0) 1)((temp230_0) #f)((temp231_0) #t))"
"(run-module-instance!125.1 temp231_0 temp229_0 unsafe-undefined temp230_0 mi227_0 ns228_0))))))"
"(define-values"
"(namespace-module-use->module+linklet-instances144.1)"
"(lambda(phase-shift138_0 shift-from136_0 shift-to137_0 ns142_0 mu143_0)"
"(begin"
" 'namespace-module-use->module+linklet-instances144"
"(let-values(((ns_0) ns142_0))"
"(let-values(((mu_0) mu143_0))"
"(let-values(((shift-from_0) shift-from136_0))"
"(let-values(((shift-to_0) shift-to137_0))"
"(let-values(((phase-shift_0) phase-shift138_0))"
"(let-values()"
"(let-values(((mod_0)(module-use-module mu_0)))"
"(let-values(((mi_0)"
"(let-values(((ns232_0) ns_0)"
"((temp233_0)"
"(1/module-path-index-resolve"
"(if shift-from_0"
"(module-path-index-shift mod_0 shift-from_0 shift-to_0)"
" mod_0)))"
"((phase-shift234_0) phase-shift_0)"
"((temp235_0) #t))"
"(namespace->module-instance70.1"
" #f"
" temp235_0"
" unsafe-undefined"
" ns232_0"
" temp233_0"
" phase-shift234_0))))"
"(let-values(((m-ns_0)(module-instance-namespace mi_0)))"
"(let-values(((d_0)"
"(small-hash-ref"
"(namespace-phase-level-to-definitions m-ns_0)"
"(module-use-phase mu_0)"
" #f)))"
"(if d_0"
"(values mi_0(definitions-variables d_0))"
"(error"
" 'eval"
"(string-append"
"                              \"namespace mismatch: phase level not found;\\n\""
"                              \"  module: ~a\\n\""
"                              \"  phase level: ~a\\n\""
"                              \"  found phase levels: ~a\")"
" mod_0"
"(module-use-phase mu_0)"
"(small-hash-keys(namespace-phase-level-to-definitions m-ns_0)))))))))))))))))"
"(define-values"
"(unresolve-requires)"
"(lambda(requires_0)"
"(begin"
"(reverse$1"
"(let-values(((lst_0) requires_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((phase+mpis_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
"(car phase+mpis_0)"
"(reverse$1"
"(let-values(((lst_2)(cdr phase+mpis_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair? lst_3)"
"(let-values(((req-mpi_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(module-path-index-unresolve"
" req-mpi_0))"
" fold-var_3))))"
"(values"
" fold-var_4)))))"
"(if(not #f)"
"(for-loop_1"
" fold-var_3"
" rest_1)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
" lst_2))))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(define-values"
"(module-compute-access!)"
"(lambda(m_0)"
"(begin"
"(let-values(((access_0)"
"(let-values(((ht_0)(module-provides m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 at-phase_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" phase_0"
"(let-values(((ht_1)"
" at-phase_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_2"
" i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((sym_0"
" binding/p_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((table_3)"
"(let-values(((table_3)"
" table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(module-binding-sym"
"(provided-as-binding"
" binding/p_0))"
"(if(provided-as-protected?"
" binding/p_0)"
" 'protected"
" 'provided)))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" table_3"
"(hash-iterate-next"
" ht_1"
" i_1))"
" table_3)))"
" table_2)))))"
" for-loop_1)"
" '#hash()"
"(hash-iterate-first"
" ht_1))))))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
"(hash-iterate-first ht_0))))))"
"(begin(set-module-access! m_0 access_0) access_0)))))"
"(define-values"
"(binding->module-instance)"
"(lambda(b_0 ns_0 phase_0 id_0)"
"(begin"
"(let-values(((at-phase_0)(phase- phase_0(module-binding-phase b_0))))"
"(let-values(((mi_0)"
"(let-values(((ns1_0) ns_0)"
"((temp2_0)(1/module-path-index-resolve(module-binding-module b_0)))"
"((at-phase3_0) at-phase_0)"
"((temp4_0)(module-binding-phase b_0))"
"((temp5_0)(lambda(mi_0) 'unavailable)))"
"(namespace->module-instance70.1 temp4_0 #f temp5_0 ns1_0 temp2_0 at-phase3_0))))"
"(begin"
"(if(eq? mi_0 'unavailable)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"(format"
"(string-append"
"                   \"module mismatch;\\n\""
"                   \" attempted to use a module that is not available\\n\""
"                   \"  possible cause:\\n\""
"                   \"   using (dynamic-require .... #f)\\n\""
"                   \"   but need (dynamic-require .... 0)\\n\""
"                   \"  module: ~s\\n\""
"                   \"  phase: ~s\")"
"(module-binding-module b_0)"
"(phase+ at-phase_0(module-binding-phase b_0)))"
" id_0))"
"(void))"
"(if mi_0"
"(void)"
"(let-values()"
"(error"
" 'expand"
"(string-append"
"                  \"namespace mismatch; cannot locate module instance\\n\""
"                  \"  module: ~s\\n\""
"                  \"  use phase: ~a\\n\""
"                  \"  definition phase: ~a\\n\""
"                  \"  for identifier: ~s\")"
"(module-binding-module b_0)"
" phase_0"
"(module-binding-phase b_0)"
" id_0)))"
" mi_0))))))"
"(define-values"
"(check-access)"
"(lambda(b_0 mi_0 id_0 in-s_0 what_0)"
"(begin"
"(let-values(((m_0)(module-instance-module mi_0)))"
"(if(if m_0(not(module-no-protected? m_0)) #f)"
"(let-values()"
"(let-values(((access_0)"
"(let-values(((or-part_0)(module-access m_0)))"
"(if or-part_0 or-part_0(module-compute-access! m_0)))))"
"(let-values(((a_0)"
"(hash-ref"
"(hash-ref access_0(module-binding-phase b_0) '#hasheq())"
"(module-binding-sym b_0)"
" 'unexported)))"
"(if(let-values(((or-part_0)(eq? a_0 'unexported)))(if or-part_0 or-part_0(eq? a_0 'protected)))"
"(let-values()"
"(begin"
"(if(let-values(((or-part_0)"
"(inspector-superior?"
"(let-values(((or-part_0)(syntax-inspector id_0)))"
"(if or-part_0 or-part_0(current-code-inspector)))"
"(namespace-inspector(module-instance-namespace mi_0)))))"
"(if or-part_0"
" or-part_0"
"(if(module-binding-extra-inspector b_0)"
"(inspector-superior?"
"(module-binding-extra-inspector b_0)"
"(namespace-inspector(module-instance-namespace mi_0)))"
" #f)))"
"(void)"
"(let-values()"
"(let-values(((complain-id_0)"
"(let-values(((c-id_0)"
"(let-values(((or-part_0) in-s_0))"
"(if or-part_0 or-part_0(module-binding-sym b_0)))))"
"(if(not"
"(eq?"
"(if(syntax?$1 c-id_0)(syntax-content c-id_0) c-id_0)"
"(syntax-content id_0)))"
" c-id_0"
" #f))))"
"(raise-syntax-error$1"
" #f"
"(format"
"                              \"access disallowed by code inspector to ~a ~a\\n  from module: ~a\""
" a_0"
" what_0"
"(1/module-path-index-resolve(namespace-mpi(module-instance-namespace mi_0))))"
" complain-id_0"
" id_0"
" null))))"
" #t))"
"(let-values() #f)))))"
"(let-values() #f))))))"
"(define-values"
"(resolve+shift/extra-inspector)"
"(lambda(id_0 phase_0 ns_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(id_1 in-s_0)"
"(begin"
" 'loop"
"(let-values(((b_0)"
"(let-values(((id1_0) id_1)((phase2_0) phase_0)((temp3_0) #t))"
"(resolve+shift28.1 #f #f null temp3_0 #f id1_0 phase2_0))))"
"(let-values(((c1_0)(binding-free=id b_0)))"
"(if c1_0"
"((lambda(next-id_0)"
"(let-values((()"
"(begin"
"(if(if(module-binding? b_0)"
"(not"
"(top-level-module-path-index?(module-binding-module b_0)))"
" #f)"
"(let-values()"
"(let-values(((mi_0)"
"(binding->module-instance"
" b_0"
" ns_0"
" phase_0"
" id_1)))"
"                                                           (check-access b_0 mi_0 id_1 in-s_0 \"provided binding\")))"
"(void))"
"(values))))"
"(let-values(((next-b_0)"
"(loop_0"
" next-id_0"
"(let-values(((or-part_0) in-s_0))"
"(if or-part_0 or-part_0 id_1)))))"
"(if(not next-b_0)"
"(let-values() b_0)"
"(if(if(module-binding? next-b_0)"
"(if(not(module-binding-extra-inspector next-b_0))"
"(syntax-inspector id_1)"
" #f)"
" #f)"
"(let-values()"
"(let-values(((next-b4_0) next-b_0)((temp5_0)(syntax-inspector id_1)))"
"(module-binding-update46.1"
" temp5_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" next-b4_0)))"
"(let-values() next-b_0))))))"
" c1_0)"
"(let-values() b_0))))))))"
" loop_0)"
" id_0"
" #f))))"
"(define-values"
"(1/prop:set!-transformer 1/set!-transformer? set!-transformer-value)"
"(make-struct-type-property"
" 'set!-transformer"
"(lambda(v_0 info_0)"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)"
"(if(procedure? v_0)"
"(let-values(((or-part_0)(procedure-arity-includes? v_0 1)))"
"(if or-part_0 or-part_0(procedure-arity-includes? v_0 2)))"
" #f)))"
"(if or-part_0 or-part_0(exact-nonnegative-integer? v_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'guard-for-prop:set!-transformer"
"(string-append"
"                           \"(or/c (procedure-arity-includes? proc 1)\\n\""
"                           \"      (procedure-arity-includes? proc 2)\\n\""
"                           \"      exact-nonnegative-integer?)\")"
" v_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(exact-nonnegative-integer? v_0)"
"(let-values()"
"(begin"
"(if(<= v_0(list-ref info_0 1))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'guard-for-prop:set!-transformer"
"                                  \"field index >= initialized-field count for structure type\""
"                                  \"field index\""
" v_0"
"                                  \"initialized-field count\""
"(list-ref info_0 1))))"
"(if(member v_0(list-ref info_0 5))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'guard-for-prop:set!-transformer"
"                                  \"field index not declared immutable\""
"                                  \"field index\""
" v_0)))))"
"(void))"
"(values))))"
"(let-values(((ref_0)(list-ref info_0 3)))"
"(if(integer? v_0)"
"(let-values()"
"(lambda(t_0)"
"(let-values(((p_0)(ref_0 t_0 v_0)))"
"(if(if(procedure? p_0)(procedure-arity-includes? p_0 1) #f)"
" p_0"
"                     (lambda (s_0) (error \"bad syntax:\" s_0))))))"
"(let-values()(lambda(t_0) v_0)))))))))"
"(define-values"
"(1/make-set!-transformer)"
"(let-values()"
"(let-values(((struct:set!-transformer_0 set!-transformer1_0 set!-transformer?_0 set!-transformer-proc_0)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'set!-transformer"
" #f"
" 1"
" 0"
" #f"
"(list(cons 1/prop:set!-transformer 0))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'set!-transformer)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'proc)))))"
"(lambda(proc_0)"
"(begin"
" 'make-set!-transformer"
"(begin"
"(if(if(procedure? proc_0)(procedure-arity-includes? proc_0 1) #f)"
"(void)"
"              (let-values () (raise-argument-error 'make-set!-transformer \"(procedure-arity-includes/c 1)\" proc_0)))"
"(set!-transformer1_0 proc_0)))))))"
"(define-values"
"(1/set!-transformer-procedure)"
"(lambda(t_0)"
"(begin"
" 'set!-transformer-procedure"
"(let-values(((v_0)((set!-transformer-value t_0) t_0)))"
"(if(procedure-arity-includes? v_0 1) v_0(lambda(s_0)(v_0 t_0 s_0)))))))"
"(define-values(empty-env) '#hasheq())"
"(define-values(env-extend)(lambda(env_0 key_0 val_0)(begin(hash-set env_0 key_0 val_0))))"
"(define-values(lookup)(lambda(env_0 key_0 default_0)(begin(hash-ref env_0 key_0 default_0))))"
"(define-values(variable)(gensym 'variable))"
"(define-values"
"(variable?)"
"(lambda(t_0)(begin(let-values(((or-part_0)(eq? t_0 variable)))(if or-part_0 or-part_0(local-variable? t_0))))))"
"(define-values"
"(struct:local-variable local-variable1.1 local-variable? local-variable-id)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'local-variable"
" #f"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'local-variable)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'id))))"
"(define-values"
"(substitute-variable6.1)"
"(lambda(no-stops?2_0 id4_0 t5_0)"
"(begin"
" 'substitute-variable6"
"(let-values(((id_0) id4_0))"
"(let-values(((t_0) t5_0))"
"(let-values(((no-stops?_0) no-stops?2_0))"
"(let-values()"
"(if(if no-stops?_0(local-variable? t_0) #f)"
"(let-values(((bind-id_0)(local-variable-id t_0)))"
"(syntax-rearm$1(datum->syntax$1(syntax-disarm$1 bind-id_0)(syntax-e$1 bind-id_0) id_0 id_0) id_0))"
" id_0))))))))"
"(define-values(missing)(gensym 'missing))"
"(define-values"
"(transformer?)"
"(lambda(t_0)"
"(begin"
"(let-values(((or-part_0)(procedure? t_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(1/set!-transformer? t_0)))"
"(if or-part_1 or-part_1(1/rename-transformer? t_0))))))))"
"(define-values"
"(transformer->procedure)"
"(lambda(t_0)"
"(begin"
"(if(1/set!-transformer? t_0)"
"(let-values()(1/set!-transformer-procedure t_0))"
"(if(1/rename-transformer? t_0)(let-values()(lambda(s_0) s_0))(let-values() t_0))))))"
"(define-values"
"(struct:core-form core-form9.1 core-form? core-form-expander core-form-name)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'core-form"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
" #f"
" #f"
" '(0 1)"
" #f"
" 'core-form)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'expander)"
"(make-struct-field-accessor -ref_0 1 'name))))"
"(define-values"
"(add-binding!17.1)"
"(lambda(in10_0 just-for-nominal?11_0 id14_0 binding15_0 phase16_0)"
"(begin"
" 'add-binding!17"
"(let-values(((id_0) id14_0))"
"(let-values(((binding_0) binding15_0))"
"(let-values(((phase_0) phase16_0))"
"(let-values(((in-s_0) in10_0))"
"(let-values(((just-for-nominal?_0) just-for-nominal?11_0))"
"(let-values()"
"(begin"
"(check-id-taint id_0 in-s_0)"
"(let-values(((temp57_0)(syntax-scope-set id_0 phase_0))"
"((temp58_0)(syntax-e$1 id_0))"
"((binding59_0) binding_0)"
"((just-for-nominal?60_0) just-for-nominal?_0))"
"(add-binding-in-scopes!20.1 just-for-nominal?60_0 temp57_0 temp58_0 binding59_0))))))))))))"
"(define-values"
"(add-bulk-binding!27.1)"
"(lambda(in20_0 shadow-except21_0 s24_0 binding25_0 phase26_0)"
"(begin"
" 'add-bulk-binding!27"
"(let-values(((s_0) s24_0))"
"(let-values(((binding_0) binding25_0))"
"(let-values(((phase_0) phase26_0))"
"(let-values(((in-s_0) in20_0))"
"(let-values(((shadow-except_0) shadow-except21_0))"
"(let-values()"
"(begin"
"(if(syntax-tainted?$1 s_0)"
"                      (let-values () (raise-syntax-error$1 #f \"cannot bind from tainted syntax\" in-s_0 s_0))"
"(void))"
"(let-values(((temp61_0)(syntax-scope-set s_0 phase_0))"
"((binding62_0) binding_0)"
"((shadow-except63_0) shadow-except_0))"
"(add-bulk-binding-in-scopes!27.1 shadow-except63_0 temp61_0 binding62_0))))))))))))"
"(define-values"
"(add-local-binding!39.1)"
"(lambda(frame-id31_0 in32_0 local-sym30_0 id36_0 phase37_0 counter38_0)"
"(begin"
" 'add-local-binding!39"
"(let-values(((id_0) id36_0))"
"(let-values(((phase_0) phase37_0))"
"(let-values(((counter_0) counter38_0))"
"(let-values(((local-sym_0) local-sym30_0))"
"(let-values(((frame-id_0) frame-id31_0))"
"(let-values(((in-s_0) in32_0))"
"(let-values()"
"(let-values((()(begin(check-id-taint id_0 in-s_0)(values))))"
"(let-values(((c_0)(add1(unbox counter_0))))"
"(let-values((()(begin(set-box! counter_0 c_0)(values))))"
"(let-values(((sym_0)(syntax-content id_0)))"
"(let-values(((key_0)"
"(string->uninterned-symbol"
"(string-append"
"(symbol->string"
"(let-values(((or-part_0) local-sym_0))(if or-part_0 or-part_0 sym_0)))"
"                                            \"_\""
"(number->string c_0)))))"
"(begin"
"(let-values(((temp64_0)(syntax-scope-set id_0 phase_0))"
"((sym65_0) sym_0)"
"((temp66_0)"
"(let-values(((key67_0) key_0)((frame-id68_0) frame-id_0))"
"(make-local-binding7.1 frame-id68_0 #f key67_0))))"
"(add-binding-in-scopes!20.1 #f temp64_0 sym65_0 temp66_0))"
" key_0))))))))))))))))"
"(define-values"
"(check-id-taint)"
"(lambda(id_0 in-s_0)"
"(begin"
"(if(syntax-tainted?$1 id_0)"
"        (let-values () (raise-syntax-error$1 #f \"cannot bind tainted identifier\" in-s_0 id_0))"
"(void)))))"
"(define-values"
"(binding-lookup52.1)"
"(lambda(in42_0 out-of-context-as-variable?43_0 b46_0 env47_0 lift-envs48_0 ns49_0 phase50_0 id51_0)"
"(begin"
" 'binding-lookup52"
"(let-values(((b_0) b46_0))"
"(let-values(((env_0) env47_0))"
"(let-values(((lift-envs_0) lift-envs48_0))"
"(let-values(((ns_0) ns49_0))"
"(let-values(((phase_0) phase50_0))"
"(let-values(((id_0) id51_0))"
"(let-values(((in-s_0) in42_0))"
"(let-values(((out-of-context-as-variable?_0) out-of-context-as-variable?43_0))"
"(let-values()"
"(if(module-binding? b_0)"
"(let-values()"
"(let-values(((top-level?_0)(top-level-module-path-index?(module-binding-module b_0))))"
"(let-values(((mi_0)"
"(if(not top-level?_0)"
"(binding->module-instance b_0 ns_0 phase_0 id_0)"
" #f)))"
"(let-values(((m_0)(if mi_0(module-instance-module mi_0) #f)))"
"(let-values(((primitive?_0)(if m_0(module-primitive? m_0) #f)))"
"(let-values(((m-ns_0)"
"(if top-level?_0 ns_0(if mi_0(module-instance-namespace mi_0) #f))))"
"(let-values((()(begin(check-taint id_0)(values))))"
"(let-values(((t_0)"
"(namespace-get-transformer"
" m-ns_0"
"(module-binding-phase b_0)"
"(module-binding-sym b_0)"
" variable)))"
"(let-values(((protected?_0)"
"(if mi_0"
"(check-access"
" b_0"
" mi_0"
" id_0"
" in-s_0"
"                                                           (if (variable? t_0) \"variable\" \"transformer\"))"
" #f)))"
"(let-values(((insp_0)"
"(if mi_0"
"(if(module-instance-module mi_0)"
"(module-inspector(module-instance-module mi_0))"
" #f)"
" #f)))"
"(values t_0 primitive?_0 insp_0 protected?_0)))))))))))"
"(if(local-binding? b_0)"
"(let-values()"
"(let-values(((t_0)(lookup env_0(local-binding-key b_0) missing)))"
"(if(eq? t_0 missing)"
"(let-values()"
"(values"
"(let-values(((or-part_0)"
"(let-values(((lst_0) lift-envs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((lift-env_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(lookup"
"(unbox"
" lift-env_0)"
"(local-binding-key"
" b_0)"
" #f)))))"
"(values result_1)))))"
"(if(if(not"
"((lambda x_0 result_1)"
" lift-env_0))"
"(not #f)"
" #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" lst_0)))))"
"(if or-part_0"
" or-part_0"
"(if out-of-context-as-variable?_0"
" variable"
"                                           (error \"identifier used out of context:\" id_0))))"
" #f"
" #f"
" #f))"
"(let-values()(begin(check-taint id_0)(values t_0 #f #f #f))))))"
"                            (let-values () (error \"internal error: unknown binding for lookup:\" b_0))))))))))))))))"
"(define-values"
"(check-taint)"
"(lambda(id_0)"
"(begin"
"(if(syntax-tainted?$1 id_0)"
"        (let-values () (raise-syntax-error$1 #f \"cannot use identifier tainted by macro transformation\" id_0))"
"(void)))))"
"(define-values(root-tag)(unsafe-root-continuation-prompt-tag))"
"(define-values(cons-ish)(lambda(a_0 b_0)(begin(if(null? b_0) a_0(cons a_0 b_0)))))"
"(define-values"
"(free-id-set)"
"(lambda(phase_0 ids_0)"
"(begin"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((ht_1)"
"(let-values(((ht_1) ht_0))"
"(let-values(((ht_2)"
"(let-values()"
"(let-values(((sym_0)"
"(identifier-binding-symbol$1"
" id_0"
" phase_0)))"
"(hash-set"
" ht_1"
" sym_0"
"(cons-ish id_0(hash-ref ht_1 sym_0 null)))))))"
"(values ht_2)))))"
"(if(not #f)(for-loop_0 ht_1 rest_0) ht_1)))"
" ht_0)))))"
" for-loop_0)"
" '#hasheq()"
" lst_0))))))"
"(define-values(empty-free-id-set)(free-id-set 0 null))"
"(define-values(free-id-set-empty?)(lambda(fs_0)(begin(eq? fs_0 empty-free-id-set))))"
"(define-values"
"(free-id-set-member?)"
"(lambda(fs_0 phase_0 given-id_0)"
"(begin"
"(if(free-id-set-empty? fs_0)"
" #f"
"(let-values(((lst_0)(hash-ref fs_0(identifier-binding-symbol$1 given-id_0 phase_0) null)))"
"(begin"
"(void)"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(not(null? lst_1))"
"(let-values(((id_0)(if(pair? lst_1)(car lst_1) lst_1))"
"((rest_0)(if(pair? lst_1)(cdr lst_1) null)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(free-identifier=?$1"
" id_0"
" given-id_0"
" phase_0"
" phase_0)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) id_0))(not #f) #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" lst_0)))))))"
"(define-values"
"(free-id-set-empty-or-just-module*?)"
"(lambda(fs_0)(begin(let-values(((c_0)(hash-count fs_0)))(<= c_0 1)))))"
"(define-values"
"(struct:expand-context/outer"
" expand-context/outer1.1"
" expand-context/outer?"
" expand-context/outer-context"
" expand-context/outer-env"
" expand-context/outer-scopes"
" expand-context/outer-def-ctx-scopes"
" expand-context/outer-binding-layer"
" expand-context/outer-reference-records"
" expand-context/outer-only-immediate?"
" expand-context/outer-need-eventually-defined"
" expand-context/outer-current-introduction-scopes"
" expand-context/outer-current-use-scopes"
" expand-context/outer-name)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'expand-context"
" struct:root-expand-context/outer"
" 11"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10)"
" #f"
" 'expand-context/outer)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'context)"
"(make-struct-field-accessor -ref_0 1 'env)"
"(make-struct-field-accessor -ref_0 2 'scopes)"
"(make-struct-field-accessor -ref_0 3 'def-ctx-scopes)"
"(make-struct-field-accessor -ref_0 4 'binding-layer)"
"(make-struct-field-accessor -ref_0 5 'reference-records)"
"(make-struct-field-accessor -ref_0 6 'only-immediate?)"
"(make-struct-field-accessor -ref_0 7 'need-eventually-defined)"
"(make-struct-field-accessor -ref_0 8 'current-introduction-scopes)"
"(make-struct-field-accessor -ref_0 9 'current-use-scopes)"
"(make-struct-field-accessor -ref_0 10 'name))))"
"(define-values"
"(struct:expand-context/inner"
" expand-context/inner2.1"
" expand-context/inner?"
" expand-context/inner-to-parsed?"
" expand-context/inner-phase"
" expand-context/inner-namespace"
" expand-context/inner-just-once?"
" expand-context/inner-module-begin-k"
" expand-context/inner-allow-unbound?"
" expand-context/inner-in-local-expand?"
" expand-context/inner-keep-#%expression?"
" expand-context/inner-stops"
" expand-context/inner-declared-submodule-names"
" expand-context/inner-lifts"
" expand-context/inner-lift-envs"
" expand-context/inner-module-lifts"
" expand-context/inner-require-lifts"
" expand-context/inner-to-module-lifts"
" expand-context/inner-requires+provides"
" expand-context/inner-observer"
" expand-context/inner-for-serializable?"
" expand-context/inner-to-correlated-linklet?"
" expand-context/inner-normalize-locals?"
" expand-context/inner-should-not-encounter-macros?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'expand-context/inner"
" struct:root-expand-context/inner"
" 21"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)"
" #f"
" 'expand-context/inner)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'to-parsed?)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'namespace)"
"(make-struct-field-accessor -ref_0 3 'just-once?)"
"(make-struct-field-accessor -ref_0 4 'module-begin-k)"
"(make-struct-field-accessor -ref_0 5 'allow-unbound?)"
"(make-struct-field-accessor -ref_0 6 'in-local-expand?)"
"(make-struct-field-accessor -ref_0 7 'keep-#%expression?)"
"(make-struct-field-accessor -ref_0 8 'stops)"
"(make-struct-field-accessor -ref_0 9 'declared-submodule-names)"
"(make-struct-field-accessor -ref_0 10 'lifts)"
"(make-struct-field-accessor -ref_0 11 'lift-envs)"
"(make-struct-field-accessor -ref_0 12 'module-lifts)"
"(make-struct-field-accessor -ref_0 13 'require-lifts)"
"(make-struct-field-accessor -ref_0 14 'to-module-lifts)"
"(make-struct-field-accessor -ref_0 15 'requires+provides)"
"(make-struct-field-accessor -ref_0 16 'observer)"
"(make-struct-field-accessor -ref_0 17 'for-serializable?)"
"(make-struct-field-accessor -ref_0 18 'to-correlated-linklet?)"
"(make-struct-field-accessor -ref_0 19 'normalize-locals?)"
"(make-struct-field-accessor -ref_0 20 'should-not-encounter-macros?))))"
"(define-values"
"(expand-context/make)"
"(lambda(self-mpi_0"
" module-scopes_0"
" post-expansion_0"
" top-level-bind-scope_0"
" all-scopes-stx_0"
" use-site-scopes_0"
" defined-syms_0"
" frame-id_0"
" counter_0"
" lift-key_0"
" to-parsed?_0"
" context_0"
" phase_0"
" namespace_0"
" env_0"
" scopes_0"
" def-ctx-scopes_0"
" binding-layer_0"
" reference-records_0"
" only-immediate?_0"
" just-once?_0"
" module-begin-k_0"
" need-eventually-defined_0"
" allow-unbound?_0"
" in-local-expand?_0"
" keep-#%expression?_0"
" stops_0"
" current-introduction-scopes_0"
" current-use-scopes_0"
" declared-submodule-names_0"
" lifts_0"
" lift-envs_0"
" module-lifts_0"
" require-lifts_0"
" to-module-lifts_0"
" requires+provides_0"
" name_0"
" observer_0"
" for-serializable?_0"
" to-correlated-linklet?_0"
" normalize-locals?_0"
" should-not-encounter-macros?_0)"
"(begin"
"(expand-context/outer1.1"
"(expand-context/inner2.1"
" self-mpi_0"
" module-scopes_0"
" top-level-bind-scope_0"
" all-scopes-stx_0"
" defined-syms_0"
" counter_0"
" lift-key_0"
" to-parsed?_0"
" phase_0"
" namespace_0"
" just-once?_0"
" module-begin-k_0"
" allow-unbound?_0"
" in-local-expand?_0"
" keep-#%expression?_0"
" stops_0"
" declared-submodule-names_0"
" lifts_0"
" lift-envs_0"
" module-lifts_0"
" require-lifts_0"
" to-module-lifts_0"
" requires+provides_0"
" observer_0"
" for-serializable?_0"
" to-correlated-linklet?_0"
" normalize-locals?_0"
" should-not-encounter-macros?_0)"
" post-expansion_0"
" use-site-scopes_0"
" frame-id_0"
" context_0"
" env_0"
" scopes_0"
" def-ctx-scopes_0"
" binding-layer_0"
" reference-records_0"
" only-immediate?_0"
" need-eventually-defined_0"
" current-introduction-scopes_0"
" current-use-scopes_0"
" name_0))))"
"(define-values(expand-context-context)(lambda(v_0)(begin(expand-context/outer-context v_0))))"
"(define-values(expand-context-env)(lambda(v_0)(begin(expand-context/outer-env v_0))))"
"(define-values(expand-context-scopes)(lambda(v_0)(begin(expand-context/outer-scopes v_0))))"
"(define-values(expand-context-def-ctx-scopes)(lambda(v_0)(begin(expand-context/outer-def-ctx-scopes v_0))))"
"(define-values(expand-context-binding-layer)(lambda(v_0)(begin(expand-context/outer-binding-layer v_0))))"
"(define-values(expand-context-reference-records)(lambda(v_0)(begin(expand-context/outer-reference-records v_0))))"
"(define-values(expand-context-only-immediate?)(lambda(v_0)(begin(expand-context/outer-only-immediate? v_0))))"
"(define-values"
"(expand-context-need-eventually-defined)"
"(lambda(v_0)(begin(expand-context/outer-need-eventually-defined v_0))))"
"(define-values"
"(expand-context-current-introduction-scopes)"
"(lambda(v_0)(begin(expand-context/outer-current-introduction-scopes v_0))))"
"(define-values"
"(expand-context-current-use-scopes)"
"(lambda(v_0)(begin(expand-context/outer-current-use-scopes v_0))))"
"(define-values(expand-context-name)(lambda(v_0)(begin(expand-context/outer-name v_0))))"
"(define-values"
"(expand-context-to-parsed?)"
"(lambda(v_0)(begin(expand-context/inner-to-parsed?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-phase)"
"(lambda(v_0)(begin(expand-context/inner-phase(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-namespace)"
"(lambda(v_0)(begin(expand-context/inner-namespace(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-just-once?)"
"(lambda(v_0)(begin(expand-context/inner-just-once?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-module-begin-k)"
"(lambda(v_0)(begin(expand-context/inner-module-begin-k(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-allow-unbound?)"
"(lambda(v_0)(begin(expand-context/inner-allow-unbound?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-in-local-expand?)"
"(lambda(v_0)(begin(expand-context/inner-in-local-expand?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-keep-#%expression?)"
"(lambda(v_0)(begin(expand-context/inner-keep-#%expression?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-stops)"
"(lambda(v_0)(begin(expand-context/inner-stops(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-declared-submodule-names)"
"(lambda(v_0)(begin(expand-context/inner-declared-submodule-names(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-lifts)"
"(lambda(v_0)(begin(expand-context/inner-lifts(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-lift-envs)"
"(lambda(v_0)(begin(expand-context/inner-lift-envs(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-module-lifts)"
"(lambda(v_0)(begin(expand-context/inner-module-lifts(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-require-lifts)"
"(lambda(v_0)(begin(expand-context/inner-require-lifts(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-to-module-lifts)"
"(lambda(v_0)(begin(expand-context/inner-to-module-lifts(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-requires+provides)"
"(lambda(v_0)(begin(expand-context/inner-requires+provides(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-observer)"
"(lambda(v_0)(begin(expand-context/inner-observer(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-for-serializable?)"
"(lambda(v_0)(begin(expand-context/inner-for-serializable?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-to-correlated-linklet?)"
"(lambda(v_0)(begin(expand-context/inner-to-correlated-linklet?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-normalize-locals?)"
"(lambda(v_0)(begin(expand-context/inner-normalize-locals?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(expand-context-should-not-encounter-macros?)"
"(lambda(v_0)(begin(expand-context/inner-should-not-encounter-macros?(root-expand-context/outer-inner v_0)))))"
"(define-values"
"(make-expand-context12.1)"
"(lambda(for-serializable?4_0 observer6_0 to-correlated-linklet?5_0 to-parsed?3_0 ns11_0)"
"(begin"
" 'make-expand-context12"
"(let-values(((ns_0) ns11_0))"
"(let-values(((to-parsed?_0) to-parsed?3_0))"
"(let-values(((for-serializable?_0) for-serializable?4_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?5_0))"
"(let-values(((observer_0) observer6_0))"
"(let-values()"
"(let-values(((root-ctx_0)(namespace-get-root-expand-ctx ns_0)))"
"(expand-context/make"
"(root-expand-context-self-mpi root-ctx_0)"
"(root-expand-context-module-scopes root-ctx_0)"
"(root-expand-context-post-expansion root-ctx_0)"
"(root-expand-context-top-level-bind-scope root-ctx_0)"
"(root-expand-context-all-scopes-stx root-ctx_0)"
"(root-expand-context-use-site-scopes root-ctx_0)"
"(root-expand-context-defined-syms root-ctx_0)"
"(root-expand-context-frame-id root-ctx_0)"
"(root-expand-context-counter root-ctx_0)"
"(root-expand-context-lift-key root-ctx_0)"
" to-parsed?_0"
" 'top-level"
"(namespace-phase ns_0)"
" ns_0"
" empty-env"
" null"
" #f"
"(root-expand-context-frame-id root-ctx_0)"
" null"
" #f"
" #f"
" #f"
" #f"
" #t"
" #f"
" #f"
" empty-free-id-set"
" null"
" null"
" '#hasheq()"
" #f"
" '()"
" #f"
" #f"
" #f"
" #f"
" #f"
" observer_0"
" for-serializable?_0"
" to-correlated-linklet?_0"
" to-correlated-linklet?_0"
" #f)))))))))))"
"(define-values"
"(copy-root-expand-context)"
"(lambda(ctx_0 root-ctx_0)"
"(begin"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((post-expansion29_0)(root-expand-context-post-expansion root-ctx_0))"
"((use-site-scopes30_0)(root-expand-context-use-site-scopes root-ctx_0))"
"((frame-id31_0)(root-expand-context-frame-id root-ctx_0))"
"((binding-layer32_0)(root-expand-context-frame-id root-ctx_0))"
"((inner33_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((self-mpi34_0)(root-expand-context-self-mpi root-ctx_0))"
"((module-scopes35_0)(root-expand-context-module-scopes root-ctx_0))"
"((top-level-bind-scope36_0)"
"(root-expand-context-top-level-bind-scope root-ctx_0))"
"((all-scopes-stx37_0)(root-expand-context-all-scopes-stx root-ctx_0))"
"((defined-syms38_0)(root-expand-context-defined-syms root-ctx_0))"
"((counter39_0)(root-expand-context-counter root-ctx_0))"
"((lift-key40_0)(root-expand-context-lift-key root-ctx_0)))"
"(expand-context/inner2.1"
" self-mpi34_0"
" module-scopes35_0"
" top-level-bind-scope36_0"
" all-scopes-stx37_0"
" defined-syms38_0"
" counter39_0"
" lift-key40_0"
"(expand-context/inner-to-parsed? the-struct_1)"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
"(expand-context/inner-just-once? the-struct_1)"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
"(expand-context/inner-in-local-expand? the-struct_1)"
"(expand-context/inner-keep-#%expression? the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-should-not-encounter-macros? the-struct_1)))"
"                              (raise-argument-error 'struct-copy \"expand-context/inner?\" the-struct_1)))))"
"(expand-context/outer1.1"
" inner33_0"
" post-expansion29_0"
" use-site-scopes30_0"
" frame-id31_0"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
" binding-layer32_0"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"            (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))"
"(define-values(default-val.1$2) #f)"
"(define-values"
"(current-expand-context)"
"(lambda()(begin(continuation-mark-set-first #f current-expand-context default-val.1$2 root-tag))))"
"(define-values"
"(get-current-expand-context18.1)"
"(lambda(fail-ok?15_0 who17_0)"
"(begin"
" 'get-current-expand-context18"
"(let-values(((who_0) who17_0))"
"(let-values(((fail-ok?_0) fail-ok?15_0))"
"(let-values()"
"(let-values(((or-part_0)(force(current-expand-context))))"
"              (if or-part_0 or-part_0 (if fail-ok?_0 #f (raise-arguments-error who_0 \"not currently expanding\"))))))))))"
"(define-values"
"(current-expand-observe)"
"(make-parameter"
" #f"
"(lambda(v_0)"
"(begin"
"(if(let-values(((or-part_0)(not v_0)))"
"(if or-part_0 or-part_0(if(procedure? v_0)(procedure-arity-includes? v_0 2) #f)))"
"(void)"
"         (let-values () (raise-argument-error 'current-expand-observe \"(or/c (procedure-arity-includes/c 2) #f)\" v_0)))"
" v_0))))"
"(define-values"
"(as-expression-context)"
"(lambda(ctx_0)"
"(begin"
"(if(if(eq? 'expression(expand-context-context ctx_0))(not(expand-context-name ctx_0)) #f)"
"(let-values() ctx_0)"
"(let-values()"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context41_0) 'expression)"
"((name42_0) #f)"
"((post-expansion43_0) #f)"
"((inner44_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner44_0"
" post-expansion43_0"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
" context41_0"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
" name42_0))"
"                (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))))"
"(define-values"
"(as-begin-expression-context)"
"(lambda(ctx_0)"
"(begin"
"(if(not(expand-context-name ctx_0))"
"(let-values() ctx_0)"
"(let-values()"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((name45_0) #f)((inner46_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner46_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
" name45_0))"
"                (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))))"
"(define-values"
"(as-tail-context24.1)"
"(lambda(wrt21_0 ctx23_0)"
"(begin"
" 'as-tail-context24"
"(let-values(((ctx_0) ctx23_0))"
"(let-values(((wrt-ctx_0) wrt21_0))"
"(let-values()"
"(if(expand-context-name wrt-ctx_0)"
"(let-values()"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((name47_0)(expand-context-name wrt-ctx_0))"
"((inner48_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner48_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
" name47_0))"
"                      (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))"
"(let-values() ctx_0))))))))"
"(define-values"
"(as-named-context)"
"(lambda(ctx_0 ids_0)"
"(begin"
"(if(if(pair? ids_0)(null?(cdr ids_0)) #f)"
"(let-values()"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((name49_0)(car ids_0))((inner50_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner50_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
" name49_0))"
"                (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))"
"(let-values() ctx_0)))))"
"(define-values"
"(as-to-parsed-context)"
"(lambda(ctx_0)"
"(begin"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner51_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((to-parsed?52_0) #t)"
"((observer53_0) #f)"
"((should-not-encounter-macros?54_0) #t))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)"
" to-parsed?52_0"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
"(expand-context/inner-just-once? the-struct_1)"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
"(expand-context/inner-in-local-expand? the-struct_1)"
"(expand-context/inner-keep-#%expression? the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
" observer53_0"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
" should-not-encounter-macros?54_0))"
"                              (raise-argument-error 'struct-copy \"expand-context/inner?\" the-struct_1)))))"
"(expand-context/outer1.1"
" inner51_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"            (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))"
"(call-with-values"
"(lambda()"
"(set-current-previously-unbound!"
"(lambda()"
"(let-values(((ctx_0)(current-expand-context)))"
"(let-values(((phase-to-ids_0)(if ctx_0(expand-context-need-eventually-defined ctx_0) #f)))"
"(if phase-to-ids_0(hash-ref phase-to-ids_0(expand-context-phase ctx_0) null) #f))))))"
" print-values)"
"(define-values"
"(to-syntax-list.1)"
"(lambda(s_0)"
"(begin"
" 'to-syntax-list"
"(if(list? s_0)"
"(let-values() s_0)"
"(if(pair? s_0)"
"(let-values()(let-values(((r_0)(to-syntax-list.1(cdr s_0))))(if r_0(cons(car s_0) r_0) #f)))"
"(if(syntax?$1 s_0)(let-values()(to-syntax-list.1(syntax-e$1 s_0)))(let-values() #f)))))))"
"(define-values(core-scope)(new-multi-scope))"
"(define-values(core-stx)(add-scope empty-syntax core-scope))"
"(define-values(core-module-name)(1/make-resolved-module-path '#%core))"
"(define-values(core-mpi)(1/module-path-index-join ''#%core #f))"
"(define-values(cell.1$3)(unsafe-make-place-local(make-hasheq)))"
"(define-values(cell.2$1)(unsafe-make-place-local(make-hasheq)))"
"(define-values"
"(core-place-init!)"
"(lambda()"
"(begin(begin(unsafe-place-local-set! cell.1$3(make-hasheq))(unsafe-place-local-set! cell.2$1(make-hasheq))))))"
"(define-values"
"(core-id)"
"(lambda(sym_0 phase_0)"
"(begin"
"(if(eqv? phase_0 0)"
"(let-values()"
"(let-values(((or-part_0)(hash-ref(unsafe-place-local-ref cell.1$3) sym_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((s_0)(datum->syntax$1 core-stx sym_0)))"
"(begin(hash-set!(unsafe-place-local-ref cell.1$3) sym_0 s_0) s_0)))))"
"(if(eq? phase_0 1)"
"(let-values()"
"(let-values(((or-part_0)(hash-ref(unsafe-place-local-ref cell.2$1) sym_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((s_0)(datum->syntax$1(syntax-shift-phase-level$1 core-stx 1) sym_0)))"
"(begin(hash-set!(unsafe-place-local-ref cell.2$1) sym_0 s_0) s_0)))))"
"(let-values()(datum->syntax$1(syntax-shift-phase-level$1 core-stx phase_0) sym_0)))))))"
"(define-values(core-forms) '#hasheq())"
"(define-values(core-primitives) '#hasheq())"
"(define-values"
"(add-core-form!*)"
"(lambda(sym_0 proc_0)"
"(begin(begin(add-core-binding! sym_0)(set! core-forms(hash-set core-forms sym_0 proc_0))))))"
"(define-values"
"(add-core-primitive!)"
"(lambda(sym_0 val_0)"
"(begin(begin(add-core-binding! sym_0)(set! core-primitives(hash-set core-primitives sym_0 val_0))))))"
"(define-values"
"(add-core-binding!)"
"(lambda(sym_0)"
"(begin"
"(let-values(((temp1_0)(datum->syntax$1 core-stx sym_0))"
"((temp2_0)"
"(let-values(((core-mpi4_0) core-mpi)((temp5_0) 0)((sym6_0) sym_0))"
"(make-module-binding20.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" core-mpi4_0"
" temp5_0"
" sym6_0)))"
"((temp3_0) 0))"
"(add-binding!17.1 #f #f temp1_0 temp2_0 temp3_0)))))"
"(define-values"
"(declare-core-module!)"
"(lambda(ns_0)"
"(begin"
"(let-values(((ns7_0) ns_0)"
"((temp8_0)"
"(let-values(((temp10_0) #t)"
"((temp11_0) #t)"
"((temp12_0) #t)"
"((core-mpi13_0) core-mpi)"
"((temp14_0)"
"(hasheqv"
" 0"
"(let-values(((lst_0)(list core-primitives core-forms))((lst_1) '(#f #t)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((syms_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((syntax?_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((ht_0) syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_2"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0)"
"(hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((table_3)"
"(let-values(((table_3)"
" table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((core-mpi17_0)"
" core-mpi)"
"((temp18_0)"
" 0)"
"((sym19_0)"
" sym_0))"
"(make-module-binding20.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" core-mpi17_0"
" temp18_0"
" sym19_0))))"
"(values"
" sym_0"
"(if syntax?_0"
"(provided1.1"
" b_0"
" #f"
" #t)"
" b_0))))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" table_3"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_3)))"
" table_2)))))"
" for-loop_1)"
" table_1"
"(hash-iterate-first ht_0)))))))"
"(if(not #f)"
"(for-loop_0 table_1 rest_0 rest_1)"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
" lst_0"
" lst_1)))))"
"((temp15_0)"
"(lambda(phase-level_0 ns_1 insp_0)"
"(if(zero? phase-level_0)"
"(let-values(((ns_2)"
"(let-values(((ns20_0) ns_1)"
"((core-module-name21_0) core-module-name)"
"((temp22_0) 0))"
"(namespace->module-namespace82.1"
" #f"
" #f"
" unsafe-undefined"
" ns20_0"
" core-module-name21_0"
" temp22_0))))"
"(if ns_2"
"(module-linklet-info2.1(namespace->instance ns_2 0) #f core-mpi #f #f #f)"
" #f))"
" #f)))"
"((temp16_0)"
"(lambda(data-box_0 ns_1 phase_0 phase-level_0 self_0 bulk-binding-registry_0 insp_0)"
"(let-values(((tmp_0) phase-level_0))"
"(if(equal? tmp_0 0)"
"(let-values()"
"(begin"
"(let-values(((ht_0) core-primitives))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 val_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(namespace-set-consistent!"
" ns_1"
" 0"
" sym_0"
" val_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(void)"
"(let-values(((ht_0) core-forms))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 proc_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(namespace-set-transformer!"
" ns_1"
" 0"
" sym_0"
"(if(procedure-arity-includes?"
" proc_0"
" 2)"
"(core-form9.1"
" proc_0"
" sym_0)"
" proc_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(void)))"
"(let-values()(void)))))))"
"(make-module39.1"
" temp10_0"
" unsafe-undefined"
" unsafe-undefined"
" temp16_0"
" #f"
" 0"
" 0"
" temp11_0"
" temp15_0"
" temp12_0"
" unsafe-undefined"
" #f"
" temp14_0"
" null"
" core-mpi13_0"
" #f"
" null"
" #f)))"
"((core-module-name9_0) core-module-name))"
"(declare-module!58.1 #t ns7_0 temp8_0 core-module-name9_0)))))"
"(define-values"
"(core-form-sym)"
"(lambda(s_0 phase_0)"
"(begin"
"(let-values(((ok?_0 id23_0 _24_0)"
"(let-values(((s_1) s_0))"
"(if(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2)))"
"(let-values(((or-part_0)(if(syntax?$1 s_3)(symbol?(syntax-e$1 s_3)) #f)))"
"(if or-part_0 or-part_0(symbol? s_3))))"
"(let-values(((s_3)(cdr s_2))) #t)"
" #f)"
" #f))"
"(let-values()"
"(let-values(((id23_0 _24_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((id25_0)(let-values(((s_3)(car s_2))) s_3))"
"((_26_0)(let-values(((s_3)(cdr s_2))) s_3)))"
"(values id25_0 _26_0)))))"
"(values #t id23_0 _24_0)))"
"(values #f #f #f)))))"
"(if ok?_0"
"(let-values(((b_0)"
"(let-values(((temp27_0) id23_0)((phase28_0) phase_0))"
"(resolve+shift28.1 #f #f null unsafe-undefined #f temp27_0 phase28_0))))"
"(if(module-binding? b_0)"
"(if(eq? core-module-name(1/module-path-index-resolve(module-binding-module b_0)))"
"(module-binding-sym b_0)"
" #f)"
" #f))"
" #f)))))"
"(define-values"
"(taint-dispatch)"
"(lambda(s_0 proc_0 phase_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(s_1 mode_0)"
"(begin"
" 'loop"
"(let-values(((tmp_0) mode_0))"
"(if(equal? tmp_0 'none)"
"(let-values() s_1)"
"(if(equal? tmp_0 'opaque)"
"(let-values()(proc_0 s_1))"
"(if(equal? tmp_0 'transparent)"
"(let-values()"
"(let-values(((c_0)"
"(let-values(((s_2)"
"(let-values(((or-part_0)(syntax->list$1 s_1)))"
"(if or-part_0 or-part_0(syntax-e$1 s_1))))"
"((f_0)(lambda(tail?_0 d_0)(begin 'f d_0)))"
"((s->_0)"
"(lambda(s_2)"
"(begin"
" 's->"
"(loop_0 s_2(syntax-taint-mode-property s_2)))))"
"((seen_0) #f))"
"(let-values(((s_3) s_2)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(s->_0 v_0))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0))"
"((letrec-values(((loop_1)"
"(lambda(tail?_0 s_4 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)"
"(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)"
"(gf_0 tail?_1 s_5))"
" seen_1))"
"(if(null? s_4)"
"(let-values()(f_1 tail?_0 s_4))"
"(if(pair? s_4)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_1 #f(car s_4) depth_0)"
"(loop_1"
" #t"
"(cdr s_4)"
" depth_0))))"
"(if(symbol? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(boolean? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(number? s_4)"
"(let-values()(f_1 #f s_4))"
"(if(let-values(((or-part_0)"
"(vector?"
" s_4)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(box?"
" s_4)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_4)))"
"(if or-part_2"
" or-part_2"
"(hash?"
" s_4)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)"
"(gf_0 tail?_1 s_5))"
" seen_1))"
"(let-values()"
"(gf_0"
" #f"
" s_4))))))))))))))"
" loop_1)"
" #f"
" s_3"
" 0)))))"
"(datum->syntax$1"
" #f"
" c_0"
" s_1"
"(if(syntax-any-macro-scopes? s_1)"
"(1/syntax-property-remove s_1 original-property-sym)"
" s_1))))"
"(if(equal? tmp_0 'transparent-binding)"
"(let-values()"
"(let-values(((c_0)(syntax-e$1 s_1)))"
"(if(pair? c_0)"
"(let-values()"
"(let-values(((cd_0)(cdr c_0)))"
"(if(let-values(((or-part_0)(pair? cd_0)))"
"(if or-part_0"
" or-part_0"
"(if(syntax?$1 cd_0)(pair?(syntax-e$1 cd_0)) #f)))"
"(let-values()"
"(let-values(((d_0)(if(syntax?$1 cd_0)(syntax-e$1 cd_0) cd_0)))"
"(datum->syntax$1"
" #f"
"(cons"
"(loop_0(car c_0)(syntax-taint-mode-property(car c_0)))"
"(cons"
"(loop_0(car d_0) 'transparent)"
"(let-values(((s_2)"
"(let-values(((or-part_0)"
"(syntax->list$1(cdr d_0))))"
"(if or-part_0 or-part_0(cdr d_0))))"
"((f_0)(lambda(tail?_0 d_1)(begin 'f d_1)))"
"((s->_0)"
"(lambda(s_2)"
"(begin"
" 's->"
"(loop_0"
" s_2"
"(syntax-taint-mode-property s_2)))))"
"((seen_0) #f))"
"(let-values(((s_3) s_2)"
"((f_1) f_0)"
"((gf_0)"
"(lambda(tail?_0 v_0)"
"(begin"
" 'gf"
"(if(syntax?$1 v_0)"
"(let-values()(s->_0 v_0))"
"(let-values()(f_0 tail?_0 v_0))))))"
"((seen_1) seen_0))"
"((letrec-values(((loop_1)"
"(lambda(tail?_0 s_4 prev-depth_0)"
"(begin"
" 'loop"
"(let-values(((depth_0)"
"(fx+ 1 prev-depth_0)))"
"(if(if seen_1(fx> depth_0 32) #f)"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1 s_5)"
"(gf_0 tail?_1 s_5))"
" seen_1))"
"(if(null? s_4)"
"(let-values()"
"(f_1 tail?_0 s_4))"
"(if(pair? s_4)"
"(let-values()"
"(f_1"
" tail?_0"
"(cons"
"(loop_1"
" #f"
"(car s_4)"
" depth_0)"
"(loop_1"
" #t"
"(cdr s_4)"
" depth_0))))"
"(if(symbol? s_4)"
"(let-values()"
"(f_1 #f s_4))"
"(if(boolean? s_4)"
"(let-values()"
"(f_1 #f s_4))"
"(if(number? s_4)"
"(let-values()"
"(f_1 #f s_4))"
"(if(let-values(((or-part_0)"
"(vector?"
" s_4)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(box?"
" s_4)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(prefab-struct-key"
" s_4)))"
"(if or-part_2"
" or-part_2"
"(hash?"
" s_4)))))))"
"(let-values()"
"(datum-map-slow"
" tail?_0"
" s_4"
"(lambda(tail?_1"
" s_5)"
"(gf_0"
" tail?_1"
" s_5))"
" seen_1))"
"(let-values()"
"(gf_0"
" #f"
" s_4))))))))))))))"
" loop_1)"
" #f"
" s_3"
" 0)))))"
" s_1"
"(if(syntax-any-macro-scopes? s_1)"
"(1/syntax-property-remove s_1 original-property-sym)"
" s_1))))"
"(let-values()(loop_0 s_1 'transparent)))))"
"(let-values()(loop_0 s_1 'transparent)))))"
"(let-values()"
"(let-values(((c_0)(syntax-e$1 s_1)))"
"(let-values(((tmp_1)(core-form-sym c_0 phase_0)))"
"(if(if(equal? tmp_1 'begin)"
" #t"
"(if(equal? tmp_1 'begin-for-syntax)"
" #t"
"(equal? tmp_1 '#%module-begin)))"
"(let-values()(loop_0 s_1 'transparent))"
"(if(if(equal? tmp_1 'define-values) #t(equal? tmp_1 'define-syntaxes))"
"(let-values()(loop_0 s_1 'transparent-binding))"
"(let-values()(loop_0 s_1 'opaque))))))))))))))))"
" loop_0)"
" s_0"
"(syntax-taint-mode-property s_0)))))"
"(define-values"
"(syntax-taint-mode-property)"
"(lambda(s_0)"
"(begin"
"(let-values(((or-part_0)(syntax-property$1 s_0 'taint-mode)))"
"(if or-part_0 or-part_0(syntax-property$1 s_0 'certify-mode))))))"
"(define-values"
"(syntax-remove-taint-dispatch-properties)"
"(lambda(s_0)(begin(1/syntax-property-remove(1/syntax-property-remove s_0 'taint-mode) 'certify-mode))))"
"(define-values(default-val.1$1) #f)"
"(define-values"
"(current-module-code-inspector)"
"(lambda()(begin(continuation-mark-set-first #f current-module-code-inspector default-val.1$1 root-tag))))"
"(define-values"
"(syntax-debug-info$1)"
"(lambda(s_0 phase_0 all-bindings?_0)"
"(begin"
" 'syntax-debug-info"
"(let-values(((hts_0)"
"(reverse$1"
"(let-values(((lst_0)(fallback->list(syntax-shifted-multi-scopes s_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((smss_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((init-ht_0)"
"(if(identifier?"
" s_0)"
"(hasheq"
" 'name"
"(syntax-e$1 s_0))"
" '#hasheq())))"
"(let-values(((s-scs_0)"
"(scope-set-at-fallback"
" s_0"
" smss_0"
" phase_0)))"
"(let-values(((context_0)"
"(scope-set->context"
" s-scs_0)))"
"(let-values(((context-ht_0)"
"(hash-set"
" init-ht_0"
" 'context"
" context_0)))"
"(let-values(((sym_0)"
"(syntax-e$1"
" s_0)))"
"(let-values(((classify-binding_0)"
"(lambda(b_0)"
"(begin"
" 'classify-binding"
"(if(local-binding?"
" b_0)"
" 'local"
" 'module)))))"
"(let-values(((extract-binding_0)"
"(lambda(b_0)"
"(begin"
" 'extract-binding"
"(if(local-binding?"
" b_0)"
"(local-binding-key"
" b_0)"
"(vector"
"(module-binding-sym"
" b_0)"
"(module-binding-module"
" b_0)"
"(module-binding-phase"
" b_0)))))))"
"(let-values(((bindings_0)"
"(append"
"(if(identifier?"
" s_0)"
"(let-values()"
"(let-values(((bindings_0"
" covered-scopess_0)"
"(let-values(((ht_0)"
" s-scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash-keys"
" ht_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(bindings_0"
" covered-scope-sets_0"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((bindings_1"
" covered-scope-sets_1)"
"(let-values(((ht_1"
" bulk-bindings_0)"
"(let-values(((table_0)"
"(scope-binding-table"
" sc_0)))"
"(if(hash?"
" table_0)"
"(values"
"(hash-ref"
" table_0"
" sym_0"
" '#hash())"
" null)"
"(values"
"(hash-ref"
"(table-with-bulk-bindings-syms"
" table_0)"
" sym_0"
" '#hash())"
"(table-with-bulk-bindings-bulk-bindings"
" table_0)))))"
"((s_1)"
" s_0)"
"((extra-shifts_0)"
" null))"
"(begin"
" #t"
"((letrec-values(((for-loop_2)"
"(lambda(bindings_1"
" covered-scope-sets_1"
" i_1)"
"(begin"
" 'for-loop"
"(if(not"
"(null?"
" i_1))"
"(let-values(((scs_0)"
"(if(pair?"
" i_1)"
"(let-values()"
"(bulk-binding-at-scopes"
"(car"
" i_1)))"
"(let-values()"
"(hash-iterate-key"
" ht_1"
" i_1))))"
"((b_0)"
"(if(pair?"
" i_1)"
"(let-values()"
"(let-values(((bulk_0)"
"(bulk-binding-at-bulk"
"(car"
" i_1))))"
"(let-values(((b-info_0)"
"(if(symbol-interned?"
" sym_0)"
"(hash-ref"
"(bulk-binding-symbols"
" bulk_0"
" s_1"
" extra-shifts_0)"
" sym_0"
" #f)"
" #f)))"
"(if b-info_0"
"((bulk-binding-create"
" bulk_0)"
" bulk_0"
" b-info_0"
" sym_0)"
" #f))))"
"(let-values()"
"(hash-iterate-value"
" ht_1"
" i_1)))))"
"(let-values(((bindings_2"
" covered-scope-sets_2)"
"(let-values(((bindings_2)"
" bindings_1)"
"((covered-scope-sets_2)"
" covered-scope-sets_1))"
"(if(if scs_0"
"(if b_0"
"(not"
"(set-member?"
" covered-scope-sets_2"
" scs_0))"
" #f)"
" #f)"
"(let-values(((bindings_3)"
" bindings_2)"
"((covered-scope-sets_3)"
" covered-scope-sets_2))"
"(let-values(((bindings_4"
" covered-scope-sets_4)"
"(let-values()"
"(values"
"(cons"
"(hasheq"
" 'name"
"(syntax-e$1"
" s_0)"
" 'context"
"(scope-set->context"
" scs_0)"
" 'match?"
"(subset?"
" scs_0"
" s-scs_0)"
"(classify-binding_0"
" b_0)"
"(extract-binding_0"
" b_0))"
" bindings_3)"
"(set-add"
" covered-scope-sets_3"
" scs_0)))))"
"(values"
" bindings_4"
" covered-scope-sets_4)))"
"(values"
" bindings_2"
" covered-scope-sets_2)))))"
"(if(not"
" #f)"
"(for-loop_2"
" bindings_2"
" covered-scope-sets_2"
"(if(pair?"
" i_1)"
"(let-values()"
"(cdr"
" i_1))"
"(let-values()"
"(let-values(((or-part_0)"
"(hash-iterate-next"
" ht_1"
" i_1)))"
"(if or-part_0"
" or-part_0"
" bulk-bindings_0)))))"
"(values"
" bindings_2"
" covered-scope-sets_2))))"
"(values"
" bindings_1"
" covered-scope-sets_1))))))"
" for-loop_2)"
" bindings_0"
" covered-scope-sets_0"
"(let-values(((or-part_0)"
"(hash-iterate-first"
" ht_1)))"
"(if or-part_0"
" or-part_0"
" bulk-bindings_0)))))))"
"(if(not"
" #f)"
"(for-loop_1"
" bindings_1"
" covered-scope-sets_1"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
"(values"
" bindings_1"
" covered-scope-sets_1))))"
"(values"
" bindings_0"
" covered-scope-sets_0))))))"
" for-loop_1)"
" null"
"(set)"
"(unsafe-immutable-hash-iterate-first"
" ht_0))))))"
" bindings_0))"
"(let-values()"
" null))"
"(if all-bindings?_0"
"(let-values()"
"(reverse$1"
"(let-values(((ht_0)"
" s-scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash-keys"
" ht_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((fold-var_3)"
"(let-values(((sym-ht_0)"
"(let-values(((table_0)"
"(scope-binding-table"
" sc_0)))"
"(if(hash?"
" table_0)"
" table_0"
"(table-with-bulk-bindings-syms"
" table_0)))))"
"(begin"
" #t"
"((letrec-values(((for-loop_2)"
"(lambda(fold-var_3"
" state_0)"
"(begin"
" 'for-loop"
"(if(car"
" state_0)"
"(let-values(((o-sym_0)"
"(vector-ref"
"(car"
" state_0)"
" 1))"
"((scs_0)"
"(hash-iterate-key"
"(vector-ref"
"(car"
" state_0)"
" 2)"
"(cdr"
" state_0)))"
"((b_0)"
"(hash-iterate-value"
"(vector-ref"
"(car"
" state_0)"
" 2)"
"(cdr"
" state_0))))"
"(let-values(((fold-var_4)"
"(let-values(((fold-var_4)"
" fold-var_3))"
"(if(eq?"
" o-sym_0"
" sym_0)"
" fold-var_4"
"(let-values(((fold-var_5)"
" fold-var_4))"
"(let-values(((fold-var_6)"
"(let-values()"
"(cons"
"(let-values()"
"(hasheq"
" 'name"
" o-sym_0"
" 'context"
"(scope-set->context"
" scs_0)"
" 'match?"
" #f"
"(classify-binding_0"
" b_0)"
"(extract-binding_0"
" b_0)))"
" fold-var_5))))"
"(values"
" fold-var_6)))))))"
"(if(not"
" #f)"
"(for-loop_2"
" fold-var_4"
"(let-values(((ht_1)"
"(vector-ref"
"(car"
" state_0)"
" 2)))"
"(let-values(((i_1)"
"(hash-iterate-next"
" ht_1"
"(cdr"
" state_0))))"
"(if i_1"
"(cons"
"(car"
" state_0)"
" i_1)"
"(next-state-in-full-binding-table"
" sym-ht_0"
"(hash-iterate-next"
" sym-ht_0"
"(vector-ref"
"(car"
" state_0)"
" 0)))))))"
" fold-var_4)))"
" fold-var_3)))))"
" for-loop_2)"
" fold-var_2"
"((letrec-values(((loop_0)"
"(lambda(sym-i_0)"
"(begin"
" 'loop"
"(if sym-i_0"
"(next-state-in-full-binding-table"
" sym-ht_0"
" sym-i_0)"
" '(#f"
" ."
" #f))))))"
" loop_0)"
"(hash-iterate-first"
" sym-ht_0)))))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_3"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
"(unsafe-immutable-hash-iterate-first"
" ht_0))))))"
"(let-values()"
" null)))))"
"(if(null?"
" bindings_0)"
" context-ht_0"
"(hash-set"
" context-ht_0"
" 'bindings"
" bindings_0)))))))))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values(((ht_0)(car hts_0)))(if(null?(cdr hts_0)) ht_0(hash-set ht_0 'fallbacks(cdr hts_0))))))))"
"(define-values"
"(scope-set->context)"
"(lambda(scs_0)"
"(begin"
"(let-values(((temp1_0)"
"(reverse$1"
"(let-values(((ht_0) scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(if(interned-scope? sc_0)"
"(let-values()"
"(vector"
"(scope-id sc_0)"
"(scope-kind sc_0)"
"(interned-scope-key sc_0)))"
"(if(representative-scope? sc_0)"
"(let-values()"
"(vector"
"(scope-id sc_0)"
"(scope-kind sc_0)"
"(multi-scope-name"
"(representative-scope-owner"
" sc_0))))"
"(let-values()"
"(vector"
"(scope-id sc_0)"
"(scope-kind sc_0))))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
"(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(unsafe-immutable-hash-iterate-first ht_0))))))"
"((<2_0) <)"
"((temp3_0)(lambda(v_0)(vector-ref v_0 0))))"
"(sort7.1 #f temp3_0 temp1_0 <2_0)))))"
"(define-values"
"(raise-ambiguous-error)"
"(lambda(id_0 ctx_0)"
"(begin"
"(raise-syntax-error$1"
" #f"
"       \"identifier's binding is ambiguous\""
" id_0"
" #f"
" null"
"(syntax-debug-info-string id_0 ctx_0)))))"
"(define-values"
"(syntax-debug-info-string)"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((info_0)(syntax-debug-info$1 s_0(expand-context-phase ctx_0) #f)))"
"(if(not"
"(let-values(((or-part_0)(pair?(hash-ref info_0 'bindings null))))"
"(if or-part_0"
" or-part_0"
"(let-values(((lst_0)(hash-ref info_0 'fallbacks null)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((fb-info_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(pair?"
"(hash-ref"
" fb-info_0"
" 'bindings"
" null))))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) fb-info_0))(not #f) #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" lst_0))))))"
"          (let-values () \"\")"
"(let-values()"
"(let-values(((relevant-scope-sets_0)"
"((letrec-values(((loop_0)"
"(lambda(info_1 layer_0)"
"(begin"
" 'loop"
"(apply"
" append"
"(cons"
"(hash-ref info_1 'context)"
"(reverse$1"
"(let-values(((lst_0)(hash-ref info_1 'bindings null)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((b_0)(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(hash-ref"
" b_0"
" 'context))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"(let-values(((fallbacks_0)(hash-ref info_1 'fallbacks null)))"
"(reverse$1"
"(let-values(((lst_0) fallbacks_0)((start_0)(add1 layer_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((fallback_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1))"
"((layer_1) pos_0))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0"
" fallback_0"
" layer_1))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0"
"(+ pos_0 1))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" start_0))))))))))"
" loop_0)"
" info_0"
" 0)))"
"(let-values(((common-scopes_0)"
"(if(null? relevant-scope-sets_0)"
"(set)"
"(let-values(((lst_0) relevant-scope-sets_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((l_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((s_2)"
"(let-values(((s_2) s_1))"
"(let-values(((s_3)"
"(let-values()"
"(set-intersect"
" s_2"
"(list->set l_0)))))"
"(values s_3)))))"
"(if(not #f)(for-loop_0 s_2 rest_0) s_2)))"
" s_1)))))"
" for-loop_0)"
"(list->set(car relevant-scope-sets_0))"
" lst_0))))))"
"(string-append"
"((letrec-values(((loop_0)"
"(lambda(info_1 layer_0)"
"(begin"
" 'loop"
"(string-append"
"                                        \"\\n  context\""
"(layer->string layer_0)"
"                                        \"...:\""
"(describe-context(hash-ref info_1 'context) common-scopes_0)"
"(apply"
" string-append"
"(reverse$1"
"(let-values(((lst_0)"
"(let-values(((temp1_0)(hash-ref info_1 'bindings null))"
"((temp2_0)"
"(lambda(a_0 b_0)"
"(begin"
" 'temp2"
"(if(hash-ref a_0 'match? #f)"
"(not(hash-ref b_0 'match? #f))"
" #f)))))"
"(sort7.1 #f #f temp1_0 temp2_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((b_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(string-append"
"                                                                                                            \"\\n  \""
"(if(hash-ref"
" b_0"
" 'match?"
" #f)"
"                                                                                                              \"matching\""
"                                                                                                              \"other\")"
"                                                                                                            \" binding\""
"(layer->string"
" layer_0)"
"                                                                                                            \"...:\""
"                                                                                                            \"\\n   \""
"(if(hash-ref"
" b_0"
" 'local"
" #f)"
"                                                                                                              \"local\""
"(format"
"                                                                                                               \"~a\""
"(hash-ref"
" b_0"
" 'module"
" #f)))"
"(describe-context"
"(hash-ref"
" b_0"
" 'context)"
" common-scopes_0)))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"(let-values(((fallbacks_0)(hash-ref info_1 'fallbacks null)))"
"(apply"
" string-append"
"(reverse$1"
"(let-values(((lst_0) fallbacks_0)((start_0)(add1 layer_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((fallback_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((layer_1) pos_0))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0"
" fallback_0"
" layer_1))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0(+ pos_0 1))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" start_0)))))))))))"
" loop_0)"
" info_0"
" 0)"
"(if(set-empty? common-scopes_0)"
"                   \"\""
"(string-append"
"                    \"\\n  common scopes...:\""
"(describe-context"
"(reverse$1"
"(let-values(((lst_0)(hash-ref info_0 'context)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s_1)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(if(set-member? common-scopes_0 s_1)"
"(let-values(((fold-var_2) fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values() s_1)"
" fold-var_2))))"
"(values fold-var_3)))"
" fold-var_1))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
"(set)))))))))))))"
"(define-values"
"(describe-context)"
"(lambda(scopes_0 common-scopes_0)"
"(begin"
"(let-values(((strs_0)"
"((letrec-values(((loop_0)"
"(lambda(strs_0 scopes_1)"
"(begin"
" 'loop"
"(if(null? scopes_1)"
"(let-values()(reverse$1 strs_0))"
"(let-values()"
"                                              (let-values (((str_0) (format \" ~a\" (car scopes_1))))"
"(if(if(pair? strs_0)"
"(<(+(string-length str_0)(string-length(car strs_0))) 72)"
" #f)"
"(loop_0"
"(cons(string-append(car strs_0) str_0)(cdr strs_0))"
"(cdr scopes_1))"
"(loop_0(cons str_0 strs_0)(cdr scopes_1))))))))))"
" loop_0)"
" null"
"(if(set-empty? common-scopes_0)"
" scopes_0"
"(append"
"(reverse$1"
"(let-values(((lst_0) scopes_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(if(not(set-member? common-scopes_0 s_0))"
"(let-values(((fold-var_2) fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values() s_0)"
" fold-var_2))))"
"(values fold-var_3)))"
" fold-var_1))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
"                        (list \"[common scopes]\"))))))"
"(if(null? strs_0)"
"          (let-values () \"\\n   [empty]\")"
"(let-values()"
"(apply"
" string-append"
"(reverse$1"
"(let-values(((lst_0) strs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((str_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"                                                                               (string-append \"\\n  \" str_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))))))"
" (define-values (layer->string) (lambda (layer_0) (begin (if (zero? layer_0) \"\" (format \" at layer ~a\" layer_0)))))"
"(define-values"
"(raise-syntax-implicit-error)"
"(lambda(s_0 sym_0 trigger-id_0 ctx_0)"
"(begin"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((what_0)"
"(let-values(((tmp_0) sym_0))"
"(if(equal? tmp_0 '#%app)"
"                          (let-values () \"function application\")"
"(if(equal? tmp_0 '#%datum)"
"                            (let-values () \"literal data\")"
"(if(equal? tmp_0 '#%top)"
"(let-values()"
"(if(expand-context-allow-unbound? ctx_0)"
"                                  \"reference to a top-level identifier\""
"                                  \"reference to an unbound identifier\"))"
"(let-values()(void))))))))"
"(let-values(((unbound?_0)"
"(if trigger-id_0"
"(not"
"(let-values(((trigger-id1_0) trigger-id_0)((phase2_0) phase_0))"
"(resolve40.1 #f #f null #f trigger-id1_0 phase2_0)))"
" #f)))"
"(let-values(((unbound-form_0)"
"(if unbound?_0(if(not(eq?(syntax-e$1 s_0)(syntax-e$1 trigger-id_0))) s_0 #f) #f)))"
"(raise-syntax-error$1"
" #f"
"(format"
"(if unbound?_0"
"                  \"unbound identifier;\\n also, no ~a syntax transformer is bound~a\""
"                  (string-append what_0 \" is not allowed;\\n no ~a syntax transformer is bound~a\"))"
" sym_0"
"(let-values(((tmp_0) phase_0))"
"(if(equal? tmp_0 0)"
"                    (let-values () \"\")"
"(if(equal? tmp_0 1)"
"                      (let-values () \" in the transformer phase\")"
"                      (let-values () (format \" at phase ~a\" phase_0))))))"
"(if unbound?_0(let-values(((or-part_0) unbound-form_0))(if or-part_0 or-part_0 trigger-id_0)) #f)"
"(if unbound?_0(if unbound-form_0 trigger-id_0 #f) s_0)"
" null"
"               (if unbound?_0 (syntax-debug-info-string trigger-id_0 ctx_0) \"\")))))))))"
"(define-values(make-check-no-duplicate-table)(lambda()(begin '#hasheq())))"
"(define-values"
"(check-no-duplicate-ids7.1)"
"(lambda(what1_0 ids4_0 phase5_0 s6_0 ht3_0)"
"(begin"
" 'check-no-duplicate-ids7"
"(let-values(((ids_0) ids4_0))"
"(let-values(((phase_0) phase5_0))"
"(let-values(((s_0) s6_0))"
"(let-values(((ht_0)(if(eq? ht3_0 unsafe-undefined)(make-check-no-duplicate-table) ht3_0)))"
"              (let-values (((what_0) (if (eq? what1_0 unsafe-undefined) \"binding name\" what1_0)))"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(v_0 ht_1)"
"(begin"
" 'loop"
"(if(identifier? v_0)"
"(let-values()"
"(let-values(((l_0)(hash-ref ht_1(syntax-e$1 v_0) null)))"
"(begin"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(bound-identifier=?$1"
" id_0"
" v_0"
" phase_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"(string-append"
"                                                                                                                        \"duplicate \""
" what_0)"
" s_0"
" v_0))"
"(void)))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0 rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(hash-set ht_1(syntax-e$1 v_0)(cons v_0 l_0)))))"
"(if(pair? v_0)"
"(let-values()(loop_0(cdr v_0)(loop_0(car v_0) ht_1)))"
"(let-values() ht_1)))))))"
" loop_0)"
" ids_0"
" ht_0))))))))))"
"(define-values"
"(remove-use-site-scopes)"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((use-sites_0)(root-expand-context-use-site-scopes ctx_0)))"
"(if(if use-sites_0(pair?(unbox use-sites_0)) #f)"
"(if(syntax?$1 s_0)"
"(remove-scopes s_0(unbox use-sites_0))"
"(reverse$1"
"(let-values(((lst_0) s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(remove-scopes id_0(unbox use-sites_0)))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
" s_0)))))"
"(define-values"
"(struct:compile-context"
" compile-context1.1"
" compile-context?"
" compile-context-namespace"
" compile-context-phase"
" compile-context-self"
" compile-context-module-self"
" compile-context-full-module-name"
" compile-context-lazy-syntax-literals?"
" compile-context-header)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'compile-context"
" #f"
" 7"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'compile-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'namespace)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'self)"
"(make-struct-field-accessor -ref_0 3 'module-self)"
"(make-struct-field-accessor -ref_0 4 'full-module-name)"
"(make-struct-field-accessor -ref_0 5 'lazy-syntax-literals?)"
"(make-struct-field-accessor -ref_0 6 'header))))"
"(define-values"
"(make-compile-context14.1)"
"(lambda(full-module-name6_0 lazy-syntax-literals?7_0 module-self5_0 namespace2_0 phase3_0 self4_0)"
"(begin"
" 'make-compile-context14"
"(let-values(((namespace_0)(if(eq? namespace2_0 unsafe-undefined)(1/current-namespace) namespace2_0)))"
"(let-values(((phase_0)(if(eq? phase3_0 unsafe-undefined)(namespace-phase namespace_0) phase3_0)))"
"(let-values(((self_0)(if(eq? self4_0 unsafe-undefined)(namespace-self-mpi namespace_0) self4_0)))"
"(let-values(((module-self_0) module-self5_0))"
"(let-values(((full-module-name_0) full-module-name6_0))"
"(let-values(((lazy-syntax-literals?_0)"
"(if(eq? lazy-syntax-literals?7_0 unsafe-undefined)"
"(if module-self_0 #t #f)"
" lazy-syntax-literals?7_0)))"
"(let-values()"
"(begin"
"(if(if module-self_0(not full-module-name_0) #f)"
"                        (let-values () (error \"internal error: module-self provided without full name\"))"
"(void))"
"(compile-context1.1"
" namespace_0"
" phase_0"
" self_0"
" module-self_0"
" full-module-name_0"
" lazy-syntax-literals?_0"
" #f))))))))))))"
"(define-values"
"(struct:mpi-intern-table mpi-intern-table1.1 mpi-intern-table? mpi-intern-table-normal mpi-intern-table-fast)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'mpi-intern-table"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'mpi-intern-table)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'normal)"
"(make-struct-field-accessor -ref_0 1 'fast))))"
"(define-values"
"(make-module-path-index-intern-table)"
"(lambda()(begin(mpi-intern-table1.1(make-hash)(make-hasheq)))))"
"(define-values"
"(intern-module-path-index!)"
"(lambda(t_0 mpi_0)"
"(begin"
"(let-values(((or-part_0)(hash-ref(mpi-intern-table-fast t_0) mpi_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((name_0 base_0)(1/module-path-index-split mpi_0)))"
"(if(not name_0)"
"(let-values()(begin(hash-set!(mpi-intern-table-fast t_0) mpi_0 mpi_0) mpi_0))"
"(let-values()"
"(let-values(((interned-base_0)(if base_0(intern-module-path-index! t_0 base_0) #f)))"
"(let-values(((at-name_0)"
"(let-values(((or-part_1)(hash-ref(mpi-intern-table-normal t_0) name_0 #f)))"
"(if or-part_1"
" or-part_1"
"(let-values(((at-name_0)(make-hasheq)))"
"(begin(hash-set!(mpi-intern-table-normal t_0) name_0 at-name_0) at-name_0))))))"
"(let-values(((i-mpi_0)"
"(let-values(((or-part_1)(hash-ref at-name_0 interned-base_0 #f)))"
"(if or-part_1"
" or-part_1"
"(let-values(((mpi_1)"
"(if(eq? base_0 interned-base_0)"
" mpi_0"
"(let-values(((the-struct_0) mpi_0))"
"(if(1/module-path-index? the-struct_0)"
"(let-values(((base3_0) interned-base_0))"
"(module-path-index2.1"
"(module-path-index-path the-struct_0)"
" base3_0"
"(module-path-index-resolved the-struct_0)"
"(module-path-index-shift-cache the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                           \"module-path-index?\""
" the-struct_0))))))"
"(begin(hash-set! at-name_0 interned-base_0 mpi_1) mpi_1))))))"
"(begin(hash-set!(mpi-intern-table-fast t_0) mpi_0 i-mpi_0) i-mpi_0))))))))))))"
"(define-values(built-in-symbols)(make-hasheq))"
"(define-values(register-built-in-symbol!)(lambda(s_0)(begin(hash-set! built-in-symbols s_0 #t))))"
"(define-values(built-in-symbol?)(lambda(s_0)(begin(hash-ref built-in-symbols s_0 #f))))"
"(define-values"
"(make-built-in-symbol!)"
"(lambda(s_0)"
"(begin"
"      (let-values (((built-in-s_0) (string->symbol (format \".~s\" s_0))))"
"(begin(register-built-in-symbol! built-in-s_0) built-in-s_0)))))"
"(void"
"(begin"
"(for-each2"
" register-built-in-symbol!"
" '(lambda case-lambda"
" if"
" begin"
" begin0"
" let-values"
" letrec-values"
" set!"
" quote"
" with-continuation-mark"
" #%variable-reference))"
"(for-each2"
" register-built-in-symbol!"
" '(check-not-undefined"
" instance-variable-box"
" variable-reference"
" variable-reference?"
" variable-reference->instance"
" variable-reference-constant?"
" variable-reference-from-unsafe?))"
"(for-each2"
" register-built-in-symbol!"
" '(or and"
" let"
" letrec*"
" define"
" pariah"
" variable-set!"
" variable-ref"
" variable-ref/no-check"
" make-instance-variable-reference"
" annotation?"
" annotation-expression"
" #%app"
" #%call-with-values"
" make-pthread-parameter"
" fasl->s-exp/intern))))"
"(define-values(phase-shift-id)(make-built-in-symbol! 'phase))"
"(define-values(dest-phase-id)(make-built-in-symbol! 'dest-phase))"
"(define-values(ns-id)(make-built-in-symbol! 'namespace))"
"(define-values(self-id)(make-built-in-symbol! 'self))"
"(define-values(syntax-literals-id)(make-built-in-symbol! 'syntax-literals))"
"(define-values(get-syntax-literal!-id)(make-built-in-symbol! 'get-syntax-literal!))"
"(define-values(bulk-binding-registry-id)(make-built-in-symbol! 'bulk-binding-registry))"
"(define-values(inspector-id)(make-built-in-symbol! 'inspector))"
"(define-values(deserialize-syntax-id)(make-built-in-symbol! 'deserialize-syntax))"
"(define-values(deserialized-syntax-vector-id)(make-built-in-symbol! 'deserialized-syntax-vector))"
"(define-values(set-transformer!-id)(make-built-in-symbol! 'set-transformer!))"
"(define-values(top-level-bind!-id)(make-built-in-symbol! 'top-level-bind!))"
"(define-values(top-level-require!-id)(make-built-in-symbol! 'top-level-require!))"
"(define-values(mpi-vector-id)(make-built-in-symbol! 'mpi-vector))"
"(define-values"
"(struct:module-path-index-table"
" module-path-index-table1.1"
" module-path-index-table?"
" module-path-index-table-positions"
" module-path-index-table-intern)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-path-index-table"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'module-path-index-table)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'positions)"
"(make-struct-field-accessor -ref_0 1 'intern))))"
"(define-values"
"(make-module-path-index-table)"
"(lambda()(begin(module-path-index-table1.1(make-hasheq)(make-module-path-index-intern-table)))))"
"(define-values"
"(add-module-path-index!)"
"(lambda(mpis_0 mpi_0)"
"(begin"
"(let-values(((pos_0)(add-module-path-index!/pos mpis_0 mpi_0)))"
"(if pos_0(list 'unsafe-vector*-ref mpi-vector-id pos_0) #f)))))"
"(define-values"
"(add-module-path-index!/pos)"
"(lambda(mpis_0 mpi_0)"
"(begin"
"(if(not mpi_0)"
"(let-values() #f)"
"(if mpi_0"
"(let-values()"
"(let-values(((mpi_1)(intern-module-path-index!(module-path-index-table-intern mpis_0) mpi_0))"
"((positions_0)(module-path-index-table-positions mpis_0)))"
"(let-values(((or-part_0)(hash-ref positions_0 mpi_1 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((pos_0)(hash-count positions_0)))"
"(begin(hash-set! positions_0 mpi_1 pos_0) pos_0))))))"
"(void))))))"
"(define-values"
"(generate-module-path-index-deserialize)"
"(lambda(mpis_0)"
"(begin"
"(let-values(((unique-list_0)"
"(lambda(v_0)"
"(begin"
" 'unique-list"
"(if(pair? v_0)"
"(reverse$1"
"(let-values(((lst_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values() i_0)"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
" v_0)))))"
"(let-values(((positions_0)(module-path-index-table-positions mpis_0)))"
"(let-values(((gen-order_0)(make-hasheqv)))"
"(let-values(((rev-positions_0)"
"(let-values(((ht_0) positions_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" v_0"
" k_0))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
"(hash-iterate-first ht_0))))))"
"(let-values((()"
"(begin"
"(let-values(((start_0) 0)((end_0)(hash-count rev-positions_0))((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((i_0) pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((mpi_0)"
"(hash-ref"
" rev-positions_0"
" i_0)))"
"((letrec-values(((loop_0)"
"(lambda(mpi_1)"
"(begin"
" 'loop"
"(if(hash-ref"
" gen-order_0"
" mpi_1"
" #f)"
"(void)"
"(let-values()"
"(let-values(((name_0"
" base_0)"
"(1/module-path-index-split"
" mpi_1)))"
"(begin"
"(if base_0"
"(let-values()"
"(loop_0"
" base_0))"
"(void))"
"(hash-set!"
" gen-order_0"
" mpi_1"
"(hash-count"
" gen-order_0))))))))))"
" loop_0)"
" mpi_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0(+ pos_0 inc_0))(values))))"
"(values))))))"
" for-loop_0)"
" start_0)))"
"(values))))"
"(let-values()"
"(let-values(((rev-gen-order_0)"
"(let-values(((ht_0) gen-order_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" v_0"
" k_0))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
"(hash-iterate-first ht_0))))))"
"(let-values(((gens_0)"
"(let-values(((len_0)(hash-count gen-order_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'for/vector \"exact-nonnegative-integer?\" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((start_0) 0)((end_0)(hash-count gen-order_0))((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((i_1) pos_0))"
"(let-values(((i_2)"
"(let-values(((i_2) i_0))"
"(let-values(((i_3)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_2"
"(let-values()"
"(let-values(((mpi_0)"
"(hash-ref"
" rev-gen-order_0"
" i_1)))"
"(let-values(((path_0"
" base_0)"
"(1/module-path-index-split"
" mpi_0)))"
"(if(top-level-module-path-index?"
" mpi_0)"
"(let-values()"
" 'top)"
"(if(not"
" path_0)"
"(let-values()"
"(box"
"(let-values(((or-part_0)"
"(unique-list_0"
"(1/resolved-module-path-name"
"(module-path-index-resolved"
" mpi_0)))))"
"(if or-part_0"
" or-part_0"
" 'self))))"
"(if(not"
" base_0)"
"(let-values()"
"(vector"
" path_0))"
"(if base_0"
"(let-values()"
"(vector"
" path_0"
"(hash-ref"
" gen-order_0"
" base_0)))"
"(void)))))))))"
"(unsafe-fx+"
" 1"
" i_2)))))"
"(values i_3)))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx= i_2 len_0))"
" i_1))"
"(not #f)"
" #f)"
"(for-loop_0 i_2(+ pos_0 inc_0))"
" i_2)))"
" i_0)))))"
" for-loop_0)"
" 0"
" start_0)))))"
" v_0))))))"
"(list"
" 'deserialize-module-path-indexes"
"(list 'quote gens_0)"
"(list"
" 'quote"
"(let-values(((vec_0 i_0)"
"(let-values(((start_0) 0)((end_0)(hash-count rev-positions_0))((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(vec_0 i_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((i_1) pos_0))"
"(let-values(((vec_1 i_2)"
"(let-values(((vec_1) vec_0)"
"((i_2) i_0))"
"(let-values(((vec_2 i_3)"
"(let-values()"
"(let-values(((new-vec_0)"
"(if(eq?"
" i_2"
"(unsafe-vector*-length"
" vec_1))"
"(grow-vector"
" vec_1)"
" vec_1)))"
"(begin"
"(unsafe-vector*-set!"
" new-vec_0"
" i_2"
"(let-values()"
"(hash-ref"
" gen-order_0"
"(hash-ref"
" rev-positions_0"
" i_1))))"
"(values"
" new-vec_0"
"(unsafe-fx+"
" i_2"
" 1)))))))"
"(values vec_2 i_3)))))"
"(if(not #f)"
"(for-loop_0 vec_1 i_2(+ pos_0 inc_0))"
"(values vec_1 i_2))))"
"(values vec_0 i_0))))))"
" for-loop_0)"
"(make-vector 16)"
" 0"
" start_0)))))"
"(shrink-vector vec_0 i_0)))))))))))))))"
"(define-values"
"(deserialize-module-path-indexes)"
"(lambda(gen-vec_0 order-vec_0)"
"(begin"
"(let-values(((gen_0)(make-vector(vector-length gen-vec_0) #f)))"
"(begin"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0) gen-vec_0))"
"(begin(check-vector vec_0)(values vec_0(unsafe-vector-length vec_0)))))"
"((start_0) 0))"
"(begin"
" #f"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0 pos_1)"
"(begin"
" 'for-loop"
"(if(if(unsafe-fx< pos_0 len_0) #t #f)"
"(let-values(((d_0)(unsafe-vector-ref vec_0 pos_0))((i_0) pos_1))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(vector-set!"
" gen_0"
" i_0"
"(if(eq? d_0 'top)"
"(let-values()"
"(deserialize-module-path-index))"
"(if(box? d_0)"
"(let-values()"
"(deserialize-module-path-index"
"(unbox d_0)))"
"(let-values()"
"(deserialize-module-path-index"
"(vector*-ref d_0 0)"
"(if(>(vector*-length d_0) 1)"
"(vector*-ref"
" gen_0"
"(vector*-ref d_0 1))"
" #f)))))))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0(unsafe-fx+ 1 pos_0)(+ pos_1 1))(values))))"
"(values))))))"
" for-loop_0)"
" 0"
" start_0)))"
"(void)"
"(let-values(((len_0)(vector-length order-vec_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"                (let-values () (raise-argument-error 'for/vector \"exact-nonnegative-integer?\" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((vec_0 len_1)"
"(let-values(((vec_0) order-vec_0))"
"(begin(check-vector vec_0)(values vec_0(unsafe-vector-length vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(i_0 pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_0 len_1)"
"(let-values(((p_0)(unsafe-vector-ref vec_0 pos_0)))"
"(let-values(((i_1)"
"(let-values(((i_1) i_0))"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_1"
"(let-values()"
"(vector*-ref gen_0 p_0)))"
"(unsafe-fx+ 1 i_1)))))"
"(values i_2)))))"
"(if(if(not((lambda x_0(unsafe-fx= i_1 len_0)) p_0))"
"(not #f)"
" #f)"
"(for-loop_0 i_1(unsafe-fx+ 1 pos_0))"
" i_1)))"
" i_0)))))"
" for-loop_0)"
" 0"
" 0)))))"
" v_0)))))))))"
"(define-values"
"(mpis-as-vector)"
"(lambda(mpis_0)"
"(begin"
"(let-values(((positions_0)(module-path-index-table-positions mpis_0)))"
"(let-values(((vec_0)(make-vector(hash-count positions_0) #f)))"
"(begin"
"(let-values(((ht_0) positions_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((mpi_0 pos_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(vector-set! vec_0 pos_0 mpi_0))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_0 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(void)"
" vec_0))))))"
"(define-values"
"(generate-module-data-linklet)"
"(lambda(mpis_0)"
"(begin"
"(list"
" 'linklet"
"(list deserialize-imports)"
"(list mpi-vector-id)"
"(list* 'define-values(list inspector-id) '((current-code-inspector)))"
"(list 'define-values(list mpi-vector-id)(generate-module-path-index-deserialize mpis_0))))))"
"(define-values"
"(generate-module-declaration-linklet)"
"(lambda(mpis_0 self_0 requires_0 provides_0 phase-to-link-module-uses-expr_0)"
"(begin"
"(list"
" 'linklet"
"(list deserialize-imports(list mpi-vector-id))"
" '(self-mpi requires provides phase-to-link-modules)"
"(list 'define-values '(self-mpi)(add-module-path-index! mpis_0 self_0))"
"(list"
" 'define-values"
" '(requires)"
"(let-values(((requires10_0) requires_0)((mpis11_0) mpis_0)((temp12_0) #f))"
"(generate-deserialize6.1 temp12_0 requires10_0 mpis11_0)))"
"(list"
" 'define-values"
" '(provides)"
"(let-values(((provides13_0) provides_0)((mpis14_0) mpis_0)((temp15_0) #f))"
"(generate-deserialize6.1 temp15_0 provides13_0 mpis14_0)))"
"(list 'define-values '(phase-to-link-modules) phase-to-link-module-uses-expr_0)))))"
"(define-values"
"(serialize-module-uses)"
"(lambda(mus_0 mpis_0)"
"(begin"
"(reverse$1"
"(let-values(((lst_0) mus_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mu_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list"
" 'module-use"
"(add-module-path-index!"
" mpis_0"
"(module-use-module mu_0))"
"(module-use-phase mu_0)))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(define-values"
"(interned-literal?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(null? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(boolean? v_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(if(fixnum? v_0)(if(< v_0(sub1(expt 2 30)))(> v_0(-(expt 2 30))) #f) #f)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(symbol? v_0)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(char? v_0)))(if or-part_4 or-part_4(keyword? v_0))))))))))))))"
"(define-values"
"(serialize-phase-to-link-module-uses)"
"(lambda(phase-to-link-module-uses_0 mpis_0)"
"(begin"
"(let-values(((phases-in-order_0)"
"(let-values(((temp16_0)(hash-keys phase-to-link-module-uses_0))((<17_0) <))"
"(sort7.1 #f #f temp16_0 <17_0))))"
"(list*"
" 'hasheqv"
"(apply"
" append"
"(reverse$1"
"(let-values(((lst_0) phases-in-order_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((phase_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list"
" phase_0"
"(list*"
" 'list"
"(serialize-module-uses"
"(hash-ref"
" phase-to-link-module-uses_0"
" phase_0)"
" mpis_0))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))))"
"(define-values"
"(generate-deserialize6.1)"
"(lambda(syntax-support?2_0 v4_0 mpis5_0)"
"(begin"
" 'generate-deserialize6"
"(let-values(((v_0) v4_0))"
"(let-values(((mpis_0) mpis5_0))"
"(let-values(((syntax-support?_0) syntax-support?2_0))"
"(let-values()"
"(let-values(((reachable-scopes_0)(find-reachable-scopes v_0)))"
"(let-values(((state_0)(make-serialize-state reachable-scopes_0)))"
"(let-values(((mutables_0)(make-hasheq)))"
"(let-values(((objs_0)(make-hasheq)))"
"(let-values(((shares_0)(make-hasheq)))"
"(let-values(((obj-step_0) 0))"
"(let-values(((frontier_0) null))"
"(letrec-values(((add-frontier!_0)"
"(case-lambda"
"((v_1)(begin 'add-frontier!(set! frontier_0(cons v_1 frontier_0))))"
"((kind_0 v_1)(add-frontier!_0 v_1)))))"
"(let-values((()"
"(begin"
"((letrec-values(((frontier-loop_0)"
"(lambda(v_1)"
"(begin"
" 'frontier-loop"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(v_2)"
"(begin"
" 'loop"
"(if(let-values(((or-part_0)"
"(interned-literal?"
" v_2)))"
"(if or-part_0"
" or-part_0"
"(1/module-path-index?"
" v_2)))"
"(let-values()(void))"
"(if(hash-ref"
" objs_0"
" v_2"
" #f)"
"(let-values()"
"(if(hash-ref"
" mutables_0"
" v_2"
" #f)"
"(void)"
"(let-values()"
"(hash-set!"
" shares_0"
" v_2"
" #t))))"
"(let-values()"
"(begin"
"(if(serialize-fill!?"
" v_2)"
"(let-values()"
"(begin"
"(hash-set!"
" mutables_0"
" v_2"
"(hash-count"
" mutables_0))"
"((serialize-fill!-ref"
" v_2)"
" v_2"
" add-frontier!_0"
" state_0)))"
"(if(serialize?"
" v_2)"
"(let-values()"
"((serialize-ref"
" v_2)"
" v_2"
"(case-lambda"
"((sub-v_0)"
"(loop_0"
" sub-v_0))"
"((kind_0"
" sub-v_0)"
"(loop_0"
" sub-v_0)))"
" state_0))"
"(if(pair? v_2)"
"(let-values()"
"(begin"
"(loop_0"
"(car"
" v_2))"
"(loop_0"
"(cdr"
" v_2))))"
"(if(vector?"
" v_2)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(immutable?"
" v_2)))"
"(if or-part_0"
" or-part_0"
"(zero?"
"(vector-length"
" v_2))))"
"(begin"
"(let-values(((vec_0"
" len_0)"
"(let-values(((vec_0)"
" v_2))"
"(begin"
"(check-vector"
" vec_0)"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void))"
"(begin"
"(hash-set!"
" mutables_0"
" v_2"
"(hash-count"
" mutables_0))"
"(begin"
"(let-values(((vec_0"
" len_0)"
"(let-values(((vec_0)"
" v_2))"
"(begin"
"(check-vector"
" vec_0)"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(add-frontier!_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))))"
"(if(box?"
" v_2)"
"(let-values()"
"(if(immutable?"
" v_2)"
"(loop_0"
"(unbox"
" v_2))"
"(begin"
"(hash-set!"
" mutables_0"
" v_2"
"(hash-count"
" mutables_0))"
"(add-frontier!_0"
"(unbox"
" v_2)))))"
"(if(hash?"
" v_2)"
"(let-values()"
"(if(immutable?"
" v_2)"
"(begin"
"(let-values(((lst_0)"
"(sorted-hash-keys"
" v_2)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((k_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(loop_0"
" k_0)"
"(loop_0"
"(hash-ref"
" v_2"
" k_0))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void))"
"(begin"
"(hash-set!"
" mutables_0"
" v_2"
"(hash-count"
" mutables_0))"
"(begin"
"(let-values(((lst_0)"
"(sorted-hash-keys"
" v_2)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((k_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(add-frontier!_0"
" k_0)"
"(add-frontier!_0"
"(hash-ref"
" v_2"
" k_0))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))))"
"(if(prefab-struct-key"
" v_2)"
"(let-values()"
"(begin"
"(let-values(((v*_0"
" start*_0"
" stop*_0"
" step*_0)"
"(normalise-inputs"
" 'in-vector"
"                                                                                                                                     \"vector\""
"(lambda(x_0)"
"(vector?"
" x_0))"
"(lambda(x_0)"
"(unsafe-vector-length"
" x_0))"
"(struct->vector"
" v_2)"
" 1"
" #f"
" 1)))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" idx_0"
" stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" idx_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start*_0)))"
"(void)))"
"(if(srcloc?"
" v_2)"
"(let-values()"
"(if(path?"
"(srcloc-source"
" v_2))"
"(void)"
"(let-values()"
"(begin"
"(let-values(((v*_0"
" start*_0"
" stop*_0"
" step*_0)"
"(normalise-inputs"
" 'in-vector"
"                                                                                                                                           \"vector\""
"(lambda(x_0)"
"(vector?"
" x_0))"
"(lambda(x_0)"
"(unsafe-vector-length"
" x_0))"
"(struct->vector"
" v_2)"
" 1"
" #f"
" 1)))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" idx_0"
" stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" idx_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start*_0)))"
"(void)))))"
"(let-values()"
"(void))))))))))"
"(hash-set!"
" objs_0"
" v_2"
" obj-step_0)"
"(set! obj-step_0"
"(add1"
" obj-step_0))))))))))"
" loop_0)"
" v_1)"
"(if(null? frontier_0)"
"(void)"
"(let-values()"
"(let-values(((l_0) frontier_0))"
"(begin"
"(set! frontier_0 null)"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((v_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(frontier-loop_0"
" v_2))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void))))))))))"
" frontier-loop_0)"
" v_0)"
"(values))))"
"(let-values(((num-mutables_0)(hash-count mutables_0)))"
"(let-values(((share-step-positions_0)"
"(let-values(((share-steps_0)"
"(reverse$1"
"(let-values(((ht_0) shares_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((obj_0)"
"(hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(hash-ref"
" objs_0"
" obj_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
"(hash-iterate-next"
" ht_0"
" i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(hash-iterate-first ht_0)))))))"
"(let-values(((lst_0)"
"(let-values(((share-steps18_0) share-steps_0)"
"((<19_0) <))"
"(sort7.1 #f #f share-steps18_0 <19_0)))"
"((start_0) num-mutables_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((step_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((pos_1) pos_0))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" step_0"
" pos_1))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
" rest_0"
"(+ pos_0 1))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
" lst_0"
" start_0))))))"
"(let-values(((stream_0) null))"
"(let-values(((stream-size_0) 0))"
"(let-values(((next-push-position_0)"
"(lambda()(begin 'next-push-position stream-size_0))))"
"(let-values(((quoted?_0)"
"(lambda(pos_0)"
"(begin"
" 'quoted?"
"(let-values(((v_1)"
"(list-ref"
" stream_0"
"(- stream-size_0(add1 pos_0)))))"
"(let-values(((or-part_0)(not(keyword? v_1))))"
"(if or-part_0 or-part_0(eq? '#:quote v_1))))))))"
"(let-values(((ser-reset!_0)"
"(lambda(pos_0)"
"(begin"
" 'ser-reset!"
"(begin"
"(set! stream_0"
"(list-tail stream_0(- stream-size_0 pos_0)))"
"(set! stream-size_0 pos_0))))))"
"(let-values(((reap-stream!_0)"
"(lambda()"
"(begin"
" 'reap-stream!"
"(begin0"
"(list->vector(reverse$1 stream_0))"
"(set! stream_0 null)"
"(set! stream-size_0 0))))))"
"(letrec-values(((ser-push!_0)"
"(case-lambda"
"((v_1)"
"(begin"
" 'ser-push!"
"(if(hash-ref shares_0 v_1 #f)"
"(let-values()"
"(let-values(((n_0)"
"(hash-ref"
" share-step-positions_0"
"(hash-ref objs_0 v_1))))"
"(begin"
"(ser-push!_0 'tag '#:ref)"
"(ser-push!_0 'exact n_0))))"
"(let-values(((c1_0)"
"(hash-ref mutables_0 v_1 #f)))"
"(if c1_0"
"((lambda(n_0)"
"(begin"
"(ser-push!_0 'tag '#:ref)"
"(ser-push!_0 'exact n_0)))"
" c1_0)"
"(let-values()"
"(ser-push-encoded!_0 v_1)))))))"
"((kind_0 v_1)"
"(let-values(((tmp_0) kind_0))"
"(if(equal? tmp_0 'exact)"
"(let-values()"
"(begin"
"(set! stream_0(cons v_1 stream_0))"
"(set! stream-size_0(add1 stream-size_0))))"
"(if(equal? tmp_0 'tag)"
"(let-values()(ser-push!_0 'exact v_1))"
"(if(equal? tmp_0 'reference)"
"(let-values()"
"(if(hash-ref shares_0 v_1 #f)"
"(let-values()"
"(let-values(((n_0)"
"(hash-ref"
" share-step-positions_0"
"(hash-ref objs_0 v_1))))"
"(ser-push!_0 'exact n_0)))"
"(let-values(((c2_0)"
"(hash-ref"
" mutables_0"
" v_1"
" #f)))"
"(if c2_0"
"((lambda(n_0)"
"(ser-push!_0 'exact n_0))"
" c2_0)"
"(let-values()(ser-push!_0 v_1))))))"
"(let-values()(ser-push!_0 v_1)))))))))"
"((ser-push-encoded!_0)"
"(lambda(v_1)"
"(begin"
" 'ser-push-encoded!"
"(if(keyword? v_1)"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:quote)"
"(ser-push!_0 'exact v_1)))"
"(if(1/module-path-index? v_1)"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:mpi)"
"(ser-push!_0"
" 'exact"
"(add-module-path-index!/pos mpis_0 v_1))))"
"(if(serialize? v_1)"
"(let-values()"
"((serialize-ref v_1)"
" v_1"
" ser-push!_0"
" state_0))"
"(if(if(list? v_1)"
"(if(pair? v_1)(pair?(cdr v_1)) #f)"
" #f)"
"(let-values()"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:list)"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
"(length v_1))"
"(values))))"
"(let-values(((all-quoted?_0)"
"(let-values(((lst_0)"
" v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(all-quoted?_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((i_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((all-quoted?_1)"
"(let-values(((all-quoted?_1)"
" all-quoted?_0))"
"(let-values(((all-quoted?_2)"
"(let-values()"
"(let-values(((i-pos_0)"
"(next-push-position_0)))"
"(begin"
"(ser-push!_0"
" i_0)"
"(if all-quoted?_1"
"(quoted?_0"
" i-pos_0)"
" #f))))))"
"(values"
" all-quoted?_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" all-quoted?_1"
" rest_0)"
" all-quoted?_1)))"
" all-quoted?_0)))))"
" for-loop_0)"
" #t"
" lst_0)))))"
"(if all-quoted?_0"
"(let-values()"
"(begin"
"(ser-reset!_0 start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0 'exact v_1)))"
"(void)))))))"
"(if(pair? v_1)"
"(let-values()"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:cons)"
"(values))))"
"(let-values(((a-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
"(car v_1))"
"(values))))"
"(let-values(((d-pos_0)"
"(next-push-position_0)))"
"(begin"
"(ser-push!_0(cdr v_1))"
"(if(if(quoted?_0 a-pos_0)"
"(quoted?_0 d-pos_0)"
" #f)"
"(let-values()"
"(begin"
"(ser-reset!_0"
" start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(void)))))))))"
"(if(box? v_1)"
"(let-values()"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:box)"
"(values))))"
"(let-values(((v-pos_0)"
"(next-push-position_0)))"
"(begin"
"(ser-push!_0(unbox v_1))"
"(if(quoted?_0 v-pos_0)"
"(let-values()"
"(begin"
"(ser-reset!_0"
" start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(void)))))))"
"(if(vector? v_1)"
"(let-values()"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:vector)"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
"(vector-length"
" v_1))"
"(values))))"
"(let-values(((all-quoted?_0)"
"(let-values(((vec_0"
" len_0)"
"(let-values(((vec_0)"
" v_1))"
"(begin"
"(check-vector"
" vec_0)"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(all-quoted?_0"
" pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((i_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values(((all-quoted?_1)"
"(let-values(((all-quoted?_1)"
" all-quoted?_0))"
"(let-values(((all-quoted?_2)"
"(let-values()"
"(let-values(((i-pos_0)"
"(next-push-position_0)))"
"(begin"
"(ser-push!_0"
" i_0)"
"(if all-quoted?_1"
"(quoted?_0"
" i-pos_0)"
" #f))))))"
"(values"
" all-quoted?_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" all-quoted?_1"
"(unsafe-fx+"
" 1"
" pos_0))"
" all-quoted?_1)))"
" all-quoted?_0)))))"
" for-loop_0)"
" #t"
" 0)))))"
"(if all-quoted?_0"
"(let-values()"
"(begin"
"(ser-reset!_0"
" start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(void)))))))"
"(if(hash? v_1)"
"(let-values()"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values(((as-set?_0)"
"(let-values(((ht_0)"
" v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash-values"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((val_0)"
"(hash-iterate-value"
" ht_0"
" i_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(eq?"
" val_0"
" #t)))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_1))"
" val_0))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" result_1"
"(hash-iterate-next"
" ht_0"
" i_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
"(hash-iterate-first"
" ht_0))))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
"(if as-set?_0"
"(if(hash-eq?"
" v_1)"
"(let-values()"
" '#:seteq)"
"(if(hash-eqv?"
" v_1)"
"(let-values()"
" '#:seteqv)"
"(let-values()"
" '#:set)))"
"(if(hash-eq?"
" v_1)"
"(let-values()"
" '#:hasheq)"
"(if(hash-eqv?"
" v_1)"
"(let-values()"
" '#:hasheqv)"
"(let-values()"
" '#:hash)))))"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
"(hash-count"
" v_1))"
"(values))))"
"(let-values(((ks_0)"
"(sorted-hash-keys"
" v_1)))"
"(let-values(((all-quoted?_0)"
"(let-values(((lst_0)"
" ks_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(all-quoted?_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((k_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((all-quoted?_1)"
"(let-values(((all-quoted?_1)"
" all-quoted?_0))"
"(let-values(((all-quoted?_2)"
"(let-values()"
"(let-values(((k-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" k_0)"
"(values))))"
"(let-values(((v-pos_0)"
"(next-push-position_0)))"
"(begin"
"(if as-set?_0"
"(void)"
"(let-values()"
"(ser-push!_0"
"(hash-ref"
" v_1"
" k_0))))"
"(if all-quoted?_1"
"(if(quoted?_0"
" k-pos_0)"
"(let-values(((or-part_0)"
" as-set?_0))"
"(if or-part_0"
" or-part_0"
"(quoted?_0"
" v-pos_0)))"
" #f)"
" #f))))))))"
"(values"
" all-quoted?_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" all-quoted?_1"
" rest_0)"
" all-quoted?_1)))"
" all-quoted?_0)))))"
" for-loop_0)"
" #t"
" lst_0)))))"
"(if all-quoted?_0"
"(let-values()"
"(begin"
"(ser-reset!_0"
" start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(void)))))))))"
"(let-values(((c3_0)"
"(prefab-struct-key"
" v_1)))"
"(if c3_0"
"((lambda(k_0)"
"(let-values(((vec_0)"
"(struct->vector"
" v_1)))"
"(let-values(((start-pos_0)"
"(next-push-position_0)))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:prefab)"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
" k_0)"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
"(sub1"
"(vector-length"
" vec_0)))"
"(values))))"
"(let-values(((all-quoted?_0)"
"(let-values(((v*_0"
" start*_0"
" stop*_0"
" step*_0)"
"(normalise-inputs"
" 'in-vector"
"                                                                                                                                   \"vector\""
"(lambda(x_0)"
"(vector?"
" x_0))"
"(lambda(x_0)"
"(unsafe-vector-length"
" x_0))"
" vec_0"
" 1"
" #f"
" 1)))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(all-quoted?_0"
" idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" idx_0"
" stop*_0)"
"(let-values(((i_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values(((all-quoted?_1)"
"(let-values(((all-quoted?_1)"
" all-quoted?_0))"
"(let-values(((all-quoted?_2)"
"(let-values()"
"(let-values(((i-pos_0)"
"(next-push-position_0)))"
"(begin"
"(ser-push!_0"
" i_0)"
"(if all-quoted?_1"
"(quoted?_0"
" i-pos_0)"
" #f))))))"
"(values"
" all-quoted?_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" all-quoted?_1"
"(unsafe-fx+"
" idx_0"
" 1))"
" all-quoted?_1)))"
" all-quoted?_0)))))"
" for-loop_0)"
" #t"
" start*_0)))))"
"(if all-quoted?_0"
"(let-values()"
"(begin"
"(ser-reset!_0"
" start-pos_0)"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(void)))))))))"
" c3_0)"
"(if(srcloc? v_1)"
"(let-values()"
"(if(path?"
"(srcloc-source v_1))"
"(let-values()"
"(begin"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))"
"(let-values()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:srcloc)"
"(ser-push!_0"
"(srcloc-source v_1))"
"(ser-push!_0"
"(srcloc-line v_1))"
"(ser-push!_0"
"(srcloc-column v_1))"
"(ser-push!_0"
"(srcloc-position"
" v_1))"
"(ser-push!_0"
"(srcloc-span"
" v_1))))))"
"(let-values()"
"(begin"
"(ser-push-optional-quote!_0)"
"(ser-push!_0"
" 'exact"
" v_1)))))))))))))))))"
"((ser-push-optional-quote!_0)"
"(lambda()(begin 'ser-push-optional-quote!(void)))))"
"(let-values(((ser-shell!_0)"
"(lambda(v_1)"
"(begin"
" 'ser-shell!"
"(if(serialize-fill!? v_1)"
"(let-values()"
"((serialize-ref v_1) v_1 ser-push!_0 state_0))"
"(if(box? v_1)"
"(let-values()(ser-push!_0 'tag '#:box))"
"(if(vector? v_1)"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:vector)"
"(ser-push!_0 'exact(vector-length v_1))))"
"(if(hash? v_1)"
"(let-values()"
"(ser-push!_0"
" 'tag"
"(if(hash-eq? v_1)"
"(let-values() '#:hasheq)"
"(if(hash-eqv? v_1)"
"(let-values() '#:hasheqv)"
"(let-values() '#:hash)))))"
"(let-values()"
"(error"
" 'ser-shell"
"                                                                               \"unknown mutable: ~e\""
" v_1))))))))))"
"(let-values(((ser-shell-fill!_0)"
"(lambda(v_1)"
"(begin"
" 'ser-shell-fill!"
"(if(serialize-fill!? v_1)"
"(let-values()"
"((serialize-fill!-ref v_1)"
" v_1"
" ser-push!_0"
" state_0))"
"(if(box? v_1)"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:set-box!)"
"(ser-push!_0(unbox v_1))))"
"(if(vector? v_1)"
"(let-values()"
"(begin"
"(ser-push!_0 'tag '#:set-vector!)"
"(ser-push!_0 'exact(vector-length v_1))"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0)"
" v_1))"
"(begin"
"(check-vector vec_0)"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_0)"
"(let-values(((v_2)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(ser-push!_0"
" v_2))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-fx+"
" 1"
" pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))"
"(if(hash? v_1)"
"(let-values()"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'tag"
" '#:set-hash!)"
"(values))))"
"(let-values((()"
"(begin"
"(ser-push!_0"
" 'exact"
"(hash-count v_1))"
"(values))))"
"(let-values(((ks_0)"
"(sorted-hash-keys"
" v_1)))"
"(begin"
"(let-values(((lst_0) ks_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((k_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(ser-push!_0"
" k_0)"
"(ser-push!_0"
"(hash-ref"
" v_1"
" k_0))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void))))))"
"(let-values()"
"(error"
" 'ser-shell-fill"
"                                                                                 \"unknown mutable: ~e\""
" v_1))))))))))"
"(let-values(((rev-mutables_0)"
"(let-values(((ht_0) mutables_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_1)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" v_1"
" k_0))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
"(hash-iterate-first ht_0))))))"
"(let-values(((mutable-shell-bindings_0)"
"(begin"
"(begin"
"(let-values(((start_0) 0)"
"((end_0)(hash-count mutables_0))"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((i_0)"
" pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(ser-shell!_0"
"(hash-ref"
" rev-mutables_0"
" i_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
"(+"
" pos_0"
" inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0)))"
"(void))"
"(reap-stream!_0))))"
"(let-values(((rev-shares_0)"
"(let-values(((ht_0) shares_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((obj_0)"
"(hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(hash-ref"
" share-step-positions_0"
"(hash-ref"
" objs_0"
" obj_0))"
" obj_0))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
"(hash-iterate-first ht_0))))))"
"(let-values(((shared-bindings_0)"
"(begin"
"(begin"
"(let-values(((start_0) num-mutables_0)"
"((end_0)"
"(+"
" num-mutables_0"
"(hash-count shares_0)))"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(<"
" pos_0"
" end_0)"
"(let-values(((i_0)"
" pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(ser-push-encoded!_0"
"(hash-ref"
" rev-shares_0"
" i_0)))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
"(+"
" pos_0"
" inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0)))"
"(void))"
"(reap-stream!_0))))"
"(let-values(((mutable-fills_0)"
"(begin"
"(begin"
"(let-values(((start_0) 0)"
"((end_0)"
"(hash-count mutables_0))"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range"
" start_0"
" end_0"
" inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(<"
" pos_0"
" end_0)"
"(let-values(((i_0)"
" pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(ser-shell-fill!_0"
"(hash-ref"
" rev-mutables_0"
" i_0)))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
"(+"
" pos_0"
" inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0)))"
"(void))"
"(reap-stream!_0))))"
"(let-values(((result_0)"
"(begin"
"(ser-push!_0 v_0)"
"(reap-stream!_0))))"
"(let-values(((finish_0)"
"(lambda(mutable-shell-bindings-expr_0"
" shared-bindings-expr_0"
" mutable-fills-expr_0"
" result-expr_0)"
"(begin"
" 'finish"
"(list"
" 'deserialize"
" mpi-vector-id"
"(if syntax-support?_0"
" inspector-id"
" #f)"
"(if syntax-support?_0"
" bulk-binding-registry-id"
" #f)"
"(list"
" 'quote"
"(hash-count mutables_0))"
" mutable-shell-bindings-expr_0"
"(list 'quote(hash-count shares_0))"
" shared-bindings-expr_0"
" mutable-fills-expr_0"
" result-expr_0)))))"
"(if(eq? 'chez-scheme(system-type 'vm))"
"(let-values()"
"(list"
" 'let-values"
"(list"
"(list"
" '(data)"
"(list"
" 'fasl->s-exp/intern"
"(let-values(((temp20_0)"
"(vector"
" mutable-shell-bindings_0"
" shared-bindings_0"
" mutable-fills_0"
" result_0)))"
"(s-exp->fasl11.1 #f temp20_0 #f)))))"
"(finish_0"
" '(unsafe-vector-ref data 0)"
" '(unsafe-vector-ref data 1)"
" '(unsafe-vector-ref data 2)"
" '(unsafe-vector-ref data 3))))"
"(let-values()"
"(finish_0"
"(list 'quote mutable-shell-bindings_0)"
"(list 'quote shared-bindings_0)"
"(list 'quote mutable-fills_0)"
"(list"
" 'quote"
" result_0))))))))))))))))))))))))))))))))))))))"
"(define-values"
"(sorted-hash-keys)"
"(lambda(ht_0)"
"(begin"
"(let-values(((ks_0)(hash-keys ht_0)))"
"(if(null? ks_0)"
"(let-values() ks_0)"
"(if(null?(cdr ks_0))"
"(let-values() ks_0)"
"(if(andmap2 symbol? ks_0)"
"(let-values()"
"(let-values(((ks21_0) ks_0)((symbol<?22_0) symbol<?))(sort7.1 #f #f ks21_0 symbol<?22_0)))"
"(if(andmap2 scope? ks_0)"
"(let-values()"
"(let-values(((ks23_0) ks_0)((scope<?24_0) scope<?))(sort7.1 #f #f ks23_0 scope<?24_0)))"
"(if(andmap2 shifted-multi-scope? ks_0)"
"(let-values()"
"(let-values(((ks25_0) ks_0)((shifted-multi-scope<?26_0) shifted-multi-scope<?))"
"(sort7.1 #f #f ks25_0 shifted-multi-scope<?26_0)))"
"(if(andmap2 real? ks_0)"
"(let-values()(let-values(((ks27_0) ks_0)((<28_0) <))(sort7.1 #f #f ks27_0 <28_0)))"
"(let-values() ks_0)))))))))))"
"(define-values"
"(deserialize)"
"(lambda(mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" num-mutables_0"
" mutable-vec_0"
" num-shared_0"
" shared-vec_0"
" mutable-fill-vec_0"
" result-vec_0)"
"(begin"
"(let-values(((shared_0)(make-vector(+ num-mutables_0 num-shared_0) 'uninit)))"
"(let-values((()"
"(begin"
"(let-values(((start_0) 0)((end_0) num-mutables_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0 pos_1)"
"(begin"
" 'for-loop"
"(if(< pos_1 end_0)"
"(let-values(((i_0) pos_1))"
"(let-values(((pos_2)"
"(let-values(((pos_2) pos_0))"
"(let-values(((pos_3)"
"(let-values()"
"(let-values(((d_0 next-pos_0)"
"(decode-shell"
" mutable-vec_0"
" pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(begin"
"(vector-set! shared_0 i_0 d_0)"
" next-pos_0)))))"
"(values pos_3)))))"
"(if(not #f)(for-loop_0 pos_2(+ pos_1 inc_0)) pos_2)))"
" pos_0)))))"
" for-loop_0)"
" 0"
" start_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((start_0) num-mutables_0)((end_0)(+ num-mutables_0 num-shared_0))((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0 pos_1)"
"(begin"
" 'for-loop"
"(if(< pos_1 end_0)"
"(let-values(((i_0) pos_1))"
"(let-values(((pos_2)"
"(let-values(((pos_2) pos_0))"
"(let-values(((pos_3)"
"(let-values()"
"(let-values(((d_0 next-pos_0)"
"(decode"
" shared-vec_0"
" pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(begin"
"(vector-set!"
" shared_0"
" i_0"
" d_0)"
" next-pos_0)))))"
"(values pos_3)))))"
"(if(not #f)(for-loop_0 pos_2(+ pos_1 inc_0)) pos_2)))"
" pos_0)))))"
" for-loop_0)"
" 0"
" start_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((start_0) 0)"
"((end_0) num-mutables_0)"
"((inc_0) 1)"
"((vec_0 len_0)"
"(let-values(((vec_0) shared_0))"
"(begin(check-vector vec_0)(values vec_0(unsafe-vector-length vec_0))))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0 pos_1 pos_2)"
"(begin"
" 'for-loop"
"(if(if(< pos_1 end_0)(unsafe-fx< pos_2 len_0) #f)"
"(let-values(((v_0)(unsafe-vector-ref vec_0 pos_2)))"
"(let-values(((pos_3)"
"(let-values(((pos_3) pos_0))"
"(let-values(((pos_4)"
"(let-values()"
"(decode-fill!"
" v_0"
" mutable-fill-vec_0"
" pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0))))"
"(values pos_4)))))"
"(if(not #f)"
"(for-loop_0 pos_3(+ pos_1 inc_0)(unsafe-fx+ 1 pos_2))"
" pos_3)))"
" pos_0)))))"
" for-loop_0)"
" 0"
" start_0"
" 0)))"
"(values))))"
"(let-values(((result_0 done-pos_0)"
"(decode result-vec_0 0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
" result_0))))))))"
"(define-values"
"(decode-shell)"
"(lambda(vec_0 pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)"
"(begin"
"(let-values(((tmp_0)(vector*-ref vec_0 pos_0)))"
"(if(equal? tmp_0 '#:box)"
"(let-values()(values(box #f)(add1 pos_0)))"
"(if(equal? tmp_0 '#:vector)"
"(let-values()(values(make-vector(vector*-ref vec_0(add1 pos_0)))(+ pos_0 2)))"
"(if(equal? tmp_0 '#:hash)"
"(let-values()(values(make-hasheq)(add1 pos_0)))"
"(if(equal? tmp_0 '#:hasheq)"
"(let-values()(values(make-hasheq)(add1 pos_0)))"
"(if(equal? tmp_0 '#:hasheqv)"
"(let-values()(values(make-hasheqv)(add1 pos_0)))"
"(let-values()(decode vec_0 pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))))))))))"
"(define-values"
"(decode)"
"(lambda(vec_0 pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)"
"(begin"
"(let-values()"
"(let-values(((tmp_0)(vector*-ref vec_0 pos_0)))"
"(let-values(((index_0)"
"(if(keyword? tmp_0)"
"(hash-ref"
" '#hasheq((#:box . 10)"
"(#:bulk-binding . 27)"
"(#:bulk-binding-at . 22)"
"(#:bulk-binding-registry . 3)"
"(#:cons . 11)"
"(#:datum->syntax . 5)"
"(#:hash . 13)"
"(#:hasheq . 13)"
"(#:hasheqv . 13)"
"(#:inspector . 2)"
"(#:interned-scope . 18)"
"(#:list . 12)"
"(#:local-binding . 26)"
"(#:module-binding . 24)"
"(#:mpi . 9)"
"(#:multi-scope . 19)"
"(#:prefab . 15)"
"(#:provided . 28)"
"(#:quote . 8)"
"(#:ref . 1)"
"(#:representative-scope . 23)"
"(#:scope . 16)"
"(#:scope+kind . 17)"
"(#:set . 14)"
"(#:seteq . 14)"
"(#:seteqv . 14)"
"(#:shifted-multi-scope . 20)"
"(#:simple-module-binding . 25)"
"(#:srcloc . 7)"
"(#:syntax . 4)"
"(#:syntax+props . 6)"
"(#:table-with-bulk-bindings . 21)"
"(#:vector . 12))"
" tmp_0"
"(lambda() 0))"
" 0)))"
"(if(unsafe-fx< index_0 14)"
"(if(unsafe-fx< index_0 6)"
"(if(unsafe-fx< index_0 2)"
"(if(unsafe-fx< index_0 1)"
"(let-values()(values(vector*-ref vec_0 pos_0)(add1 pos_0)))"
"(let-values()(values(vector*-ref shared_0(vector*-ref vec_0(add1 pos_0)))(+ pos_0 2))))"
"(if(unsafe-fx< index_0 3)"
"(let-values()(values inspector_0(add1 pos_0)))"
"(if(unsafe-fx< index_0 4)"
"(let-values()(values bulk-binding-registry_0(add1 pos_0)))"
"(if(unsafe-fx< index_0 5)"
"(let-values()"
"(let-values(((content_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((context_0 next-pos_1)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_0)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_0))"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(let-values(((srcloc_0 next-pos_2)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_1)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_1))"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(values"
"(deserialize-syntax content_0 context_0 srcloc_0 #f #f inspector_0)"
" next-pos_2)))))"
"(let-values()"
"(let-values(((content_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((context_0 next-pos_1)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_0)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_0))"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(let-values(((srcloc_0 next-pos_2)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_1)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_1))"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(values"
"(deserialize-datum->syntax content_0 context_0 srcloc_0 inspector_0)"
" next-pos_2)))))))))"
"(if(unsafe-fx< index_0 9)"
"(if(unsafe-fx< index_0 7)"
"(let-values()"
"(let-values(((content_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((context_0 next-pos_1)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_0)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_0))"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(let-values(((srcloc_0 next-pos_2)"
"(let-values(((i_0)(vector*-ref vec_0 next-pos_1)))"
"(if(exact-integer? i_0)"
"(values(vector*-ref shared_0 i_0)(add1 next-pos_1))"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))))"
"(let-values(((props_0 next-pos_3)"
"(decode"
" vec_0"
" next-pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((tamper_0 next-pos_4)"
"(decode"
" vec_0"
" next-pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(deserialize-syntax content_0 context_0 srcloc_0 props_0 tamper_0 inspector_0)"
" next-pos_4)))))))"
"(if(unsafe-fx< index_0 8)"
"(let-values()"
"(let-values(((source_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((line_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((column_0 next-pos_2)"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((position_0 next-pos_3)"
"(decode"
" vec_0"
" next-pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((span_0 next-pos_4)"
"(decode"
" vec_0"
" next-pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values(srcloc source_0 line_0 column_0 position_0 span_0) next-pos_4)))))))"
"(let-values()(values(vector*-ref vec_0(add1 pos_0))(+ pos_0 2)))))"
"(if(unsafe-fx< index_0 11)"
"(if(unsafe-fx< index_0 10)"
"(let-values()(values(vector*-ref mpis_0(vector*-ref vec_0(add1 pos_0)))(+ pos_0 2)))"
"(let-values()"
"(let-values(((v_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(box-immutable v_0) next-pos_0))))"
"(if(unsafe-fx< index_0 12)"
"(let-values()"
"(let-values(((a_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((d_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(cons a_0 d_0) next-pos_1))))"
"(if(unsafe-fx< index_0 13)"
"(let-values()"
"(let-values(((len_0)(vector*-ref vec_0(add1 pos_0))))"
"(let-values(((r_0)(make-vector len_0)))"
"(let-values(((next-pos_0)"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_1 pos_2)"
"(begin"
" 'for-loop"
"(if(< pos_2 end_0)"
"(let-values(((i_0) pos_2))"
"(let-values(((pos_3)"
"(let-values(((pos_3) pos_1))"
"(let-values(((pos_4)"
"(let-values()"
"(let-values(((v_0"
" next-pos_0)"
"(let-values(((v_0"
" next-pos_0)"
"(decode"
" vec_0"
" pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
" v_0"
" next-pos_0))))"
"(begin"
"(vector-set!"
" r_0"
" i_0"
" v_0)"
" next-pos_0)))))"
"(values pos_4)))))"
"(if(not #f)"
"(for-loop_0 pos_3(+ pos_2 inc_0))"
" pos_3)))"
" pos_1)))))"
" for-loop_0)"
"(+ pos_0 2)"
" start_0)))))"
"(values"
"(if(eq?(vector*-ref vec_0 pos_0) '#:list)"
"(vector->list r_0)"
"(vector->immutable-vector r_0))"
" next-pos_0)))))"
"(let-values()"
"(let-values(((ht_0)"
"(let-values(((tmp_1)(vector*-ref vec_0 pos_0)))"
"(if(equal? tmp_1 '#:hash)"
"(let-values()(hash))"
"(if(equal? tmp_1 '#:hasheq)"
"(let-values()(hasheq))"
"(if(equal? tmp_1 '#:hasheqv)"
"(let-values()(hasheqv))"
"(let-values()(void))))))))"
"(let-values(((len_0)(vector*-ref vec_0(add1 pos_0))))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_1 pos_1 pos_2)"
"(begin"
" 'for-loop"
"(if(< pos_2 end_0)"
"(let-values()"
"(let-values(((ht_2 pos_3)"
"(let-values(((ht_2) ht_1)((pos_3) pos_1))"
"(let-values(((ht_3 pos_4)"
"(let-values()"
"(let-values(((k_0"
" next-pos_0)"
"(decode"
" vec_0"
" pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((v_0"
" next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(hash-set ht_2 k_0 v_0)"
" next-pos_1))))))"
"(values ht_3 pos_4)))))"
"(if(not #f)"
"(for-loop_0 ht_2 pos_3(+ pos_2 inc_0))"
"(values ht_2 pos_3))))"
"(values ht_1 pos_1))))))"
" for-loop_0)"
" ht_0"
"(+ pos_0 2)"
" start_0)))))))))))"
"(if(unsafe-fx< index_0 21)"
"(if(unsafe-fx< index_0 17)"
"(if(unsafe-fx< index_0 15)"
"(let-values()"
"(let-values(((s_0)"
"(let-values(((tmp_1)(vector*-ref vec_0 pos_0)))"
"(if(equal? tmp_1 '#:set)"
"(let-values()(set))"
"(if(equal? tmp_1 '#:seteq)"
"(let-values()(seteq))"
"(if(equal? tmp_1 '#:seteqv)"
"(let-values()(seteqv))"
"(let-values()(void))))))))"
"(let-values(((len_0)(vector*-ref vec_0(add1 pos_0))))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_1 pos_1 pos_2)"
"(begin"
" 'for-loop"
"(if(< pos_2 end_0)"
"(let-values()"
"(let-values(((s_2 pos_3)"
"(let-values(((s_2) s_1)((pos_3) pos_1))"
"(let-values(((s_3 pos_4)"
"(let-values()"
"(let-values(((k_0 next-pos_0)"
"(decode"
" vec_0"
" pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(set-add s_2 k_0)"
" next-pos_0)))))"
"(values s_3 pos_4)))))"
"(if(not #f)"
"(for-loop_0 s_2 pos_3(+ pos_2 inc_0))"
"(values s_2 pos_3))))"
"(values s_1 pos_1))))))"
" for-loop_0)"
" s_0"
"(+ pos_0 2)"
" start_0))))))"
"(if(unsafe-fx< index_0 16)"
"(let-values()"
"(let-values(((key_0 next-pos_0)"
"(let-values(((k_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values k_0 next-pos_0))))"
"(let-values(((len_0)(vector*-ref vec_0 next-pos_0)))"
"(let-values(((r_0 done-pos_0)"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(r_0 pos_1 pos_2)"
"(begin"
" 'for-loop"
"(if(< pos_2 end_0)"
"(let-values()"
"(let-values(((r_1 pos_3)"
"(let-values(((r_1) r_0)"
"((pos_3) pos_1))"
"(let-values(((r_2 pos_4)"
"(let-values()"
"(let-values(((v_0"
" next-pos_1)"
"(decode"
" vec_0"
" pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(cons"
" v_0"
" r_1)"
" next-pos_1)))))"
"(values r_2 pos_4)))))"
"(if(not #f)"
"(for-loop_0 r_1 pos_3(+ pos_2 inc_0))"
"(values r_1 pos_3))))"
"(values r_0 pos_1))))))"
" for-loop_0)"
" null"
"(add1 next-pos_0)"
" start_0)))))"
"(values(apply make-prefab-struct key_0(reverse$1 r_0)) done-pos_0)))))"
"(let-values()(values(deserialize-scope)(add1 pos_0)))))"
"(if(unsafe-fx< index_0 18)"
"(let-values()"
"(let-values(((kind_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(deserialize-scope kind_0) next-pos_0)))"
"(if(unsafe-fx< index_0 19)"
"(let-values()"
"(let-values(((id_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(make-interned-scope id_0) next-pos_0)))"
"(if(unsafe-fx< index_0 20)"
"(let-values()"
"(let-values(((name_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((scopes_0 next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values(deserialize-multi-scope name_0 scopes_0) next-pos_1))))"
"(let-values()"
"(let-values(((phase_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((multi-scope_0 next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values(deserialize-shifted-multi-scope phase_0 multi-scope_0) next-pos_1))))))))"
"(if(unsafe-fx< index_0 24)"
"(if(unsafe-fx< index_0 22)"
"(let-values()"
"(let-values(((syms_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((bulk-bindings_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(deserialize-table-with-bulk-bindings syms_0 bulk-bindings_0) next-pos_1))))"
"(if(unsafe-fx< index_0 23)"
"(let-values()"
"(let-values(((scopes_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((bulk_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(deserialize-bulk-binding-at scopes_0 bulk_0) next-pos_1))))"
"(let-values()"
"(let-values(((kind_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((phase_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(deserialize-representative-scope kind_0 phase_0) next-pos_1))))))"
"(if(unsafe-fx< index_0 26)"
"(if(unsafe-fx< index_0 25)"
"(let-values()"
"(let-values(((module_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((sym_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((phase_0 next-pos_2)"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((nominal-module_0 next-pos_3)"
"(decode"
" vec_0"
" next-pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((nominal-phase_0 next-pos_4)"
"(decode"
" vec_0"
" next-pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((nominal-sym_0 next-pos_5)"
"(decode"
" vec_0"
" next-pos_4"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((nominal-require-phase_0 next-pos_6)"
"(decode"
" vec_0"
" next-pos_5"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((free=id_0 next-pos_7)"
"(decode"
" vec_0"
" next-pos_6"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((extra-inspector_0 next-pos_8)"
"(decode"
" vec_0"
" next-pos_7"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((extra-nominal-bindings_0 next-pos_9)"
"(decode"
" vec_0"
" next-pos_8"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(deserialize-full-module-binding"
" module_0"
" sym_0"
" phase_0"
" nominal-module_0"
" nominal-phase_0"
" nominal-sym_0"
" nominal-require-phase_0"
" free=id_0"
" extra-inspector_0"
" extra-nominal-bindings_0)"
" next-pos_9))))))))))))"
"(let-values()"
"(let-values(((module_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((sym_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((phase_0 next-pos_2)"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((nominal-module_0 next-pos_3)"
"(decode"
" vec_0"
" next-pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(deserialize-simple-module-binding module_0 sym_0 phase_0 nominal-module_0)"
" next-pos_3)))))))"
"(if(unsafe-fx< index_0 27)"
"(let-values()"
"(let-values(((key_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((free=id_0 next-pos_1)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(values(deserialize-full-local-binding key_0 free=id_0) next-pos_1))))"
"(if(unsafe-fx< index_0 28)"
"(let-values()"
"(let-values(((prefix_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((excepts_0 next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((mpi_0 next-pos_2)"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((provide-phase-level_0 next-pos_3)"
"(decode"
" vec_0"
" next-pos_2"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((phase-shift_0 next-pos_4)"
"(decode"
" vec_0"
" next-pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((bulk-binding-registry_1 next-pos_5)"
"(decode"
" vec_0"
" next-pos_4"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(deserialize-bulk-binding"
" prefix_0"
" excepts_0"
" mpi_0"
" provide-phase-level_0"
" phase-shift_0"
" bulk-binding-registry_1)"
" next-pos_5))))))))"
"(let-values()"
"(let-values(((binding_0 next-pos_0)"
"(decode"
" vec_0"
"(add1 pos_0)"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((protected?_0 next-pos_1)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((syntax?_0 next-pos_2)"
"(decode"
" vec_0"
" next-pos_1"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(values"
"(deserialize-provided binding_0 protected?_0 syntax?_0)"
" next-pos_2)))))))))))))))))"
"(define-values"
"(decode-fill!)"
"(lambda(v_0 vec_0 pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)"
"(begin"
"(let-values(((tmp_0)(vector*-ref vec_0 pos_0)))"
"(if(equal? tmp_0 #f)"
"(let-values()(add1 pos_0))"
"(if(equal? tmp_0 '#:set-box!)"
"(let-values()"
"(let-values(((c_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(begin(set-box! v_0 c_0) next-pos_0)))"
"(if(equal? tmp_0 '#:set-vector!)"
"(let-values()"
"(let-values(((len_0)(vector*-ref vec_0(add1 pos_0))))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_1 pos_2)"
"(begin"
" 'for-loop"
"(if(< pos_2 end_0)"
"(let-values(((i_0) pos_2))"
"(let-values(((pos_3)"
"(let-values(((pos_3) pos_1))"
"(let-values(((pos_4)"
"(let-values()"
"(let-values(((c_0 next-pos_0)"
"(decode"
" vec_0"
" pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(begin"
"(vector-set! v_0 i_0 c_0)"
" next-pos_0)))))"
"(values pos_4)))))"
"(if(not #f)(for-loop_0 pos_3(+ pos_2 inc_0)) pos_3)))"
" pos_1)))))"
" for-loop_0)"
"(+ pos_0 2)"
" start_0)))))"
"(if(equal? tmp_0 '#:set-hash!)"
"(let-values()"
"(let-values(((len_0)(vector*-ref vec_0(add1 pos_0))))"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_1 pos_2)"
"(begin"
" 'for-loop"
"(if(< pos_2 end_0)"
"(let-values()"
"(let-values(((pos_3)"
"(let-values(((pos_3) pos_1))"
"(let-values(((pos_4)"
"(let-values()"
"(let-values(((key_0 next-pos_0)"
"(decode"
" vec_0"
" pos_3"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(let-values(((val_0 done-pos_0)"
"(decode"
" vec_0"
" next-pos_0"
" mpis_0"
" inspector_0"
" bulk-binding-registry_0"
" shared_0)))"
"(begin"
"(hash-set! v_0 key_0 val_0)"
" done-pos_0))))))"
"(values pos_4)))))"
"(if(not #f)(for-loop_0 pos_3(+ pos_2 inc_0)) pos_3)))"
" pos_1)))))"
" for-loop_0)"
"(+ pos_0 2)"
" start_0)))))"
"(if(equal? tmp_0 '#:scope-fill!)"
"(let-values()"
"(let-values(((c_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(begin(deserialize-scope-fill! v_0 c_0) next-pos_0)))"
"(if(equal? tmp_0 '#:representative-scope-fill!)"
"(let-values()"
"(let-values(((a_0 next-pos_0)"
"(decode vec_0(add1 pos_0) mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(let-values(((d_0 done-pos_0)"
"(decode vec_0 next-pos_0 mpis_0 inspector_0 bulk-binding-registry_0 shared_0)))"
"(begin(deserialize-representative-scope-fill! v_0 a_0 d_0) done-pos_0))))"
"                    (let-values () (error 'deserialize \"bad fill encoding: ~v\" (vector*-ref vec_0 pos_0)))))))))))))"
"(define-values"
"(find-reachable-scopes)"
"(lambda(v_0)"
"(begin"
"(let-values(((seen_0)(make-hasheq)))"
"(let-values(((reachable-scopes_0)(seteq)))"
"(let-values(((get-reachable-scopes_0)(lambda()(begin 'get-reachable-scopes reachable-scopes_0))))"
"(let-values(((scope-triggers_0)(make-hasheq)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(v_1)"
"(begin"
" 'loop"
"(if(interned-literal? v_1)"
"(let-values()(void))"
"(if(hash-ref seen_0 v_1 #f)"
"(let-values()(void))"
"(let-values()"
"(begin"
"(hash-set! seen_0 v_1 #t)"
"(if(scope-with-bindings? v_1)"
"(let-values()"
"(begin"
"(set! reachable-scopes_0(set-add reachable-scopes_0 v_1))"
"((reach-scopes-ref v_1) v_1 loop_0)"
"(let-values(((lst_0)(hash-ref scope-triggers_0 v_1 null)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((proc_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(proc_0"
" loop_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0 rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(hash-remove! scope-triggers_0 v_1)"
"((scope-with-bindings-ref v_1)"
" v_1"
" get-reachable-scopes_0"
" loop_0"
"(lambda(sc-unreachable_0 b_0)"
"(hash-update!"
" scope-triggers_0"
" sc-unreachable_0"
"(lambda(l_0)(cons b_0 l_0))"
" null)))))"
"(if(reach-scopes? v_1)"
"(let-values()((reach-scopes-ref v_1) v_1 loop_0))"
"(if(pair? v_1)"
"(let-values()(begin(loop_0(car v_1))(loop_0(cdr v_1))))"
"(if(vector? v_1)"
"(let-values()"
"(begin"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0) v_1))"
"(begin"
"(check-vector vec_0)"
"(values"
" vec_0"
"(unsafe-vector-length vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
"(unsafe-fx+ 1 pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)))"
"(if(box? v_1)"
"(let-values()(loop_0(unbox v_1)))"
"(if(hash? v_1)"
"(let-values()"
"(begin"
"(let-values(((ht_0) v_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_2)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(loop_0"
" k_0)"
"(loop_0"
" v_2)))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
"(hash-iterate-next"
" ht_0"
" i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(void)))"
"(if(prefab-struct-key v_1)"
"(let-values()"
"(begin"
"(let-values(((v*_0 start*_0 stop*_0 step*_0)"
"(normalise-inputs"
" 'in-vector"
"                                                                               \"vector\""
"(lambda(x_0)(vector? x_0))"
"(lambda(x_0)(unsafe-vector-length x_0))"
"(struct->vector v_1)"
" 1"
" #f"
" 1)))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< idx_0 stop*_0)"
"(let-values(((e_0)"
"(unsafe-vector-ref"
" v*_0"
" idx_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
"(unsafe-fx+ idx_0 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start*_0)))"
"(void)))"
"(if(srcloc? v_1)"
"(let-values()(loop_0(srcloc-source v_1)))"
"(let-values()(void))))))))))))))))))"
" loop_0)"
" v_0)"
" reachable-scopes_0))))))))"
"(define-values"
"(deserialize-imports)"
" '(deserialize-module-path-indexes syntax-module-path-index-shift syntax-shift-phase-level module-use deserialize))"
"(define-values"
"(syntax-module-path-index-shift/no-keywords)"
"(let-values(((syntax-module-path-index-shift_0)"
"(let-values(((core33_0)"
"(lambda(s30_0 from-mpi31_0 to-mpi32_0 inspector29_0)"
"(begin"
" 'core33"
"(let-values(((s_0) s30_0))"
"(let-values(((from-mpi_0) from-mpi31_0))"
"(let-values(((to-mpi_0) to-mpi32_0))"
"(let-values(((inspector_0) inspector29_0))"
"(let-values()"
"(let-values(((s35_0) s_0)"
"((from-mpi36_0) from-mpi_0)"
"((to-mpi37_0) to-mpi_0)"
"((inspector38_0) inspector_0))"
"(syntax-module-path-index-shift13.1"
" #f"
" s35_0"
" from-mpi36_0"
" to-mpi37_0"
" inspector38_0)))))))))))"
"(case-lambda"
"((s_0 from-mpi_0 to-mpi_0)"
"(begin 'syntax-module-path-index-shift(core33_0 s_0 from-mpi_0 to-mpi_0 #f)))"
"((s_0 from-mpi_0 to-mpi_0 inspector29_0)(core33_0 s_0 from-mpi_0 to-mpi_0 inspector29_0))))))"
" syntax-module-path-index-shift_0))"
"(define-values"
"(deserialize-instance)"
"(1/make-instance"
" 'deserialize"
" #f"
" 'constant"
" 'deserialize-module-path-indexes"
" deserialize-module-path-indexes"
" 'syntax-module-path-index-shift"
" syntax-module-path-index-shift/no-keywords"
" 'syntax-shift-phase-level"
" syntax-shift-phase-level$1"
" 'module-use"
" module-use1.1"
" 'deserialize"
" deserialize))"
"(define-values"
"(struct:parsed parsed1.1 parsed? parsed-s)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'parsed #f 1 0 #f(list(cons prop:authentic #t)) #f #f '(0) #f 'parsed)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 's))))"
"(define-values"
"(struct:parsed-id parsed-id2.1 parsed-id? parsed-id-binding parsed-id-inspector)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-id"
" struct:parsed"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'parsed-id)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'binding)"
"(make-struct-field-accessor -ref_0 1 'inspector))))"
"(define-values"
"(struct:parsed-primitive-id parsed-primitive-id3.1 parsed-primitive-id?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-primitive-id"
" struct:parsed-id"
" 0"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'parsed-primitive-id)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:parsed-top-id parsed-top-id4.1 parsed-top-id?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-top-id"
" struct:parsed-id"
" 0"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'parsed-top-id)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:parsed-lambda parsed-lambda5.1 parsed-lambda? parsed-lambda-keys parsed-lambda-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-lambda"
" struct:parsed"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'parsed-lambda)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'keys)"
"(make-struct-field-accessor -ref_0 1 'body))))"
"(define-values"
"(struct:parsed-case-lambda parsed-case-lambda6.1 parsed-case-lambda? parsed-case-lambda-clauses)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-case-lambda"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-case-lambda)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'clauses))))"
"(define-values"
"(struct:parsed-app parsed-app7.1 parsed-app? parsed-app-rator parsed-app-rands)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-app"
" struct:parsed"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'parsed-app)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'rator)"
"(make-struct-field-accessor -ref_0 1 'rands))))"
"(define-values"
"(struct:parsed-if parsed-if8.1 parsed-if? parsed-if-tst parsed-if-thn parsed-if-els)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-if"
" struct:parsed"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'parsed-if)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'tst)"
"(make-struct-field-accessor -ref_0 1 'thn)"
"(make-struct-field-accessor -ref_0 2 'els))))"
"(define-values"
"(struct:parsed-set! parsed-set!9.1 parsed-set!? parsed-set!-id parsed-set!-rhs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-set!"
" struct:parsed"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'parsed-set!)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'id)"
"(make-struct-field-accessor -ref_0 1 'rhs))))"
"(define-values"
"(struct:parsed-with-continuation-mark"
" parsed-with-continuation-mark10.1"
" parsed-with-continuation-mark?"
" parsed-with-continuation-mark-key"
" parsed-with-continuation-mark-val"
" parsed-with-continuation-mark-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-with-continuation-mark"
" struct:parsed"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'parsed-with-continuation-mark)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'key)"
"(make-struct-field-accessor -ref_0 1 'val)"
"(make-struct-field-accessor -ref_0 2 'body))))"
"(define-values"
"(struct:parsed-#%variable-reference"
" parsed-#%variable-reference11.1"
" parsed-#%variable-reference?"
" parsed-#%variable-reference-id)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-#%variable-reference"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-#%variable-reference)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'id))))"
"(define-values"
"(struct:parsed-begin parsed-begin12.1 parsed-begin? parsed-begin-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-begin"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-begin)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'body))))"
"(define-values"
"(struct:parsed-begin0 parsed-begin013.1 parsed-begin0? parsed-begin0-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-begin0"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-begin0)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'body))))"
"(define-values"
"(struct:parsed-quote parsed-quote14.1 parsed-quote? parsed-quote-datum)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-quote"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-quote)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'datum))))"
"(define-values"
"(struct:parsed-quote-syntax parsed-quote-syntax15.1 parsed-quote-syntax? parsed-quote-syntax-datum)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-quote-syntax"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-quote-syntax)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'datum))))"
"(define-values"
"(struct:parsed-let_-values"
" parsed-let_-values16.1"
" parsed-let_-values?"
" parsed-let_-values-idss"
" parsed-let_-values-clauses"
" parsed-let_-values-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-let_-values"
" struct:parsed"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'parsed-let_-values)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'idss)"
"(make-struct-field-accessor -ref_0 1 'clauses)"
"(make-struct-field-accessor -ref_0 2 'body))))"
"(define-values"
"(struct:parsed-let-values parsed-let-values17.1 parsed-let-values?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-let-values"
" struct:parsed-let_-values"
" 0"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'parsed-let-values)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:parsed-letrec-values parsed-letrec-values18.1 parsed-letrec-values?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-letrec-values"
" struct:parsed-let_-values"
" 0"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'parsed-letrec-values)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:parsed-define-values"
" parsed-define-values19.1"
" parsed-define-values?"
" parsed-define-values-ids"
" parsed-define-values-syms"
" parsed-define-values-rhs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-define-values"
" struct:parsed"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'parsed-define-values)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'ids)"
"(make-struct-field-accessor -ref_0 1 'syms)"
"(make-struct-field-accessor -ref_0 2 'rhs))))"
"(define-values"
"(struct:parsed-define-syntaxes"
" parsed-define-syntaxes20.1"
" parsed-define-syntaxes?"
" parsed-define-syntaxes-ids"
" parsed-define-syntaxes-syms"
" parsed-define-syntaxes-rhs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-define-syntaxes"
" struct:parsed"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'parsed-define-syntaxes)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'ids)"
"(make-struct-field-accessor -ref_0 1 'syms)"
"(make-struct-field-accessor -ref_0 2 'rhs))))"
"(define-values"
"(struct:parsed-begin-for-syntax parsed-begin-for-syntax21.1 parsed-begin-for-syntax? parsed-begin-for-syntax-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-begin-for-syntax"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-begin-for-syntax)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'body))))"
"(define-values"
"(struct:parsed-#%declare parsed-#%declare22.1 parsed-#%declare?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-#%declare"
" struct:parsed"
" 0"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'parsed-#%declare)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:parsed-require parsed-require23.1 parsed-require?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-require"
" struct:parsed"
" 0"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'parsed-require)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:parsed-#%module-begin parsed-#%module-begin24.1 parsed-#%module-begin? parsed-#%module-begin-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-#%module-begin"
" struct:parsed"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'parsed-#%module-begin)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'body))))"
"(define-values"
"(struct:parsed-module"
" parsed-module25.1"
" parsed-module?"
" parsed-module-star?"
" parsed-module-name-id"
" parsed-module-self"
" parsed-module-requires"
" parsed-module-provides"
" parsed-module-root-ctx-simple?"
" parsed-module-encoded-root-ctx"
" parsed-module-body"
" parsed-module-compiled-module"
" parsed-module-compiled-submodules)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'parsed-module"
" struct:parsed"
" 10"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9)"
" #f"
" 'parsed-module)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'star?)"
"(make-struct-field-accessor -ref_0 1 'name-id)"
"(make-struct-field-accessor -ref_0 2 'self)"
"(make-struct-field-accessor -ref_0 3 'requires)"
"(make-struct-field-accessor -ref_0 4 'provides)"
"(make-struct-field-accessor -ref_0 5 'root-ctx-simple?)"
"(make-struct-field-accessor -ref_0 6 'encoded-root-ctx)"
"(make-struct-field-accessor -ref_0 7 'body)"
"(make-struct-field-accessor -ref_0 8 'compiled-module)"
"(make-struct-field-accessor -ref_0 9 'compiled-submodules))))"
"(define-values"
"(module-path->mpi5.1)"
"(lambda(declared-submodule-names1_0 mod-path3_0 self4_0)"
"(begin"
" 'module-path->mpi5"
"(let-values(((mod-path_0) mod-path3_0))"
"(let-values(((self_0) self4_0))"
"(let-values(((declared-submodule-names_0)"
"(if(eq? declared-submodule-names1_0 unsafe-undefined) '#hasheq() declared-submodule-names1_0)))"
"(let-values()"
"(if(if(list? mod-path_0)"
"(if(= 2(length mod-path_0))"
"(if(eq? 'quote(car mod-path_0))"
"(if(symbol?(cadr mod-path_0))(hash-ref declared-submodule-names_0(cadr mod-path_0) #f) #f)"
" #f)"
" #f)"
" #f)"
"                (let-values () (1/module-path-index-join (list 'submod \".\" (cadr mod-path_0)) self_0))"
"(if(if(list? mod-path_0)"
"(if(eq? 'submod(car mod-path_0))"
"(let-values(((mod-path_1)(cadr mod-path_0)))"
"(if(list? mod-path_1)"
"(if(= 2(length mod-path_1))"
"(if(eq? 'quote(car mod-path_1))"
"(if(symbol?(cadr mod-path_1))"
"(hash-ref declared-submodule-names_0(cadr mod-path_1) #f)"
" #f)"
" #f)"
" #f)"
" #f))"
" #f)"
" #f)"
"(let-values()"
"                    (1/module-path-index-join (list* 'submod \".\" (cadr (cadr mod-path_0)) (cddr mod-path_0)) self_0))"
"(let-values()(1/module-path-index-join mod-path_0 self_0)))))))))))"
"(define-values"
"(module-path->mpi/context)"
"(lambda(mod-path_0 ctx_0)"
"(begin"
"(let-values(((mod-path8_0) mod-path_0)"
"((temp9_0)(namespace-mpi(expand-context-namespace ctx_0)))"
"((temp10_0)(expand-context-declared-submodule-names ctx_0)))"
"(module-path->mpi5.1 temp10_0 mod-path8_0 temp9_0)))))"
"(define-values"
"(syntax-mapped-names)"
"(lambda(s_0 phase_0)"
"(begin"
"(let-values(((s-scs_0)(syntax-scope-set s_0 phase_0)))"
"(let-values(((ht_0) s-scs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(syms_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((syms_1)"
"(let-values(((syms_1) syms_0))"
"(let-values(((syms_2)"
"(let-values()"
"(set-union"
" syms_1"
"(binding-table-symbols"
"(scope-binding-table sc_0)"
" s-scs_0"
" s_0"
" null)))))"
"(values syms_2)))))"
"(if(not #f)"
"(for-loop_0 syms_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" syms_1)))"
" syms_0)))))"
" for-loop_0)"
"(seteq)"
"(unsafe-immutable-hash-iterate-first ht_0))))))))"
"(define-values"
"(struct:requires+provides"
" requires+provides1.1"
" requires+provides?"
" requires+provides-self"
" requires+provides-require-mpis"
" requires+provides-require-mpis-in-order"
" requires+provides-requires"
" requires+provides-provides"
" requires+provides-phase-to-defined-syms"
" requires+provides-also-required"
" requires+provides-can-cross-phase-persistent?"
" requires+provides-all-bindings-simple?"
" set-requires+provides-can-cross-phase-persistent?!"
" set-requires+provides-all-bindings-simple?!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'requires+provides"
" #f"
" 9"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'requires+provides)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'self)"
"(make-struct-field-accessor -ref_0 1 'require-mpis)"
"(make-struct-field-accessor -ref_0 2 'require-mpis-in-order)"
"(make-struct-field-accessor -ref_0 3 'requires)"
"(make-struct-field-accessor -ref_0 4 'provides)"
"(make-struct-field-accessor -ref_0 5 'phase-to-defined-syms)"
"(make-struct-field-accessor -ref_0 6 'also-required)"
"(make-struct-field-accessor -ref_0 7 'can-cross-phase-persistent?)"
"(make-struct-field-accessor -ref_0 8 'all-bindings-simple?)"
"(make-struct-field-mutator -set!_0 7 'can-cross-phase-persistent?)"
"(make-struct-field-mutator -set!_0 8 'all-bindings-simple?))))"
"(define-values"
"(struct:required required2.1 required? required-id required-phase required-can-be-shadowed? required-as-transformer?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'required"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'required)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'id)"
"(make-struct-field-accessor -ref_0 1 'phase)"
"(make-struct-field-accessor -ref_0 2 'can-be-shadowed?)"
"(make-struct-field-accessor -ref_0 3 'as-transformer?))))"
"(define-values"
"(struct:nominal nominal3.1 nominal? nominal-module nominal-provide-phase nominal-require-phase nominal-sym)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'nominal"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t))"
" #f"
" #f"
" '(0 1 2 3)"
" #f"
" 'nominal)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'module)"
"(make-struct-field-accessor -ref_0 1 'provide-phase)"
"(make-struct-field-accessor -ref_0 2 'require-phase)"
"(make-struct-field-accessor -ref_0 3 'sym))))"
"(define-values"
"(struct:bulk-required"
" bulk-required4.1"
" bulk-required?"
" bulk-required-provides"
" bulk-required-prefix-len"
" bulk-required-s"
" bulk-required-provide-phase-level"
" bulk-required-can-be-shadowed?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'bulk-required"
" #f"
" 5"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4)"
" #f"
" 'bulk-required)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'provides)"
"(make-struct-field-accessor -ref_0 1 'prefix-len)"
"(make-struct-field-accessor -ref_0 2 's)"
"(make-struct-field-accessor -ref_0 3 'provide-phase-level)"
"(make-struct-field-accessor -ref_0 4 'can-be-shadowed?))))"
"(define-values"
"(make-requires+provides8.1)"
"(lambda(copy-requires5_0 self7_0)"
"(begin"
" 'make-requires+provides8"
"(let-values(((self_0) self7_0))"
"(let-values(((copy-r+p_0) copy-requires5_0))"
"(let-values()"
"(requires+provides1.1"
" self_0"
"(if copy-r+p_0(requires+provides-require-mpis copy-r+p_0)(make-module-path-index-intern-table))"
"(if copy-r+p_0(hash-copy(requires+provides-require-mpis-in-order copy-r+p_0))(make-hasheqv))"
"(make-hasheq)"
"(make-hasheqv)"
"(make-hasheqv)"
"(make-hasheq)"
" #t"
" #t)))))))"
"(define-values"
"(requires+provides-reset!)"
"(lambda(r+p_0)"
"(begin"
"(begin"
"(hash-clear!(requires+provides-requires r+p_0))"
"(hash-clear!(requires+provides-provides r+p_0))"
"(hash-clear!(requires+provides-phase-to-defined-syms r+p_0))"
"(hash-clear!(requires+provides-also-required r+p_0))))))"
"(define-values"
"(intern-mpi)"
"(lambda(r+p_0 mpi_0)(begin(intern-module-path-index!(requires+provides-require-mpis r+p_0) mpi_0))))"
"(define-values"
"(add-required-module!)"
"(lambda(r+p_0 mod-name_0 phase-shift_0 is-cross-phase-persistent?_0)"
"(begin"
"(let-values(((mpi_0)(intern-mpi r+p_0 mod-name_0)))"
"(begin"
"(if(hash-ref(hash-ref(requires+provides-requires r+p_0) mpi_0 '#hasheqv()) phase-shift_0 #f)"
"(void)"
"(let-values()"
"(begin"
"(hash-update!"
"(requires+provides-require-mpis-in-order r+p_0)"
" phase-shift_0"
"(lambda(l_0)(cons mpi_0 l_0))"
" null)"
"(hash-set!"
"(hash-ref!(requires+provides-requires r+p_0) mpi_0 make-hasheqv)"
" phase-shift_0"
"(make-hasheq)))))"
"(if is-cross-phase-persistent?_0"
"(void)"
"(let-values()(set-requires+provides-can-cross-phase-persistent?! r+p_0 #f)))"
" mpi_0)))))"
"(define-values"
"(add-defined-or-required-id!19.1)"
"(lambda(as-transformer?12_0 can-be-shadowed?11_0 r+p15_0 id16_0 phase17_0 binding18_0)"
"(begin"
" 'add-defined-or-required-id!19"
"(let-values(((r+p_0) r+p15_0))"
"(let-values(((id_0) id16_0))"
"(let-values(((phase_0) phase17_0))"
"(let-values(((binding_0) binding18_0))"
"(let-values(((can-be-shadowed?_0) can-be-shadowed?11_0))"
"(let-values(((as-transformer?_0) as-transformer?12_0))"
"(let-values()"
"(begin"
"(if(equal?"
" phase_0"
"(phase+"
"(module-binding-nominal-phase binding_0)"
"(module-binding-nominal-require-phase binding_0)))"
"(void)"
"                        (let-values () (error \"internal error: binding phase does not match nominal info\")))"
"(let-values(((r+p124_0) r+p_0)"
"((id125_0) id_0)"
"((phase126_0) phase_0)"
"((temp127_0)(module-binding-nominal-module binding_0))"
"((temp128_0)(module-binding-nominal-require-phase binding_0))"
"((can-be-shadowed?129_0) can-be-shadowed?_0)"
"((as-transformer?130_0) as-transformer?_0))"
"(add-defined-or-required-id-at-nominal!33.1"
" as-transformer?130_0"
" can-be-shadowed?129_0"
" temp127_0"
" temp128_0"
" r+p124_0"
" id125_0"
" phase126_0)))))))))))))"
"(define-values"
"(add-defined-or-required-id-at-nominal!33.1)"
"(lambda(as-transformer?25_0"
" can-be-shadowed?24_0"
" nominal-module22_0"
" nominal-require-phase23_0"
" r+p30_0"
" id31_0"
" phase32_0)"
"(begin"
" 'add-defined-or-required-id-at-nominal!33"
"(let-values(((r+p_0) r+p30_0))"
"(let-values(((id_0) id31_0))"
"(let-values(((phase_0) phase32_0))"
"(let-values(((nominal-module_0) nominal-module22_0))"
"(let-values(((nominal-require-phase_0) nominal-require-phase23_0))"
"(let-values(((can-be-shadowed?_0) can-be-shadowed?24_0))"
"(let-values(((as-transformer?_0) as-transformer?25_0))"
"(let-values()"
"(let-values(((at-mod_0)"
"(hash-ref!"
"(requires+provides-requires r+p_0)"
"(intern-mpi r+p_0 nominal-module_0)"
" make-hasheqv)))"
"(let-values(((sym-to-reqds_0)(hash-ref! at-mod_0 nominal-require-phase_0 make-hasheq)))"
"(let-values(((sym_0)(syntax-e$1 id_0)))"
"(hash-set!"
" sym-to-reqds_0"
" sym_0"
"(cons-ish"
"(required2.1 id_0 phase_0 can-be-shadowed?_0 as-transformer?_0)"
"(hash-ref sym-to-reqds_0 sym_0 null)))))))))))))))))"
"(define-values"
"(add-bulk-required-ids!59.1)"
"(lambda(accum-update-nominals42_0"
" can-be-shadowed?40_0"
" check-and-remove?41_0"
" excepts37_0"
" in39_0"
" prefix36_0"
" symbols-accum38_0"
" who43_0"
" r+p52_0"
" s53_0"
" self54_0"
" nominal-module55_0"
" phase-shift56_0"
" provides57_0"
" provide-phase-level58_0)"
"(begin"
" 'add-bulk-required-ids!59"
"(let-values(((r+p_0) r+p52_0))"
"(let-values(((s_0) s53_0))"
"(let-values(((self_0) self54_0))"
"(let-values(((nominal-module_0) nominal-module55_0))"
"(let-values(((phase-shift_0) phase-shift56_0))"
"(let-values(((provides_0) provides57_0))"
"(let-values(((provide-phase-level_0) provide-phase-level58_0))"
"(let-values(((bulk-prefix_0) prefix36_0))"
"(let-values(((bulk-excepts_0) excepts37_0))"
"(let-values(((symbols-accum_0) symbols-accum38_0))"
"(let-values(((orig-s_0) in39_0))"
"(let-values(((can-be-shadowed?_0) can-be-shadowed?40_0))"
"(let-values(((check-and-remove?_0) check-and-remove?41_0))"
"(let-values(((accum-update-nominals_0) accum-update-nominals42_0))"
"(let-values(((who_0) who43_0))"
"(let-values()"
"(let-values(((phase_0)(phase+ provide-phase-level_0 phase-shift_0)))"
"(let-values(((shortcut-table_0)"
"(if check-and-remove?_0"
"(if(>(hash-count provides_0) 64)"
"(syntax-mapped-names s_0 phase_0)"
" #f)"
" #f)))"
"(let-values(((mpi_0)(intern-mpi r+p_0 nominal-module_0)))"
"(let-values(((at-mod_0)"
"(hash-ref!"
"(requires+provides-requires r+p_0)"
" mpi_0"
" make-hasheqv)))"
"(let-values(((sym-to-reqds_0)"
"(hash-ref! at-mod_0 phase-shift_0 make-hasheq)))"
"(let-values(((prefix-len_0)"
"(if bulk-prefix_0"
"(string-length(symbol->string bulk-prefix_0))"
" 0)))"
"(let-values(((br_0)"
"(bulk-required4.1"
" provides_0"
" prefix-len_0"
" s_0"
" provide-phase-level_0"
" can-be-shadowed?_0)))"
"(let-values(((ht_0) provides_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(any-already-defined?_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((out-sym_0 binding/p_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((any-already-defined?_1)"
"(let-values(((any-already-defined?_1)"
" any-already-defined?_0))"
"(if(not"
"(symbol-interned?"
" out-sym_0))"
" any-already-defined?_1"
"(let-values(((any-already-defined?_2)"
" any-already-defined?_1))"
"(let-values(((any-already-defined?_3)"
"(let-values()"
"(begin"
"(if symbols-accum_0"
"(let-values()"
"(hash-set!"
" symbols-accum_0"
" out-sym_0"
" #t))"
"(void))"
"(if(hash-ref"
" bulk-excepts_0"
" out-sym_0"
" #f)"
"(let-values()"
" #f)"
"(let-values()"
"(let-values(((sym_0)"
"(if(not"
" bulk-prefix_0)"
"(let-values()"
" out-sym_0)"
"(let-values()"
"(string->symbol"
"(string-append"
"(symbol->string"
" bulk-prefix_0)"
"(symbol->string"
" out-sym_0)))))))"
"(let-values(((already-defined?_0)"
"(if(if check-and-remove?_0"
"(let-values(((or-part_0)"
"(not"
" shortcut-table_0)))"
"(if or-part_0"
" or-part_0"
"(hash-ref"
" shortcut-table_0"
" sym_0"
" #f)))"
" #f)"
"(let-values()"
"(let-values(((temp131_0)"
" #t)"
"((temp132_0)"
" #t)"
"((r+p133_0)"
" r+p_0)"
"((temp134_0)"
"(datum->syntax$1"
" s_0"
" sym_0"
" s_0))"
"((phase135_0)"
" phase_0)"
"((orig-s136_0)"
" orig-s_0)"
"((temp137_0)"
"(lambda()"
"(let-values(((binding/p141_0)"
" binding/p_0)"
"((sym142_0)"
" sym_0)"
"((self143_0)"
" self_0)"
"((mpi144_0)"
" mpi_0)"
"((provide-phase-level145_0)"
" provide-phase-level_0)"
"((phase-shift146_0)"
" phase-shift_0))"
"(provide-binding-to-require-binding11.1"
" mpi144_0"
" phase-shift146_0"
" provide-phase-level145_0"
" self143_0"
" binding/p141_0"
" sym142_0))))"
"((temp138_0)"
" #t)"
"((accum-update-nominals139_0)"
" accum-update-nominals_0)"
"((who140_0)"
" who_0))"
"(check-not-defined95.1"
" accum-update-nominals139_0"
" temp132_0"
" temp131_0"
" orig-s136_0"
" temp138_0"
" temp137_0"
" who140_0"
" r+p133_0"
" temp134_0"
" phase135_0)))"
"(let-values()"
" #f))))"
"(begin"
"(if already-defined?_0"
"(void)"
"(let-values()"
"(hash-set!"
" sym-to-reqds_0"
" sym_0"
"(cons-ish"
" br_0"
"(hash-ref"
" sym-to-reqds_0"
" sym_0"
" null)))))"
"(let-values(((or-part_0)"
" any-already-defined?_2))"
"(if or-part_0"
" or-part_0"
" already-defined?_0)))))))))))"
"(values"
" any-already-defined?_3)))))))"
"(if(not #f)"
"(for-loop_0"
" any-already-defined?_1"
"(hash-iterate-next ht_0 i_0))"
" any-already-defined?_1)))"
" any-already-defined?_0)))))"
" for-loop_0)"
" #f"
"(hash-iterate-first ht_0))))))))))))))))))))))))))))))"
"(define-values"
"(bulk-required->required)"
"(lambda(br_0 nominal-module_0 phase_0 sym_0)"
"(begin"
"(let-values(((prefix-len_0)(bulk-required-prefix-len br_0)))"
"(let-values(((out-sym_0)"
"(if(zero? prefix-len_0) sym_0(string->symbol(substring(symbol->string sym_0) prefix-len_0)))))"
"(let-values(((binding/p_0)(hash-ref(bulk-required-provides br_0) out-sym_0)))"
"(required2.1"
"(datum->syntax$1(bulk-required-s br_0) sym_0)"
"(phase+ phase_0(bulk-required-provide-phase-level br_0))"
"(bulk-required-can-be-shadowed? br_0)"
"(provided-as-transformer? binding/p_0))))))))"
"(define-values"
"(normalize-required)"
"(lambda(r_0 mod-name_0 phase_0 sym_0)"
"(begin(if(bulk-required? r_0)(bulk-required->required r_0 mod-name_0 phase_0 sym_0) r_0))))"
"(define-values"
"(add-enclosing-module-defined-and-required!67.1)"
"(lambda(enclosing-requires+provides62_0 r+p64_0 enclosing-mod65_0 phase-shift66_0)"
"(begin"
" 'add-enclosing-module-defined-and-required!67"
"(let-values(((r+p_0) r+p64_0))"
"(let-values(((enclosing-r+p_0) enclosing-requires+provides62_0))"
"(let-values(((enclosing-mod_0) enclosing-mod65_0))"
"(let-values(((phase-shift_0) phase-shift66_0))"
"(let-values()"
"(begin"
"(set-requires+provides-all-bindings-simple?! r+p_0 #f)"
"(let-values(((ht_0)(requires+provides-requires enclosing-r+p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((mod-name_0 at-mod_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(let-values(((ht_1) at-mod_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((phase_0"
" at-phase_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values((()"
"(let-values(((ht_2)"
" at-phase_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_2)))"
"((letrec-values(((for-loop_2)"
"(lambda(i_2)"
"(begin"
" 'for-loop"
"(if i_2"
"(let-values(((sym_0"
" reqds_0)"
"(hash-iterate-key+value"
" ht_2"
" i_2)))"
"(let-values((()"
"(let-values(((lst_0)"
" reqds_0))"
"(begin"
"(void)"
"((letrec-values(((for-loop_3)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(not"
"(null?"
" lst_1))"
"(let-values(((reqd/maybe-bulk_0)"
"(if(pair?"
" lst_1)"
"(car"
" lst_1)"
" lst_1))"
"((rest_0)"
"(if(pair?"
" lst_1)"
"(cdr"
" lst_1)"
" null)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((reqd_0)"
"(normalize-required"
" reqd/maybe-bulk_0"
" mod-name_0"
" phase_0"
" sym_0)))"
"(let-values(((r+p147_0)"
" r+p_0)"
"((temp148_0)"
"(syntax-shift-phase-level$1"
"(let-values(((temp154_0)"
"(required-id"
" reqd_0))"
"((temp155_0)"
"(requires+provides-self"
" enclosing-r+p_0))"
"((enclosing-mod156_0)"
" enclosing-mod_0))"
"(syntax-module-path-index-shift13.1"
" #f"
" temp154_0"
" temp155_0"
" enclosing-mod156_0"
" #f))"
" phase-shift_0))"
"((temp149_0)"
"(phase+"
"(required-phase"
" reqd_0)"
" phase-shift_0))"
"((enclosing-mod150_0)"
" enclosing-mod_0)"
"((phase-shift151_0)"
" phase-shift_0)"
"((temp152_0)"
" #t)"
"((temp153_0)"
"(required-as-transformer?"
" reqd_0)))"
"(add-defined-or-required-id-at-nominal!33.1"
" temp153_0"
" temp152_0"
" enclosing-mod150_0"
" phase-shift151_0"
" r+p147_0"
" temp148_0"
" temp149_0))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_3"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_3)"
" lst_0)))))"
"(if(not"
" #f)"
"(for-loop_2"
"(hash-iterate-next"
" ht_2"
" i_2))"
"(values))))"
"(values))))))"
" for-loop_2)"
"(hash-iterate-first"
" ht_2))))))"
"(if(not"
" #f)"
"(for-loop_1"
"(hash-iterate-next"
" ht_1"
" i_1))"
"(values))))"
"(values))))))"
" for-loop_1)"
"(hash-iterate-first ht_1))))"
"(void)))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_0 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(void))))))))))"
"(define-values"
"(remove-required-id!75.1)"
"(lambda(unless-matches70_0 r+p72_0 id73_0 phase74_0)"
"(begin"
" 'remove-required-id!75"
"(let-values(((r+p_0) r+p72_0))"
"(let-values(((id_0) id73_0))"
"(let-values(((phase_0) phase74_0))"
"(let-values(((binding_0) unless-matches70_0))"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((id157_0) id_0)((phase158_0) phase_0)((temp159_0) #t))"
"(resolve+shift28.1 #f temp159_0 null unsafe-undefined #f id157_0 phase158_0))))"
"(if b_0"
"(let-values()"
"(let-values(((mpi_0)(intern-mpi r+p_0(module-binding-nominal-module b_0))))"
"(let-values(((at-mod_0)(hash-ref(requires+provides-requires r+p_0) mpi_0 #f)))"
"(if at-mod_0"
"(let-values()"
"(let-values(((nominal-phase_0)(module-binding-nominal-require-phase b_0)))"
"(let-values(((sym-to-reqds_0)(hash-ref at-mod_0 nominal-phase_0 #f)))"
"(if sym-to-reqds_0"
"(let-values()"
"(let-values(((sym_0)(syntax-e$1 id_0)))"
"(let-values(((l_0)(hash-ref sym-to-reqds_0 sym_0 null)))"
"(if(null? l_0)"
"(void)"
"(let-values()"
"(if(same-binding? b_0 binding_0)"
"(void)"
"(let-values()"
"(hash-set!"
" sym-to-reqds_0"
" sym_0"
"(remove-non-matching-requireds"
" l_0"
" id_0"
" phase_0"
" mpi_0"
" nominal-phase_0"
" sym_0)))))))))"
"(void)))))"
"(void)))))"
"(void)))))))))))"
"(define-values"
"(remove-non-matching-requireds)"
"(lambda(reqds_0 id_0 phase_0 mpi_0 nominal-phase_0 sym_0)"
"(begin"
"(reverse$1"
"(let-values(((lst_0) reqds_0))"
"(begin"
"(void)"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(not(null? lst_1))"
"(let-values(((r_0)(if(pair? lst_1)(car lst_1) lst_1))"
"((rest_0)(if(pair? lst_1)(cdr lst_1) null)))"
"(let-values(((fold-var_1)"
"(let-values(((r_1)"
"(normalize-required r_0 mpi_0 nominal-phase_0 sym_0)))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" fold-var_1))"
"(if(if(eqv?"
" phase_0"
"(required-phase"
" r_1))"
"(free-identifier=?$1"
"(required-id r_1)"
" id_0"
" phase_0"
" phase_0)"
" #f)"
" fold-var_2"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
" r_1)"
" fold-var_3))))"
"(values"
" fold-var_4)))))))"
" fold-var_2))))))"
" for-loop_1)"
" fold-var_0)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(define-values"
"(check-not-defined95.1)"
"(lambda(accum-update-nominals83_0"
" allow-defined?79_0"
" check-not-required?78_0"
" in80_0"
" remove-shadowed!?82_0"
" unless-matches81_0"
" who84_0"
" r+p92_0"
" id93_0"
" phase94_0)"
"(begin"
" 'check-not-defined95"
"(let-values(((check-not-required?_0) check-not-required?78_0))"
"(let-values(((allow-defined?_0) allow-defined?79_0))"
"(let-values(((r+p_0) r+p92_0))"
"(let-values(((id_0) id93_0))"
"(let-values(((phase_0) phase94_0))"
"(let-values(((orig-s_0) in80_0))"
"(let-values(((ok-binding/delayed_0) unless-matches81_0))"
"(let-values(((remove-shadowed!?_0) remove-shadowed!?82_0))"
"(let-values(((accum-update-nominals_0) accum-update-nominals83_0))"
"(let-values(((who_0) who84_0))"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((id160_0) id_0)((phase161_0) phase_0)((temp162_0) #t))"
"(resolve+shift28.1"
" #f"
" temp162_0"
" null"
" unsafe-undefined"
" #f"
" id160_0"
" phase161_0))))"
"(if(not b_0)"
"(let-values() #f)"
"(if(not(module-binding? b_0))"
"                                  (let-values () (raise-syntax-error$1 #f \"identifier out of context\" id_0))"
"(let-values()"
"(let-values(((defined?_0)"
"(if b_0"
"(eq?(requires+provides-self r+p_0)(module-binding-module b_0))"
" #f)))"
"(if(if defined?_0"
"(not"
"(hash-ref"
"(hash-ref"
"(requires+provides-phase-to-defined-syms r+p_0)"
" phase_0"
" '#hasheq())"
"(module-binding-sym b_0)"
" #f))"
" #f)"
"(let-values() #f)"
"(let-values()"
"(let-values(((define-shadowing-require?_0)"
"(if(not defined?_0)(not check-not-required?_0) #f)))"
"(let-values(((mpi_0)"
"(intern-mpi r+p_0(module-binding-nominal-module b_0))))"
"(let-values(((at-mod_0)"
"(hash-ref(requires+provides-requires r+p_0) mpi_0 #f)))"
"(let-values(((ok-binding_0)"
"(if(not define-shadowing-require?_0)"
"(if(procedure? ok-binding/delayed_0)"
"(ok-binding/delayed_0)"
" ok-binding/delayed_0)"
" #f)))"
"(let-values(((raise-already-bound_0)"
"(lambda(defined?_1)"
"(begin"
" 'raise-already-bound"
"(raise-syntax-error$1"
" who_0"
"(string-append"
"                                                                      \"identifier already \""
"                                                                      (if defined?_1 \"defined\" \"required\")"
"(if(zero-phase? phase_0)"
"                                                                        (let-values () \"\")"
"(if(label-phase? phase_0)"
"                                                                          (let-values () \" for label\")"
"(if(= 1 phase_0)"
"                                                                            (let-values () \" for syntax\")"
"(let-values()"
"                                                                              (format \" for phase ~a\" phase_0))))))"
" orig-s_0"
" id_0)))))"
"(if(if(not at-mod_0)(not define-shadowing-require?_0) #f)"
"(let-values() #f)"
"(if(if ok-binding_0(same-binding? b_0 ok-binding_0) #f)"
"(let-values()"
"(begin"
"(if(same-binding-nominals? b_0 ok-binding_0)"
"(void)"
"(let-values()"
"(let-values(((update!_0)"
"(lambda()"
"(begin"
" 'update!"
"(let-values(((temp163_0) #t)"
"((id164_0) id_0)"
"((temp165_0)"
"(let-values(((ok-binding167_0)"
" ok-binding_0)"
"((temp168_0)"
"(cons"
" b_0"
"(module-binding-extra-nominal-bindings"
" b_0))))"
"(module-binding-update46.1"
" unsafe-undefined"
" temp168_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" ok-binding167_0)))"
"((phase166_0) phase_0))"
"(add-binding!17.1"
" #f"
" temp163_0"
" id164_0"
" temp165_0"
" phase166_0))))))"
"(if accum-update-nominals_0"
"(let-values()"
"(set-box!"
" accum-update-nominals_0"
"(cons"
" update!_0"
"(unbox accum-update-nominals_0))))"
"(let-values()(update!_0))))))"
" defined?_0))"
"(if(if defined?_0 allow-defined?_0 #f)"
"(let-values()"
"(let-values(((also-required_0)"
"(requires+provides-also-required r+p_0)))"
"(let-values(((prev-b_0)"
"(hash-ref"
" also-required_0"
"(module-binding-sym b_0)"
" #f)))"
"(begin"
"(if(if prev-b_0"
"(not(same-binding? ok-binding_0 prev-b_0))"
" #f)"
"(let-values()(raise-already-bound_0 #f))"
"(void))"
"(hash-set!"
" also-required_0"
"(module-binding-sym b_0)"
" ok-binding_0)"
"(set-requires+provides-all-bindings-simple?! r+p_0 #f)"
" #t))))"
"(let-values()"
"(let-values(((nominal-phase_0)"
"(module-binding-nominal-require-phase b_0)))"
"(let-values(((sym-to-reqds_0)"
"(hash-ref"
" at-mod_0"
" nominal-phase_0"
" '#hasheq())))"
"(let-values(((reqds_0)"
"(hash-ref"
" sym-to-reqds_0"
"(syntax-e$1 id_0)"
" null)))"
"(let-values(((only-can-can-shadow-require?_0)"
"(let-values(((lst_0) reqds_0))"
"(begin"
"(void)"
"((letrec-values(((for-loop_0)"
"(lambda(only-can-can-shadow-require?_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(not"
"(null?"
" lst_1))"
"(let-values(((r_0)"
"(if(pair?"
" lst_1)"
"(car"
" lst_1)"
" lst_1))"
"((rest_0)"
"(if(pair?"
" lst_1)"
"(cdr"
" lst_1)"
" null)))"
"(let-values(((only-can-can-shadow-require?_1)"
"(let-values(((only-can-can-shadow-require?_1)"
" only-can-can-shadow-require?_0))"
"(let-values(((only-can-can-shadow-require?_2)"
"(let-values()"
"(if(if(bulk-required?"
" r_0)"
"(bulk-required-can-be-shadowed?"
" r_0)"
"(required-can-be-shadowed?"
" r_0))"
"(let-values()"
"(begin"
"(set-requires+provides-all-bindings-simple?!"
" r+p_0"
" #f)"
" only-can-can-shadow-require?_1))"
"(if define-shadowing-require?_0"
"(let-values()"
" #f)"
"(let-values()"
"(raise-already-bound_0"
" defined?_0)))))))"
"(values"
" only-can-can-shadow-require?_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" only-can-can-shadow-require?_1"
" rest_0)"
" only-can-can-shadow-require?_1)))"
" only-can-can-shadow-require?_0)))))"
" for-loop_0)"
" #t"
" lst_0)))))"
"(begin"
"(if define-shadowing-require?_0"
"(let-values()"
"(begin"
"(set-requires+provides-all-bindings-simple?!"
" r+p_0"
" #f)"
"(if only-can-can-shadow-require?_0"
"(void)"
"(let-values()"
"(hash-set!"
"(requires+provides-also-required r+p_0)"
"(module-binding-sym b_0)"
" b_0)))))"
"(let-values()"
"(if(if remove-shadowed!?_0"
"(not(null? reqds_0))"
" #f)"
"(let-values()"
"(hash-set!"
" sym-to-reqds_0"
"(syntax-e$1 id_0)"
"(remove-non-matching-requireds"
" reqds_0"
" id_0"
" phase_0"
" mpi_0"
" nominal-phase_0"
"(syntax-e$1 id_0))))"
"(void))))"
" #f)))))))))))))))))))))))))))))))))))"
"(define-values"
"(add-defined-syms!103.1)"
"(lambda(as-transformer?98_0 r+p100_0 syms101_0 phase102_0)"
"(begin"
" 'add-defined-syms!103"
"(let-values(((r+p_0) r+p100_0))"
"(let-values(((syms_0) syms101_0))"
"(let-values(((phase_0) phase102_0))"
"(let-values(((as-transformer?_0) as-transformer?98_0))"
"(let-values()"
"(let-values(((phase-to-defined-syms_0)(requires+provides-phase-to-defined-syms r+p_0)))"
"(let-values(((defined-syms_0)(hash-ref phase-to-defined-syms_0 phase_0 '#hasheq())))"
"(let-values(((new-defined-syms_0)"
"(let-values(((lst_0) syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(defined-syms_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((sym_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((defined-syms_2)"
"(let-values(((defined-syms_2)"
" defined-syms_1))"
"(let-values(((defined-syms_3)"
"(let-values()"
"(hash-set"
" defined-syms_2"
" sym_0"
"(if as-transformer?_0"
" 'transformer"
" 'variable)))))"
"(values defined-syms_3)))))"
"(if(not #f)"
"(for-loop_0 defined-syms_2 rest_0)"
" defined-syms_2)))"
" defined-syms_1)))))"
" for-loop_0)"
" defined-syms_0"
" lst_0)))))"
"(hash-set! phase-to-defined-syms_0 phase_0 new-defined-syms_0))))))))))))"
"(define-values"
"(defined-sym-kind)"
"(lambda(r+p_0 sym_0 phase_0)"
"(begin"
"(let-values(((phase-to-defined-syms_0)(requires+provides-phase-to-defined-syms r+p_0)))"
"(let-values(((defined-syms_0)(hash-ref phase-to-defined-syms_0 phase_0 '#hasheq())))"
"(hash-ref defined-syms_0 sym_0 #f))))))"
"(define-values"
"(extract-module-requires)"
"(lambda(r+p_0 mod-name_0 phase_0)"
"(begin"
"(let-values(((mpi_0)(intern-mpi r+p_0 mod-name_0)))"
"(let-values(((at-mod_0)(hash-ref(requires+provides-requires r+p_0) mpi_0 #f)))"
"(if at-mod_0"
"(reverse$1"
"(let-values(((ht_0)(hash-ref at-mod_0 phase_0 '#hasheq())))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 reqds_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((lst_0) reqds_0))"
"(begin"
"(void)"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1 lst_1)"
"(begin"
" 'for-loop"
"(if(not(null? lst_1))"
"(let-values(((reqd_0)"
"(if(pair? lst_1)"
"(car lst_1)"
" lst_1))"
"((rest_0)"
"(if(pair? lst_1)"
"(cdr lst_1)"
" null)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
"(normalize-required"
" reqd_0"
" mpi_0"
" phase_0"
" sym_0))"
" fold-var_2))))"
"(values"
" fold-var_3)))))"
"(if(not #f)"
"(for-loop_1"
" fold-var_2"
" rest_0)"
" fold-var_2)))"
" fold-var_1)))))"
" for-loop_1)"
" fold-var_0"
" lst_0)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1(hash-iterate-next ht_0 i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(hash-iterate-first ht_0)))))"
" #f))))))"
"(define-values"
"(extract-module-definitions)"
"(lambda(r+p_0)"
"(begin"
"(let-values(((or-part_0)(extract-module-requires r+p_0(requires+provides-self r+p_0) 0)))"
"(if or-part_0 or-part_0 null)))))"
"(define-values"
"(extract-all-module-requires)"
"(lambda(r+p_0 mod-name_0 phase_0)"
"(begin"
"(let-values(((self_0)(requires+provides-self r+p_0)))"
"(let-values(((requires_0)(requires+provides-requires r+p_0)))"
"(call/ec"
"(lambda(esc_0)"
"(reverse$1"
"(let-values(((lst_0)(if mod-name_0(list(intern-mpi r+p_0 mod-name_0))(hash-keys requires_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mod-name_1)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(if(eq? mod-name_1 self_0)"
" fold-var_1"
"(let-values(((phase-to-requireds_0)"
"(hash-ref"
" requires_0"
" mod-name_1"
" '#hasheqv())))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((fold-var_3)"
"(let-values(((lst_2)"
"(if(eq?"
" phase_0"
" 'all)"
"(hash-keys"
" phase-to-requireds_0)"
"(list"
" phase_0))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_2)"
"(lambda(fold-var_3"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((phase_1)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_4)"
"(let-values(((ht_0)"
"(hash-ref"
" phase-to-requireds_0"
" phase_1"
"(lambda()"
"(esc_0"
" #f)))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_3)"
"(lambda(fold-var_4"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0"
" reqds_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((fold-var_5)"
"(let-values(((lst_4)"
" reqds_0))"
"(begin"
"(void)"
"((letrec-values(((for-loop_4)"
"(lambda(fold-var_5"
" lst_5)"
"(begin"
" 'for-loop"
"(if(not"
"(null?"
" lst_5))"
"(let-values(((reqd_0)"
"(if(pair?"
" lst_5)"
"(car"
" lst_5)"
" lst_5))"
"((rest_2)"
"(if(pair?"
" lst_5)"
"(cdr"
" lst_5)"
" null)))"
"(let-values(((fold-var_6)"
"(let-values(((fold-var_6)"
" fold-var_5))"
"(let-values(((fold-var_7)"
"(let-values()"
"(cons"
"(let-values()"
"(normalize-required"
" reqd_0"
" mod-name_1"
" phase_1"
" sym_0))"
" fold-var_6))))"
"(values"
" fold-var_7)))))"
"(if(not"
" #f)"
"(for-loop_4"
" fold-var_6"
" rest_2)"
" fold-var_6)))"
" fold-var_5)))))"
" for-loop_4)"
" fold-var_4"
" lst_4)))))"
"(if(not"
" #f)"
"(for-loop_3"
" fold-var_5"
"(hash-iterate-next"
" ht_0"
" i_0))"
" fold-var_5)))"
" fold-var_4)))))"
" for-loop_3)"
" fold-var_3"
"(hash-iterate-first"
" ht_0))))))"
"(if(not"
" #f)"
"(for-loop_2"
" fold-var_4"
" rest_1)"
" fold-var_4)))"
" fold-var_3)))))"
" for-loop_2)"
" fold-var_2"
" lst_2)))))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_1)))))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))))))"
"(define-values"
"(add-provide!117.1)"
"(lambda(as-protected?106_0"
" as-transformer?107_0"
" r+p110_0"
" sym111_0"
" phase112_0"
" binding113_0"
" immed-binding114_0"
" id115_0"
" orig-s116_0)"
"(begin"
" 'add-provide!117"
"(let-values(((r+p_0) r+p110_0))"
"(let-values(((sym_0) sym111_0))"
"(let-values(((phase_0) phase112_0))"
"(let-values(((binding_0) binding113_0))"
"(let-values(((immed-binding_0) immed-binding114_0))"
"(let-values(((id_0) id115_0))"
"(let-values(((orig-s_0) orig-s116_0))"
"(let-values(((as-protected?_0) as-protected?106_0))"
"(let-values(((as-transformer?_0) as-transformer?107_0))"
"(let-values()"
"(begin"
"(if(if as-protected?_0"
"(not(eq?(module-binding-module immed-binding_0)(requires+provides-self r+p_0)))"
" #f)"
"(let-values()"
"                                (raise-syntax-error$1 #f \"cannot protect required identifier in re-provide\" sym_0))"
"(void))"
"(hash-update!"
"(requires+provides-provides r+p_0)"
" phase_0"
"(lambda(at-phase_0)"
"(let-values(((b/p_0)(hash-ref at-phase_0 sym_0 #f)))"
"(let-values(((b_0)(provided-as-binding b/p_0)))"
"(if(not b_0)"
"(let-values()"
"(let-values(((plain-binding_0)"
"(if(binding-free=id binding_0)"
"(let-values(((binding169_0) binding_0)((temp170_0) #f))"
"(module-binding-update46.1"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" temp170_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" binding169_0))"
" binding_0)))"
"(hash-set"
" at-phase_0"
" sym_0"
"(if(let-values(((or-part_0) as-protected?_0))"
"(if or-part_0 or-part_0 as-transformer?_0))"
"(provided1.1 plain-binding_0 as-protected?_0 as-transformer?_0)"
" plain-binding_0))))"
"(if(same-binding? b_0 binding_0)"
"(let-values() at-phase_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                          \"identifier already provided (as a different binding)\""
" orig-s_0"
" id_0)))))))"
" '#hasheq())))))))))))))))"
"(define-values"
"(extract-requires-and-provides)"
"(lambda(r+p_0 old-self_0 new-self_0)"
"(begin"
"(let-values(((extract-requires_0)"
"(lambda()"
"(begin"
" 'extract-requires"
"(let-values(((phase-to-mpis-in-order_0)(requires+provides-require-mpis-in-order r+p_0)))"
"(let-values(((phases-in-order_0)"
"(let-values(((temp171_0)(hash-keys phase-to-mpis-in-order_0))"
"((phase<?172_0) phase<?))"
"(sort7.1 #f #f temp171_0 phase<?172_0))))"
"(reverse$1"
"(let-values(((lst_0) phases-in-order_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((phase_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
" phase_0"
"(reverse$1"
"(let-values(((lst_2)"
"(reverse$1"
"(hash-ref"
" phase-to-mpis-in-order_0"
" phase_0))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((mpi_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(if(eq?"
" mpi_0"
" old-self_0)"
" fold-var_3"
"(let-values(((fold-var_4)"
" fold-var_3))"
"(let-values(((fold-var_5)"
"(let-values()"
"(cons"
"(let-values()"
"(module-path-index-shift"
" mpi_0"
" old-self_0"
" new-self_0))"
" fold-var_4))))"
"(values"
" fold-var_5)))))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_3"
" rest_1)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
" lst_2))))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))))"
"(let-values(((extract-provides_0)"
"(lambda()"
"(begin"
" 'extract-provides"
"(shift-provides-module-path-index"
"(requires+provides-provides r+p_0)"
" old-self_0"
" new-self_0)))))"
"(values(extract-requires_0)(extract-provides_0)))))))"
"(define-values"
"(shift-provides-module-path-index)"
"(lambda(provides_0 from-mpi_0 to-mpi_0)"
"(begin"
"(let-values(((ht_0) provides_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 at-phase_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" phase_0"
"(let-values(((ht_1) at-phase_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_2"
" i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((sym_0"
" binding_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((table_3)"
"(let-values(((table_3)"
" table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" sym_0"
"(if(eq?"
" from-mpi_0"
" to-mpi_0)"
"(let-values()"
" binding_0)"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(binding_1)"
"(begin"
" 'loop"
"(if(provided?"
" binding_1)"
"(let-values()"
"(provided1.1"
"(loop_0"
"(provided-binding"
" binding_1))"
"(provided-protected?"
" binding_1)"
"(provided-syntax?"
" binding_1)))"
"(let-values()"
"(binding-module-path-index-shift"
" binding_1"
" from-mpi_0"
" to-mpi_0)))))))"
" loop_0)"
" binding_0)))))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" table_3"
"(hash-iterate-next"
" ht_1"
" i_1))"
" table_3)))"
" table_2)))))"
" for-loop_1)"
" '#hasheq()"
"(hash-iterate-first"
" ht_1))))))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1(hash-iterate-next ht_0 i_0)) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
"(hash-iterate-first ht_0)))))))"
"(define-values"
"(struct:adjust-only adjust-only1.1 adjust-only? adjust-only-syms)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'adjust-only #f 1 0 #f null(current-inspector) #f '(0) #f 'adjust-only)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'syms))))"
"(define-values"
"(struct:adjust-prefix adjust-prefix2.1 adjust-prefix? adjust-prefix-sym)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'adjust-prefix #f 1 0 #f null(current-inspector) #f '(0) #f 'adjust-prefix)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'sym))))"
"(define-values"
"(struct:adjust-all-except adjust-all-except3.1 adjust-all-except? adjust-all-except-prefix-sym adjust-all-except-syms)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'adjust-all-except"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'adjust-all-except)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'prefix-sym)"
"(make-struct-field-accessor -ref_0 1 'syms))))"
"(define-values"
"(struct:adjust-rename adjust-rename4.1 adjust-rename? adjust-rename-to-id adjust-rename-from-sym)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'adjust-rename #f 2 0 #f null(current-inspector) #f '(0 1) #f 'adjust-rename)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'to-id)"
"(make-struct-field-accessor -ref_0 1 'from-sym))))"
"(define-values(layers$1) '(raw phaseless path))"
"(define-values"
"(parse-and-perform-requires!30.1)"
"(lambda(copy-variable-as-constant?11_0"
" copy-variable-phase-level10_0"
" declared-submodule-names9_0"
" initial-require?13_0"
" run-phase6_0"
" run?7_0"
" self5_0"
" skip-variable-phase-level12_0"
" visit?8_0"
" who14_0"
" reqs25_0"
" orig-s26_0"
" m-ns27_0"
" phase-shift28_0"
" requires+provides29_0)"
"(begin"
" 'parse-and-perform-requires!30"
"(let-values(((reqs_0) reqs25_0))"
"(let-values(((orig-s_0) orig-s26_0))"
"(let-values(((m-ns_0) m-ns27_0))"
"(let-values(((phase-shift_0) phase-shift28_0))"
"(let-values(((requires+provides_0) requires+provides29_0))"
"(let-values(((self_0) self5_0))"
"(let-values(((run-phase_0)"
"(if(eq? run-phase6_0 unsafe-undefined)(namespace-phase m-ns_0) run-phase6_0)))"
"(let-values(((run?_0) run?7_0))"
"(let-values(((visit?_0) visit?8_0))"
"(let-values(((declared-submodule-names_0)"
"(if(eq? declared-submodule-names9_0 unsafe-undefined)"
" '#hasheq()"
" declared-submodule-names9_0)))"
"(let-values(((copy-variable-phase-level_0) copy-variable-phase-level10_0))"
"(let-values(((copy-variable-as-constant?_0) copy-variable-as-constant?11_0))"
"(let-values(((skip-variable-phase-level_0) skip-variable-phase-level12_0))"
"(let-values(((initial-require?_0) initial-require?13_0))"
"(let-values(((who_0) who14_0))"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(reqs_1"
" top-req_0"
" phase-shift_1"
" just-meta_0"
" adjust_0"
" for-meta-ok?_0"
" just-meta-ok?_0"
" layer_0)"
"(begin"
" 'loop"
"(let-values(((lst_0) reqs_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((req_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(let-values(((check-nested_0)"
"(let-values(((check-nested116_0)"
"(lambda(want-layer115_0"
" ok?114_0)"
"(begin"
" 'check-nested116"
"(let-values(((want-layer_0)"
" want-layer115_0))"
"(let-values(((ok?_0)"
" ok?114_0))"
"(let-values()"
"(if(if ok?_0"
"(member"
" want-layer_0"
"(member"
" layer_0"
" layers$1))"
" #f)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                       \"invalid nesting\""
" orig-s_0"
" req_0))))))))))"
"(case-lambda"
"((want-layer_0)"
"(begin"
" 'check-nested"
"(check-nested116_0"
" want-layer_0"
" #t)))"
"((want-layer_0"
" ok?114_0)"
"(check-nested116_0"
" want-layer_0"
" ok?114_0))))))"
"(let-values(((fm_0)"
"(if(pair?"
"(syntax-e$1"
" req_0))"
"(if(identifier?"
"(car"
"(syntax-e$1"
" req_0)))"
"(syntax-e$1"
"(car"
"(syntax-e$1"
" req_0)))"
" #f)"
" #f)))"
"(let-values(((tmp_0)"
" fm_0))"
"(if(equal?"
" tmp_0"
" 'for-meta)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw"
" for-meta-ok?_0)"
"(values))))"
"(let-values(((ok?_0"
" for-meta118_0"
" phase-level119_0"
" spec120_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-meta118_0"
" phase-level119_0"
" spec120_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-meta121_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((phase-level122_0"
" spec123_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((phase-level124_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec125_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" phase-level124_0"
" spec125_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))))))"
"(values"
" for-meta121_0"
" phase-level122_0"
" spec123_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                             \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-meta118_0"
" phase-level119_0"
" spec120_0))))))"
"(let-values(((p_0)"
"(syntax-e$1"
" phase-level119_0)))"
"(begin"
"(if(phase?"
" p_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                   \"bad phase\""
" orig-s_0"
" req_0)))"
"(loop_0"
" spec120_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
"(phase+"
" phase-shift_1"
" p_0)"
" just-meta_0"
" adjust_0"
" #f"
" just-meta-ok?_0"
" 'raw))))))"
"(if(equal?"
" tmp_0"
" 'for-syntax)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw"
" for-meta-ok?_0)"
"(values))))"
"(let-values(((ok?_0"
" for-syntax126_0"
" spec127_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-syntax126_0"
" spec127_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-syntax128_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec129_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" for-syntax128_0"
" spec129_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                               \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-syntax126_0"
" spec127_0))))))"
"(loop_0"
" spec127_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
"(phase+"
" phase-shift_1"
" 1)"
" just-meta_0"
" adjust_0"
" #f"
" just-meta-ok?_0"
" 'raw))))"
"(if(equal?"
" tmp_0"
" 'for-template)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw"
" for-meta-ok?_0)"
"(values))))"
"(let-values(((ok?_0"
" for-template130_0"
" spec131_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-template130_0"
" spec131_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-template132_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec133_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" for-template132_0"
" spec133_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                 \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-template130_0"
" spec131_0))))))"
"(loop_0"
" spec131_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
"(phase+"
" phase-shift_1"
" -1)"
" just-meta_0"
" adjust_0"
" #f"
" just-meta-ok?_0"
" 'raw))))"
"(if(equal?"
" tmp_0"
" 'for-label)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw"
" for-meta-ok?_0)"
"(values))))"
"(let-values(((ok?_0"
" for-label134_0"
" spec135_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-label134_0"
" spec135_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-label136_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec137_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" for-label136_0"
" spec137_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                   \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-label134_0"
" spec135_0))))))"
"(loop_0"
" spec135_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
"(phase+"
" phase-shift_1"
" #f)"
" just-meta_0"
" adjust_0"
" #f"
" just-meta-ok?_0"
" 'raw))))"
"(if(equal?"
" tmp_0"
" 'just-meta)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw"
" just-meta-ok?_0)"
"(values))))"
"(let-values(((ok?_0"
" just-meta138_0"
" phase-level139_0"
" spec140_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((just-meta138_0"
" phase-level139_0"
" spec140_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((just-meta141_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((phase-level142_0"
" spec143_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((phase-level144_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec145_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" phase-level144_0"
" spec145_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))))))"
"(values"
" just-meta141_0"
" phase-level142_0"
" spec143_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                     \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" just-meta138_0"
" phase-level139_0"
" spec140_0))))))"
"(let-values(((p_0)"
"(syntax-e$1"
" phase-level139_0)))"
"(begin"
"(if(phase?"
" p_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                           \"bad phase\""
" orig-s_0"
" req_0)))"
"(loop_0"
" spec140_0"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" p_0"
" adjust_0"
" for-meta-ok?_0"
" #f"
" 'raw))))))"
"(if(equal?"
" tmp_0"
" 'only)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" only146_0"
" spec147_0"
" id148_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((only146_0"
" spec147_0"
" id148_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((only149_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec150_0"
" id151_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((spec152_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((id153_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id154_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                 \"not an identifier\""
" orig-s_1"
" s_6)))))"
"(cons"
" id154_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_1"
" rest_1)"
" id_1)))"
" id_0)))))"
" for-loop_1)"
" null"
" lst_2)))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" spec152_0"
" id153_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1))))))"
"(values"
" only149_0"
" spec150_0"
" id151_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                       \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" only146_0"
" spec147_0"
" id148_0))))))"
"(loop_0"
"(list"
" spec147_0)"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" just-meta_0"
"(adjust-only1.1"
"(ids->sym-set"
" id148_0))"
" #f"
" #f"
" 'path))))"
"(if(equal?"
" tmp_0"
" 'prefix)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" prefix155_0"
" id:prefix156_0"
" spec157_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((prefix155_0"
" id:prefix156_0"
" spec157_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((prefix158_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:prefix159_0"
" spec160_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:prefix161_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                               \"not an identifier\""
" orig-s_1"
" s_4))))"
"((spec162_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((spec163_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_1))))))"
"(values"
" spec163_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:prefix161_0"
" spec162_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                             \"bad syntax\""
" orig-s_1))))))"
"(values"
" prefix158_0"
" id:prefix159_0"
" spec160_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                         \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" prefix155_0"
" id:prefix156_0"
" spec157_0))))))"
"(loop_0"
"(list"
" spec157_0)"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" just-meta_0"
"(adjust-prefix2.1"
"(syntax-e$1"
" id:prefix156_0))"
" #f"
" #f"
" 'path))))"
"(if(equal?"
" tmp_0"
" 'all-except)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" all-except164_0"
" spec165_0"
" id166_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((all-except164_0"
" spec165_0"
" id166_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((all-except167_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec168_0"
" id169_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((spec170_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((id171_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id172_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                     \"not an identifier\""
" orig-s_1"
" s_6)))))"
"(cons"
" id172_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_1"
" rest_1)"
" id_1)))"
" id_0)))))"
" for-loop_1)"
" null"
" lst_2)))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" spec170_0"
" id171_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                               \"bad syntax\""
" orig-s_1))))))"
"(values"
" all-except167_0"
" spec168_0"
" id169_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                           \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" all-except164_0"
" spec165_0"
" id166_0))))))"
"(loop_0"
"(list"
" spec165_0)"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" just-meta_0"
"(adjust-all-except3.1"
" '||"
"(ids->sym-set"
" id166_0))"
" #f"
" #f"
" 'path))))"
"(if(equal?"
" tmp_0"
" 'prefix-all-except)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" prefix-all-except173_0"
" id:prefix174_0"
" spec175_0"
" id176_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((prefix-all-except173_0"
" id:prefix174_0"
" spec175_0"
" id176_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((prefix-all-except177_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:prefix178_0"
" spec179_0"
" id180_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:prefix181_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                   \"not an identifier\""
" orig-s_1"
" s_4))))"
"((spec182_0"
" id183_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((spec184_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((id185_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_7)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                             \"bad syntax\""
" orig-s_1))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((s_8)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id186_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_8)"
"(symbol?"
"(syntax-e$1"
" s_8))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_8)))"
" s_8"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                                           \"not an identifier\""
" orig-s_1"
" s_8)))))"
"(cons"
" id186_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_1"
" rest_1)"
" id_1)))"
" id_0)))))"
" for-loop_1)"
" null"
" lst_2)))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" spec184_0"
" id185_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:prefix181_0"
" spec182_0"
" id183_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))))))"
"(values"
" prefix-all-except177_0"
" id:prefix178_0"
" spec179_0"
" id180_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                             \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" prefix-all-except173_0"
" id:prefix174_0"
" spec175_0"
" id176_0))))))"
"(loop_0"
"(list"
" spec175_0)"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" just-meta_0"
"(adjust-all-except3.1"
"(syntax-e$1"
" id:prefix174_0)"
"(ids->sym-set"
" id176_0))"
" #f"
" #f"
" 'path))))"
"(if(equal?"
" tmp_0"
" 'rename)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" rename187_0"
" spec188_0"
" id:to189_0"
" id:from190_0)"
"(let-values(((s_0)"
" req_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((rename187_0"
" spec188_0"
" id:to189_0"
" id:from190_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((rename191_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec192_0"
" id:to193_0"
" id:from194_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((spec195_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((id:to196_0"
" id:from197_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((id:to198_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                         \"not an identifier\""
" orig-s_1"
" s_6))))"
"((id:from199_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(let-values(((id:from200_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_8)"
"(symbol?"
"(syntax-e$1"
" s_8))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_8)))"
" s_8"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                             \"not an identifier\""
" orig-s_1"
" s_8))))"
"(()"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(syntax?$1"
" s_8)"
"(syntax-e$1"
" s_8)"
" s_8)))"
"(if(null?"
" s_9)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:from200_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:to198_0"
" id:from199_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))))))"
"(values"
" spec195_0"
" id:to196_0"
" id:from197_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1))))))"
"(values"
" rename191_0"
" spec192_0"
" id:to193_0"
" id:from194_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                               \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" rename187_0"
" spec188_0"
" id:to189_0"
" id:from190_0))))))"
"(loop_0"
"(list"
" spec188_0)"
"(let-values(((or-part_0)"
" top-req_0))"
"(if or-part_0"
" or-part_0"
" req_0))"
" phase-shift_1"
" just-meta_0"
"(adjust-rename4.1"
" id:to189_0"
"(syntax-e$1"
" id:from190_0))"
" #f"
" #f"
" 'path))))"
"(let-values()"
"(let-values(((maybe-mp_0)"
"(syntax->datum$1"
" req_0)))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)"
"(1/module-path?"
" maybe-mp_0)))"
"(if or-part_0"
" or-part_0"
"(1/resolved-module-path?"
" maybe-mp_0)))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                               \"bad require spec\""
" orig-s_0"
" req_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)"
" adjust_0))"
"(if or-part_0"
" or-part_0"
"(not"
"(eq?"
" just-meta_0"
" 'all))))"
"(let-values()"
"(set-requires+provides-all-bindings-simple?!"
" requires+provides_0"
" #f))"
"(void))"
"(values))))"
"(let-values(((mp_0)"
"(if(1/resolved-module-path?"
" maybe-mp_0)"
"(resolved-module-path->module-path"
" maybe-mp_0)"
" maybe-mp_0)))"
"(let-values(((mpi_0)"
"(let-values(((mp218_0)"
" mp_0)"
"((self219_0)"
" self_0)"
"((declared-submodule-names220_0)"
" declared-submodule-names_0))"
"(module-path->mpi5.1"
" declared-submodule-names220_0"
" mp218_0"
" self219_0))))"
"(begin"
"(let-values(((mpi201_0)"
" mpi_0)"
"((req202_0)"
" req_0)"
"((self203_0)"
" self_0)"
"((temp204_0)"
"(let-values(((or-part_0)"
" req_0))"
"(if or-part_0"
" or-part_0"
" top-req_0)))"
"((m-ns205_0)"
" m-ns_0)"
"((phase-shift206_0)"
" phase-shift_1)"
"((run-phase207_0)"
" run-phase_0)"
"((just-meta208_0)"
" just-meta_0)"
"((adjust209_0)"
" adjust_0)"
"((requires+provides210_0)"
" requires+provides_0)"
"((run?211_0)"
" run?_0)"
"((visit?212_0)"
" visit?_0)"
"((copy-variable-phase-level213_0)"
" copy-variable-phase-level_0)"
"((copy-variable-as-constant?214_0)"
" copy-variable-as-constant?_0)"
"((skip-variable-phase-level215_0)"
" skip-variable-phase-level_0)"
"((initial-require?216_0)"
" initial-require?_0)"
"((who217_0)"
" who_0))"
"(perform-require!78.1"
" adjust209_0"
" #t"
" #f"
" copy-variable-as-constant?214_0"
" copy-variable-phase-level213_0"
" initial-require?216_0"
" just-meta208_0"
" phase-shift206_0"
" requires+provides210_0"
" run-phase207_0"
" run?211_0"
" skip-variable-phase-level215_0"
" visit?212_0"
" who217_0"
" mpi201_0"
" req202_0"
" self203_0"
" temp204_0"
" m-ns205_0))"
"(set! initial-require?_0"
" #f)))))))))))))))))))))))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
"(not result_1))"
" req_0))"
"(not #f)"
" #f)"
"(for-loop_0"
" result_1"
" rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))))))"
" loop_0)"
" reqs_0"
" #f"
" phase-shift_0"
" 'all"
" #f"
" #t"
" #t"
" 'raw))))))))))))))))))))"
"(define-values"
"(ids->sym-set)"
"(lambda(ids_0)"
"(begin"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()(syntax-e$1 id_0))"
" #t))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1 rest_0) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
" lst_0))))))"
"(define-values"
"(perform-initial-require!42.1)"
"(lambda(bind?33_0 who34_0 mod-path37_0 self38_0 in-stx39_0 m-ns40_0 requires+provides41_0)"
"(begin"
" 'perform-initial-require!42"
"(let-values(((mod-path_0) mod-path37_0))"
"(let-values(((self_0) self38_0))"
"(let-values(((in-stx_0) in-stx39_0))"
"(let-values(((m-ns_0) m-ns40_0))"
"(let-values(((requires+provides_0) requires+provides41_0))"
"(let-values(((bind?_0) bind?33_0))"
"(let-values(((who_0) who34_0))"
"(let-values()"
"(let-values(((temp221_0)"
"(let-values(((mod-path233_0) mod-path_0)((self234_0) self_0))"
"(module-path->mpi5.1 unsafe-undefined mod-path233_0 self234_0)))"
"((temp222_0) #f)"
"((self223_0) self_0)"
"((in-stx224_0) in-stx_0)"
"((m-ns225_0) m-ns_0)"
"((temp226_0) 0)"
"((temp227_0) 0)"
"((requires+provides228_0) requires+provides_0)"
"((temp229_0) #t)"
"((temp230_0) #t)"
"((bind?231_0) bind?_0)"
"((who232_0) who_0))"
"(perform-require!78.1"
" #f"
" bind?231_0"
" temp229_0"
" #f"
" #f"
" temp230_0"
" 'all"
" temp226_0"
" requires+provides228_0"
" temp227_0"
" #f"
" #f"
" #t"
" who232_0"
" temp221_0"
" temp222_0"
" self223_0"
" in-stx224_0"
" m-ns225_0)))))))))))))"
"(define-values"
"(perform-require!78.1)"
"(lambda(adjust48_0"
" bind?57_0"
" can-be-shadowed?52_0"
" copy-variable-as-constant?55_0"
" copy-variable-phase-level54_0"
" initial-require?53_0"
" just-meta47_0"
" phase-shift45_0"
" requires+provides49_0"
" run-phase46_0"
" run?51_0"
" skip-variable-phase-level56_0"
" visit?50_0"
" who58_0"
" mpi73_0"
" orig-s74_0"
" self75_0"
" in-stx76_0"
" m-ns77_0)"
"(begin"
" 'perform-require!78"
"(let-values(((mpi_0) mpi73_0))"
"(let-values(((orig-s_0) orig-s74_0))"
"(let-values()"
"(let-values(((in-stx_0) in-stx76_0))"
"(let-values(((m-ns_0) m-ns77_0))"
"(let-values(((phase-shift_0) phase-shift45_0))"
"(let-values(((run-phase_0) run-phase46_0))"
"(let-values(((just-meta_0) just-meta47_0))"
"(let-values(((adjust_0) adjust48_0))"
"(let-values(((requires+provides_0) requires+provides49_0))"
"(let-values(((visit?_0) visit?50_0))"
"(let-values(((run?_0) run?51_0))"
"(let-values(((can-be-shadowed?_0) can-be-shadowed?52_0))"
"(let-values(((initial-require?_0) initial-require?53_0))"
"(let-values(((copy-variable-phase-level_0) copy-variable-phase-level54_0))"
"(let-values(((copy-variable-as-constant?_0) copy-variable-as-constant?55_0))"
"(let-values(((skip-variable-phase-level_0) skip-variable-phase-level56_0))"
"(let-values(((bind?_0) bind?57_0))"
"(let-values(((who_0) who58_0))"
"(let-values()"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'expand 'require))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((module-name_0)"
"(1/module-path-index-resolve mpi_0 #t)))"
"(let-values(((bind-in-stx_0)"
"(if(adjust-rename? adjust_0)"
"(adjust-rename-to-id adjust_0)"
" in-stx_0)))"
"(let-values(((done-syms_0)(if adjust_0(make-hash) #f)))"
"(let-values(((m_0)(namespace->module m-ns_0 module-name_0)))"
"(let-values((()"
"(begin"
"(if m_0"
"(void)"
"(let-values()"
"(raise-unknown-module-error"
" 'require"
" module-name_0)))"
"(values))))"
"(let-values(((interned-mpi_0)"
"(if requires+provides_0"
"(add-required-module!"
" requires+provides_0"
" mpi_0"
" phase-shift_0"
"(module-cross-phase-persistent? m_0))"
" mpi_0)))"
"(let-values((()"
"(begin"
"(if visit?_0"
"(let-values()"
"(let-values(((m-ns251_0) m-ns_0)"
"((interned-mpi252_0)"
" interned-mpi_0)"
"((phase-shift253_0)"
" phase-shift_0)"
"((run-phase254_0)"
" run-phase_0))"
"(namespace-module-visit!104.1"
" run-phase254_0"
" m-ns251_0"
" interned-mpi252_0"
" phase-shift253_0)))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if run?_0"
"(let-values()"
"(let-values(((m-ns255_0) m-ns_0)"
"((interned-mpi256_0)"
" interned-mpi_0)"
"((phase-shift257_0)"
" phase-shift_0)"
"((run-phase258_0)"
" run-phase_0))"
"(namespace-module-instantiate!96.1"
" #t"
" run-phase258_0"
" unsafe-undefined"
" #f"
" m-ns255_0"
" interned-mpi256_0"
" phase-shift257_0)))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if(not"
"(let-values(((or-part_0)"
" visit?_0))"
"(if or-part_0"
" or-part_0"
" run?_0)))"
"(let-values()"
"(let-values(((m-ns259_0)"
" m-ns_0)"
"((interned-mpi260_0)"
" interned-mpi_0)"
"((phase-shift261_0)"
" phase-shift_0)"
"((run-phase262_0)"
" run-phase_0))"
"(namespace-module-make-available!112.1"
" run-phase262_0"
" m-ns259_0"
" interned-mpi260_0"
" phase-shift261_0)))"
"(void))"
"(values))))"
"(let-values(((can-bulk-bind?_0)"
"(if(let-values(((or-part_0)"
"(not adjust_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(adjust-prefix?"
" adjust_0)))"
"(if or-part_1"
" or-part_1"
"(adjust-all-except?"
" adjust_0)))))"
"(not skip-variable-phase-level_0)"
" #f)))"
"(let-values(((bulk-prefix_0)"
"(if(adjust-prefix? adjust_0)"
"(let-values()"
"(adjust-prefix-sym adjust_0))"
"(if(adjust-all-except?"
" adjust_0)"
"(let-values()"
"(adjust-all-except-prefix-sym"
" adjust_0))"
"(let-values() #f)))))"
"(let-values(((bulk-excepts_0)"
"(if(adjust-all-except?"
" adjust_0)"
"(let-values()"
"(adjust-all-except-syms"
" adjust_0))"
"(let-values() '#hasheq()))))"
"(let-values(((update-nominals-box_0)"
"(if can-bulk-bind?_0"
"(box null)"
" #f)))"
"(let-values((()"
"(begin"
"(let-values(((m235_0)"
" m_0)"
"((bind-in-stx236_0)"
" bind-in-stx_0)"
"((phase-shift237_0)"
" phase-shift_0)"
"((m-ns238_0)"
" m-ns_0)"
"((interned-mpi239_0)"
" interned-mpi_0)"
"((module-name240_0)"
" module-name_0)"
"((orig-s241_0)"
" orig-s_0)"
"((temp242_0)"
"(if requires+provides_0"
"(requires+provides-self"
" requires+provides_0)"
" #f))"
"((temp243_0)"
"(if(adjust-only?"
" adjust_0)"
"(let-values()"
"(set->list"
"(adjust-only-syms"
" adjust_0)))"
"(if(adjust-rename?"
" adjust_0)"
"(let-values()"
"(list"
"(adjust-rename-from-sym"
" adjust_0)))"
"(let-values()"
" #f))))"
"((just-meta244_0)"
" just-meta_0)"
"((bind?245_0)"
" bind?_0)"
"((can-bulk-bind?246_0)"
" can-bulk-bind?_0)"
"((bulk-prefix247_0)"
" bulk-prefix_0)"
"((bulk-excepts248_0)"
" bulk-excepts_0)"
"((temp249_0)"
"(if requires+provides_0"
"(if can-bulk-bind?_0"
"(lambda(provides_0"
" provide-phase-level_0)"
"(begin"
" 'temp249"
"(let-values(((requires+provides263_0)"
" requires+provides_0)"
"((bind-in-stx264_0)"
" bind-in-stx_0)"
"((temp265_0)"
"(module-self"
" m_0))"
"((mpi266_0)"
" mpi_0)"
"((phase-shift267_0)"
" phase-shift_0)"
"((provides268_0)"
" provides_0)"
"((provide-phase-level269_0)"
" provide-phase-level_0)"
"((bulk-prefix270_0)"
" bulk-prefix_0)"
"((bulk-excepts271_0)"
" bulk-excepts_0)"
"((temp272_0)"
"(if(positive?"
"(hash-count"
" bulk-excepts_0))"
" done-syms_0"
" #f))"
"((can-be-shadowed?273_0)"
" can-be-shadowed?_0)"
"((temp274_0)"
"(not"
" initial-require?_0))"
"((orig-s275_0)"
" orig-s_0)"
"((update-nominals-box276_0)"
" update-nominals-box_0)"
"((who277_0)"
" who_0))"
"(add-bulk-required-ids!59.1"
" update-nominals-box276_0"
" can-be-shadowed?273_0"
" temp274_0"
" bulk-excepts271_0"
" orig-s275_0"
" bulk-prefix270_0"
" temp272_0"
" who277_0"
" requires+provides263_0"
" bind-in-stx264_0"
" temp265_0"
" mpi266_0"
" phase-shift267_0"
" provides268_0"
" provide-phase-level269_0))))"
" #f)"
" #f))"
"((temp250_0)"
"(if(let-values(((or-part_0)"
"(not"
" can-bulk-bind?_0)))"
"(if or-part_0"
" or-part_0"
" copy-variable-phase-level_0))"
"(lambda(binding_0"
" as-transformer?_0)"
"(begin"
" 'temp250"
"(let-values(((sym_0)"
"(module-binding-nominal-sym"
" binding_0)))"
"(let-values(((provide-phase_0)"
"(module-binding-nominal-phase"
" binding_0)))"
"(let-values(((adjusted-sym_0)"
"(if(not"
"(symbol-interned?"
" sym_0))"
"(let-values()"
" #f)"
"(if(if skip-variable-phase-level_0"
"(if(not"
" as-transformer?_0)"
"(equal?"
" provide-phase_0"
" skip-variable-phase-level_0)"
" #f)"
" #f)"
"(let-values()"
" #f)"
"(if(not"
" adjust_0)"
"(let-values()"
" sym_0)"
"(if(adjust-only?"
" adjust_0)"
"(let-values()"
"(if(set-member?"
"(adjust-only-syms"
" adjust_0)"
" sym_0)"
"(if(hash-set!"
" done-syms_0"
" sym_0"
" #t)"
" sym_0"
" #f)"
" #f))"
"(if(adjust-prefix?"
" adjust_0)"
"(let-values()"
"(string->symbol"
"(string-append"
"(symbol->string"
"(adjust-prefix-sym"
" adjust_0))"
"(symbol->string"
" sym_0))))"
"(if(adjust-all-except?"
" adjust_0)"
"(let-values()"
"(if(not"
"(if(set-member?"
"(adjust-all-except-syms"
" adjust_0)"
" sym_0)"
"(hash-set!"
" done-syms_0"
" sym_0"
" #t)"
" #f))"
"(string->symbol"
"(string-append"
"(symbol->string"
"(adjust-all-except-prefix-sym"
" adjust_0))"
"(symbol->string"
" sym_0)))"
" #f))"
"(if(adjust-rename?"
" adjust_0)"
"(let-values()"
"(if(eq?"
" sym_0"
"(adjust-rename-from-sym"
" adjust_0))"
"(if(hash-set!"
" done-syms_0"
" sym_0"
" #t)"
"(adjust-rename-to-id"
" adjust_0)"
" #f)"
" #f))"
"(void))))))))))"
"(let-values(((skip-bind?_0)"
"(if(if adjusted-sym_0"
" requires+provides_0"
" #f)"
"(let-values()"
"(let-values(((s_0)"
"(datum->syntax$1"
" bind-in-stx_0"
" adjusted-sym_0)))"
"(let-values(((bind-phase_0)"
"(phase+"
" phase-shift_0"
" provide-phase_0)))"
"(let-values(((skip-bind?_0)"
"(if initial-require?_0"
"(let-values()"
" #f)"
"(let-values()"
"(let-values(((temp278_0)"
" #t)"
"((temp279_0)"
" #t)"
"((requires+provides280_0)"
" requires+provides_0)"
"((s281_0)"
" s_0)"
"((bind-phase282_0)"
" bind-phase_0)"
"((binding283_0)"
" binding_0)"
"((orig-s284_0)"
" orig-s_0)"
"((temp285_0)"
" #t)"
"((who286_0)"
" who_0))"
"(check-not-defined95.1"
" #f"
" temp279_0"
" temp278_0"
" orig-s284_0"
" temp285_0"
" binding283_0"
" who286_0"
" requires+provides280_0"
" s281_0"
" bind-phase282_0))))))"
"(begin"
"(if skip-bind?_0"
"(void)"
"(let-values()"
"(let-values(((requires+provides287_0)"
" requires+provides_0)"
"((s288_0)"
" s_0)"
"((bind-phase289_0)"
" bind-phase_0)"
"((binding290_0)"
" binding_0)"
"((can-be-shadowed?291_0)"
" can-be-shadowed?_0)"
"((as-transformer?292_0)"
" as-transformer?_0))"
"(add-defined-or-required-id!19.1"
" as-transformer?292_0"
" can-be-shadowed?291_0"
" requires+provides287_0"
" s288_0"
" bind-phase289_0"
" binding290_0))))"
" skip-bind?_0)))))"
"(let-values()"
" #f))))"
"(begin"
"(if(if copy-variable-phase-level_0"
"(if(not"
" as-transformer?_0)"
"(equal?"
" provide-phase_0"
" copy-variable-phase-level_0)"
" #f)"
" #f)"
"(let-values()"
"(copy-namespace-value"
" m-ns_0"
" sym_0"
" binding_0"
" copy-variable-phase-level_0"
" phase-shift_0"
" copy-variable-as-constant?_0))"
"(void))"
"(if(not"
" skip-bind?_0)"
" adjusted-sym_0"
" #f))))))))"
" #f)))"
"(bind-all-provides!107.1"
" bind?245_0"
" temp249_0"
" bulk-excepts248_0"
" bulk-prefix247_0"
" can-bulk-bind?246_0"
" temp242_0"
" temp250_0"
" orig-s241_0"
" just-meta244_0"
" temp243_0"
" m235_0"
" bind-in-stx236_0"
" phase-shift237_0"
" m-ns238_0"
" interned-mpi239_0"
" module-name240_0))"
"(values))))"
"(let-values((()"
"(begin"
"(if update-nominals-box_0"
"(let-values()"
"(begin"
"(let-values(((lst_0)"
"(unbox"
" update-nominals-box_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((update!_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(update!_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))"
"(void))"
"(values))))"
"(let-values(((need-syms_0)"
"(if(adjust-only?"
" adjust_0)"
"(let-values()"
"(adjust-only-syms"
" adjust_0))"
"(if(adjust-all-except?"
" adjust_0)"
"(let-values()"
"(adjust-all-except-syms"
" adjust_0))"
"(if(adjust-rename?"
" adjust_0)"
"(let-values()"
"(set"
"(adjust-rename-from-sym"
" adjust_0)))"
"(let-values()"
" #f))))))"
"(if(if need-syms_0"
"(not"
"(="
"(set-count need-syms_0)"
"(hash-count done-syms_0)))"
" #f)"
"(let-values()"
"(begin"
"(let-values(((ht_0)"
" need-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-immutable-hash-keys"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(hash-ref"
" done-syms_0"
" sym_0"
" #f)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" who_0"
"                                                                                                                                                                 \"not in nested spec\""
" orig-s_0"
" sym_0))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(unsafe-immutable-hash-iterate-first"
" ht_0))))"
"(void)))"
"(void)))))))))))))))))))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void)))))))))))))))))))))))))))"
"(define-values"
"(bind-all-provides!107.1)"
"(lambda(bind?85_0"
" bulk-callback90_0"
" bulk-excepts88_0"
" bulk-prefix87_0"
" can-bulk?86_0"
" defines-mpi82_0"
" filter89_0"
" in81_0"
" just-meta84_0"
" only83_0"
" m101_0"
" in-stx102_0"
" phase-shift103_0"
" ns104_0"
" mpi105_0"
" module-name106_0)"
"(begin"
" 'bind-all-provides!107"
"(let-values(((m_0) m101_0))"
"(let-values(((in-stx_0) in-stx102_0))"
"(let-values(((phase-shift_0) phase-shift103_0))"
"(let-values(((ns_0) ns104_0))"
"(let-values(((mpi_0) mpi105_0))"
"(let-values(((module-name_0) module-name106_0))"
"(let-values(((orig-s_0) in81_0))"
"(let-values(((defines-mpi_0) defines-mpi82_0))"
"(let-values(((only-syms_0) only83_0))"
"(let-values(((just-meta_0) just-meta84_0))"
"(let-values(((bind?_0) bind?85_0))"
"(let-values(((can-bulk?_0) can-bulk?86_0))"
"(let-values(((bulk-prefix_0) bulk-prefix87_0))"
"(let-values(((bulk-excepts_0) bulk-excepts88_0))"
"(let-values(((filter_0) filter89_0))"
"(let-values(((bulk-callback_0) bulk-callback90_0))"
"(let-values()"
"(let-values(((self_0)(module-self m_0)))"
"(begin"
"(let-values(((ht_0)(module-provides m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((provide-phase-level_0 provides_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values()"
"(if(let-values(((or-part_0)"
"(eq?"
" just-meta_0"
" 'all)))"
"(if or-part_0"
" or-part_0"
"(eqv?"
" just-meta_0"
" provide-phase-level_0)))"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((phase_0)"
"(phase+"
" phase-shift_0"
" provide-phase-level_0)))"
"(let-values(((need-except?_0)"
"(if bulk-callback_0"
"(bulk-callback_0"
" provides_0"
" provide-phase-level_0)"
" #f)))"
"(if bind?_0"
"(let-values()"
"(begin"
"(if filter_0"
"(let-values()"
"(begin"
"(let-values(((lst_0)"
"(let-values(((or-part_0)"
" only-syms_0))"
"(if or-part_0"
" or-part_0"
"(hash-keys"
" provides_0)))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((binding/p_0)"
"(hash-ref"
" provides_0"
" sym_0"
" #f)))"
"(if binding/p_0"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((binding/p293_0)"
" binding/p_0)"
"((sym294_0)"
" sym_0)"
"((self295_0)"
" self_0)"
"((mpi296_0)"
" mpi_0)"
"((provide-phase-level297_0)"
" provide-phase-level_0)"
"((phase-shift298_0)"
" phase-shift_0))"
"(provide-binding-to-require-binding11.1"
" mpi296_0"
" phase-shift298_0"
" provide-phase-level297_0"
" self295_0"
" binding/p293_0"
" sym294_0))))"
"(let-values(((sym_1)"
"(filter_0"
" b_0"
"(provided-as-transformer?"
" binding/p_0))))"
"(if(if sym_1"
"(not"
" can-bulk?_0)"
" #f)"
"(let-values()"
"(let-values(((temp299_0)"
"(datum->syntax$1"
" in-stx_0"
" sym_1))"
"((b300_0)"
" b_0)"
"((phase301_0)"
" phase_0))"
"(add-binding!17.1"
" #f"
" #f"
" temp299_0"
" b300_0"
" phase301_0)))"
"(void)))))"
"(void))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_0)))"
"(void)))"
"(void))"
"(if can-bulk?_0"
"(let-values()"
"(let-values(((bulk-binding-registry_0)"
"(namespace-bulk-binding-registry"
" ns_0)))"
"(let-values(((in-stx302_0)"
" in-stx_0)"
"((temp303_0)"
"(bulk-binding14.1"
"(let-values(((or-part_0)"
"(if(not"
" bulk-prefix_0)"
"(if(zero?"
"(hash-count"
" bulk-excepts_0))"
" provides_0"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(if(not"
"(registered-bulk-provide?"
" bulk-binding-registry_0"
" module-name_0))"
"(bulk-provides-add-prefix-remove-exceptions"
" provides_0"
" bulk-prefix_0"
" bulk-excepts_0)"
" #f)))"
" bulk-prefix_0"
" bulk-excepts_0"
" self_0"
" mpi_0"
" provide-phase-level_0"
" phase-shift_0"
" bulk-binding-registry_0))"
"((phase304_0)"
" phase_0)"
"((orig-s305_0)"
" orig-s_0)"
"((temp306_0)"
"(if need-except?_0"
" defines-mpi_0"
" #f)))"
"(add-bulk-binding!27.1"
" orig-s305_0"
" temp306_0"
" in-stx302_0"
" temp303_0"
" phase304_0))))"
"(void))))"
"(void)))))"
"(values)))))"
"(values)))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(void)))))))))))))))))))))))"
"(define-values"
"(require-spec-shift-for-syntax)"
"(lambda(req_0)"
"(begin"
"(let-values(((rebuild-req_0)"
"(lambda(req_1 new-req_0)(begin 'rebuild-req(datum->syntax$1 req_1 new-req_0 req_1 req_1)))))"
"(letrec-values(((loop_0)"
"(lambda(shifted?_0)"
"(begin"
" 'loop"
"(lambda(req_1)"
"(let-values(((fm_0)"
"(if(pair?(syntax-e$1 req_1))"
"(if(identifier?(car(syntax-e$1 req_1)))"
"(syntax-e$1(car(syntax-e$1 req_1)))"
" #f)"
" #f)))"
"(let-values(((tmp_0) fm_0))"
"(if(equal? tmp_0 'for-meta)"
"(let-values()"
"(let-values(((ok?_0 for-meta307_0 phase-level308_0 spec309_0)"
"(let-values(((s_0) req_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((for-meta307_0 phase-level308_0 spec309_0)"
"(let-values(((s_1)"
"(if(syntax?$1 s_0)"
"(syntax-e$1 s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((for-meta310_0)"
"(let-values(((s_2)(car s_1)))"
" s_2))"
"((phase-level311_0 spec312_0)"
"(let-values(((s_2)(cdr s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair? s_3)"
"(let-values(((phase-level313_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec314_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                        \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" phase-level313_0"
" spec314_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                \"bad syntax\""
" orig-s_0))))))"
"(values"
" for-meta310_0"
" phase-level311_0"
" spec312_0))"
"(raise-syntax-error$1"
" #f"
"                                                                            \"bad syntax\""
" orig-s_0)))))"
"(values #t for-meta307_0 phase-level308_0 spec309_0))))))"
"(let-values(((p_0)(syntax-e$1 phase-level308_0)))"
"(begin"
"(if(phase? p_0)"
"(void)"
"                                               (let-values () (raise-syntax-error$1 #f \"bad phase\" req_1)))"
"(rebuild-req_0"
" req_1"
"(list* for-meta307_0(phase+ p_0 1)(map2(loop_0 #t) spec309_0)))))))"
"(if(equal? tmp_0 'for-syntax)"
"(let-values()"
"(let-values(((ok?_0 for-syntax315_0 spec316_0)"
"(let-values(((s_0) req_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((for-syntax315_0 spec316_0)"
"(let-values(((s_1)"
"(if(syntax?$1 s_0)"
"(syntax-e$1 s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((for-syntax317_0)"
"(let-values(((s_2)"
"(car s_1)))"
" s_2))"
"((spec318_0)"
"(let-values(((s_2)"
"(cdr s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                      \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values for-syntax317_0 spec318_0))"
"(raise-syntax-error$1"
" #f"
"                                                                              \"bad syntax\""
" orig-s_0)))))"
"(values #t for-syntax315_0 spec316_0))))))"
"(rebuild-req_0 req_1(list* 'for-meta 2(map2(loop_0 #t) spec316_0)))))"
"(if(equal? tmp_0 'for-template)"
"(let-values()"
"(let-values(((ok?_0 for-template319_0 spec320_0)"
"(let-values(((s_0) req_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((for-template319_0 spec320_0)"
"(let-values(((s_1)"
"(if(syntax?$1 s_0)"
"(syntax-e$1 s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((for-template321_0)"
"(let-values(((s_2)"
"(car s_1)))"
" s_2))"
"((spec322_0)"
"(let-values(((s_2)"
"(cdr s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                        \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values for-template321_0 spec322_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                \"bad syntax\""
" orig-s_0)))))"
"(values #t for-template319_0 spec320_0))))))"
"(rebuild-req_0 req_1(list* 'for-meta 0(map2(loop_0 #t) spec320_0)))))"
"(if(equal? tmp_0 'for-label)"
"(let-values()"
"(let-values(((ok?_0 for-label323_0 spec324_0)"
"(let-values(((s_0) req_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((for-label323_0 spec324_0)"
"(let-values(((s_1)"
"(if(syntax?$1 s_0)"
"(syntax-e$1 s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((for-label325_0)"
"(let-values(((s_2)"
"(car s_1)))"
" s_2))"
"((spec326_0)"
"(let-values(((s_2)"
"(cdr s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                          \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values for-label325_0 spec326_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                  \"bad syntax\""
" orig-s_0)))))"
"(values #t for-label323_0 spec324_0))))))"
"(rebuild-req_0"
" req_1"
"(list* for-label323_0(map2(loop_0 #t) spec324_0)))))"
"(if(equal? tmp_0 'just-meta)"
"(let-values()"
"(let-values(((ok?_0 just-meta327_0 phase-level328_0 spec329_0)"
"(let-values(((s_0) req_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((just-meta327_0"
" phase-level328_0"
" spec329_0)"
"(let-values(((s_1)"
"(if(syntax?$1 s_0)"
"(syntax-e$1 s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((just-meta330_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((phase-level331_0"
" spec332_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair? s_3)"
"(let-values(((phase-level333_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec334_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" phase-level333_0"
" spec334_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                        \"bad syntax\""
" orig-s_0))))))"
"(values"
" just-meta330_0"
" phase-level331_0"
" spec332_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                    \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" just-meta327_0"
" phase-level328_0"
" spec329_0))))))"
"(rebuild-req_0"
" req_1"
"(list*"
" just-meta327_0"
" phase-level328_0"
"(map2(loop_0 #f) spec329_0)))))"
"(let-values()"
"(if shifted?_0"
" req_1"
"(datum->syntax$1 #f(list 'for-syntax req_1))))))))))))))))"
"((loop_0 #f) req_0))))))"
"(define-values"
"(copy-namespace-value)"
"(lambda(m-ns_0 adjusted-sym_0 binding_0 phase-level_0 phase-shift_0 as-constant?_0)"
"(begin"
"(let-values(((i-ns_0)"
"(let-values(((m-ns335_0) m-ns_0)"
"((temp336_0)(1/module-path-index-resolve(module-binding-module binding_0)))"
"((temp337_0)(phase-(module-binding-phase binding_0) phase-level_0))"
"((temp338_0) #t))"
"(namespace->module-namespace82.1 #f temp338_0 unsafe-undefined m-ns335_0 temp336_0 temp337_0))))"
"(let-values(((val_0)"
"(namespace-get-variable"
" i-ns_0"
"(module-binding-phase binding_0)"
"(module-binding-sym binding_0)"
"(lambda()"
"(error"
" 'namespace-require/copy"
"(format"
"(string-append"
"                            \"namespace mismatch;\\n\""
"                            \" variable not found\\n\""
"                            \"  module: ~a\\n\""
"                            \"  variable name: ~s\\n\""
"                            \"  phase level: ~s\")"
"(module-binding-module binding_0)"
"(module-binding-sym binding_0)"
"(module-binding-phase binding_0)))))))"
"(namespace-set-variable! m-ns_0(phase+ phase-shift_0 phase-level_0) adjusted-sym_0 val_0 as-constant?_0))))))"
"(define-values"
"(top-level-instance)"
"(1/make-instance"
" 'top-level"
" #f"
" 'constant"
" top-level-bind!-id"
"(lambda(id_0 mpi_0 orig-phase_0 phase-shift_0 ns_0 sym_0 trans?_0 trans-val_0)"
"(let-values(((phase_0)(phase+ orig-phase_0 phase-shift_0)))"
"(let-values(((b_0)"
"(let-values(((mpi4_0) mpi_0)"
"((phase5_0) phase_0)"
"((sym6_0) sym_0)"
"((temp7_0)(root-expand-context-frame-id(namespace-get-root-expand-ctx ns_0))))"
"(make-module-binding20.1"
" #f"
" null"
" temp7_0"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" mpi4_0"
" phase5_0"
" sym6_0))))"
"(begin"
"(let-values(((id1_0) id_0)((b2_0) b_0)((phase3_0) phase_0))(add-binding!17.1 #f #f id1_0 b2_0 phase3_0))"
"(if trans?_0"
"(let-values()(if trans-val_0(let-values()(maybe-install-free=id! trans-val_0 id_0 phase_0))(void)))"
"(let-values()(namespace-unset-transformer! ns_0 phase_0 sym_0)))))))"
" top-level-require!-id"
"(lambda(stx_0 ns_0)"
"(let-values(((reqs_0)(cdr(syntax->list$1 stx_0))))"
"(let-values(((temp8_0) #t)"
"((temp9_0) #f)"
"((reqs10_0) reqs_0)"
"((temp11_0) #f)"
"((ns12_0) ns_0)"
"((temp13_0)(namespace-phase ns_0))"
"((temp14_0)(let-values(((temp17_0) #f))(make-requires+provides8.1 #f temp17_0)))"
"((temp15_0) 'require)"
"((temp16_0) #t))"
"(parse-and-perform-requires!30.1"
" #f"
" #f"
" unsafe-undefined"
" temp16_0"
" unsafe-undefined"
" temp8_0"
" #f"
" #f"
" temp9_0"
" temp15_0"
" reqs10_0"
" temp11_0"
" ns12_0"
" temp13_0"
" temp14_0))))))"
"(define-values"
"(struct:compiled-in-memory"
" compiled-in-memory1.1"
" compiled-in-memory?"
" compiled-in-memory-linklet-directory"
" compiled-in-memory-original-self"
" compiled-in-memory-requires"
" compiled-in-memory-provides"
" compiled-in-memory-phase-to-link-module-uses"
" compiled-in-memory-compile-time-inspector"
" compiled-in-memory-phase-to-link-extra-inspectorsss"
" compiled-in-memory-mpis"
" compiled-in-memory-syntax-literals"
" compiled-in-memory-pre-compiled-in-memorys"
" compiled-in-memory-post-compiled-in-memorys"
" compiled-in-memory-namespace-scopes"
" compiled-in-memory-purely-functional?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'compiled-in-memory"
" #f"
" 13"
" 0"
" #f"
"(list"
"(cons"
" prop:custom-write"
"(lambda(cim_0 port_0 mode_0)(write(compiled-in-memory-linklet-directory cim_0) port_0))))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10 11 12)"
" #f"
" 'compiled-in-memory)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'linklet-directory)"
"(make-struct-field-accessor -ref_0 1 'original-self)"
"(make-struct-field-accessor -ref_0 2 'requires)"
"(make-struct-field-accessor -ref_0 3 'provides)"
"(make-struct-field-accessor -ref_0 4 'phase-to-link-module-uses)"
"(make-struct-field-accessor -ref_0 5 'compile-time-inspector)"
"(make-struct-field-accessor -ref_0 6 'phase-to-link-extra-inspectorsss)"
"(make-struct-field-accessor -ref_0 7 'mpis)"
"(make-struct-field-accessor -ref_0 8 'syntax-literals)"
"(make-struct-field-accessor -ref_0 9 'pre-compiled-in-memorys)"
"(make-struct-field-accessor -ref_0 10 'post-compiled-in-memorys)"
"(make-struct-field-accessor -ref_0 11 'namespace-scopes)"
"(make-struct-field-accessor -ref_0 12 'purely-functional?))))"
"(define-values(version-bytes$1)(string->bytes/utf-8(version)))"
"(define-values(vm-bytes$1)(1/linklet-virtual-machine-bytes))"
"(define-values(datum->syntax$3) datum->syntax)"
"(define-values(syntax-property$2) syntax-property)"
"(define-values(syntax-span$2) syntax-span)"
"(define-values(syntax-position$2) syntax-position)"
"(define-values(syntax-column$2) syntax-column)"
"(define-values(syntax-line$2) syntax-line)"
"(define-values(syntax-source$2) syntax-source)"
"(define-values(syntax-e$2) syntax-e)"
"(define-values(1/syntax?) syntax?)"
"(define-values(correlated?)(lambda(e_0)(begin(1/syntax? e_0))))"
"(define-values"
"(datum->correlated)"
"(let-values(((datum->correlated3_0)"
"(lambda(d2_0 srcloc1_0)"
"(begin"
" 'datum->correlated3"
"(let-values(((d_0) d2_0))"
"(let-values(((srcloc_0) srcloc1_0))(let-values()(datum->syntax$3 #f d_0 srcloc_0))))))))"
"(case-lambda((d_0)(begin(datum->correlated3_0 d_0 #f)))((d_0 srcloc1_0)(datum->correlated3_0 d_0 srcloc1_0)))))"
"(define-values(correlated-e)(lambda(e_0)(begin(if(1/syntax? e_0)(syntax-e$2 e_0) e_0))))"
"(define-values(correlated-cadr)(lambda(e_0)(begin(car(correlated-e(cdr(correlated-e e_0)))))))"
"(define-values"
"(correlated-length)"
"(lambda(e_0)(begin(let-values(((l_0)(correlated-e e_0)))(if(list? l_0)(length l_0) #f)))))"
"(define-values"
"(correlated->list)"
"(lambda(e_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(e_1)"
"(begin"
" 'loop"
"(if(list? e_1)"
"(let-values() e_1)"
"(if(pair? e_1)"
"(let-values()(cons(car e_1)(loop_0(cdr e_1))))"
"(if(null? e_1)"
"(let-values() null)"
"(if(1/syntax? e_1)"
"(let-values()(loop_0(syntax-e$2 e_1)))"
"                                    (let-values () (error 'correlated->list \"not a list\"))))))))))"
" loop_0)"
" e_0))))"
"(define-values"
"(correlated-property)"
"(case-lambda((e_0 k_0)(begin(syntax-property$2 e_0 k_0)))((e_0 k_0 v_0)(syntax-property$2 e_0 k_0 v_0))))"
"(define-values"
"(to-syntax-list.1$1)"
"(lambda(s_0)"
"(begin"
" 'to-syntax-list"
"(if(list? s_0)"
"(let-values() s_0)"
"(if(pair? s_0)"
"(let-values()(let-values(((r_0)(to-syntax-list.1$1(cdr s_0))))(if r_0(cons(car s_0) r_0) #f)))"
"(if(1/syntax? s_0)(let-values()(to-syntax-list.1$1(syntax-e$2 s_0)))(let-values() #f)))))))"
"(define-values(correlated-source)(lambda(s_0)(begin(syntax-source$2 s_0))))"
"(define-values(correlated-line)(lambda(s_0)(begin(syntax-line$2 s_0))))"
"(define-values(correlated-column)(lambda(s_0)(begin(syntax-column$2 s_0))))"
"(define-values(correlated-position)(lambda(s_0)(begin(syntax-position$2 s_0))))"
"(define-values(correlated-span)(lambda(s_0)(begin(syntax-span$2 s_0))))"
"(define-values"
"(struct:correlated-linklet"
" correlated-linklet1.1"
" correlated-linklet?"
" correlated-linklet-expr"
" correlated-linklet-name"
" correlated-linklet-compiled"
" set-correlated-linklet-compiled!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'correlated-linklet"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'correlated-linklet)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'expr)"
"(make-struct-field-accessor -ref_0 1 'name)"
"(make-struct-field-accessor -ref_0 2 'compiled)"
"(make-struct-field-mutator -set!_0 2 'compiled))))"
"(define-values(make-correlated-linklet)(lambda(expr_0 name_0)(begin(correlated-linklet1.1 expr_0 name_0 #f))))"
"(define-values"
"(force-compile-linklet)"
"(lambda(l_0)"
"(begin"
"(if(correlated-linklet? l_0)"
"(let-values()"
"(let-values(((or-part_0)(correlated-linklet-compiled l_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((c_0)(1/compile-linklet(correlated-linklet-expr l_0)(correlated-linklet-name l_0))))"
"(begin(set-correlated-linklet-compiled! l_0 c_0) c_0)))))"
"(let-values() l_0)))))"
" (define-values (correlated-linklet-vm-bytes) #\"linklet\")"
"(define-values"
"(struct:faslable-correlated"
" faslable-correlated2.1"
" faslable-correlated?"
" faslable-correlated-e"
" faslable-correlated-source"
" faslable-correlated-position"
" faslable-correlated-line"
" faslable-correlated-column"
" faslable-correlated-span"
" faslable-correlated-name)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'faslable-correlated"
" #f"
" 7"
" 0"
" #f"
" null"
" 'prefab"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'faslable-correlated)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'e)"
"(make-struct-field-accessor -ref_0 1 'source)"
"(make-struct-field-accessor -ref_0 2 'position)"
"(make-struct-field-accessor -ref_0 3 'line)"
"(make-struct-field-accessor -ref_0 4 'column)"
"(make-struct-field-accessor -ref_0 5 'span)"
"(make-struct-field-accessor -ref_0 6 'name))))"
"(define-values"
"(struct:faslable-correlated-linklet"
" faslable-correlated-linklet3.1"
" faslable-correlated-linklet?"
" faslable-correlated-linklet-expr"
" faslable-correlated-linklet-name)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'faslable-correlated-linklet"
" #f"
" 2"
" 0"
" #f"
" null"
" 'prefab"
" #f"
" '(0 1)"
" #f"
" 'faslable-correlated-linklet)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'expr)"
"(make-struct-field-accessor -ref_0 1 'name))))"
"(define-values"
"(write-correlated-linklet-bundle-hash)"
"(lambda(ht_0 o_0)"
"(begin(let-values(((temp7_0)(->faslable ht_0))((o8_0) o_0))(s-exp->fasl11.1 #f temp7_0 o8_0)))))"
"(define-values"
"(->faslable)"
"(lambda(v_0)"
"(begin"
"(if(pair? v_0)"
"(let-values()"
"(let-values(((a_0)(->faslable(car v_0))))"
"(let-values(((d_0)(->faslable(cdr v_0))))"
"(if(if(eq? a_0(car v_0))(eq? d_0(cdr v_0)) #f) v_0(cons a_0 d_0)))))"
"(if(correlated? v_0)"
"(let-values()"
"(faslable-correlated2.1"
"(->faslable(correlated-e v_0))"
"(correlated-source v_0)"
"(correlated-position v_0)"
"(correlated-line v_0)"
"(correlated-column v_0)"
"(correlated-span v_0)"
"(correlated-property v_0 'inferred-name)))"
"(if(hash? v_0)"
"(let-values()"
"(if(hash-eq? v_0)"
"(let-values()"
"(let-values(((ht_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((key_0 value_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_1 val_0)"
"(let-values()"
"(values"
"(->faslable key_0)"
"(->faslable"
" value_0)))))"
"(hash-set table_1 key_1 val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first ht_0)))))"
"(if(hash-eqv? v_0)"
"(let-values()"
"(let-values(((ht_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((key_0 value_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_1 val_0)"
"(let-values()"
"(values"
"(->faslable key_0)"
"(->faslable"
" value_0)))))"
"(hash-set table_1 key_1 val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
"(hash-iterate-first ht_0)))))"
"(let-values()"
"(let-values(((ht_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((key_0 value_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_1 val_0)"
"(let-values()"
"(values"
"(->faslable key_0)"
"(->faslable"
" value_0)))))"
"(hash-set table_1 key_1 val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first ht_0))))))))"
"(if(correlated-linklet? v_0)"
"(let-values()"
"(faslable-correlated-linklet3.1"
"(->faslable(correlated-linklet-expr v_0))"
"(->faslable(correlated-linklet-name v_0))))"
"(let-values() v_0))))))))"
"(define-values"
"(read-correlated-linklet-bundle-hash)"
"(lambda(in_0)(begin(faslable->(let-values(((in9_0) in_0))(fasl->s-exp17.1 #t in9_0))))))"
"(define-values"
"(faslable->)"
"(lambda(v_0)"
"(begin"
"(if(pair? v_0)"
"(let-values()"
"(let-values(((a_0)(faslable->(car v_0))))"
"(let-values(((d_0)(faslable->(cdr v_0))))"
"(if(if(eq? a_0(car v_0))(eq? d_0(cdr v_0)) #f) v_0(cons a_0 d_0)))))"
"(if(faslable-correlated? v_0)"
"(let-values()"
"(let-values(((name_0)(faslable-correlated-name v_0)))"
"(let-values(((c_0)"
"(datum->correlated"
"(faslable->(faslable-correlated-e v_0))"
"(vector"
"(faslable-correlated-source v_0)"
"(faslable-correlated-line v_0)"
"(faslable-correlated-column v_0)"
"(faslable-correlated-position v_0)"
"(faslable-correlated-span v_0)))))"
"(if name_0(correlated-property c_0 'inferred-name name_0) c_0))))"
"(if(hash? v_0)"
"(let-values()"
"(if(hash-eq? v_0)"
"(let-values()"
"(let-values(((ht_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((key_0 value_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_1 val_0)"
"(let-values()"
"(values"
"(faslable-> key_0)"
"(faslable->"
" value_0)))))"
"(hash-set table_1 key_1 val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first ht_0)))))"
"(if(hash-eqv? v_0)"
"(let-values()"
"(let-values(((ht_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((key_0 value_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_1 val_0)"
"(let-values()"
"(values"
"(faslable-> key_0)"
"(faslable->"
" value_0)))))"
"(hash-set table_1 key_1 val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheqv()"
"(hash-iterate-first ht_0)))))"
"(let-values()"
"(let-values(((ht_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((key_0 value_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_1 val_0)"
"(let-values()"
"(values"
"(faslable-> key_0)"
"(faslable->"
" value_0)))))"
"(hash-set table_1 key_1 val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first ht_0))))))))"
"(if(faslable-correlated-linklet? v_0)"
"(let-values()"
"(make-correlated-linklet"
"(faslable->(faslable-correlated-linklet-expr v_0))"
"(faslable->(faslable-correlated-linklet-name v_0))))"
"(let-values() v_0))))))))"
"(define-values"
"(write-linklet-bundle)"
"(lambda(b_0 as-correlated-linklet?_0 linklet-bundle->hash_0 port_0)"
"(begin"
"(begin"
"        (write-bytes #\"#~\" port_0)"
"(write-bytes(bytes(bytes-length version-bytes$1)) port_0)"
"(write-bytes version-bytes$1 port_0)"
"(let-values(((vm-bytes_0)(if as-correlated-linklet?_0 correlated-linklet-vm-bytes vm-bytes$1)))"
"(begin(write-bytes(bytes(bytes-length vm-bytes_0)) port_0)(write-bytes vm-bytes_0 port_0)))"
"        (write-bytes #\"B\" port_0)"
"(write-bytes(make-bytes 20 0) port_0)"
"(if as-correlated-linklet?_0"
"(write-correlated-linklet-bundle-hash(linklet-bundle->hash_0 b_0) port_0)"
"(1/write-linklet-bundle-hash(linklet-bundle->hash_0 b_0) port_0))))))"
"(define-values"
"(linklet-bundle->bytes)"
"(lambda(b_0 as-correlated-linklet?_0 linklet-bundle->hash_0)"
"(begin"
"(let-values(((o_0)(open-output-bytes)))"
"(begin"
"(write-linklet-bundle b_0 as-correlated-linklet?_0 linklet-bundle->hash_0 o_0)"
"(get-output-bytes o_0))))))"
"(define-values"
"(write-linklet-directory)"
"(lambda(ld_0 as-correlated-linklet?_0 linklet-directory->hash_0 linklet-bundle->hash_0 port_0)"
"(begin"
"(let-values(((vm-bytes_0)(if as-correlated-linklet?_0 correlated-linklet-vm-bytes vm-bytes$1)))"
"        (let-values ((() (begin (write-bytes #\"#~\" port_0) (values))))"
"(let-values((()(begin(write-byte(bytes-length version-bytes$1) port_0)(values))))"
"(let-values((()(begin(write-bytes version-bytes$1 port_0)(values))))"
"(let-values((()(begin(write-byte(bytes-length vm-bytes_0) port_0)(values))))"
"(let-values((()(begin(write-bytes vm-bytes_0 port_0)(values))))"
"                  (let-values ((() (begin (write-bytes #\"D\" port_0) (values))))"
"(letrec-values(((flatten-linklet-directory_0)"
"(lambda(ld_1 rev-name-prefix_0 accum_0)"
"(begin"
" 'flatten-linklet-directory"
"(let-values(((new-accum_0 saw-bundle?_0)"
"(let-values(((ht_0)(linklet-directory->hash_0 ld_1)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(accum_1 saw-bundle?_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((key_0 value_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((accum_2"
" saw-bundle?_1)"
"(let-values(((accum_2)"
" accum_1)"
"((saw-bundle?_1)"
" saw-bundle?_0))"
"(let-values(((accum_3"
" saw-bundle?_2)"
"(let-values()"
"(if(eq?"
" key_0"
" #f)"
"(let-values()"
"(values"
"(cons"
"(cons"
"(encode-name"
" rev-name-prefix_0)"
"(linklet-bundle->bytes"
" value_0"
" as-correlated-linklet?_0"
" linklet-bundle->hash_0))"
" accum_2)"
" #t))"
"(let-values()"
"(values"
"(flatten-linklet-directory_0"
" value_0"
"(cons"
" key_0"
" rev-name-prefix_0)"
" accum_2)"
" saw-bundle?_1))))))"
"(values"
" accum_3"
" saw-bundle?_2)))))"
"(if(not #f)"
"(for-loop_0"
" accum_2"
" saw-bundle?_1"
"(hash-iterate-next ht_0 i_0))"
"(values"
" accum_2"
" saw-bundle?_1))))"
"(values accum_1 saw-bundle?_0))))))"
" for-loop_0)"
" accum_0"
" #f"
"(hash-iterate-first ht_0))))))"
"(if saw-bundle?_0"
"(let-values() new-accum_0)"
"(let-values()"
"                                               (cons (cons (encode-name rev-name-prefix_0) #\"#f\") new-accum_0))))))))"
"(let-values(((bundles_0)"
"(list->vector"
"(let-values(((temp1_0)(flatten-linklet-directory_0 ld_0 '() '()))"
"((temp2_0)"
"(lambda(a_0 b_0)(begin 'temp2(bytes<?(car a_0)(car b_0))))))"
"(sort7.1 #f #f temp1_0 temp2_0)))))"
"(let-values(((len_0)(vector-length bundles_0)))"
"(let-values(((initial-offset_0)"
"(+ 2 1(bytes-length version-bytes$1) 1(bytes-length vm-bytes_0) 1 4)))"
"(let-values((()(begin(write-int len_0 port_0)(values))))"
"(let-values(((btree-size_0)(compute-btree-size bundles_0 len_0)))"
"(let-values(((node-offsets_0)"
"(compute-btree-node-offsets bundles_0 len_0 initial-offset_0)))"
"(let-values(((bundle-offsets_0)"
"(compute-bundle-offsets"
" bundles_0"
" len_0"
"(+ initial-offset_0 btree-size_0))))"
"(begin"
"(write-directory-btree bundles_0 node-offsets_0 bundle-offsets_0 len_0 port_0)"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((i_0) pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(write-bytes"
"(cdr"
"(vector-ref"
" bundles_0"
" i_0))"
" port_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(+ pos_0 inc_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" start_0)))"
"(void))))))))))))))))))))"
"(define-values"
"(encode-name)"
"(lambda(rev-name_0)"
"(begin"
"(let-values(((encode-symbol_0)"
"(lambda(s_0)"
"(begin"
" 'encode-symbol"
"(let-values(((bstr_0)(string->bytes/utf-8(symbol->string s_0))))"
"(let-values(((len_0)(bytes-length bstr_0)))"
"(if(< len_0 255)"
"(list(bytes len_0) bstr_0)"
"(list(bytes 255)(integer->integer-bytes len_0 4 #f #f) bstr_0))))))))"
"((letrec-values(((loop_0)"
"(lambda(rev-name_1 accum_0)"
"(begin"
" 'loop"
"(if(null? rev-name_1)"
"(let-values()(apply bytes-append accum_0))"
"(let-values()"
"(loop_0(cdr rev-name_1)(append(encode-symbol_0(car rev-name_1)) accum_0))))))))"
" loop_0)"
" rev-name_0"
" '())))))"
"(define-values"
"(compute-btree-size)"
"(lambda(bundles_0 len_0)"
"(begin"
"(let-values(((start_0) 0)((end_0) len_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((i_0) pos_0))"
"(let-values(((result_1)"
"(let-values(((result_1) result_0))"
"(let-values(((result_2)"
"(let-values()"
"(+"
" result_1"
"(let-values()"
"(let-values(((nlen_0)"
"(bytes-length"
"(car"
"(vector-ref bundles_0 i_0)))))"
"(+ nlen_0(* 5 4))))))))"
"(values result_2)))))"
"(if(not #f)(for-loop_0 result_1(+ pos_0 inc_0)) result_1)))"
" result_0)))))"
" for-loop_0)"
" 0"
" start_0))))))"
"(define-values"
"(compute-btree-node-offsets)"
"(lambda(bundles_0 len_0 initial-offset_0)"
"(begin"
"(let-values(((node-offsets_0)(make-vector len_0)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(lo_0 hi_0 offset_0)"
"(begin"
" 'loop"
"(if(= lo_0 hi_0)"
"(let-values() offset_0)"
"(let-values()"
"(let-values(((mid_0)(quotient(+ lo_0 hi_0) 2)))"
"(let-values((()(begin(vector-set! node-offsets_0 mid_0 offset_0)(values))))"
"(let-values(((nlen_0)(bytes-length(car(vector-ref bundles_0 mid_0)))))"
"(let-values(((offset_1)(+ offset_0 4 nlen_0 4 4 4 4)))"
"(let-values(((offset_2)(loop_0 lo_0 mid_0 offset_1)))"
"(loop_0(add1 mid_0) hi_0 offset_2))))))))))))"
" loop_0)"
" 0"
" len_0"
" initial-offset_0)"
" node-offsets_0)))))"
"(define-values"
"(compute-bundle-offsets)"
"(lambda(bundles_0 len_0 offset_0)"
"(begin"
"(let-values(((bundle-offsets_0)(make-vector len_0)))"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(i_0 offset_1)"
"(begin"
" 'loop"
"(if(= i_0 len_0)"
"(void)"
"(let-values()"
"(begin"
"(vector-set! bundle-offsets_0 i_0 offset_1)"
"(loop_0"
"(add1 i_0)"
"(+ offset_1(bytes-length(cdr(vector-ref bundles_0 i_0))))))))))))"
" loop_0)"
" 0"
" offset_0)"
" bundle-offsets_0)))))"
"(define-values"
"(write-directory-btree)"
"(lambda(bundles_0 node-offsets_0 bundle-offsets_0 len_0 port_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(lo_0 hi_0)"
"(begin"
" 'loop"
"(if(= lo_0 hi_0)"
"(let-values()(void))"
"(let-values()"
"(let-values(((mid_0)(quotient(+ lo_0 hi_0) 2)))"
"(let-values(((p_0)(vector-ref bundles_0 mid_0)))"
"(let-values(((nlen_0)(bytes-length(car p_0))))"
"(begin"
"(write-int nlen_0 port_0)"
"(write-bytes(car p_0) port_0)"
"(write-int(vector-ref bundle-offsets_0 mid_0) port_0)"
"(write-int(bytes-length(cdr p_0)) port_0)"
"(if(> mid_0 lo_0)"
"(let-values()"
"(let-values(((left_0)(quotient(+ lo_0 mid_0) 2)))"
"(write-int(vector-ref node-offsets_0 left_0) port_0)))"
"(let-values()(write-int 0 port_0)))"
"(if(<(add1 mid_0) hi_0)"
"(let-values()"
"(let-values(((right_0)(quotient(+(add1 mid_0) hi_0) 2)))"
"(write-int(vector-ref node-offsets_0 right_0) port_0)))"
"(let-values()(write-int 0 port_0)))"
"(loop_0 lo_0 mid_0)"
"(loop_0(add1 mid_0) hi_0)))))))))))"
" loop_0)"
" 0"
" len_0))))"
"(define-values(write-int)(lambda(n_0 port_0)(begin(write-bytes(integer->integer-bytes n_0 4 #f #f) port_0))))"
"(define-values"
"(struct:linklet-directory linklet-directory1.1 linklet-directory? linklet-directory-ht)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'linklet-directory"
" #f"
" 1"
" 0"
" #f"
"(list"
"(cons"
" prop:custom-write"
"(lambda(ld_0 port_0 mode_0)"
"(write-linklet-directory"
" ld_0"
"(correlated-linklet-directory? ld_0)"
" linklet-directory->hash"
" linklet-bundle->hash"
" port_0))))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'linklet-directory)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'ht))))"
"(define-values"
"(struct:linklet-bundle linklet-bundle2.1 linklet-bundle? linklet-bundle-ht)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'linklet-bundle"
" #f"
" 1"
" 0"
" #f"
"(list"
"(cons"
" prop:custom-write"
"(lambda(b_0 port_0 mode_0)"
"(write-linklet-bundle b_0(correlated-linklet-bundle? b_0) linklet-bundle->hash port_0))))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'linklet-bundle)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'ht))))"
"(define-values"
"(hash->linklet-directory)"
"(lambda(ht_0)"
"(begin"
"(let-values()"
"(let-values()"
"(begin"
"(if((lambda(ht_1)"
"(if(not(impersonator? ht_1))(if(hash? ht_1)(if(immutable? ht_1)(hash-eq? ht_1) #f) #f) #f))"
" ht_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'hash->linklet-directory"
"                 \"(and/c hash? hash-eq? immutable? (not/c impersonator?))\""
" ht_0)))"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_1 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(not k_0)"
"(let-values()"
"(if(linklet-bundle? v_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'hash->linklet-directory"
"                                                                                       \"value for #f key is not a linklet bundle\""
"                                                                                       \"value\""
" v_0))))"
"(if(symbol? k_0)"
"(let-values()"
"(if(linklet-directory? v_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'hash->linklet-directory"
"                                                                                         \"value for symbol key is not a linklet directory\""
"                                                                                         \"value\""
" v_0))))"
"(let-values()"
"(raise-arguments-error"
" 'hash->linklet-directory"
"                                                                                     \"key in given hash is not #f or a symbol\""
"                                                                                     \"key\""
" k_0)))))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_1 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_1))))"
"(void)"
"(linklet-directory1.1 ht_0)))))))"
"(define-values"
"(hash->linklet-bundle)"
"(lambda(ht_0)"
"(begin"
"(let-values()"
"(let-values()"
"(begin"
"(if((lambda(ht_1)"
"(if(not(impersonator? ht_1))(if(hash? ht_1)(if(immutable? ht_1)(hash-eq? ht_1) #f) #f) #f))"
" ht_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'hash->linklet-bundle"
"                 \"(and/c hash? hash-eq? immutable? (not/c impersonator?))\""
" ht_0)))"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0)(hash-iterate-key ht_1 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(let-values(((or-part_0)"
"(symbol? k_0)))"
"(if or-part_0"
" or-part_0"
"(fixnum? k_0)))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'hash->linklet-bundle"
"                                                                                   \"key in given hash is not a symbol or fixnum\""
"                                                                                   \"key\""
" k_0))))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_1 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_1))))"
"(void)"
"(linklet-bundle2.1 ht_0)))))))"
"(define-values"
"(linklet-directory->hash)"
"(lambda(ld_0)"
"(begin"
"(let-values()"
"(let-values()"
"(begin"
"(if(linklet-directory? ld_0)"
"(void)"
"              (let-values () (raise-argument-error 'linklet-directory->hash \"linklet-directory?\" ld_0)))"
"(linklet-directory-ht ld_0)))))))"
"(define-values"
"(linklet-bundle->hash)"
"(lambda(ld_0)"
"(begin"
"(let-values()"
"(let-values()"
"(begin"
"(if(linklet-bundle? ld_0)"
"(void)"
"              (let-values () (raise-argument-error 'linklet-bundle->hash \"linklet-bundle?\" ld_0)))"
"(linklet-bundle-ht ld_0)))))))"
"(define-values"
"(correlated-linklet-directory?)"
"(lambda(ld_0)"
"(begin"
"(let-values(((ht_0)(linklet-directory->hash ld_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(if(not k_0)"
"(let-values()(correlated-linklet-bundle? v_0))"
"(if(symbol? k_0)"
"(let-values()"
"(correlated-linklet-directory? v_0))"
"(let-values() #t)))))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) k_0 v_0))(not #f) #f)"
"(for-loop_0 result_1(hash-iterate-next ht_0 i_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
"(hash-iterate-first ht_0)))))))"
"(define-values"
"(correlated-linklet-bundle?)"
"(lambda(b_0)"
"(begin"
"(let-values(((ht_0)(linklet-bundle->hash b_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()(not(1/linklet? v_0))))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) k_0 v_0))(not #f) #f)"
"(for-loop_0 result_1(hash-iterate-next ht_0 i_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
"(hash-iterate-first ht_0)))))))"
"(define-values"
"(struct:namespace-scopes namespace-scopes1.1 namespace-scopes? namespace-scopes-post namespace-scopes-other)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'namespace-scopes #f 2 0 #f null 'prefab #f '(0 1) #f 'namespace-scopes)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'post)"
"(make-struct-field-accessor -ref_0 1 'other))))"
"(define-values"
"(swap-top-level-scopes)"
"(lambda(s_0 original-scopes-s_0 new-ns_0)"
"(begin"
"(let-values(((old-scs-post_0 old-scs-other_0)"
"(if(namespace-scopes? original-scopes-s_0)"
"(values(namespace-scopes-post original-scopes-s_0)(namespace-scopes-other original-scopes-s_0))"
"(decode-namespace-scopes original-scopes-s_0))))"
"(let-values(((new-scs-post_0 new-scs-other_0)(extract-namespace-scopes/values new-ns_0)))"
"(syntax-swap-scopes"
"(syntax-swap-scopes s_0 old-scs-post_0 new-scs-post_0)"
" old-scs-other_0"
" new-scs-other_0))))))"
"(define-values"
"(extract-namespace-scopes/values)"
"(lambda(ns_0)"
"(begin"
"(let-values(((root-ctx_0)(namespace-get-root-expand-ctx ns_0)))"
"(let-values(((post-expansion-sc_0)(post-expansion-scope(root-expand-context-post-expansion root-ctx_0))))"
"(values"
"(seteq post-expansion-sc_0)"
"(set-remove(list->seteq(root-expand-context-module-scopes root-ctx_0)) post-expansion-sc_0)))))))"
"(define-values"
"(extract-namespace-scopes)"
"(lambda(ns_0)"
"(begin"
"(let-values(((scs-post_0 scs-other_0)(extract-namespace-scopes/values ns_0)))"
"(namespace-scopes1.1 scs-post_0 scs-other_0)))))"
"(define-values"
"(encode-namespace-scopes)"
"(lambda(ns_0)"
"(begin"
"(let-values(((post-expansion-scs_0 other-scs_0)(extract-namespace-scopes/values ns_0)))"
"(let-values(((post-expansion-s_0)(add-scopes(datum->syntax$1 #f 'post)(set->list post-expansion-scs_0))))"
"(let-values(((other-s_0)(add-scopes(datum->syntax$1 #f 'other)(set->list other-scs_0))))"
"(datum->syntax$1 #f(vector post-expansion-s_0 other-s_0))))))))"
"(define-values"
"(decode-namespace-scopes)"
"(lambda(stx_0)"
"(begin"
"(let-values(((vec_0)(syntax-e$1 stx_0)))"
"(values(syntax-scope-set(vector-ref vec_0 0) 0)(syntax-scope-set(vector-ref vec_0 1) 0))))))"
"(define-values"
"(namespace-scopes=?)"
"(lambda(nss1_0 nss2_0)"
"(begin"
"(if(set=?(namespace-scopes-post nss1_0)(namespace-scopes-post nss2_0))"
"(set=?(namespace-scopes-other nss1_0)(namespace-scopes-other nss2_0))"
" #f))))"
"(define-values"
"(struct:syntax-literals"
" syntax-literals1.1"
" syntax-literals?"
" syntax-literals-stxes"
" syntax-literals-count"
" set-syntax-literals-stxes!"
" set-syntax-literals-count!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'syntax-literals"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'syntax-literals)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'stxes)"
"(make-struct-field-accessor -ref_0 1 'count)"
"(make-struct-field-mutator -set!_0 0 'stxes)"
"(make-struct-field-mutator -set!_0 1 'count))))"
"(define-values"
"(struct:header"
" header2.1"
" header?"
" header-module-path-indexes"
" header-binding-sym-to-define-sym"
" header-binding-syms-in-order"
" header-require-var-to-import-sym"
" header-import-sym-to-extra-inspectors"
" header-require-vars-in-order"
" header-define-and-import-syms"
" header-syntax-literals"
" set-header-binding-syms-in-order!"
" set-header-require-vars-in-order!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'header #f 8 0 #f null(current-inspector) #f '(0 1 3 4 6 7) #f 'header)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'module-path-indexes)"
"(make-struct-field-accessor -ref_0 1 'binding-sym-to-define-sym)"
"(make-struct-field-accessor -ref_0 2 'binding-syms-in-order)"
"(make-struct-field-accessor -ref_0 3 'require-var-to-import-sym)"
"(make-struct-field-accessor -ref_0 4 'import-sym-to-extra-inspectors)"
"(make-struct-field-accessor -ref_0 5 'require-vars-in-order)"
"(make-struct-field-accessor -ref_0 6 'define-and-import-syms)"
"(make-struct-field-accessor -ref_0 7 'syntax-literals)"
"(make-struct-field-mutator -set!_0 2 'binding-syms-in-order)"
"(make-struct-field-mutator -set!_0 5 'require-vars-in-order))))"
"(define-values"
"(struct:variable-use variable-use3.1 variable-use? variable-use-module-use variable-use-sym)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'variable-use #f 2 0 #f null #f #f '(0 1) #f 'variable-use)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'module-use)"
"(make-struct-field-accessor -ref_0 1 'sym))))"
"(define-values(make-syntax-literals)(lambda()(begin(syntax-literals1.1 null 0))))"
"(define-values"
"(make-header)"
"(lambda(mpis_0 syntax-literals_0)"
"(begin"
"(header2.1 mpis_0(make-hasheq) null(make-variable-uses)(make-hasheq) null(make-hasheq) syntax-literals_0))))"
"(define-values(make-variable-uses)(lambda()(begin(make-hash))))"
"(define-values"
"(add-syntax-literal!)"
"(lambda(header-or-literals_0 q_0)"
"(begin"
"(let-values(((sl_0)"
"(if(header? header-or-literals_0)"
"(header-syntax-literals header-or-literals_0)"
" header-or-literals_0)))"
"(let-values(((pos_0)(syntax-literals-count sl_0)))"
"(begin"
"(set-syntax-literals-count! sl_0(add1 pos_0))"
"(set-syntax-literals-stxes! sl_0(cons q_0(syntax-literals-stxes sl_0)))"
" pos_0))))))"
"(define-values"
"(add-syntax-literals!)"
"(lambda(sl_0 vec_0)"
"(begin"
"(let-values(((pos_0)(syntax-literals-count sl_0)))"
"(begin"
"(let-values(((vec_1 len_0)"
"(let-values(((vec_1) vec_0))"
"(begin(check-vector vec_1)(values vec_1(unsafe-vector-length vec_1))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(pos_1)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_1 len_0)"
"(let-values(((e_0)(unsafe-vector-ref vec_1 pos_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()(add-syntax-literal! sl_0 e_0))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0(unsafe-fx+ 1 pos_1))(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(void)"
"(cons pos_0(vector-length vec_0)))))))"
"(define-values(syntax-literals-empty?)(lambda(sl_0)(begin(null?(syntax-literals-stxes sl_0)))))"
"(define-values"
"(generate-lazy-syntax-literals!9.1)"
"(lambda(skip-deserialize?4_0 sl6_0 mpis7_0 self8_0)"
"(begin"
" 'generate-lazy-syntax-literals!9"
"(let-values(((sl_0) sl6_0))"
"(let-values(((mpis_0) mpis7_0))"
"(let-values(((self_0) self8_0))"
"(let-values(((skip-deserialize?_0) skip-deserialize?4_0))"
"(let-values()"
"(list"
"(list 'define-values(list syntax-literals-id)(list* 'make-vector(syntax-literals-count sl_0) '(#f)))"
"(list"
" 'define-values"
"(list get-syntax-literal!-id)"
"(list"
" 'lambda"
" '(pos)"
"(list"
" 'let-values"
"(list(list '(ready-stx)(list* 'unsafe-vector*-ref syntax-literals-id '(pos))))"
"(list"
" 'if"
" 'ready-stx"
" 'ready-stx"
"(list*"
" 'begin"
"(qq-append"
"(if skip-deserialize?_0"
" null"
"(list"
"(list"
" 'if"
"(list* 'unsafe-vector*-ref deserialized-syntax-vector-id '(0))"
" '(void)"
"(list deserialize-syntax-id bulk-binding-registry-id))))"
"(list"
"(list"
" 'let-values"
"(list"
"(list"
" '(stx)"
"(list"
" 'syntax-module-path-index-shift"
"(list"
" 'syntax-shift-phase-level"
"(list* 'unsafe-vector*-ref deserialized-syntax-vector-id '(pos))"
" phase-shift-id)"
"(add-module-path-index! mpis_0 self_0)"
" self-id"
" inspector-id)))"
"(list"
" 'begin"
"(list* 'vector-cas! syntax-literals-id '(pos #f stx))"
"(list* 'unsafe-vector*-ref syntax-literals-id '(pos))))))))))))))))))))"
"(define-values"
"(generate-lazy-syntax-literals-data!)"
"(lambda(sl_0 mpis_0)"
"(begin"
"(if(syntax-literals-empty? sl_0)"
"(let-values()(list(list* 'define-values(list deserialize-syntax-id) '(#f))))"
"(let-values()"
"(list"
"(list"
" 'define-values"
"(list deserialize-syntax-id)"
"(list"
" 'lambda"
"(list bulk-binding-registry-id)"
"(list"
" 'begin"
"(list"
" 'vector-copy!"
" deserialized-syntax-vector-id"
" ''0"
"(list"
" 'let-values"
"(list(list*(list inspector-id) '(#f)))"
"(let-values(((temp25_0)"
"(vector->immutable-vector(list->vector(reverse$1(syntax-literals-stxes sl_0)))))"
"((mpis26_0) mpis_0))"
"(generate-deserialize6.1 #t temp25_0 mpis26_0))))"
"(list* 'set! deserialize-syntax-id '(#f)))))))))))"
"(define-values(generate-lazy-syntax-literal-lookup)(lambda(pos_0)(begin(list get-syntax-literal!-id pos_0))))"
"(define-values"
"(generate-eager-syntax-literals!)"
"(lambda(sl_0 mpis_0 base-phase_0 self_0 ns_0)"
"(begin"
"(if(syntax-literals-empty? sl_0)"
"(let-values() #f)"
"(let-values()"
"(list"
" 'let-values"
"(list"
"(list"
" '(ns+stxss)"
"(let-values(((temp27_0)(cons(encode-namespace-scopes ns_0)(reverse$1(syntax-literals-stxes sl_0))))"
"((mpis28_0) mpis_0))"
"(generate-deserialize6.1 #t temp27_0 mpis28_0))))"
"(list"
" 'let-values"
" '(((ns-scope-s)(car ns+stxss)))"
"(list"
" 'list->vector"
"(list*"
" 'map"
"(list"
" 'lambda"
" '(stx)"
"(list"
" 'swap-top-level-scopes"
"(list"
" 'syntax-module-path-index-shift"
"(list 'syntax-shift-phase-level 'stx(list '- base-phase_0 dest-phase-id))"
"(add-module-path-index! mpis_0 self_0)"
" self-id)"
" 'ns-scope-s"
" ns-id))"
" '((cdr ns+stxss)))))))))))"
"(define-values"
"(generate-eager-syntax-literal-lookup)"
"(lambda(pos_0)(begin(list 'unsafe-vector*-ref syntax-literals-id pos_0))))"
"(define-values"
"(syntax-literals-as-vector)"
"(lambda(sl_0)(begin(list->vector(reverse$1(syntax-literals-stxes sl_0))))))"
"(define-values"
"(select-fresh)"
"(lambda(sym_0 header_0)"
"(begin"
"(if(symbol-conflicts? sym_0 header_0)"
"((letrec-values(((loop_0)"
"(lambda(pos_0)"
"(begin"
" 'loop"
"(let-values(((new-sym_0)"
"(string->symbol"
"                                             (string-append (number->string pos_0) \"/\" (symbol->string sym_0)))))"
"(if(symbol-conflicts? new-sym_0 header_0)(loop_0(add1 pos_0)) new-sym_0))))))"
" loop_0)"
" 1)"
" sym_0))))"
"(define-values"
"(symbol-conflicts?)"
"(lambda(sym_0 header_0)"
"(begin"
"(let-values(((or-part_0)(built-in-symbol? sym_0)))"
"(if or-part_0 or-part_0(hash-ref(header-define-and-import-syms header_0) sym_0 #f))))))"
"(define-values"
"(register-required-variable-use!19.1)"
"(lambda(defined?12_0 header14_0 mpi15_0 phase16_0 sym17_0 extra-inspector18_0)"
"(begin"
" 'register-required-variable-use!19"
"(let-values(((header_0) header14_0))"
"(let-values(((mpi_0) mpi15_0))"
"(let-values(((phase_0) phase16_0))"
"(let-values(((sym_0) sym17_0))"
"(let-values(((extra-inspector_0) extra-inspector18_0))"
"(let-values(((defined?_0) defined?12_0))"
"(let-values()"
"(let-values(((key_0)(variable-use3.1(module-use1.1 mpi_0 phase_0) sym_0)))"
"(let-values(((variable-uses_0)(header-require-var-to-import-sym header_0)))"
"(let-values(((prev-var-sym_0)(hash-ref variable-uses_0 key_0 #f)))"
"(let-values(((var-sym_0)"
"(let-values(((or-part_0) prev-var-sym_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((sym_1)(select-fresh(variable-use-sym key_0) header_0)))"
"(begin"
"(hash-set! variable-uses_0 key_0 sym_1)"
"(set-header-require-vars-in-order!"
" header_0"
"(cons key_0(header-require-vars-in-order header_0)))"
"(hash-set!"
"(header-define-and-import-syms header_0)"
" sym_1"
"(if defined?_0 'defined 'required))"
" sym_1))))))"
"(begin"
"(if(if extra-inspector_0(not prev-var-sym_0) #f)"
"(let-values()"
"(let-values(((extra-inspectors_0)(header-import-sym-to-extra-inspectors header_0)))"
"(hash-update!"
" extra-inspectors_0"
" var-sym_0"
"(lambda(s_0)(set-add s_0 extra-inspector_0))"
" '#hasheq())))"
"(void))"
" var-sym_0)))))))))))))))"
"(define-values"
"(register-as-defined!)"
"(lambda(header_0 def-sym_0)(begin(hash-set!(header-define-and-import-syms header_0) def-sym_0 'defined))))"
"(define-values"
"(registered-as-required?)"
"(lambda(header_0 var-sym_0)"
"(begin(eq? 'required(hash-ref(header-define-and-import-syms header_0) var-sym_0 #f)))))"
"(define-values"
"(generate-links+imports)"
"(lambda(header_0 phase_0 cctx_0 cross-linklet-inlining?_0)"
"(begin"
"(let-values(((mod-use-ht_0 link-mod-uses_0)"
"(let-values(((lst_0)(header-require-vars-in-order header_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_0 link-mod-uses_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((vu_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((ht_1 link-mod-uses_1)"
"(let-values(((ht_1) ht_0)"
"((link-mod-uses_1) link-mod-uses_0))"
"(let-values(((ht_2 link-mod-uses_2)"
"(let-values()"
"(let-values(((mu_0)"
"(variable-use-module-use"
" vu_0)))"
"(if(let-values(((or-part_0)"
"(hash-ref"
" ht_1"
" mu_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(eq?"
"(module-use-module"
" mu_0)"
"(compile-context-self"
" cctx_0))))"
"(if or-part_1"
" or-part_1"
"(top-level-module-path-index?"
"(module-use-module"
" mu_0))))))"
"(values ht_1 link-mod-uses_1)"
"(values"
"(hash-set ht_1 mu_0 #t)"
"(cons mu_0 link-mod-uses_1)))))))"
"(values ht_2 link-mod-uses_2)))))"
"(if(not #f)"
"(for-loop_0 ht_1 link-mod-uses_1 rest_0)"
"(values ht_1 link-mod-uses_1))))"
"(values ht_0 link-mod-uses_0))))))"
" for-loop_0)"
" '#hash()"
" null"
" lst_0)))))"
"(values"
" link-mod-uses_0"
"(reverse$1"
"(let-values(((lst_0) link-mod-uses_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mu_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((lst_2)"
"(header-require-vars-in-order"
" header_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair? lst_3)"
"(let-values(((vu_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(if(equal?"
" mu_0"
"(variable-use-module-use"
" vu_0))"
"(let-values(((fold-var_4)"
" fold-var_3))"
"(let-values(((fold-var_5)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((var-sym_0)"
"(hash-ref"
"(header-require-var-to-import-sym"
" header_0)"
" vu_0)))"
"(let-values(((ex-sym_0)"
"(variable-use-sym"
" vu_0)))"
"(if(eq?"
" var-sym_0"
" ex-sym_0)"
" var-sym_0"
"(list"
" ex-sym_0"
" var-sym_0)))))"
" fold-var_4))))"
"(values"
" fold-var_5)))"
" fold-var_3))))"
"(if(not #f)"
"(for-loop_1"
" fold-var_3"
" rest_1)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
" lst_2)))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
"(reverse$1"
"(let-values(((lst_0) link-mod-uses_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mu_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((extra-inspectorss_0)"
"(let-values(((lst_2)"
"(header-require-vars-in-order"
" header_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((vu_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(if(equal?"
" mu_0"
"(variable-use-module-use"
" vu_0))"
"(let-values(((var-sym_0)"
"(hash-ref"
"(header-require-var-to-import-sym"
" header_0)"
" vu_0)))"
"(begin"
" #t"
"((letrec-values(((for-loop_2)"
"(lambda(table_2)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((table_3)"
"(let-values(((extra-inspectors_0)"
"(hash-ref"
"(header-import-sym-to-extra-inspectors"
" header_0)"
" var-sym_0"
" #f)))"
"(begin"
" #t"
"((letrec-values(((for-loop_3)"
"(lambda(table_3)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((table_4)"
"(let-values(((table_4)"
" table_3))"
"(if(let-values(((or-part_0)"
" extra-inspectors_0))"
"(if or-part_0"
" or-part_0"
" cross-linklet-inlining?_0))"
"(let-values(((table_5)"
" table_4))"
"(let-values(((table_6)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" var-sym_0"
" extra-inspectors_0))))"
"(hash-set"
" table_5"
" key_0"
" val_0)))))"
"(values"
" table_6)))"
" table_4))))"
" table_4))))))"
" for-loop_3)"
" table_2)))))"
" table_3))))))"
" for-loop_2)"
" table_1)))"
" table_1))))"
"(if(not"
" #f)"
"(for-loop_1"
" table_1"
" rest_1)"
" table_1)))"
" table_0)))))"
" for-loop_1)"
" '#hash()"
" lst_2)))))"
"(if(hash-count extra-inspectorss_0)"
" extra-inspectorss_0"
" #f)))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
"(reverse$1"
"(let-values(((lst_0)(header-require-vars-in-order header_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((vu_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(if(let-values(((mod_0)"
"(module-use-module"
"(variable-use-module-use vu_0))))"
"(let-values(((or-part_0)"
"(eq? mod_0(compile-context-self cctx_0))))"
"(if or-part_0"
" or-part_0"
"(top-level-module-path-index? mod_0))))"
"(let-values(((fold-var_2) fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((var-sym_0)"
"(hash-ref"
"(header-require-var-to-import-sym"
" header_0)"
" vu_0)))"
"(let-values(((ex-sym_0)"
"(variable-use-sym vu_0)))"
"(if(eq? var-sym_0 ex-sym_0)"
" var-sym_0"
"(list var-sym_0 ex-sym_0)))))"
" fold-var_2))))"
"(values fold-var_3)))"
" fold-var_1))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))))"
"(define-values"
"(instance-imports)"
"(list ns-id phase-shift-id self-id inspector-id bulk-binding-registry-id set-transformer!-id))"
"(define-values"
"(make-instance-instance13.1)"
"(lambda(bulk-binding-registry5_0 inspector4_0 namespace1_0 phase-shift2_0 self3_0 set-transformer!6_0)"
"(begin"
" 'make-instance-instance13"
"(let-values(((ns_0) namespace1_0))"
"(let-values(((phase-shift_0) phase-shift2_0))"
"(let-values(((self_0) self3_0))"
"(let-values(((inspector_0) inspector4_0))"
"(let-values(((bulk-binding-registry_0) bulk-binding-registry5_0))"
"(let-values(((set-transformer!_0) set-transformer!6_0))"
"(let-values()"
"(1/make-instance"
" 'instance"
" #f"
" 'constant"
" ns-id"
" ns_0"
" phase-shift-id"
" phase-shift_0"
" self-id"
" self_0"
" inspector-id"
" inspector_0"
" bulk-binding-registry-id"
" bulk-binding-registry_0"
" set-transformer!-id"
" set-transformer!_0)))))))))))"
"(define-values"
"(make-module-body-instance-instance18.1)"
"(lambda(set-transformer!16_0)"
"(begin"
" 'make-module-body-instance-instance18"
"(let-values(((set-transformer!_0) set-transformer!16_0))"
"(let-values()(1/make-instance 'body-instance #f 'constant set-transformer!-id set-transformer!_0))))))"
"(define-values"
"(empty-syntax-literals-instance)"
"(1/make-instance 'empty-stx #f 'constant get-syntax-literal!-id(lambda(pos_0) #f) 'get-encoded-root-expand-ctx #f))"
"(void(1/instance-describe-variable! empty-syntax-literals-instance get-syntax-literal!-id '(procedure/succeeds 2)))"
"(define-values"
"(empty-module-body-instance)"
"(let-values(((temp21_0)(lambda(name_0 val_0)(void))))(make-module-body-instance-instance18.1 temp21_0)))"
"(void(1/instance-describe-variable! empty-module-body-instance set-transformer!-id '(procedure/succeeds 4)))"
"(define-values"
"(empty-top-syntax-literal-instance)"
"(1/make-instance 'top-syntax-literal #f 'constant mpi-vector-id #f syntax-literals-id #f))"
"(define-values"
"(empty-syntax-literals-data-instance)"
"(1/make-instance 'empty-stx-data #f 'constant deserialized-syntax-vector-id(vector) deserialize-syntax-id void))"
"(define-values"
"(empty-instance-instance)"
"(let-values(((temp22_0) #f)((temp23_0) #f)((temp24_0) #f)((temp25_0) #f)((temp26_0) #f)((temp27_0) #f))"
"(make-instance-instance13.1 temp26_0 temp25_0 temp22_0 temp23_0 temp24_0 temp27_0)))"
"(define-values"
"(eager-instance-imports)"
"(list* ns-id dest-phase-id self-id bulk-binding-registry-id inspector-id '(swap-top-level-scopes)))"
"(define-values"
"(make-eager-instance-instance11.1)"
"(lambda(bulk-binding-registry4_0 dest-phase2_0 inspector5_0 namespace1_0 self3_0)"
"(begin"
" 'make-eager-instance-instance11"
"(let-values(((ns_0) namespace1_0))"
"(let-values(((dest-phase_0) dest-phase2_0))"
"(let-values(((self_0) self3_0))"
"(let-values(((bulk-binding-registry_0) bulk-binding-registry4_0))"
"(let-values(((inspector_0) inspector5_0))"
"(let-values()"
"(1/make-instance"
" 'instance"
" #f"
" 'constant"
" ns-id"
" ns_0"
" dest-phase-id"
" dest-phase_0"
" self-id"
" self_0"
" bulk-binding-registry-id"
" bulk-binding-registry_0"
" inspector-id"
" inspector_0"
" 'swap-top-level-scopes"
" swap-top-level-scopes))))))))))"
"(define-values"
"(empty-eager-instance-instance)"
"(let-values(((temp14_0) #f)((temp15_0) #f)((temp16_0) #f)((temp17_0) #f)((temp18_0) #f))"
"(make-eager-instance-instance11.1 temp17_0 temp15_0 temp18_0 temp14_0 temp16_0)))"
"(define-values"
"(self-quoting-in-linklet?)"
"(lambda(datum_0)"
"(begin"
"(let-values(((or-part_0)(number? datum_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(boolean? datum_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(string? datum_0)))(if or-part_2 or-part_2(bytes? datum_0))))))))))"
"(define-values"
"(srcloc->vector)"
"(lambda(s_0)"
"(begin"
"(if s_0"
"(vector(srcloc-source s_0)(srcloc-line s_0)(srcloc-column s_0)(srcloc-position s_0)(srcloc-span s_0))"
" #f))))"
"(define-values(keep-source-locations?) #f)"
"(define-values"
"(correlate*)"
"(lambda(stx_0 s-exp_0)"
"(begin(if(syntax-srcloc stx_0)(datum->correlated s-exp_0(srcloc->vector(syntax-srcloc stx_0))) s-exp_0))))"
"(define-values(correlate~)(lambda(stx_0 s-exp_0)(begin s-exp_0)))"
"(define-values"
"(correlate/app)"
"(lambda(stx_0 s-exp_0)(begin(if keep-source-locations?(correlate* stx_0 s-exp_0)(correlate~ stx_0 s-exp_0)))))"
"(define-values(->correlated)(lambda(s_0)(begin(datum->correlated s_0 #f))))"
"(define-values"
"(correlate-source-name)"
"(lambda(sym_0 e-sym_0)"
"(begin(if(eq? sym_0 e-sym_0) sym_0(correlated-property(datum->correlated sym_0 #f) 'source-name e-sym_0)))))"
"(define-values(compile-keep-source-locations!)(lambda(on?_0)(begin(set! keep-source-locations? on?_0))))"
"(define-values"
"(compile$2)"
"(let-values(((compile5_0)"
"(lambda(p3_0 cctx4_0 name1_0 result-used?2_0)"
"(begin"
" 'compile5"
"(let-values(((p_0) p3_0))"
"(let-values(((cctx_0) cctx4_0))"
"(let-values(((name_0) name1_0))"
"(let-values(((result-used?_0) result-used?2_0))"
"(let-values()"
"(let-values(((compile_0)"
"(lambda(p_1 name_1 result-used?_1)"
"(begin 'compile(compile$2 p_1 cctx_0 name_1 result-used?_1)))))"
"(let-values(((s_0)(parsed-s p_0)))"
"(if(parsed-id? p_0)"
"(let-values()"
"(let-values(((p25_0) p_0)((cctx26_0) cctx_0))"
"(compile-identifier22.1 #f #f p25_0 cctx26_0)))"
"(if(parsed-lambda? p_0)"
"(let-values()"
"(if result-used?_0"
"(let-values()"
"(add-lambda-properties"
"(correlate*"
" s_0"
"(list*"
" 'lambda"
"(compile-lambda"
"(parsed-lambda-keys p_0)"
"(parsed-lambda-body p_0)"
" cctx_0)))"
" name_0"
" s_0))"
"(let-values()(correlate~ s_0 ''unused-lambda))))"
"(if(parsed-case-lambda? p_0)"
"(let-values()"
"(if result-used?_0"
"(let-values()"
"(add-lambda-properties"
"(correlate*"
" s_0"
"(list*"
" 'case-lambda"
"(reverse$1"
"(let-values(((lst_0)(parsed-case-lambda-clauses p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((clause_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(compile-lambda"
"(car"
" clause_0)"
"(cadr"
" clause_0)"
" cctx_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
" name_0"
" s_0))"
"(let-values()(correlate~ s_0 ''unused-case-lambda))))"
"(if(parsed-app? p_0)"
"(let-values()"
"(let-values(((rands_0)(parsed-app-rands p_0)))"
"(correlate/app"
" s_0"
"(cons"
"(compile_0(parsed-app-rator p_0) #f #t)"
"(reverse$1"
"(let-values(((lst_0) rands_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((r_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(compile_0"
" r_0"
" #f"
" #t))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))"
"(if(parsed-if? p_0)"
"(let-values()"
"(let-values(((tst-e_0)(compile_0(parsed-if-tst p_0) #f #f)))"
"(if(eq?(correlated-e tst-e_0) #t)"
"(let-values()(compile_0(parsed-if-thn p_0) name_0 result-used?_0))"
"(if(eq?(correlated-e tst-e_0) #f)"
"(let-values()"
"(compile_0(parsed-if-els p_0) name_0 result-used?_0))"
"(let-values()"
"(correlate~"
" s_0"
"(list"
" 'if"
" tst-e_0"
"(compile_0(parsed-if-thn p_0) name_0 result-used?_0)"
"(compile_0(parsed-if-els p_0) name_0 result-used?_0))))))))"
"(if(parsed-with-continuation-mark? p_0)"
"(let-values()"
"(correlate~"
" s_0"
"(list"
" 'with-continuation-mark"
"(compile_0(parsed-with-continuation-mark-key p_0) #f #t)"
"(compile_0(parsed-with-continuation-mark-val p_0) #f #t)"
"(compile_0"
"(parsed-with-continuation-mark-body p_0)"
" name_0"
" result-used?_0))))"
"(if(parsed-begin0? p_0)"
"(let-values()"
"(correlate~"
" s_0"
"(list*"
" 'begin0"
"(compile_0(car(parsed-begin0-body p_0)) name_0 result-used?_0)"
"(reverse$1"
"(let-values(((lst_0)(cdr(parsed-begin0-body p_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(compile_0"
" e_0"
" #f"
" #f))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(if(parsed-begin? p_0)"
"(let-values()"
"(correlate~"
" s_0"
"(compile-begin"
"(parsed-begin-body p_0)"
" cctx_0"
" name_0"
" result-used?_0)))"
"(if(parsed-set!? p_0)"
"(let-values()"
"(correlate~"
" s_0"
"(let-values(((temp27_0)(parsed-set!-id p_0))"
"((cctx28_0) cctx_0)"
"((temp29_0) #t)"
"((temp30_0)"
"(compile_0"
"(parsed-set!-rhs p_0)"
"(parsed-s(parsed-set!-id p_0))"
" #t)))"
"(compile-identifier22.1 temp30_0 temp29_0 temp27_0 cctx28_0))))"
"(if(parsed-let-values? p_0)"
"(let-values()"
"(let-values(((p31_0) p_0)"
"((cctx32_0) cctx_0)"
"((name33_0) name_0)"
"((temp34_0) #f)"
"((result-used?35_0) result-used?_0))"
"(compile-let13.1"
" temp34_0"
" p31_0"
" cctx32_0"
" name33_0"
" result-used?35_0)))"
"(if(parsed-letrec-values? p_0)"
"(let-values()"
"(let-values(((p36_0) p_0)"
"((cctx37_0) cctx_0)"
"((name38_0) name_0)"
"((temp39_0) #t)"
"((result-used?40_0) result-used?_0))"
"(compile-let13.1"
" temp39_0"
" p36_0"
" cctx37_0"
" name38_0"
" result-used?40_0)))"
"(if(parsed-quote? p_0)"
"(let-values()"
"(let-values(((datum_0)(parsed-quote-datum p_0)))"
"(if(self-quoting-in-linklet? datum_0)"
"(let-values()(correlate~ s_0 datum_0))"
"(let-values()"
"(correlate~ s_0(list 'quote datum_0))))))"
"(if(parsed-quote-syntax? p_0)"
"(let-values()"
"(if result-used?_0"
"(compile-quote-syntax"
"(parsed-quote-syntax-datum p_0)"
" cctx_0)"
"(correlate~ s_0(list 'quote(syntax->datum$1 s_0)))))"
"(if(parsed-#%variable-reference? p_0)"
"(let-values()"
"(let-values(((id_0)"
"(parsed-#%variable-reference-id p_0)))"
"(correlate~"
" s_0"
"(if id_0"
"(list"
" '#%variable-reference"
"(let-values(((id41_0) id_0)((cctx42_0) cctx_0))"
"(compile-identifier22.1 #f #f id41_0 cctx42_0)))"
" '(#%variable-reference)))))"
"(let-values()"
"(error"
"                                                                 \"unrecognized parsed form:\""
" p_0)))))))))))))))))))))))))))"
"(case-lambda"
"((p_0 cctx_0)(begin 'compile(compile5_0 p_0 cctx_0 #f #t)))"
"((p_0 cctx_0 name_0 result-used?2_0)(compile5_0 p_0 cctx_0 name_0 result-used?2_0))"
"((p_0 cctx_0 name1_0)(compile5_0 p_0 cctx_0 name1_0 #t)))))"
"(define-values"
"(compile-lambda)"
"(lambda(formals_0 bodys_0 cctx_0)(begin(list formals_0(compile-sequence bodys_0 cctx_0 #f #t)))))"
"(define-values"
"(compile-sequence)"
"(lambda(bodys_0 cctx_0 name_0 result-used?_0)"
"(begin"
"(if(null?(cdr bodys_0))"
"(compile$2(car bodys_0) cctx_0 name_0 result-used?_0)"
"(compile-begin bodys_0 cctx_0 name_0 result-used?_0)))))"
"(define-values"
"(compile-begin)"
"(lambda(es_0 cctx_0 name_0 result-used?_0)"
"(begin"
"(let-values(((used-pos_0)(sub1(length es_0))))"
"(list*"
" 'begin"
"(reverse$1"
"(let-values(((lst_0) es_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((e_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((i_0) pos_0))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((used?_0)(= i_0 used-pos_0)))"
"(compile$2"
" e_0"
" cctx_0"
"(if used?_0 name_0 #f)"
"(if used?_0 result-used?_0 #f))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0(+ pos_0 1)) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" start_0)))))))))"
"(define-values"
"(add-lambda-properties)"
"(lambda(s_0 inferred-name_0 orig-s_0)"
"(begin"
"(letrec-values(((simplify-name_0)"
"(lambda(v_0)"
"(begin"
" 'simplify-name"
"(if(pair? v_0)"
"(let-values()"
"(let-values(((n1_0)(simplify-name_0(car v_0))))"
"(let-values(((n2_0)(simplify-name_0(cdr v_0))))(if(eq? n1_0 n2_0) n1_0 v_0))))"
"(let-values() v_0))))))"
"(let-values(((name_0)"
"(let-values(((or-part_0)"
"(let-values(((v_0)(simplify-name_0(syntax-property$1 orig-s_0 'inferred-name))))"
"(if(let-values(((or-part_0)(symbol? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(syntax?$1 v_0)))"
"(if or-part_1 or-part_1(void? v_0)))))"
" v_0"
" #f))))"
"(if or-part_0 or-part_0 inferred-name_0))))"
"(let-values(((named-s_0)"
"(if name_0"
"(correlated-property"
"(->correlated s_0)"
" 'inferred-name"
"(if(syntax?$1 name_0)(syntax-e$1 name_0) name_0))"
" s_0)))"
"(let-values(((as-method_0)(syntax-property$1 orig-s_0 'method-arity-error)))"
"(if as-method_0"
"(correlated-property(->correlated named-s_0) 'method-arity-error as-method_0)"
" named-s_0))))))))"
"(define-values"
"(compile-let13.1)"
"(lambda(rec?7_0 p9_0 cctx10_0 name11_0 result-used?12_0)"
"(begin"
" 'compile-let13"
"(let-values(((p_0) p9_0))"
"(let-values(((cctx_0) cctx10_0))"
"(let-values(((name_0) name11_0))"
"(let-values(((rec?_0) rec?7_0))"
"(let-values(((result-used?_0) result-used?12_0))"
"(let-values()"
"(let-values(((body_0)(parsed-let_-values-body p_0)))"
"(correlate~"
"(parsed-s p_0)"
"(list"
"(if rec?_0 'letrec-values 'let-values)"
"(reverse$1"
"(let-values(((lst_0)(parsed-let_-values-clauses p_0))((lst_1)(parsed-let_-values-idss p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((clause_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((ids_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list"
"(if rec?_0"
"(reverse$1"
"(let-values(((lst_4)"
"(car"
" clause_0))"
"((lst_5)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_4)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_5)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((id_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(add-undefined-error-name-property"
" sym_0"
" id_0))"
" fold-var_3))))"
"(values"
" fold-var_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_3"
" rest_2"
" rest_3)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
" lst_4"
" lst_5))))"
"(car clause_0))"
"(compile$2"
"(cadr clause_0)"
" cctx_0"
"(if(= 1(length ids_0))"
"(car ids_0)"
" #f))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0 rest_1) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1))))"
"(compile-sequence body_0 cctx_0 name_0 result-used?_0)))))))))))))"
"(define-values"
"(add-undefined-error-name-property)"
"(lambda(sym_0 orig-id_0)"
"(begin"
"(let-values(((id_0)(correlate~ orig-id_0 sym_0)))"
"(correlated-property"
"(->correlated id_0)"
" 'undefined-error-name"
"(let-values(((or-part_0)(syntax-property$1 orig-id_0 'undefined-error-name)))"
"(if or-part_0 or-part_0(syntax-e$1 orig-id_0))))))))"
"(define-values"
"(compile-identifier22.1)"
"(lambda(set-to17_0 set-to?16_0 p20_0 cctx21_0)"
"(begin"
" 'compile-identifier22"
"(let-values(((p_0) p20_0))"
"(let-values(((cctx_0) cctx21_0))"
"(let-values(((set-to?_0) set-to?16_0))"
"(let-values(((rhs_0) set-to17_0))"
"(let-values()"
"(let-values(((normal-b_0)(parsed-id-binding p_0)))"
"(let-values(((b_0)"
"(let-values(((or-part_0) normal-b_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((temp43_0)(compile-context-self cctx_0))"
"((temp44_0)(compile-context-phase cctx_0))"
"((temp45_0)(syntax-e$1(parsed-s p_0))))"
"(make-module-binding20.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" temp43_0"
" temp44_0"
" temp45_0))))))"
"(let-values(((sym_0)"
"(if(local-binding? b_0)"
"(let-values()(local-binding-key b_0))"
"(if(module-binding? b_0)"
"(let-values()"
"(let-values(((mpi_0)"
"(if(parsed-top-id? p_0)"
"(compile-context-self cctx_0)"
"(module-binding-module b_0))))"
"(if(parsed-primitive-id? p_0)"
"(let-values()"
"(begin"
"(if(zero?(module-binding-phase b_0))"
"(void)"
"(let-values()"
"                                                    (error \"internal error: non-zero phase for a primitive\")))"
"(if set-to?_0"
"(let-values()"
"(error"
"                                                     \"internal error: cannot assign to a primitive:\""
"(module-binding-sym b_0)))"
"(void))"
"(module-binding-sym b_0)))"
"(if(eq? mpi_0(compile-context-module-self cctx_0))"
"(let-values()"
"(let-values(((header_0)(compile-context-header cctx_0)))"
"(hash-ref"
"(header-binding-sym-to-define-sym header_0)"
"(module-binding-sym b_0))))"
"(let-values()"
"(let-values(((temp46_0)(compile-context-header cctx_0))"
"((temp47_0)"
"(if(inside-module-context?"
" mpi_0"
"(compile-context-self cctx_0))"
"(compile-context-self cctx_0)"
" mpi_0))"
"((temp48_0)(module-binding-phase b_0))"
"((temp49_0)(module-binding-sym b_0))"
"((temp50_0)"
"(let-values(((or-part_0)"
"(module-binding-extra-inspector b_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(parsed-id-inspector p_0)))"
"(if or-part_1"
" or-part_1"
"(if(parsed-s p_0)"
"(syntax-inspector(parsed-s p_0))"
" #f)))))))"
"(register-required-variable-use!19.1"
" #f"
" temp46_0"
" temp47_0"
" temp48_0"
" temp49_0"
" temp50_0)))))))"
"(let-values()"
"                                        (error \"not a reference to a module or local binding:\" b_0 (parsed-s p_0)))))))"
"(correlate~(parsed-s p_0)(if set-to?_0(list 'set! sym_0 rhs_0) sym_0)))))))))))))"
"(define-values"
"(compile-quote-syntax)"
"(lambda(q_0 cctx_0)"
"(begin"
"(let-values(((pos_0)(add-syntax-literal!(compile-context-header cctx_0) q_0)))"
"(if(compile-context-lazy-syntax-literals? cctx_0)"
"(let-values()(generate-lazy-syntax-literal-lookup pos_0))"
"(let-values()(generate-eager-syntax-literal-lookup pos_0)))))))"
"(define-values"
"(extra-inspectors-allow?)"
"(lambda(extra-inspectors_0 guard-insp_0)"
"(begin"
"(if(not extra-inspectors_0)"
"(let-values() #f)"
"(if(set? extra-inspectors_0)"
"(let-values()"
"(let-values(((ht_0) extra-inspectors_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((extra-insp_0)(unsafe-immutable-hash-iterate-key ht_0 i_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(inspector-superior?"
" extra-insp_0"
" guard-insp_0)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) extra-insp_0))(not #f) #f)"
"(for-loop_0 result_1(unsafe-immutable-hash-iterate-next ht_0 i_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
"(unsafe-immutable-hash-iterate-first ht_0)))))"
"(if(procedure? extra-inspectors_0)"
"(let-values()(extra-inspectors_0 guard-insp_0))"
"(let-values()"
"(error"
" 'extra-inspectors-allow?"
"               \"unknown representation of extra inspectors: ~e\""
" extra-inspectors_0))))))))"
"(define-values"
"(extra-inspectors-merge)"
"(lambda(extra-inspectors-1_0 extra-inspectors-2_0)"
"(begin"
"(if(let-values(((or-part_0)(not extra-inspectors-1_0)))(if or-part_0 or-part_0(not extra-inspectors-2_0)))"
"(let-values() #f)"
"(if(if(set? extra-inspectors-1_0)(set? extra-inspectors-2_0) #f)"
"(let-values()(set-union extra-inspectors-1_0 extra-inspectors-2_0))"
"(let-values()"
"(lambda(guard-insp_0)"
"(if(extra-inspectors-allow? extra-inspectors-1_0 guard-insp_0)"
"(extra-inspectors-allow? extra-inspectors-2_0 guard-insp_0)"
" #f))))))))"
"(define-values"
"(struct:module-use*"
" module-use*1.1"
" module-use*?"
" module-use*-extra-inspectorss"
" module-use*-self-inspector"
" set-module-use*-extra-inspectorss!"
" set-module-use*-self-inspector!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-use*"
" struct:module-use"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'module-use*)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'extra-inspectorss)"
"(make-struct-field-accessor -ref_0 1 'self-inspector)"
"(make-struct-field-mutator -set!_0 0 'extra-inspectorss)"
"(make-struct-field-mutator -set!_0 1 'self-inspector))))"
"(define-values"
"(module-uses-add-extra-inspectorsss)"
"(lambda(mus_0 extra-inspectorsss_0)"
"(begin"
"(if extra-inspectorsss_0"
"(let-values()"
"(reverse$1"
"(let-values(((lst_0) mus_0)((lst_1) extra-inspectorsss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((mu_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((extra-inspectorss_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(module-use*1.1"
"(module-use-module mu_0)"
"(module-use-phase mu_0)"
" extra-inspectorss_0"
" #f))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0 rest_1) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1)))))"
"(let-values()"
"(reverse$1"
"(let-values(((lst_0) mus_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mu_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(module-use*1.1"
"(module-use-module mu_0)"
"(module-use-phase mu_0)"
" #f"
" #f))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))))"
"(define-values"
"(module-uses-strip-extra-inspectorsss)"
"(lambda(mu*s_0)"
"(begin"
"(reverse$1"
"(let-values(((lst_0) mu*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mu*_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(module-use1.1"
"(module-use-module mu*_0)"
"(module-use-phase mu*_0)))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(define-values"
"(module-uses-extract-extra-inspectorsss)"
"(lambda(mu*s_0 linklet_0 check-inlined-reference?_0 skip-n_0)"
"(begin"
"(if(not check-inlined-reference?_0)"
"(let-values()"
"(reverse$1"
"(let-values(((lst_0) mu*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mu*_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(module-use*-extra-inspectorss mu*_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"(let-values()"
"(reverse$1"
"(let-values(((lst_0) mu*s_0)((lst_1)(list-tail(1/linklet-import-variables linklet_0) skip-n_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((mu*_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((imports_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((extra-inspectorss_0)"
"(module-use*-extra-inspectorss"
" mu*_0)))"
"(let-values(((lst_4) imports_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_4)))"
"((letrec-values(((for-loop_1)"
"(lambda(extra-inspectorss_1"
" lst_5)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_5)"
"(let-values(((import_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((extra-inspectorss_2)"
"(let-values(((extra-inspectorss_2)"
" extra-inspectorss_1))"
"(let-values(((extra-inspectorss_3)"
"(let-values()"
"(if(eq?"
"(hash-ref"
" extra-inspectorss_2"
" import_0"
" '#:not-recorded)"
" '#:not-recorded)"
"(let-values()"
"(hash-set"
" extra-inspectorss_2"
" import_0"
"(set"
"(module-use*-self-inspector"
" mu*_0))))"
"(let-values()"
" extra-inspectorss_2)))))"
"(values"
" extra-inspectorss_3)))))"
"(if(not"
" #f)"
"(for-loop_1"
" extra-inspectorss_2"
" rest_2)"
" extra-inspectorss_2)))"
" extra-inspectorss_1)))))"
" for-loop_1)"
" extra-inspectorss_0"
" lst_4)))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0 rest_1) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1)))))))))"
"(define-values"
"(module-use*-declaration-inspector!)"
"(lambda(mu*_0 insp_0)(begin(set-module-use*-self-inspector! mu*_0 insp_0))))"
"(define-values"
"(module-use+extra-inspectors)"
"(lambda(mpi_0 phase_0 imports_0 inspector_0 extra-inspector_0 extra-inspectorss_0)"
"(begin"
"(let-values(((now-inspector_0)(current-code-inspector)))"
"(let-values(((add-insp?_0)(if inspector_0(inspector-superior? inspector_0 now-inspector_0) #f)))"
"(let-values(((add-extra-insp?_0)"
"(if extra-inspector_0(inspector-superior? extra-inspector_0 now-inspector_0) #f)))"
"(let-values(((new-extra-inspectorss_0)"
"(if(let-values(((or-part_0) add-insp?_0))(if or-part_0 or-part_0 add-extra-insp?_0))"
"(let-values()"
"(let-values(((lst_0) imports_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((import_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" import_0"
"(let-values(((extra-inspectors_0)"
"(if extra-inspectorss_0"
"(hash-ref"
" extra-inspectorss_0"
" import_0"
" #f)"
" #f)))"
"(lambda(guard-insp_0)"
"(let-values(((or-part_0)"
"(if add-insp?_0"
"(inspector-superior?"
" inspector_0"
" guard-insp_0)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if add-extra-insp?_0"
"(inspector-superior?"
" extra-inspector_0"
" guard-insp_0)"
" #f)))"
"(if or-part_1"
" or-part_1"
"(extra-inspectors-allow?"
" extra-inspectors_0"
" guard-insp_0)))))))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1 rest_0) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
" lst_0))))"
"(let-values()"
"(let-values(((lst_0) imports_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(extra-inspectorss_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((import_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((extra-inspectorss_2)"
"(let-values(((extra-inspectorss_2)"
" extra-inspectorss_1))"
"(let-values(((extra-inspectorss_3)"
"(let-values()"
"(if(hash-ref"
" extra-inspectorss_2"
" import_0"
" #f)"
" extra-inspectorss_2"
"(hash-set"
" extra-inspectorss_2"
" import_0"
" #f)))))"
"(values extra-inspectorss_3)))))"
"(if(not #f)"
"(for-loop_0 extra-inspectorss_2 rest_0)"
" extra-inspectorss_2)))"
" extra-inspectorss_1)))))"
" for-loop_0)"
"(let-values(((or-part_0) extra-inspectorss_0))(if or-part_0 or-part_0(seteq)))"
" lst_0)))))))"
"(module-use*1.1 mpi_0 phase_0 new-extra-inspectorss_0 #f))))))))"
"(define-values"
"(module-use-merge-extra-inspectorss!)"
"(lambda(existing-mu*_0 mu*_0)"
"(begin"
"(let-values(((existing-extra-inspectorss_0)(module-use*-extra-inspectorss existing-mu*_0)))"
"(let-values(((extra-inspectorss_0)(module-use*-extra-inspectorss mu*_0)))"
"(let-values(((new-extra-inspectorss_0)"
"(if(not existing-extra-inspectorss_0)"
"(let-values() extra-inspectorss_0)"
"(if(not extra-inspectorss_0)"
"(let-values() existing-extra-inspectorss_0)"
"(let-values()"
"(let-values(((ht_0) extra-inspectorss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(new-extra-inspectorss_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 extra-inspectors_0)"
"(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((new-extra-inspectorss_1)"
"(let-values(((new-extra-inspectorss_1)"
" new-extra-inspectorss_0))"
"(let-values(((new-extra-inspectorss_2)"
"(let-values()"
"(hash-set"
" new-extra-inspectorss_1"
" sym_0"
"(extra-inspectors-merge"
" extra-inspectors_0"
"(hash-ref"
" new-extra-inspectorss_1"
" sym_0"
"(seteq)))))))"
"(values new-extra-inspectorss_2)))))"
"(if(not #f)"
"(for-loop_0"
" new-extra-inspectorss_1"
"(hash-iterate-next ht_0 i_0))"
" new-extra-inspectorss_1)))"
" new-extra-inspectorss_0)))))"
" for-loop_0)"
" existing-extra-inspectorss_0"
"(hash-iterate-first ht_0)))))))))"
"(set-module-use*-extra-inspectorss! existing-mu*_0 new-extra-inspectorss_0)))))))"
"(define-values"
"(struct:link-info"
" link-info1.1"
" link-info?"
" link-info-link-module-uses"
" link-info-imports"
" link-info-extra-inspectorsss"
" link-info-def-decls)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'link-info #f 4 0 #f null(current-inspector) #f '(0 1 2 3) #f 'link-info)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'link-module-uses)"
"(make-struct-field-accessor -ref_0 1 'imports)"
"(make-struct-field-accessor -ref_0 2 'extra-inspectorsss)"
"(make-struct-field-accessor -ref_0 3 'def-decls))))"
"(define-values"
"(compile-forms33.1)"
"(lambda(body-import-instances3_0"
" body-imports2_0"
" body-suffix-forms4_0"
" compiled-expression-callback8_0"
" cross-linklet-inlining?15_0"
" definition-callback9_0"
" encoded-root-expand-ctx-box6_0"
" force-phases5_0"
" get-module-linklet-info11_0"
" module-prompt?13_0"
" other-form-callback10_0"
" root-ctx-only-if-syntax?7_0"
" serializable?12_0"
" to-correlated-linklet?14_0"
" bodys30_0"
" cctx31_0"
" mpis32_0)"
"(begin"
" 'compile-forms33"
"(let-values(((bodys_0) bodys30_0))"
"(let-values(((cctx_0) cctx31_0))"
"(let-values(((mpis_0) mpis32_0))"
"(let-values(((body-imports_0) body-imports2_0))"
"(let-values(((body-import-instances_0) body-import-instances3_0))"
"(let-values(((body-suffix-forms_0) body-suffix-forms4_0))"
"(let-values(((force-phases_0) force-phases5_0))"
"(let-values(((encoded-root-expand-ctx-box_0) encoded-root-expand-ctx-box6_0))"
"(let-values(((root-ctx-only-if-syntax?_0) root-ctx-only-if-syntax?7_0))"
"(let-values(((compiled-expression-callback_0)"
"(if(eq? compiled-expression-callback8_0 unsafe-undefined)"
" void"
" compiled-expression-callback8_0)))"
"(let-values(((definition-callback_0)"
"(if(eq? definition-callback9_0 unsafe-undefined) void definition-callback9_0)))"
"(let-values(((other-form-callback_0)"
"(if(eq? other-form-callback10_0 unsafe-undefined)"
" void"
" other-form-callback10_0)))"
"(let-values(((get-module-linklet-info_0)"
"(if(eq? get-module-linklet-info11_0 unsafe-undefined)"
"(lambda(mod-name_0 p_0)(begin 'get-module-linklet-info #f))"
" get-module-linklet-info11_0)))"
"(let-values(((serializable?_0) serializable?12_0))"
"(let-values(((module-prompt?_0) module-prompt?13_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?14_0))"
"(let-values(((cross-linklet-inlining?_0) cross-linklet-inlining?15_0))"
"(let-values()"
"(let-values(((phase_0)(compile-context-phase cctx_0)))"
"(let-values(((self_0)(compile-context-self cctx_0)))"
"(let-values(((syntax-literals_0)(make-syntax-literals)))"
"(let-values(((phase-to-body_0)(make-hasheqv)))"
"(let-values(((add-body!_0)"
"(lambda(phase_1 body_0)"
"(begin"
" 'add-body!"
"(hash-update!"
" phase-to-body_0"
" phase_1"
"(lambda(l_0)(cons body_0 l_0))"
" null)))))"
"(let-values(((phase-to-header_0)(make-hasheqv)))"
"(let-values(((find-or-create-header!_0)"
"(lambda(phase_1)"
"(begin"
" 'find-or-create-header!"
"(let-values(((or-part_0)"
"(hash-ref"
" phase-to-header_0"
" phase_1"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((header_0)"
"(make-header"
" mpis_0"
" syntax-literals_0)))"
"(begin"
"(hash-set!"
" phase-to-header_0"
" phase_1"
" header_0)"
" header_0))))))))"
"(let-values((()"
"(begin"
"(let-values(((lst_0) force-phases_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((phase_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(find-or-create-header!_0"
" phase_1)"
"(add-body!_0"
" phase_1"
" '(void))))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(values))))"
"(let-values()"
"(let-values(((saw-define-syntaxes?_0) #f))"
"(let-values((()"
"(begin"
"(if(compile-context-module-self cctx_0)"
"(let-values()"
"((letrec-values(((loop!_0)"
"(lambda(bodys_1"
" phase_1"
" header_0)"
"(begin"
" 'loop!"
"(begin"
"(let-values(((lst_0)"
" bodys_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(parsed-define-values?"
" body_0)"
"(let-values()"
"(begin"
"(let-values(((lst_2)"
"(parsed-define-values-syms"
" body_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((def-sym_0)"
"(select-fresh"
" sym_0"
" header_0)))"
"(begin"
"(hash-set!"
"(header-binding-sym-to-define-sym"
" header_0)"
" sym_0"
" def-sym_0)"
"(set-header-binding-syms-in-order!"
" header_0"
"(cons"
" sym_0"
"(header-binding-syms-in-order"
" header_0)))"
"(register-as-defined!"
" header_0"
" def-sym_0))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2)))"
"(void)))"
"(if(parsed-begin-for-syntax?"
" body_0)"
"(let-values()"
"(loop!_0"
"(parsed-begin-for-syntax-body"
" body_0)"
"(add1"
" phase_1)"
"(find-or-create-header!_0"
"(add1"
" phase_1))))"
"(void))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void))))))"
" loop!_0)"
" bodys_0"
" phase_0"
"(find-or-create-header!_0 phase_0)))"
"(void))"
"(values))))"
"(let-values(((as-required?_0)"
"(lambda(header_0)"
"(begin"
" 'as-required?"
"(lambda(sym_0)"
"(registered-as-required?"
" header_0"
" sym_0))))))"
"(let-values(((last-i_0)(sub1(length bodys_0))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop!_0)"
"(lambda(bodys_1"
" phase_1"
" header_0)"
"(begin"
" 'loop!"
"(begin"
"(let-values(((lst_0)"
" bodys_1)"
"((start_0)"
" 0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-naturals"
" start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1"
" pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_1)"
" #t"
" #f)"
"(let-values(((body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1))"
"((i_0)"
" pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(parsed-define-values?"
" body_0)"
"(let-values()"
"(let-values(((ids_0)"
"(parsed-define-values-ids"
" body_0)))"
"(let-values(((binding-syms_0)"
"(parsed-define-values-syms"
" body_0)))"
"(let-values(((def-syms_0)"
"(if(compile-context-module-self"
" cctx_0)"
"(let-values()"
"(reverse$1"
"(let-values(((lst_2)"
" binding-syms_0)"
"((lst_3)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_3)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_0"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_4)"
"(pair?"
" lst_5)"
" #f)"
"(let-values(((binding-sym_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((id_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(correlate-source-name"
"(hash-ref"
"(header-binding-sym-to-define-sym"
" header_0)"
" binding-sym_0)"
"(syntax-e$1"
" id_0)))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_1"
" rest_1"
" rest_2)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_1)"
" null"
" lst_2"
" lst_3)))))"
"(let-values()"
"(reverse$1"
"(let-values(((lst_2)"
" binding-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((binding-sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((header61_0)"
" header_0)"
"((temp62_0)"
"(compile-context-self"
" cctx_0))"
"((phase63_0)"
" phase_1)"
"((binding-sym64_0)"
" binding-sym_0)"
"((temp65_0)"
" #f)"
"((temp66_0)"
" #t))"
"(register-required-variable-use!19.1"
" temp66_0"
" header61_0"
" temp62_0"
" phase63_0"
" binding-sym64_0"
" temp65_0)))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_1"
" rest_1)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_1)"
" null"
" lst_2))))))))"
"(let-values(((rhs_0)"
"(compile$2"
"(parsed-define-values-rhs"
" body_0)"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase67_0)"
" phase_1)"
"((header68_0)"
" header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase67_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header68_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                            \"compile-context?\""
" the-struct_0)))"
"(if(="
"(length"
" ids_0)"
" 1)"
"(car"
" ids_0)"
" #f))))"
"(begin"
"(definition-callback_0)"
"(compiled-expression-callback_0"
" rhs_0"
"(length"
" def-syms_0)"
" phase_1"
"(as-required?_0"
" header_0))"
"(add-body!_0"
" phase_1"
"(propagate-inline-property"
"(correlate*"
"(parsed-s"
" body_0)"
"(list"
" 'define-values"
" def-syms_0"
" rhs_0))"
"(parsed-s"
" body_0)))"
"(if(let-values(((or-part_0)"
"(compile-context-module-self"
" cctx_0)))"
"(if or-part_0"
" or-part_0"
"(null?"
" ids_0)))"
"(void)"
"(let-values()"
"(begin"
"(add-body!_0"
" phase_1"
"(list*"
" 'if"
" #f"
"(list*"
" 'begin"
"(reverse$1"
"(let-values(((lst_2)"
" def-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((def-sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list*"
" 'set!"
" def-sym_0"
" '(#f)))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_1"
" rest_1)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_1)"
" null"
" lst_2)))))"
" '((void))))"
"(add-body!_0"
" phase_1"
"(compile-top-level-bind"
" ids_0"
" binding-syms_0"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase69_0)"
" phase_1)"
"((header70_0)"
" header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase69_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header70_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                         \"compile-context?\""
" the-struct_0)))"
" #f)))))))))))"
"(if(parsed-define-syntaxes?"
" body_0)"
"(let-values()"
"(let-values(((ids_0)"
"(parsed-define-syntaxes-ids"
" body_0)))"
"(let-values(((binding-syms_0)"
"(parsed-define-syntaxes-syms"
" body_0)))"
"(let-values(((next-header_0)"
"(find-or-create-header!_0"
"(add1"
" phase_1))))"
"(let-values(((gen-syms_0)"
"(reverse$1"
"(let-values(((lst_2)"
" binding-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((binding-sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((gen-sym_0)"
"(select-fresh"
" binding-sym_0"
" next-header_0)))"
"(begin"
"(register-as-defined!"
" next-header_0"
" gen-sym_0)"
" gen-sym_0)))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_1"
" rest_1)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_1)"
" null"
" lst_2))))))"
"(let-values(((rhs_0)"
"(compile$2"
"(parsed-define-syntaxes-rhs"
" body_0)"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase71_0)"
"(add1"
" phase_1))"
"((header72_0)"
" next-header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase71_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header72_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                \"compile-context?\""
" the-struct_0))))))"
"(let-values((()"
"(begin"
"(definition-callback_0)"
"(values))))"
"(let-values((()"
"(begin"
"(compiled-expression-callback_0"
" rhs_0"
"(length"
" gen-syms_0)"
"(add1"
" phase_1)"
"(as-required?_0"
" header_0))"
"(values))))"
"(let-values(((transformer-set!s_0)"
"(reverse$1"
"(let-values(((lst_2)"
" binding-syms_0)"
"((lst_3)"
" gen-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_3)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_0"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_4)"
"(pair?"
" lst_5)"
" #f)"
"(let-values(((binding-sym_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((gen-sym_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list"
" set-transformer!-id"
"(list"
" 'quote"
" binding-sym_0)"
" gen-sym_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_1"
" rest_1"
" rest_2)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_1)"
" null"
" lst_2"
" lst_3))))))"
"(begin"
"(if(compile-context-module-self"
" cctx_0)"
"(let-values()"
"(add-body!_0"
"(add1"
" phase_1)"
"(list"
" 'let-values"
"(list"
"(list"
" gen-syms_0"
" rhs_0))"
"(list*"
" 'begin"
"(qq-append"
" transformer-set!s_0"
" '((void)))))))"
"(let-values()"
"(add-body!_0"
"(add1"
" phase_1)"
"(generate-top-level-define-syntaxes"
" gen-syms_0"
" rhs_0"
" transformer-set!s_0"
"(compile-top-level-bind"
" ids_0"
" binding-syms_0"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase73_0)"
" phase_1)"
"((header74_0)"
" header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase73_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header74_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                  \"compile-context?\""
" the-struct_0)))"
" gen-syms_0)))))"
"(set! saw-define-syntaxes?_0"
" #t)))))))))))"
"(if(parsed-begin-for-syntax?"
" body_0)"
"(let-values()"
"(loop!_0"
"(parsed-begin-for-syntax-body"
" body_0)"
"(add1"
" phase_1)"
"(find-or-create-header!_0"
"(add1"
" phase_1))))"
"(if(let-values(((or-part_0)"
"(parsed-#%declare?"
" body_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(parsed-module?"
" body_0)))"
"(if or-part_1"
" or-part_1"
"(parsed-require?"
" body_0)))))"
"(let-values()"
"(let-values(((e_0)"
"(other-form-callback_0"
" body_0"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase75_0)"
" phase_1)"
"((header76_0)"
" header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase75_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header76_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                            \"compile-context?\""
" the-struct_0))))))"
"(if e_0"
"(let-values()"
"(begin"
"(compiled-expression-callback_0"
" e_0"
" #f"
" phase_1"
"(as-required?_0"
" header_0))"
"(add-body!_0"
" phase_1"
" e_0)))"
"(void))))"
"(let-values()"
"(let-values(((e_0)"
"(compile$2"
" body_0"
"(let-values(((the-struct_0)"
" cctx_0))"
"(if(compile-context?"
" the-struct_0)"
"(let-values(((phase77_0)"
" phase_1)"
"((header78_0)"
" header_0))"
"(compile-context1.1"
"(compile-context-namespace"
" the-struct_0)"
" phase77_0"
"(compile-context-self"
" the-struct_0)"
"(compile-context-module-self"
" the-struct_0)"
"(compile-context-full-module-name"
" the-struct_0)"
"(compile-context-lazy-syntax-literals?"
" the-struct_0)"
" header78_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                            \"compile-context?\""
" the-struct_0)))"
" #f"
"(="
" i_0"
" last-i_0))))"
"(begin"
"(compiled-expression-callback_0"
" e_0"
" #f"
" phase_1"
"(as-required?_0"
" header_0))"
"(add-body!_0"
" phase_1"
" e_0)))))))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0"
"(+"
" pos_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" start_0)))"
"(void))))))"
" loop!_0)"
" bodys_0"
" phase_0"
"(find-or-create-header!_0 phase_0))"
"(values))))"
"(let-values(((encoded-root-expand-pos_0)"
"(if encoded-root-expand-ctx-box_0"
"(if(unbox"
" encoded-root-expand-ctx-box_0)"
"(if(not"
"(if root-ctx-only-if-syntax?_0"
"(if(not"
" saw-define-syntaxes?_0)"
"(syntax-literals-empty?"
" syntax-literals_0)"
" #f)"
" #f))"
"(add-syntax-literal!"
" syntax-literals_0"
"(unbox"
" encoded-root-expand-ctx-box_0))"
" #f)"
" #f)"
" #f)))"
"(let-values(((phases-in-order_0)"
"(let-values(((temp79_0)"
"(hash-keys"
" phase-to-body_0))"
"((<80_0) <))"
"(sort7.1"
" #f"
" #f"
" temp79_0"
" <80_0))))"
"(let-values(((min-phase_0)"
"(if(pair? phases-in-order_0)"
"(car phases-in-order_0)"
" phase_0)))"
"(let-values(((max-phase_0)"
"(if(pair? phases-in-order_0)"
"(car"
"(reverse$1"
" phases-in-order_0))"
" phase_0)))"
"(let-values(((phase-to-link-info_0)"
"(let-values(((lst_0)"
" phases-in-order_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((phase_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values(((header_0)"
"(hash-ref"
" phase-to-header_0"
" phase_1"
" #f)))"
"(let-values(((link-module-uses_0"
" imports_0"
" extra-inspectorsss_0"
" def-decls_0)"
"(generate-links+imports"
" header_0"
" phase_1"
" cctx_0"
" cross-linklet-inlining?_0)))"
"(values"
" phase_1"
"(link-info1.1"
" link-module-uses_0"
" imports_0"
" extra-inspectorsss_0"
" def-decls_0)))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_1"
" rest_0)"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
" lst_0)))))"
"(let-values(((body-linklets+module-use*s_0)"
"(let-values(((lst_0)"
" phases-in-order_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((phase_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values(((bodys_1)"
"(hash-ref"
" phase-to-body_0"
" phase_1)))"
"(let-values(((li_0)"
"(hash-ref"
" phase-to-link-info_0"
" phase_1)))"
"(let-values(((binding-sym-to-define-sym_0)"
"(header-binding-sym-to-define-sym"
"(hash-ref"
" phase-to-header_0"
" phase_1))))"
"(let-values(((module-use*s_0)"
"(module-uses-add-extra-inspectorsss"
"(link-info-link-module-uses"
" li_0)"
"(link-info-extra-inspectorsss"
" li_0))))"
"(let-values(((body-linklet_0)"
"(list*"
" 'linklet"
"(qq-append"
" body-imports_0"
"(link-info-imports"
" li_0))"
"(qq-append"
"(link-info-def-decls"
" li_0)"
"(reverse$1"
"(let-values(((lst_2)"
"(header-binding-syms-in-order"
"(hash-ref"
" phase-to-header_0"
" phase_1))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((binding-sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((def-sym_0)"
"(hash-ref"
" binding-sym-to-define-sym_0"
" binding-sym_0)))"
"(if(eq?"
" def-sym_0"
" binding-sym_0)"
" def-sym_0"
"(list"
" def-sym_0"
" binding-sym_0))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_1"
" rest_1)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_1)"
" null"
" lst_2)))))"
"(qq-append"
"(reverse$1"
" bodys_1)"
" body-suffix-forms_0))))"
"(let-values(((linklet_0"
" new-module-use*s_0)"
"(if to-correlated-linklet?_0"
"(let-values()"
"(values"
"(make-correlated-linklet"
" body-linklet_0"
" 'module)"
" module-use*s_0))"
"(let-values()"
"(let-values(((body-linklet81_0)"
" body-linklet_0)"
"((body-imports82_0)"
" body-imports_0)"
"((body-import-instances83_0)"
" body-import-instances_0)"
"((get-module-linklet-info84_0)"
" get-module-linklet-info_0)"
"((serializable?85_0)"
" serializable?_0)"
"((module-prompt?86_0)"
" module-prompt?_0)"
"((module-use*s87_0)"
" module-use*s_0)"
"((cross-linklet-inlining?88_0)"
" cross-linklet-inlining?_0)"
"((temp89_0)"
" #f)"
"((temp90_0)"
"(compile-context-namespace"
" cctx_0)))"
"(compile-module-linklet57.1"
" body-import-instances83_0"
" body-imports82_0"
" unsafe-undefined"
" cross-linklet-inlining?88_0"
" get-module-linklet-info84_0"
" temp89_0"
" module-prompt?86_0"
" module-use*s87_0"
" temp90_0"
" serializable?85_0"
" body-linklet81_0))))))"
"(values"
" phase_1"
"(cons"
" linklet_0"
" new-module-use*s_0)))))))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_1"
" rest_0)"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
" lst_0)))))"
"(let-values(((body-linklets_0)"
"(let-values(((ht_0)"
" body-linklets+module-use*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_1"
" l+mu*s_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_1"
"(car"
" l+mu*s_0)))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first"
" ht_0))))))"
"(let-values(((phase-to-link-module-uses_0)"
"(let-values(((ht_0)"
" body-linklets+module-use*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_1"
" l+mu*s_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_1"
"(module-uses-strip-extra-inspectorsss"
"(cdr"
" l+mu*s_0))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first"
" ht_0))))))"
"(let-values(((phase-to-link-module-uses-expr_0)"
"(serialize-phase-to-link-module-uses"
" phase-to-link-module-uses_0"
" mpis_0)))"
"(let-values(((phase-to-link-extra-inspectorsss_0)"
"(let-values(((ht_0)"
" body-linklets+module-use*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_1"
" l+mu*s_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((extra-inspectorsss_0)"
"(module-uses-extract-extra-inspectorsss"
"(cdr"
" l+mu*s_0)"
"(car"
" l+mu*s_0)"
"(if cross-linklet-inlining?_0"
"(not"
" to-correlated-linklet?_0)"
" #f)"
"(length"
" body-imports_0))))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(table_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((table_2)"
"(let-values(((table_2)"
" table_1))"
"(if extra-inspectorsss_0"
"(let-values(((table_3)"
" table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_1"
" extra-inspectorsss_0))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4)))"
" table_2))))"
" table_2))))))"
" for-loop_1)"
" table_0)))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first"
" ht_0))))))"
"(values"
" body-linklets_0"
" min-phase_0"
" max-phase_0"
" phase-to-link-module-uses_0"
" phase-to-link-module-uses-expr_0"
" phase-to-link-extra-inspectorsss_0"
" syntax-literals_0"
" encoded-root-expand-pos_0))))))))))))))))))))))))))))))))))))))))))))))"
"(define-values"
"(compile-top-level-bind)"
"(lambda(ids_0 binding-syms_0 cctx_0 trans-exprs_0)"
"(begin"
"(let-values(((phase_0)(compile-context-phase cctx_0)))"
"(let-values(((self_0)(compile-context-self cctx_0)))"
"(let-values(((header_0)(compile-context-header cctx_0)))"
"(let-values(((mpis_0)(header-module-path-indexes header_0)))"
"(let-values(((top-level-bind-scope_0)"
"(root-expand-context-top-level-bind-scope"
"(namespace-get-root-expand-ctx(compile-context-namespace cctx_0)))))"
"(let-values(((self-expr_0)(add-module-path-index! mpis_0 self_0)))"
"(list*"
" 'begin"
"(reverse$1"
"(let-values(((lst_0) ids_0)"
"((lst_1) binding-syms_0)"
"((lst_2)"
"(let-values(((or-part_0) trans-exprs_0))"
"(if or-part_0"
" or-part_0"
"(reverse$1"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" ''#f)"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_3 lst_4 lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_3)(if(pair? lst_4)(pair? lst_5) #f) #f)"
"(let-values(((id_0)(unsafe-car lst_3))"
"((rest_0)(unsafe-cdr lst_3))"
"((binding-sym_0)(unsafe-car lst_4))"
"((rest_1)(unsafe-cdr lst_4))"
"((trans-expr_0)(unsafe-car lst_5))"
"((rest_2)(unsafe-cdr lst_5)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((id-stx_0)"
"(compile-quote-syntax"
"(remove-scope"
" id_0"
" top-level-bind-scope_0)"
" cctx_0)))"
"(list"
" top-level-bind!-id"
" id-stx_0"
" self-expr_0"
" phase_0"
" phase-shift-id"
" ns-id"
"(list 'quote binding-sym_0)"
"(if trans-exprs_0 #t #f)"
" trans-expr_0)))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0 rest_1 rest_2)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1"
" lst_2))))))))))))))"
"(define-values"
"(generate-top-level-define-syntaxes)"
"(lambda(gen-syms_0 rhs_0 transformer-set!s_0 finish_0)"
"(begin"
"(list"
" 'call-with-values"
"(list 'lambda '() rhs_0)"
"(list"
" 'case-lambda"
"(list gen-syms_0(list* 'begin(qq-append transformer-set!s_0(list* finish_0 '((void))))))"
"(list"
" '()"
"(list"
" 'let-values"
"(list"
"(list"
" gen-syms_0"
"(list*"
" 'values"
"(reverse$1"
"(let-values(((lst_0) gen-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons(let-values() ''#f) fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(list* 'begin finish_0 '((void)))))"
"(list 'args(list* 'let-values(list(list* gen-syms_0 '((apply values args)))) '((void)))))))))"
"(define-values"
"(propagate-inline-property)"
"(lambda(e_0 orig-s_0)"
"(begin"
"(let-values(((v_0)(syntax-property$1 orig-s_0 'compiler-hint:cross-module-inline)))"
"(if v_0(correlated-property e_0 'compiler-hint:cross-module-inline v_0) e_0)))))"
"(define-values"
"(compile-module-linklet57.1)"
"(lambda(body-import-instances38_0"
" body-imports37_0"
" compile-linklet36_0"
" cross-linklet-inlining?43_0"
" get-module-linklet-info39_0"
" load-modules?44_0"
" module-prompt?41_0"
" module-use*s42_0"
" namespace45_0"
" serializable?40_0"
" body-linklet56_0)"
"(begin"
" 'compile-module-linklet57"
"(let-values(((body-linklet_0) body-linklet56_0))"
"(let-values(((compile-linklet_0)"
"(if(eq? compile-linklet36_0 unsafe-undefined) 1/compile-linklet compile-linklet36_0)))"
"(let-values(((body-imports_0) body-imports37_0))"
"(let-values(((body-import-instances_0) body-import-instances38_0))"
"(let-values(((get-module-linklet-info_0) get-module-linklet-info39_0))"
"(let-values(((serializable?_0) serializable?40_0))"
"(let-values(((module-prompt?_0) module-prompt?41_0))"
"(let-values(((module-use*s_0) module-use*s42_0))"
"(let-values(((cross-linklet-inlining?_0) cross-linklet-inlining?43_0))"
"(let-values(((load-modules?_0) load-modules?44_0))"
"(let-values(((namespace_0) namespace45_0))"
"(let-values()"
"(let-values(((linklet_0 new-module-use*s_0)"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'compile '_ 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"((lambda(l_0 name_0 keys_0 getter_0)"
"(compile-linklet_0"
" l_0"
" name_0"
" keys_0"
" getter_0"
"(if serializable?_0"
"(if module-prompt?_0 '(serializable use-prompt) '(serializable))"
"(if module-prompt?_0 '(use-prompt) '()))))"
" body-linklet_0"
" 'module"
"(list->vector(append body-import-instances_0 module-use*s_0))"
"(make-module-use-to-linklet"
" cross-linklet-inlining?_0"
" load-modules?_0"
" namespace_0"
" get-module-linklet-info_0"
" module-use*s_0)))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void))))))"
"(values"
" linklet_0"
"(list-tail(vector->list new-module-use*s_0)(length body-imports_0)))))))))))))))))))"
"(define-values"
"(make-module-use-to-linklet)"
"(lambda(cross-linklet-inlining?_0 load-modules?_0 ns_0 get-module-linklet-info_0 init-mu*s_0)"
"(begin"
"(let-values(((mu*-intern-table_0)(make-hash)))"
"(let-values(((intern-module-use*_0)"
"(lambda(mu*_0)"
"(begin"
" 'intern-module-use*"
"(let-values(((mod-name_0)(1/module-path-index-resolve(module-use-module mu*_0))))"
"(let-values(((existing-mu*_0)"
"(hash-ref mu*-intern-table_0(cons mod-name_0(module-use-phase mu*_0)) #f)))"
"(if existing-mu*_0"
"(let-values()"
"(begin(module-use-merge-extra-inspectorss! existing-mu*_0 mu*_0) existing-mu*_0))"
"(let-values()"
"(begin"
"(hash-set! mu*-intern-table_0(cons mod-name_0(module-use-phase mu*_0)) mu*_0)"
" mu*_0)))))))))"
"(begin"
"(let-values(((lst_0) init-mu*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((mu*_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()(intern-module-use*_0 mu*_0))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(lambda(mu*-or-instance_0)"
"(if(1/instance? mu*-or-instance_0)"
"(let-values()(values mu*-or-instance_0 #f))"
"(if(not cross-linklet-inlining?_0)"
"(let-values()(values #f #f))"
"(if mu*-or-instance_0"
"(let-values()"
"(let-values(((mu*_0) mu*-or-instance_0))"
"(let-values(((mod-name_0)"
"(1/module-path-index-resolve(module-use-module mu*_0) load-modules?_0)))"
"(let-values(((mli_0)"
"(let-values(((or-part_0)"
"(get-module-linklet-info_0 mod-name_0(module-use-phase mu*_0))))"
"(if or-part_0"
" or-part_0"
"(namespace->module-linklet-info"
" ns_0"
" mod-name_0"
"(module-use-phase mu*_0))))))"
"(begin"
"(if mli_0"
"(let-values()"
"(module-use*-declaration-inspector! mu*_0(module-linklet-info-inspector mli_0)))"
"(void))"
"(if mli_0"
"(values"
"(module-linklet-info-linklet-or-instance mli_0)"
"(if(module-linklet-info-module-uses mli_0)"
"(list->vector"
"(append"
" '(#f #f)"
"(let-values(((mus_0)(module-linklet-info-module-uses mli_0))"
"((extra-inspectorsss_0)"
"(module-linklet-info-extra-inspectorsss mli_0)))"
"(reverse$1"
"(let-values(((lst_0) mus_0)"
"((lst_1)"
"(1/linklet-import-variables"
"(module-linklet-info-linklet-or-instance mli_0)))"
"((lst_2)"
"(let-values(((or-part_0) extra-inspectorsss_0))"
"(if or-part_0 or-part_0 mus_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_3 lst_4 lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_3)"
"(if(pair? lst_4)(pair? lst_5) #f)"
" #f)"
"(let-values(((sub-mu_0)(unsafe-car lst_3))"
"((rest_0)(unsafe-cdr lst_3))"
"((imports_0)(unsafe-car lst_4))"
"((rest_1)(unsafe-cdr lst_4))"
"((extra-inspectorss_0)"
"(unsafe-car lst_5))"
"((rest_2)(unsafe-cdr lst_5)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(intern-module-use*_0"
"(module-use+extra-inspectors"
"(module-path-index-shift"
"(module-use-module"
" sub-mu_0)"
"(module-linklet-info-self"
" mli_0)"
"(module-use-module"
" mu*_0))"
"(module-use-phase"
" sub-mu_0)"
" imports_0"
"(module-linklet-info-inspector"
" mli_0)"
"(module-linklet-info-extra-inspector"
" mli_0)"
"(if extra-inspectorsss_0"
" extra-inspectorss_0"
" #f))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0 rest_1 rest_2)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1"
" lst_2)))))))"
" #f))"
"(values #f #f)))))))"
"(let-values()(values #f #f))))))))))))"
"(define-values"
"(build-shared-data-linklet)"
"(lambda(cims_0 ns_0)"
"(begin"
"(let-values(((mpis_0)(make-module-path-index-table)))"
"(let-values(((mpi-trees_0)"
"(map-cim-tree"
" cims_0"
"(lambda(cim_0)"
"(let-values(((vec_0 i_0)"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0)(compiled-in-memory-mpis cim_0)))"
"(begin"
"(check-vector vec_0)"
"(values vec_0(unsafe-vector-length vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(vec_1 i_0 pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((mpi_0)"
"(unsafe-vector-ref vec_0 pos_0)))"
"(let-values(((vec_2 i_1)"
"(let-values(((vec_2) vec_1)"
"((i_1) i_0))"
"(let-values(((vec_3 i_2)"
"(let-values()"
"(let-values(((new-vec_0)"
"(if(eq?"
" i_1"
"(unsafe-vector*-length"
" vec_2))"
"(grow-vector"
" vec_2)"
" vec_2)))"
"(begin"
"(unsafe-vector*-set!"
" new-vec_0"
" i_1"
"(let-values()"
"(add-module-path-index!/pos"
" mpis_0"
" mpi_0)))"
"(values"
" new-vec_0"
"(unsafe-fx+"
" i_1"
" 1)))))))"
"(values vec_3 i_2)))))"
"(if(not #f)"
"(for-loop_0 vec_2 i_1(unsafe-fx+ 1 pos_0))"
"(values vec_2 i_1))))"
"(values vec_1 i_0))))))"
" for-loop_0)"
"(make-vector 16)"
" 0"
" 0)))))"
"(shrink-vector vec_0 i_0))))))"
"(let-values(((syntax-literals_0)(make-syntax-literals)))"
"(let-values(((syntax-literals-trees_0)"
"(map-cim-tree"
" cims_0"
"(lambda(cim_0)"
"(add-syntax-literals! syntax-literals_0(compiled-in-memory-syntax-literals cim_0))))))"
"(let-values(((module-uses-tables_0) null))"
"(let-values(((module-uses-tables-count_0) 0))"
"(let-values(((phase-to-link-module-uses-trees_0)"
"(map-cim-tree"
" cims_0"
"(lambda(cim_0)"
"(let-values(((pos_0) module-uses-tables-count_0))"
"(begin"
"(set! module-uses-tables_0"
"(cons"
"(compiled-in-memory-phase-to-link-module-uses cim_0)"
" module-uses-tables_0))"
"(set! module-uses-tables-count_0(add1 pos_0))"
" pos_0))))))"
"(let-values(((syntax-literals-expr_0)"
"(generate-eager-syntax-literals! syntax-literals_0 mpis_0 0 #f ns_0)))"
"(let-values(((phase-to-link-module-uses-expr_0)"
"(list*"
" 'vector"
"(reverse$1"
"(let-values(((lst_0)(reverse$1 module-uses-tables_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((phase-to-link-module-uses_0)"
"(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(serialize-phase-to-link-module-uses"
" phase-to-link-module-uses_0"
" mpis_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(1/compile-linklet"
"(list"
" 'linklet"
"(list deserialize-imports eager-instance-imports)"
"(list*"
" mpi-vector-id"
" '(mpi-vector-trees"
" phase-to-link-modules-vector"
" phase-to-link-modules-trees"
" syntax-literals"
" syntax-literals-trees))"
"(list 'define-values(list mpi-vector-id)(generate-module-path-index-deserialize mpis_0))"
"(list 'define-values '(mpi-vector-trees)(list 'quote mpi-trees_0))"
"(list 'define-values '(phase-to-link-modules-vector) phase-to-link-module-uses-expr_0)"
"(list"
" 'define-values"
" '(phase-to-link-modules-trees)"
"(list 'quote phase-to-link-module-uses-trees_0))"
"(list 'define-values '(syntax-literals) syntax-literals-expr_0)"
"(list"
" 'define-values"
" '(syntax-literals-trees)"
"(list 'quote syntax-literals-trees_0))))))))))))))))"
"(define-values"
"(map-cim-tree)"
"(lambda(cims_0 proc_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(cims_1)"
"(begin"
" 'loop"
"(reverse$1"
"(let-values(((lst_0) cims_1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((cim_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(vector"
"(proc_0 cim_0)"
"(loop_0"
"(compiled-in-memory-pre-compiled-in-memorys"
" cim_0))"
"(loop_0"
"(compiled-in-memory-post-compiled-in-memorys"
" cim_0))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))"
" loop_0)"
" cims_0))))"
"(define-values"
"(compiled-tops->compiled-top8.1)"
"(lambda(merge-serialization?2_0 namespace3_0 to-correlated-linklet?1_0 all-cims7_0)"
"(begin"
" 'compiled-tops->compiled-top8"
"(let-values(((all-cims_0) all-cims7_0))"
"(let-values()"
"(let-values(((merge-serialization?_0) merge-serialization?2_0))"
"(let-values(((ns_0) namespace3_0))"
"(let-values()"
"(let-values(((cims_0)(remove-nontail-purely-functional all-cims_0)))"
"(if(= 1(length cims_0))"
"(let-values()(car cims_0))"
"(let-values()"
"(let-values(((sequence-ht_0)"
"(let-values(((lst_0) cims_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1) #t #f)"
"(let-values(((cim_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1))"
"((i_0) pos_0))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
"(string->symbol"
"(number->string"
" i_0))"
"(compiled-in-memory-linklet-directory"
" cim_0)))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1 rest_0(+ pos_0 1))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
" lst_0"
" start_0)))))"
"(let-values(((ht_0)"
"(if merge-serialization?_0"
"(hash-set"
" sequence-ht_0"
" 'data"
"(hash->linklet-directory"
"(hasheq"
" #f"
"(hash->linklet-bundle(hasheq 0(build-shared-data-linklet cims_0 ns_0))))))"
" sequence-ht_0)))"
"(compiled-in-memory1.1"
"(hash->linklet-directory ht_0)"
" #f"
" #f"
" #f"
" '#hasheqv()"
" #f"
" '#hasheqv()"
" '#()"
" '#()"
" cims_0"
" null"
" #f"
" #f))))))))))))))"
"(define-values"
"(compiled-top->compiled-tops)"
"(lambda(ld_0)"
"(begin"
"(let-values(((ht_0)(linklet-directory->hash ld_0)))"
"(reverse$1"
"(let-values(((start_0) 0)((end_0)(hash-count ht_0))((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((i_0) pos_0))"
"(let-values(((fold-var_1)"
"(let-values(((top_0)"
"(hash-ref"
" ht_0"
"(string->symbol(number->string i_0))"
" #f)))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" fold-var_1))"
"(if top_0"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
" top_0)"
" fold-var_3))))"
"(values"
" fold-var_4)))"
" fold-var_2))))"
" fold-var_2))))))"
" for-loop_1)"
" fold-var_0)))))"
"(if(not #f)(for-loop_0 fold-var_1(+ pos_0 inc_0)) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" start_0))))))))"
"(define-values"
"(remove-nontail-purely-functional)"
"(lambda(cims_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(cims_1)"
"(begin"
" 'loop"
"(if(null? cims_1)"
"(let-values() null)"
"(if(null?(cdr cims_1))"
"(let-values() cims_1)"
"(if(if(compiled-in-memory?(car cims_1))"
"(compiled-in-memory-purely-functional?(car cims_1))"
" #f)"
"(let-values()(loop_0(cdr cims_1)))"
"(let-values()(cons(car cims_1)(cdr cims_1))))))))))"
" loop_0)"
" cims_0))))"
"(define-values"
"(struct:known-defined/delay known-defined/delay2.1 known-defined/delay? known-defined/delay-thunk)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'known-defined/delay #f 1 0 #f null 'prefab #f '(0) #f 'known-defined/delay)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'thunk))))"
"(define-values"
"(struct:known-property known-property3.1 known-property?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'known-property #f 0 0 #f null 'prefab #f '() #f 'known-property)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(struct:known-function known-function4.1 known-function? known-function-arity known-function-pure?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'known-function #f 2 0 #f null 'prefab #f '(0 1) #f 'known-function)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'arity)"
"(make-struct-field-accessor -ref_0 1 'pure?))))"
"(define-values"
"(struct:known-function-of-satisfying"
" known-function-of-satisfying5.1"
" known-function-of-satisfying?"
" known-function-of-satisfying-arg-predicate-keys)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'known-function-of-satisfying"
" #f"
" 1"
" 0"
" #f"
" null"
" 'prefab"
" #f"
" '(0)"
" #f"
" 'known-function-of-satisfying)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'arg-predicate-keys))))"
"(define-values"
"(struct:known-predicate known-predicate6.1 known-predicate? known-predicate-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'known-predicate #f 1 0 #f null 'prefab #f '(0) #f 'known-predicate)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'key))))"
"(define-values"
"(struct:known-satisfies known-satisfies7.1 known-satisfies? known-satisfies-predicate-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'known-satisfies #f 1 0 #f null 'prefab #f '(0) #f 'known-satisfies)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'predicate-key))))"
"(define-values"
"(struct:known-struct-op known-struct-op8.1 known-struct-op? known-struct-op-type known-struct-op-field-count)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'known-struct-op #f 2 0 #f null 'prefab #f '(0 1) #f 'known-struct-op)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'type)"
"(make-struct-field-accessor -ref_0 1 'field-count))))"
"(define-values"
"(lookup-defn)"
"(lambda(defns_0 sym_0)"
"(begin"
"(let-values(((d_0)(hash-ref defns_0 sym_0 #f)))"
"(if(known-defined/delay? d_0)"
"(let-values()(begin((known-defined/delay-thunk d_0))(lookup-defn defns_0 sym_0)))"
"(let-values() d_0))))))"
"(define-values"
"(any-side-effects?9.1)"
"(lambda(known-defns2_0 known-locals1_0 ready-variable?3_0 e7_0 expected-results8_0)"
"(begin"
" 'any-side-effects?9"
"(let-values(((e_0) e7_0))"
"(let-values(((expected-results_0) expected-results8_0))"
"(let-values(((locals_0)(if(eq? known-locals1_0 unsafe-undefined) '#hasheq() known-locals1_0)))"
"(let-values(((defns_0)(if(eq? known-defns2_0 unsafe-undefined) '#hasheq() known-defns2_0)))"
"(let-values(((ready-variable?_0)"
"(if(eq? ready-variable?3_0 unsafe-undefined)"
"(lambda(id_0)(begin 'ready-variable? #f))"
" ready-variable?3_0)))"
"(let-values()"
"(let-values(((effects?_0)"
"(lambda(e_1 expected-results_1 locals_1)"
"(begin"
" 'effects?"
"(let-values(((e12_0) e_1)"
"((expected-results13_0) expected-results_1)"
"((locals14_0) locals_1)"
"((defns15_0) defns_0)"
"((ready-variable?16_0) ready-variable?_0))"
"(any-side-effects?9.1"
" defns15_0"
" locals14_0"
" ready-variable?16_0"
" e12_0"
" expected-results13_0))))))"
"(let-values(((actual-results_0)"
"((letrec-values(((loop_0)"
"(lambda(e_1 locals_1)"
"(begin"
" 'loop"
"(let-values(((tmp_0)"
"(if(pair?(correlated-e e_1))"
"(correlated-e(car(correlated-e e_1)))"
" #f)))"
"(let-values(((index_0)"
"(if(symbol? tmp_0)"
"(hash-ref"
" '#hasheq((#%variable-reference . 1)"
"(begin . 5)"
"(begin0 . 6)"
"(case-lambda . 1)"
"(gensym . 11)"
"(if . 12)"
"(lambda . 1)"
"(let-values . 2)"
"(letrec-values . 2)"
"(make-struct-field-accessor . 8)"
"(make-struct-field-mutator . 9)"
"(make-struct-type . 7)"
"(make-struct-type-property . 10)"
"(quote . 1)"
"(values . 3)"
"(void . 4))"
" tmp_0"
"(lambda() 0))"
" 0)))"
"(if(unsafe-fx< index_0 6)"
"(if(unsafe-fx< index_0 2)"
"(if(unsafe-fx< index_0 1)"
"(let-values()"
"(let-values(((v_0)(correlated-e e_1)))"
"(if(let-values(((or-part_0)(string? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(number? v_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(boolean? v_0)))"
"(if or-part_2"
" or-part_2"
"(char? v_0)))))))"
"(let-values() 1)"
"(let-values(((c1_0)"
"(if(pair? v_0)"
"(let-values(((rator_0)"
"(correlated-e"
"(car v_0))))"
"(let-values(((or-part_0)"
"(hash-ref"
" locals_1"
" rator_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(lookup-defn"
" defns_0"
" rator_0))))"
" #f)))"
"(if c1_0"
"((lambda(d_0)"
"(let-values(((ok?_0 _17_0 e18_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((_17_0"
" e18_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((_19_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e20_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                            \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _19_0"
" e20_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                    \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _17_0"
" e18_0))))))"
"(let-values(((n-args_0)"
"(length e18_0)))"
"(if(let-values(((or-part_0)"
"(if(let-values(((or-part_0)"
"(if(known-struct-op?"
" d_0)"
"(if(eq?"
" 'constructor"
"(known-struct-op-type"
" d_0))"
"(="
"(known-struct-op-field-count"
" d_0)"
" n-args_0)"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(if(known-function?"
" d_0)"
"(if(known-function-pure?"
" d_0)"
"(arity-includes?"
"(known-function-arity"
" d_0)"
" n-args_0)"
" #f)"
" #f)))"
"(let-values(((lst_0)"
" e18_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((e_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(not"
"(effects?_0"
" e_2"
" 1"
" locals_1))))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_1))"
" e_2))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" result_1"
" rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(if(known-function-of-satisfying?"
" d_0)"
"(if(="
" n-args_0"
"(length"
"(known-function-of-satisfying-arg-predicate-keys"
" d_0)))"
"(let-values(((lst_0)"
" e18_0)"
"((lst_1)"
"(known-function-of-satisfying-arg-predicate-keys"
" d_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_2)"
"(pair?"
" lst_3)"
" #f)"
"(let-values(((e_2)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((key_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(if(not"
"(effects?_0"
" e_2"
" 1"
" locals_1))"
"(satisfies?"
" e_2"
" key_0"
" defns_0"
" locals_1)"
" #f)))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_1))"
" e_2))"
"(if(not"
"((lambda x_0"
"(not"
" result_1))"
" key_0))"
"(not"
" #f)"
" #f)"
" #f)"
"(for-loop_0"
" result_1"
" rest_0"
" rest_1)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0"
" lst_1)))"
" #f)"
" #f)))"
" 1"
" #f))))"
" c1_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(self-quoting-in-linklet?"
" v_0)))"
"(if or-part_0"
" or-part_0"
"(if(symbol? v_0)"
"(let-values(((or-part_1)"
"(hash-ref"
" locals_1"
" v_0"
" #f)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(lookup-defn"
" defns_0"
" v_0)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)"
"(built-in-symbol?"
" v_0)))"
"(if or-part_3"
" or-part_3"
"(ready-variable?_0"
" v_0)))))))"
" #f)))"
" 1"
" #f)))))))"
"(let-values() 1))"
"(if(unsafe-fx< index_0 3)"
"(let-values()"
"(let-values(((ok?_0 _21_0 ids22_0 rhs23_0 body24_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((_21_0"
" ids22_0"
" rhs23_0"
" body24_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((_25_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((ids26_0"
" rhs27_0"
" body28_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((ids29_0"
" rhs30_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((ids_0"
" rhs_0)"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ids_0"
" rhs_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((ids_1"
" rhs_1)"
"(let-values(((ids_1)"
" ids_0)"
"((rhs_1)"
" rhs_0))"
"(let-values(((ids_2"
" rhs_2)"
"(let-values()"
"(let-values(((ids36_0"
" rhs37_0)"
"(let-values()"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(let-values(((ids32_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
" s_8))"
"((rhs33_0)"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(if(pair?"
" s_9)"
"(let-values(((rhs34_0)"
"(let-values(((s_10)"
"(car"
" s_9)))"
" s_10))"
"(()"
"(let-values(((s_10)"
"(cdr"
" s_9)))"
"(let-values(((s_11)"
"(if(1/syntax?"
" s_10)"
"(syntax-e$2"
" s_10)"
" s_10)))"
"(if(null?"
" s_11)"
"(values)"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                                                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
" rhs34_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_0))))))"
"(values"
" ids32_0"
" rhs33_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
"(cons"
" ids36_0"
" ids_1)"
"(cons"
" rhs37_0"
" rhs_1))))))"
"(values"
" ids_2"
" rhs_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" ids_1"
" rhs_1"
" rest_0)"
"(values"
" ids_1"
" rhs_1))))"
"(values"
" ids_0"
" rhs_0))))))"
" for-loop_0)"
" null"
" null"
" lst_0)))))"
"(values"
"(reverse$1"
" ids_0)"
"(reverse$1"
" rhs_0)))))))))"
"((body31_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((body35_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" body35_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                 \"bad syntax\""
" orig-s_0))))))"
"(values"
" ids29_0"
" rhs30_0"
" body31_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
" _25_0"
" ids26_0"
" rhs27_0"
" body28_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                         \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _21_0"
" ids22_0"
" rhs23_0"
" body24_0))))))"
"(if(not"
"(let-values(((lst_0) ids22_0)"
"((lst_1) rhs23_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_2)"
"(pair? lst_3)"
" #f)"
"(let-values(((ids_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((rhs_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(effects?_0"
" rhs_0"
"(correlated-length"
" ids_0)"
" locals_1)))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
" result_1)"
" ids_0))"
"(if(not"
"((lambda x_0"
" result_1)"
" rhs_0))"
"(not"
" #f)"
" #f)"
" #f)"
"(for-loop_0"
" result_1"
" rest_0"
" rest_1)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" lst_0"
" lst_1))))"
"(loop_0"
" body24_0"
"(add-binding-info locals_1 ids22_0 rhs23_0))"
" #f)))"
"(if(unsafe-fx< index_0 4)"
"(let-values()"
"(let-values(((ok?_0 _38_0 e39_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((_38_0 e39_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((_40_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e41_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                   \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _40_0"
" e41_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                           \"bad syntax\""
" orig-s_0)))))"
"(values #t _38_0 e39_0))))))"
"(if(let-values(((lst_0) e39_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(not"
"(effects?_0"
" e_2"
" 1"
" locals_1))))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_1))"
" e_2))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" result_1"
" rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
"(length e39_0)"
" #f)))"
"(if(unsafe-fx< index_0 5)"
"(let-values()"
"(let-values(((ok?_0 _42_0 e43_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((_42_0 e43_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((_44_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e45_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _44_0"
" e45_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                             \"bad syntax\""
" orig-s_0)))))"
"(values #t _42_0 e43_0))))))"
"(if(let-values(((lst_0) e43_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((e_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(not"
"(effects?_0"
" e_2"
" 1"
" locals_1))))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_1))"
" e_2))"
"(not"
" #f)"
" #f)"
"(for-loop_0"
" result_1"
" rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
" 1"
" #f)))"
"(let-values()"
"(let-values(((ok?_0 _46_0 e47_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((_46_0 e47_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((_48_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e49_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _48_0"
" e49_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                             \"bad syntax\""
" orig-s_0)))))"
"(values #t _46_0 e47_0))))))"
"((letrec-values(((bloop_0)"
"(lambda(es_0)"
"(begin"
" 'bloop"
"(if(null? es_0)"
"(let-values() #f)"
"(if(null?(cdr es_0))"
"(let-values()"
"(loop_0"
"(car es_0)"
" locals_1))"
"(let-values()"
"(if(not"
"(effects?_0"
"(car es_0)"
" #f"
" locals_1))"
"(bloop_0"
"(cdr es_0))"
" #f))))))))"
" bloop_0)"
" e47_0)))))))"
"(if(unsafe-fx< index_0 9)"
"(if(unsafe-fx< index_0 7)"
"(let-values()"
"(let-values(((ok?_0 _50_0 e051_0 e52_0)"
"(let-values(((s_0) e_1))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((_50_0 e051_0 e52_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((_53_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e054_0"
" e55_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((e056_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((e57_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1$1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" e056_0"
" e57_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
" _53_0"
" e054_0"
" e55_0))"
"((lambda(false_0"
" str_0"
" e_2)"
"(error"
" str_0))"
" #f"
"                                                                                                         \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _50_0"
" e051_0"
" e52_0))))))"
"(if(let-values(((lst_0) e52_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(not"
"(effects?_0"
" e_2"
" #f"
" locals_1))))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
"(not"
" result_1))"
" e_2))"
"(not #f)"
" #f)"
"(for-loop_0"
" result_1"
" rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
"(loop_0 e051_0 locals_1)"
" #f)))"
"(if(unsafe-fx< index_0 8)"
"(let-values()"
"(if(ok-make-struct-type?"
" e_1"
" ready-variable?_0"
" defns_0)"
" 5"
" #f))"
"(let-values()"
"(if(ok-make-struct-field-accessor/mutator?"
" e_1"
" locals_1"
" 'general-accessor"
" defns_0)"
" 1"
" #f))))"
"(if(unsafe-fx< index_0 10)"
"(let-values()"
"(if(ok-make-struct-field-accessor/mutator?"
" e_1"
" locals_1"
" 'general-mutator"
" defns_0)"
" 1"
" #f))"
"(if(unsafe-fx< index_0 11)"
"(let-values()"
"(if(ok-make-struct-type-property? e_1 defns_0)"
" 3"
" #f))"
"(if(unsafe-fx< index_0 12)"
"(let-values()"
"(let-values(((ok?_0 gs58_0 quot59_0 datum60_0)"
"(let-values(((s_0) e_1))"
"(if(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(if(let-values(((s_2)"
"(car"
" s_1)))"
" #t)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(if(pair? s_3)"
"(if(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
" #t)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(if(let-values(((s_8)"
"(car"
" s_7)))"
" #t)"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(null?"
" s_9)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(null?"
" s_5)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((gs58_0"
" quot59_0"
" datum60_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(let-values(((gs61_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((quot62_0"
" datum63_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((quot64_0"
" datum65_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((quot66_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((datum67_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(let-values(((datum68_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
" s_8))"
"(()"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(values)))))"
"(values"
" datum68_0))))))"
"(values"
" quot66_0"
" datum67_0)))))"
"(()"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(values)))))"
"(values"
" quot64_0"
" datum65_0))))))"
"(values"
" gs61_0"
" quot62_0"
" datum63_0)))))"
"(values"
" #t"
" gs58_0"
" quot59_0"
" datum60_0)))"
"(values #f #f #f #f)))))"
"(if(let-values(((or-part_0)"
"(if ok?_0"
"(if(eq? 'quote quot59_0)"
"(let-values(((or-part_0)"
"(symbol?"
" datum60_0)))"
"(if or-part_0"
" or-part_0"
"(string?"
" datum60_0)))"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(null?(cdr(correlated-e e_1)))))"
" 1"
" #f)))"
"(let-values()"
"(let-values(((ok?_0"
" _69_0"
" id:rator70_0"
" id:arg71_0"
" thn72_0"
" els73_0)"
"(let-values(((s_0) e_1))"
"(if(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(if(let-values(((s_2)"
"(car"
" s_1)))"
" #t)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(if(pair? s_3)"
"(if(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
"(let-values(((or-part_0)"
"(if(1/syntax?"
" s_6)"
"(symbol?"
"(syntax-e$2"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6))))"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(if(let-values(((s_8)"
"(car"
" s_7)))"
"(let-values(((or-part_0)"
"(if(1/syntax?"
" s_8)"
"(symbol?"
"(syntax-e$2"
" s_8))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_8))))"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(null?"
" s_9)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
" #t)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(if(let-values(((s_8)"
"(car"
" s_7)))"
" #t)"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(null?"
" s_9)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((_69_0"
" id:rator70_0"
" id:arg71_0"
" thn72_0"
" els73_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(let-values(((_74_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:rator75_0"
" id:arg76_0"
" thn77_0"
" els78_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((id:rator79_0"
" id:arg80_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((id:rator83_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((id:arg84_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(let-values(((id:arg85_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
" s_8))"
"(()"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(values)))))"
"(values"
" id:arg85_0))))))"
"(values"
" id:rator83_0"
" id:arg84_0)))))"
"((thn81_0"
" els82_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((thn86_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((els87_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(let-values(((els88_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
" s_8))"
"(()"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(values)))))"
"(values"
" els88_0))))))"
"(values"
" thn86_0"
" els87_0))))))"
"(values"
" id:rator79_0"
" id:arg80_0"
" thn81_0"
" els82_0))))))"
"(values"
" _74_0"
" id:rator75_0"
" id:arg76_0"
" thn77_0"
" els78_0)))))"
"(values"
" #t"
" _69_0"
" id:rator70_0"
" id:arg71_0"
" thn72_0"
" els73_0)))"
"(values #f #f #f #f #f #f)))))"
"(if ok?_0"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((or-part_0)"
"(hash-ref"
" locals_1"
" id:rator70_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(lookup-defn"
" defns_0"
" id:rator70_0)))))"
"(if c2_0"
"((lambda(d_0)"
"(if(known-predicate? d_0)"
"(if(not"
"(effects?_0"
" thn72_0"
" expected-results_0"
"(hash-set"
" locals_1"
" id:arg71_0"
"(known-satisfies7.1"
"(known-predicate-key"
" d_0)))))"
"(loop_0 els73_0 locals_1)"
" #f)"
" #f))"
" c2_0)"
"(let-values() #f))))"
"(let-values()"
"(let-values(((ok?_1"
" _89_0"
" tst90_0"
" thn91_0"
" els92_0)"
"(let-values(((s_0) e_1))"
"(if(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(if(let-values(((s_2)"
"(car"
" s_1)))"
" #t)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(if(let-values(((s_4)"
"(car"
" s_3)))"
" #t)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
" #t)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(if(pair?"
" s_7)"
"(if(let-values(((s_8)"
"(car"
" s_7)))"
" #t)"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(null?"
" s_9)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((_89_0"
" tst90_0"
" thn91_0"
" els92_0)"
"(let-values(((s_1)"
"(if(1/syntax?"
" s_0)"
"(syntax-e$2"
" s_0)"
" s_0)))"
"(let-values(((_93_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((tst94_0"
" thn95_0"
" els96_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(1/syntax?"
" s_2)"
"(syntax-e$2"
" s_2)"
" s_2)))"
"(let-values(((tst97_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((thn98_0"
" els99_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(1/syntax?"
" s_4)"
"(syntax-e$2"
" s_4)"
" s_4)))"
"(let-values(((thn100_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"((els101_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(1/syntax?"
" s_6)"
"(syntax-e$2"
" s_6)"
" s_6)))"
"(let-values(((els102_0)"
"(let-values(((s_8)"
"(car"
" s_7)))"
" s_8))"
"(()"
"(let-values(((s_8)"
"(cdr"
" s_7)))"
"(let-values(((s_9)"
"(if(1/syntax?"
" s_8)"
"(syntax-e$2"
" s_8)"
" s_8)))"
"(values)))))"
"(values"
" els102_0))))))"
"(values"
" thn100_0"
" els101_0))))))"
"(values"
" tst97_0"
" thn98_0"
" els99_0))))))"
"(values"
" _93_0"
" tst94_0"
" thn95_0"
" els96_0)))))"
"(values"
" #t"
" _89_0"
" tst90_0"
" thn91_0"
" els92_0)))"
"(values"
" #f"
" #f"
" #f"
" #f"
" #f)))))"
"(if ok?_1"
"(if(not"
"(effects?_0 tst90_0 1 locals_1))"
"(if(not"
"(effects?_0"
" thn91_0"
" expected-results_0"
" locals_1))"
"(loop_0 els92_0 locals_1)"
" #f)"
" #f)"
" #f)))))))))))))))))"
" loop_0)"
" e_0"
" locals_0)))"
"(not"
"(if actual-results_0"
"(let-values(((or-part_0)(not expected-results_0)))"
"(if or-part_0 or-part_0(= actual-results_0 expected-results_0)))"
" #f)))))))))))))"
"(define-values"
"(satisfies?)"
"(lambda(e_0 key_0 defns_0 locals_0)"
"(begin"
"(let-values(((d_0)"
"(let-values(((or-part_0)(hash-ref locals_0 e_0 #f)))"
"(if or-part_0 or-part_0(lookup-defn defns_0 e_0)))))"
"(if d_0(if(known-satisfies? d_0)(eq? key_0(known-satisfies-predicate-key d_0)) #f) #f)))))"
"(define-values"
"(add-binding-info)"
"(lambda(locals_0 idss_0 rhss_0)"
"(begin"
"(let-values(((lst_0) idss_0)((lst_1) rhss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(locals_1 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((ids_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((rhs_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((locals_2)"
"(let-values(((locals_2) locals_1))"
"(let-values(((locals_3)"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(rhs_1)"
"(begin"
" 'loop"
"(let-values(((tmp_0)"
"(if(pair?"
"(correlated-e"
" rhs_1))"
"(correlated-e"
"(car"
"(correlated-e"
" rhs_1)))"
" #f)))"
"(if(equal?"
" tmp_0"
" 'make-struct-type)"
"(let-values()"
"(let-values(((field-count_0)"
"(extract-struct-field-count-lower-bound"
" rhs_1)))"
"(let-values(((lst_4)"
"(correlated->list"
" ids_0))"
"((lst_5)"
" '(struct-type"
" constructor"
" predicate"
" general-accessor"
" general-mutator)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_4)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_5)))"
"((letrec-values(((for-loop_1)"
"(lambda(locals_3"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((type_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((locals_4)"
"(let-values(((locals_4)"
" locals_3))"
"(let-values(((locals_5)"
"(let-values()"
"(hash-set"
" locals_4"
"(correlated-e"
" id_0)"
"(known-struct-op8.1"
" type_0"
" field-count_0)))))"
"(values"
" locals_5)))))"
"(if(not"
" #f)"
"(for-loop_1"
" locals_4"
" rest_2"
" rest_3)"
" locals_4)))"
" locals_3)))))"
" for-loop_1)"
" locals_2"
" lst_4"
" lst_5)))))"
"(if(equal?"
" tmp_0"
" 'let-values)"
"(let-values()"
"(if(null?"
"(correlated-e"
"(correlated-cadr"
" rhs_1)))"
"(loop_0"
"(caddr"
"(correlated->list"
" rhs_1)))"
"(loop_0 #f)))"
"(let-values()"
"(let-values(((lst_4)"
"(correlated->list"
" ids_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_4)))"
"((letrec-values(((for-loop_1)"
"(lambda(locals_3"
" lst_5)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_5)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((locals_4)"
"(let-values(((locals_4)"
" locals_3))"
"(let-values(((locals_5)"
"(let-values()"
"(hash-set"
" locals_4"
"(correlated-e"
" id_0)"
" #t))))"
"(values"
" locals_5)))))"
"(if(not"
" #f)"
"(for-loop_1"
" locals_4"
" rest_2)"
" locals_4)))"
" locals_3)))))"
" for-loop_1)"
" locals_2"
" lst_4)))))))))))"
" loop_0)"
" rhs_0))))"
"(values locals_3)))))"
"(if(not #f)(for-loop_0 locals_2 rest_0 rest_1) locals_2)))"
" locals_1)))))"
" for-loop_0)"
" locals_0"
" lst_0"
" lst_1))))))"
"(define-values"
"(ok-make-struct-type-property?)"
"(lambda(e_0 defns_0)"
"(begin"
"(let-values(((l_0)(correlated->list e_0)))"
"(if(<= 2(length l_0) 5)"
"(let-values(((lst_0)(cdr l_0))"
"((lst_1)"
"(list"
"(lambda(v_0)(quoted? symbol? v_0))"
"(lambda(v_0)(is-lambda? v_0 2 defns_0))"
"(lambda(v_0)(ok-make-struct-type-property-super? v_0 defns_0))"
"(lambda(v_0)"
"(let-values(((v103_0) v_0)((temp104_0) 1)((defns105_0) defns_0))"
"(any-side-effects?9.1 defns105_0 unsafe-undefined unsafe-undefined v103_0 temp104_0))))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((arg_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((pred_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()(let-values()(pred_0 arg_0)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) arg_0))"
"(if(not((lambda x_0(not result_1)) pred_0))(not #f) #f)"
" #f)"
"(for-loop_0 result_1 rest_0 rest_1)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0"
" lst_1)))"
" #f)))))"
"(define-values"
"(ok-make-struct-type-property-super?)"
"(lambda(v_0 defns_0)"
"(begin"
"(let-values(((or-part_0)(quoted? null? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eq? 'null(correlated-e v_0))))"
"(if or-part_1"
" or-part_1"
"(if(pair?(correlated-e v_0))"
"(if(eq?(correlated-e(car(correlated-e v_0))) 'list)"
"(if(let-values(((lst_0)(cdr(correlated->list v_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((prop+val_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(if(="
"(correlated-length"
" prop+val_0)"
" 3)"
"(let-values(((prop+val_1)"
"(correlated->list"
" prop+val_0)))"
"(if(eq?"
" 'cons"
"(correlated-e"
"(car prop+val_1)))"
"(if(let-values(((or-part_2)"
"(memq"
"(correlated-e"
"(list-ref"
" prop+val_1"
" 1))"
" '(prop:procedure"
" prop:equal+hash"
" prop:custom-write))))"
"(if or-part_2"
" or-part_2"
"(known-property?"
"(lookup-defn"
" defns_0"
"(correlated-e"
"(list-ref"
" prop+val_1"
" 1))))))"
"(not"
"(let-values(((temp106_0)"
"(list-ref"
" prop+val_1"
" 2))"
"((temp107_0)"
" 1)"
"((defns108_0)"
" defns_0))"
"(any-side-effects?9.1"
" defns108_0"
" unsafe-undefined"
" unsafe-undefined"
" temp106_0"
" temp107_0)))"
" #f)"
" #f))"
" #f)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) prop+val_0))"
"(not #f)"
" #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
"(="
"(sub1(correlated-length v_0))"
"(set-count"
"(let-values(((lst_0)(cdr(correlated->list v_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((prop+val_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
"(correlated-e"
"(list-ref"
"(correlated->list"
" prop+val_0)"
" 1)))"
" #t))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1 rest_0) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
" lst_0)))))"
" #f)"
" #f)"
" #f))))))))"
"(define-values"
"(ok-make-struct-type?)"
"(lambda(e_0 ready-variable?_0 defns_0)"
"(begin"
"(let-values(((l_0)(correlated->list e_0)))"
"(let-values(((init-field-count-expr_0)(if(>(length l_0) 3)(list-ref l_0 3) #f)))"
"(let-values(((auto-field-count-expr_0)(if(>(length l_0) 4)(list-ref l_0 4) #f)))"
"(let-values(((num-fields_0)"
"(maybe+"
"(field-count-expr-to-field-count init-field-count-expr_0)"
"(field-count-expr-to-field-count auto-field-count-expr_0))))"
"(let-values(((immutables-expr_0)"
"(let-values(((or-part_0)(if(>(length l_0) 9)(list-ref l_0 9) #f)))"
"(if or-part_0 or-part_0 'null))))"
"(let-values(((super-expr_0)(if(>(length l_0) 2)(list-ref l_0 2) #f)))"
"(if(>=(length l_0) 5)"
"(if(<=(length l_0) 12)"
"(let-values(((lst_0)(cdr l_0))"
"((lst_1)"
"(list"
"(lambda(v_0)(quoted? symbol? v_0))"
"(lambda(v_0)(super-ok? v_0 defns_0))"
"(lambda(v_0)(field-count-expr-to-field-count v_0))"
"(lambda(v_0)(field-count-expr-to-field-count v_0))"
"(lambda(v_0)"
"(not"
"(let-values(((v109_0) v_0)"
"((temp110_0) 1)"
"((ready-variable?111_0) ready-variable?_0)"
"((defns112_0) defns_0))"
"(any-side-effects?9.1"
" defns112_0"
" unsafe-undefined"
" ready-variable?111_0"
" v109_0"
" temp110_0))))"
"(lambda(v_0)"
"(known-good-struct-properties? v_0 immutables-expr_0 super-expr_0 defns_0))"
"(lambda(v_0)(inspector-or-false? v_0))"
"(lambda(v_0)(procedure-spec? v_0 num-fields_0))"
"(lambda(v_0)(immutables-ok? v_0 init-field-count-expr_0)))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((arg_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((pred_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()(pred_0 arg_0)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) arg_0))"
"(if(not((lambda x_0(not result_1)) pred_0))(not #f) #f)"
" #f)"
"(for-loop_0 result_1 rest_0 rest_1)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0"
" lst_1)))"
" #f)"
" #f))))))))))"
"(define-values"
"(super-ok?)"
"(lambda(e_0 defns_0)"
"(begin"
"(let-values(((or-part_0)(quoted? false? e_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((o_0)(lookup-defn defns_0(correlated-e e_0))))"
"(if o_0(if(known-struct-op? o_0)(eq? 'struct-type(known-struct-op-type o_0)) #f) #f)))))))"
"(define-values"
"(extract-struct-field-count-lower-bound)"
"(lambda(e_0)"
"(begin"
"(let-values(((l_0)(correlated->list e_0)))"
"(+(field-count-expr-to-field-count(list-ref l_0 3))(field-count-expr-to-field-count(list-ref l_0 4)))))))"
"(define-values"
"(quoted?)"
"(lambda(val?_0 v_0)"
"(begin"
"(let-values(((or-part_0)"
"(if(pair?(correlated-e v_0))"
"(if(eq?(correlated-e(car(correlated-e v_0))) 'quote)"
"(val?_0(correlated-e(correlated-cadr v_0)))"
" #f)"
" #f)))"
"(if or-part_0 or-part_0(val?_0(correlated-e v_0)))))))"
"(define-values"
"(quoted-value)"
"(lambda(v_0)(begin(if(pair?(correlated-e v_0))(correlated-e(correlated-cadr v_0))(correlated-e v_0)))))"
"(define-values(false?)(lambda(v_0)(begin(eq?(correlated-e v_0) #f))))"
"(define-values"
"(field-count-expr-to-field-count)"
"(lambda(v_0)(begin(if(quoted? exact-nonnegative-integer? v_0)(quoted-value v_0) #f))))"
"(define-values"
"(inspector-or-false?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(quoted? false? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(if(quoted? symbol? v_0)(eq? 'prefab(quoted-value v_0)) #f)))"
"(if or-part_1"
" or-part_1"
"(if(= 1(correlated-length v_0))"
"(eq? 'current-inspector(correlated-e(car(correlated-e v_0))))"
" #f))))))))"
"(define-values"
"(known-good-struct-properties?)"
"(lambda(v_0 immutables-expr_0 super-expr_0 defns_0)"
"(begin"
"(let-values(((or-part_0)(quoted? null? v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eq? 'null(correlated-e v_0))))"
"(if or-part_1"
" or-part_1"
"(if(pair?(correlated-e v_0))"
"(if(eq?(correlated-e(car(correlated-e v_0))) 'list)"
"(if(let-values(((lst_0)(cdr(correlated->list v_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((prop+val_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(if(="
"(correlated-length"
" prop+val_0)"
" 3)"
"(let-values(((prop+val_1)"
"(correlated->list"
" prop+val_0)))"
"(if(eq?"
" 'cons"
"(correlated-e"
"(car prop+val_1)))"
"(known-good-struct-property+value?"
"(list-ref prop+val_1 1)"
"(list-ref prop+val_1 2)"
" immutables-expr_0"
" super-expr_0"
" defns_0)"
" #f))"
" #f)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) prop+val_0))"
"(not #f)"
" #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
"(="
"(sub1(correlated-length v_0))"
"(set-count"
"(let-values(((lst_0)(cdr(correlated->list v_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((prop+val_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
"(correlated-e"
"(list-ref"
"(correlated->list"
" prop+val_0)"
" 1)))"
" #t))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1 rest_0) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
" lst_0)))))"
" #f)"
" #f)"
" #f))))))))"
"(define-values"
"(known-good-struct-property+value?)"
"(lambda(prop-expr_0 val-expr_0 immutables-expr_0 super-expr_0 defns_0)"
"(begin"
"(let-values(((prop-name_0)(correlated-e prop-expr_0)))"
"(let-values(((tmp_0) prop-name_0))"
"(if(equal? tmp_0 'prop:evt)"
"(let-values()"
"(let-values(((or-part_0)(is-lambda? val-expr_0 1 defns_0)))"
"(if or-part_0 or-part_0(immutable-field? val-expr_0 immutables-expr_0))))"
"(if(equal? tmp_0 'prop:procedure)"
"(let-values()"
"(let-values(((or-part_0)(is-lambda? val-expr_0 1 defns_0)))"
"(if or-part_0 or-part_0(immutable-field? val-expr_0 immutables-expr_0))))"
"(if(equal? tmp_0 'prop:custom-write)"
"(let-values()(is-lambda? val-expr_0 3 defns_0))"
"(if(equal? tmp_0 'prop:equal+hash)"
"(let-values()"
"(let-values(((l_0)(correlated->list val-expr_0)))"
"(if(eq? 'list(car l_0))"
"(if(is-lambda?(list-ref l_0 1) 3 defns_0)"
"(if(is-lambda?(list-ref l_0 2) 2 defns_0)(is-lambda?(list-ref l_0 3) 2 defns_0) #f)"
" #f)"
" #f)))"
"(if(if(equal? tmp_0 'prop:method-arity-error) #t(equal? tmp_0 'prop:incomplete-arity))"
"(let-values()"
"(not"
"(let-values(((val-expr113_0) val-expr_0)((temp114_0) 1)((defns115_0) defns_0))"
"(any-side-effects?9.1 defns115_0 unsafe-undefined unsafe-undefined val-expr113_0 temp114_0))))"
"(if(equal? tmp_0 'prop:impersonator-of)"
"(let-values()(is-lambda? val-expr_0 1 defns_0))"
"(if(equal? tmp_0 'prop:arity-string)"
"(let-values()(is-lambda? val-expr_0 1 defns_0))"
"(if(equal? tmp_0 'prop:checked-procedure)"
"(let-values()(if(quoted? false? super-expr_0)(immutable-field? 1 immutables-expr_0) #f))"
"(let-values()"
"(let-values(((o_0)(lookup-defn defns_0 prop-name_0)))"
"(if o_0"
"(if(known-property? o_0)"
"(not"
"(let-values(((val-expr116_0) val-expr_0)((temp117_0) 1)((defns118_0) defns_0))"
"(any-side-effects?9.1"
" defns118_0"
" unsafe-undefined"
" unsafe-undefined"
" val-expr116_0"
" temp117_0)))"
" #f)"
" #f))))))))))))))))"
"(define-values"
"(is-lambda?)"
"(lambda(expr_0 arity_0 defns_0)"
"(begin"
"(let-values(((lookup_0)(lookup-defn defns_0 expr_0)))"
"(let-values(((or-part_0)"
"(if lookup_0"
"(if(known-function? lookup_0)"
"(let-values(((or-part_0)(not arity_0)))"
"(if or-part_0 or-part_0(arity-includes?(known-function-arity lookup_0) arity_0)))"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if(pair?(correlated-e expr_0))"
"(if(eq? 'case-lambda(car(correlated-e expr_0)))(not arity_0) #f)"
" #f)))"
"(if or-part_1"
" or-part_1"
"(if(pair?(correlated-e expr_0))"
"(if(eq? 'lambda(car(correlated-e expr_0)))"
"(let-values(((or-part_2)(not arity_0)))"
"(if or-part_2"
" or-part_2"
"((letrec-values(((loop_0)"
"(lambda(args_0 arity_1)"
"(begin"
" 'loop"
"(if(correlated? args_0)"
"(let-values()(loop_0(correlated-e args_0) arity_1))"
"(if(null? args_0)"
"(let-values()(zero? arity_1))"
"(if(pair? args_0)"
"(let-values()(loop_0(cdr args_0)(sub1 arity_1)))"
"(let-values()(not(negative? arity_1))))))))))"
" loop_0)"
"(cadr(correlated->list expr_0))"
" arity_0)))"
" #f)"
" #f)))))))))"
"(define-values"
"(arity-includes?)"
"(lambda(a_0 n_0)"
"(begin"
"(let-values(((or-part_0)(equal? a_0 n_0)))"
"(if or-part_0"
" or-part_0"
"(if(list? a_0)"
"(let-values(((lst_0) a_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((a_1)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()(equal? a_1 n_0)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) a_1))(not #f) #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" lst_0)))"
" #f))))))"
"(define-values"
"(immutable-field?)"
"(lambda(val-expr_0 immutables-expr_0)"
"(begin"
"(if(quoted? exact-nonnegative-integer? val-expr_0)"
"(memv(quoted-value val-expr_0)(immutables-expr-to-immutables immutables-expr_0 null))"
" #f))))"
"(define-values"
"(immutables-expr-to-immutables)"
"(lambda(e_0 fail-v_0)"
"(begin"
"(let-values(((tmp_0)(if(pair?(correlated-e e_0))(correlated-e(car(correlated-e e_0))) #f)))"
"(if(equal? tmp_0 'quote)"
"(let-values()"
"(let-values(((v_0)(correlated-cadr e_0)))"
"(let-values(((or-part_0)"
"(if(correlated-length v_0)"
"(let-values(((l_0)(map2 correlated-e(correlated->list v_0))))"
"(if(andmap2 exact-nonnegative-integer? l_0)"
"(if(=(length l_0)(set-count(list->set l_0))) l_0 #f)"
" #f))"
" #f)))"
"(if or-part_0 or-part_0 fail-v_0))))"
"(let-values() fail-v_0))))))"
"(define-values"
"(procedure-spec?)"
"(lambda(e_0 field-count_0)"
"(begin"
"(let-values(((or-part_0)(quoted? false? e_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if(quoted? exact-nonnegative-integer? e_0)"
"(if field-count_0(<(quoted-value e_0) field-count_0) #f)"
" #f)))"
"(if or-part_1 or-part_1(is-lambda? e_0 #f '#hasheq()))))))))"
"(define-values"
"(immutables-ok?)"
"(lambda(e_0 init-field-count-expr_0)"
"(begin"
"(let-values(((l_0)(immutables-expr-to-immutables e_0 #f)))"
"(let-values(((c_0)(field-count-expr-to-field-count init-field-count-expr_0)))"
"(if l_0"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((n_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()(let-values()(< n_0 c_0)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) n_0))(not #f) #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
" #f))))))"
"(define-values"
"(ok-make-struct-field-accessor/mutator?)"
"(lambda(e_0 locals_0 type_0 defns_0)"
"(begin"
"(let-values(((l_0)(correlated->list e_0)))"
"(let-values(((a_0)"
"(if(let-values(((or-part_0)(=(length l_0) 3)))(if or-part_0 or-part_0(=(length l_0) 4)))"
"(let-values(((or-part_0)(hash-ref locals_0(correlated-e(list-ref l_0 1)) #f)))"
"(if or-part_0 or-part_0(lookup-defn defns_0(correlated-e(list-ref l_0 1)))))"
" #f)))"
"(if(known-struct-op? a_0)"
"(if(eq?(known-struct-op-type a_0) type_0)"
"(if(<(field-count-expr-to-field-count(list-ref l_0 2))(known-struct-op-field-count a_0))"
"(let-values(((or-part_0)(=(length l_0) 3)))"
"(if or-part_0 or-part_0(quoted? symbol?(list-ref l_0 3))))"
" #f)"
" #f)"
" #f))))))"
"(define-values(maybe+)(lambda(x_0 y_0)(begin(if x_0(if y_0(+ x_0 y_0) #f) #f))))"
"(define-values"
"(compile-single)"
"(lambda(p_0 cctx_0)"
"(begin"
"(let-values(((p12_0) p_0)((cctx13_0) cctx_0)((temp14_0) #f)((temp15_0) #t))"
"(compile-top9.1 temp14_0 temp15_0 #f p12_0 cctx13_0)))))"
"(define-values"
"(compile-top9.1)"
"(lambda(serializable?1_0 single-expression?2_0 to-correlated-linklet?3_0 p7_0 cctx8_0)"
"(begin"
" 'compile-top9"
"(let-values(((p_0) p7_0))"
"(let-values(((cctx_0) cctx8_0))"
"(let-values(((serializable?_0) serializable?1_0))"
"(let-values(((single-expression?_0) single-expression?2_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?3_0))"
"(let-values()"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'compile(if single-expression?_0 'transformer 'top)))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((phase_0)(compile-context-phase cctx_0)))"
"(let-values(((mpis_0)(make-module-path-index-table)))"
"(let-values(((purely-functional?_0) #t))"
"(let-values(((body-linklets_0"
" min-phase_0"
" max-phase_0"
" phase-to-link-module-uses_0"
" phase-to-link-module-uses-expr_0"
" phase-to-link-extra-inspectorss_0"
" syntax-literals_0"
" no-root-context-pos_0)"
"(let-values(((temp16_0)(list p_0))"
"((cctx17_0) cctx_0)"
"((mpis18_0) mpis_0)"
"((temp19_0)"
"(if single-expression?_0"
"(list* '()(list syntax-literals-id) '(()))"
"(list"
"(list top-level-bind!-id top-level-require!-id)"
"(list mpi-vector-id syntax-literals-id)"
" instance-imports)))"
"((temp20_0)"
"(list"
" top-level-instance"
" empty-top-syntax-literal-instance"
" empty-instance-instance))"
"((serializable?21_0) serializable?_0)"
"((to-correlated-linklet?22_0) to-correlated-linklet?_0)"
"((temp23_0)(lambda()(set! purely-functional?_0 #f)))"
"((temp24_0)"
"(lambda(e_0 expected-results_0 phase_1 required-reference?_0)"
"(if(if purely-functional?_0"
"(let-values(((e27_0) e_0)"
"((expected-results28_0)"
" expected-results_0)"
"((required-reference?29_0)"
" required-reference?_0))"
"(any-side-effects?9.1"
" unsafe-undefined"
" unsafe-undefined"
" required-reference?29_0"
" e27_0"
" expected-results28_0))"
" #f)"
"(let-values()(set! purely-functional?_0 #f))"
"(void))))"
"((temp25_0)"
"(lambda(s_0 cctx_1)"
"(begin"
"(set! purely-functional?_0 #f)"
"(compile-top-level-require s_0 cctx_1))))"
"((temp26_0)(not single-expression?_0)))"
"(compile-forms33.1"
" temp20_0"
" temp19_0"
" null"
" temp24_0"
" temp26_0"
" temp23_0"
" #f"
" null"
" unsafe-undefined"
" #f"
" temp25_0"
" #f"
" serializable?21_0"
" to-correlated-linklet?22_0"
" temp16_0"
" cctx17_0"
" mpis18_0))))"
"(let-values(((add-metadata_0)"
"(lambda(ht_0)"
"(begin"
" 'add-metadata"
"(let-values(((ht_1)(hash-set ht_0 'original-phase phase_0)))"
"(let-values(((ht_2)(hash-set ht_1 'max-phase max-phase_0)))"
" ht_2))))))"
"(let-values(((bundle_0)"
"(hash->linklet-bundle"
"(add-metadata_0"
"(if serializable?_0"
"(let-values()"
"(let-values(((syntax-literals-expr_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'top"
" 'serialize))"
"(void))"
"(begin0"
"(let-values()"
"(generate-eager-syntax-literals!"
" syntax-literals_0"
" mpis_0"
" phase_0"
"(compile-context-self cctx_0)"
"(compile-context-namespace cctx_0)))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void))))))"
"(let-values(((link-linklet_0)"
"((lambda(s_0)"
"(if to-correlated-linklet?_0"
"(make-correlated-linklet s_0 #f)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'top"
" 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((linklet_0 new-keys_0)"
"(1/compile-linklet"
" s_0"
" #f"
"(vector"
" deserialize-instance"
" empty-eager-instance-instance)"
"(lambda(inst_0)"
"(values inst_0 #f)))))"
" linklet_0))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(list"
" 'linklet"
"(list"
" deserialize-imports"
" eager-instance-imports)"
"(list"
" mpi-vector-id"
" deserialized-syntax-vector-id"
" 'phase-to-link-modules"
" syntax-literals-id)"
"(list"
" 'define-values"
"(list mpi-vector-id)"
"(generate-module-path-index-deserialize"
" mpis_0))"
"(list"
" 'define-values"
"(list deserialized-syntax-vector-id)"
"(list* 'make-vector(add1 phase_0) '(#f)))"
"(list"
" 'define-values"
" '(phase-to-link-modules)"
" phase-to-link-module-uses-expr_0)"
"(list"
" 'define-values"
"(list syntax-literals-id)"
" syntax-literals-expr_0)))))"
"(hash-set body-linklets_0 'link link-linklet_0))))"
"(let-values() body-linklets_0))))))"
"(compiled-in-memory1.1"
"(hash->linklet-directory(hasheq #f bundle_0))"
" #f"
" #f"
" #f"
" phase-to-link-module-uses_0"
"(current-code-inspector)"
" phase-to-link-extra-inspectorss_0"
"(mpis-as-vector mpis_0)"
"(syntax-literals-as-vector syntax-literals_0)"
" null"
" null"
"(extract-namespace-scopes(compile-context-namespace cctx_0))"
" purely-functional?_0))))))))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))))))))"
"(define-values"
"(compile-top-level-require)"
"(lambda(p_0 cctx_0)"
"(begin"
"(let-values(((phase_0)(compile-context-phase cctx_0)))"
"(if(parsed-require? p_0)"
"(let-values()"
"(let-values(((form-stx_0)(compile-quote-syntax(syntax-disarm$1(parsed-s p_0)) cctx_0)))"
"(list top-level-require!-id form-stx_0 ns-id)))"
"(let-values() #f))))))"
"(define-values"
"(select-defined-syms-and-bind!16.1)"
"(lambda(as-transformer?5_0"
" frame-id1_0"
" in4_0"
" requires+provides3_0"
" top-level-bind-scope2_0"
" ids11_0"
" defined-syms12_0"
" self13_0"
" phase14_0"
" all-scopes-stx15_0)"
"(begin"
" 'select-defined-syms-and-bind!16"
"(let-values(((ids_0) ids11_0))"
"(let-values(((defined-syms_0) defined-syms12_0))"
"(let-values(((self_0) self13_0))"
"(let-values(((phase_0) phase14_0))"
"(let-values(((all-scopes-stx_0) all-scopes-stx15_0))"
"(let-values(((frame-id_0) frame-id1_0))"
"(let-values(((top-level-bind-scope_0) top-level-bind-scope2_0))"
"(let-values(((requires+provides_0) requires+provides3_0))"
"(let-values(((orig-s_0) in4_0))"
"(let-values(((as-transformer?_0) as-transformer?5_0))"
"(let-values()"
"(let-values(((defined-syms-at-phase_0)"
"(let-values(((or-part_0)(hash-ref defined-syms_0 phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheq)))"
"(begin(hash-set! defined-syms_0 phase_0 ht_0) ht_0))))))"
"(reverse$1"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((sym_0)"
"(syntax-e$1"
" id_0)))"
"(let-values(((defined-sym_0)"
"(if(if(not"
"(defined-as-other?"
"(hash-ref"
" defined-syms-at-phase_0"
" sym_0"
" #f)"
" id_0"
" phase_0"
" top-level-bind-scope_0))"
"(if(no-extra-scopes?"
" id_0"
" all-scopes-stx_0"
" top-level-bind-scope_0"
" phase_0)"
"(symbol-interned?"
" sym_0)"
" #f)"
" #f)"
" sym_0"
"((letrec-values(((loop_0)"
"(lambda(pos_0)"
"(begin"
" 'loop"
"(let-values(((s_0)"
"(string->unreadable-symbol"
"(string-append"
"(symbol->string"
" sym_0)"
"                                                                                                                                                        \".\""
"(number->string"
" pos_0)))))"
"(if(defined-as-other?"
"(hash-ref"
" defined-syms-at-phase_0"
" s_0"
" #f)"
" id_0"
" phase_0"
" top-level-bind-scope_0)"
"(loop_0"
"(add1"
" pos_0))"
" s_0))))))"
" loop_0)"
" 1))))"
"(let-values((()"
"(begin"
"(hash-set!"
" defined-syms-at-phase_0"
" defined-sym_0"
" id_0)"
"(values))))"
"(let-values(((b_0)"
"(let-values(((self23_0)"
" self_0)"
"((phase24_0)"
" phase_0)"
"((defined-sym25_0)"
" defined-sym_0)"
"((frame-id26_0)"
" frame-id_0)"
"((sym27_0)"
" sym_0))"
"(make-module-binding20.1"
" #f"
" null"
" frame-id26_0"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" sym27_0"
" self23_0"
" phase24_0"
" defined-sym25_0))))"
"(begin"
"(if requires+provides_0"
"(let-values()"
"(let-values(((requires+provides28_0)"
" requires+provides_0)"
"((id29_0)"
" id_0)"
"((phase30_0)"
" phase_0)"
"((b31_0)"
" b_0))"
"(remove-required-id!75.1"
" b31_0"
" requires+provides28_0"
" id29_0"
" phase30_0)))"
"(void))"
"(let-values(((id19_0)"
" id_0)"
"((b20_0)"
" b_0)"
"((phase21_0)"
" phase_0)"
"((orig-s22_0)"
" orig-s_0))"
"(add-binding!17.1"
" orig-s22_0"
" #f"
" id19_0"
" b20_0"
" phase21_0))"
"(if requires+provides_0"
"(let-values()"
"(let-values(((requires+provides32_0)"
" requires+provides_0)"
"((id33_0)"
" id_0)"
"((phase34_0)"
" phase_0)"
"((b35_0)"
" b_0)"
"((as-transformer?36_0)"
" as-transformer?_0))"
"(add-defined-or-required-id!19.1"
" as-transformer?36_0"
" #f"
" requires+provides32_0"
" id33_0"
" phase34_0"
" b35_0)))"
"(void))"
" defined-sym_0))))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))))))))))))))"
"(define-values"
"(no-extra-scopes?)"
"(lambda(id_0 all-scopes-stx_0 top-level-bind-scope_0 phase_0)"
"(begin"
"(let-values(((m-id_0)(datum->syntax$1 all-scopes-stx_0(syntax-e$1 id_0))))"
"(let-values(((or-part_0)(bound-identifier=?$1 id_0 m-id_0 phase_0)))"
"(if or-part_0"
" or-part_0"
"(if top-level-bind-scope_0"
"(bound-identifier=?$1 id_0(add-scope m-id_0 top-level-bind-scope_0) phase_0)"
" #f)))))))"
"(define-values"
"(defined-as-other?)"
"(lambda(prev-id_0 id_0 phase_0 top-level-bind-scope_0)"
"(begin"
"(if prev-id_0"
"(if(not(bound-identifier=?$1 prev-id_0 id_0 phase_0))"
"(let-values(((or-part_0)(not top-level-bind-scope_0)))"
"(if or-part_0"
" or-part_0"
"(not"
"(bound-identifier=?$1"
"(remove-scope prev-id_0 top-level-bind-scope_0)"
"(remove-scope id_0 top-level-bind-scope_0)"
" phase_0))))"
" #f)"
" #f))))"
"(define-values"
"(select-defined-syms-and-bind!/ctx)"
"(lambda(tl-ids_0 ctx_0)"
"(begin"
"(let-values(((tl-ids37_0) tl-ids_0)"
"((temp38_0)(root-expand-context-defined-syms ctx_0))"
"((temp39_0)(root-expand-context-self-mpi ctx_0))"
"((temp40_0)(expand-context-phase ctx_0))"
"((temp41_0)(root-expand-context-all-scopes-stx ctx_0))"
"((temp42_0)(root-expand-context-frame-id ctx_0))"
"((temp43_0)(root-expand-context-top-level-bind-scope ctx_0)))"
"(select-defined-syms-and-bind!16.1"
" #f"
" temp42_0"
" #f"
" #f"
" temp43_0"
" tl-ids37_0"
" temp38_0"
" temp39_0"
" temp40_0"
" temp41_0)))))"
"(define-values"
"(add-defined-sym!)"
"(lambda(defined-syms_0 phase_0 sym_0 id_0)"
"(begin"
"(let-values(((defined-syms-at-phase_0)"
"(let-values(((or-part_0)(hash-ref defined-syms_0 phase_0 #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheq)))(begin(hash-set! defined-syms_0 phase_0 ht_0) ht_0))))))"
"(hash-set! defined-syms-at-phase_0 sym_0 id_0)))))"
"(define-values"
"(make-create-root-expand-context-from-module)"
"(lambda(requires_0 evaled-ld-h_0)"
"(begin"
"(lambda(ns_0 phase-shift_0 original-self_0 self_0)"
"(let-values(((root-ctx_0)"
"(let-values(((temp1_0)(namespace-mpi ns_0)))"
"(make-root-expand-context13.1 #f null unsafe-undefined unsafe-undefined temp1_0))))"
"(let-values(((s_0)(add-scopes empty-syntax(root-expand-context-module-scopes root-ctx_0))))"
"(let-values((()"
"(begin"
"(let-values(((lst_0) requires_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((phase+reqs_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((phase_0)"
"(car"
" phase+reqs_0)))"
"(begin"
"(let-values(((lst_2)"
"(cdr"
" phase+reqs_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((req_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((mpi_0)"
"(module-path-index-shift"
" req_0"
" original-self_0"
" self_0)))"
"(let-values(((mpi2_0)"
" mpi_0)"
"((s3_0)"
" s_0)"
"((self4_0)"
" self_0)"
"((s5_0)"
" s_0)"
"((ns6_0)"
" ns_0)"
"((temp7_0)"
"(phase+"
" phase_0"
" phase-shift_0))"
"((phase-shift8_0)"
" phase-shift_0)"
"((temp9_0)"
" 'module))"
"(perform-require!78.1"
" #f"
" #t"
" #f"
" #f"
" #f"
" #f"
" 'all"
" temp7_0"
" #f"
" phase-shift8_0"
" #f"
" #f"
" #t"
" temp9_0"
" mpi2_0"
" s3_0"
" self4_0"
" s5_0"
" ns6_0))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2)))"
"(void))))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(values))))"
"(let-values()"
"(let-values(((defined-syms_0)(root-expand-context-defined-syms root-ctx_0)))"
"(begin"
"(let-values(((ht_0) evaled-ld-h_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 linklet_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(let-values(((lst_0)"
"(1/linklet-export-variables"
" linklet_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((id_0)"
"(datum->syntax$1"
" s_0"
" sym_0)))"
"(begin"
"(let-values(((id10_0)"
" id_0)"
"((temp11_0)"
"(let-values(((self13_0)"
" self_0)"
"((phase14_0)"
" phase_0)"
"((sym15_0)"
" sym_0))"
"(make-module-binding20.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" self13_0"
" phase14_0"
" sym15_0)))"
"((phase12_0)"
" phase_0))"
"(add-binding!17.1"
" #f"
" #f"
" id10_0"
" temp11_0"
" phase12_0))"
"(add-defined-sym!"
" defined-syms_0"
" phase_0"
" sym_0"
" id_0))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_0)))"
"(void)))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_0 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(void)"
" root-ctx_0))))))))))"
"(define-values"
"(shift-to-inside-root-context)"
"(lambda(root-context_0)"
"(begin"
"(let-values(((outside-mpi_0)(root-expand-context-self-mpi root-context_0)))"
"(let-values(((inside-mpi_0)(make-self-module-path-index(module-path-index-resolved outside-mpi_0))))"
"(let-values(((v_0) root-context_0))"
"(let-values(((the-struct_0) v_0))"
"(if(root-expand-context/outer? the-struct_0)"
"(let-values(((inner16_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(root-expand-context/inner? the-struct_1)"
"(let-values(((self-mpi17_0) inside-mpi_0)"
"((all-scopes-stx18_0)"
"(let-values(((temp19_0)"
"(root-expand-context-all-scopes-stx root-context_0))"
"((outside-mpi20_0) outside-mpi_0)"
"((inside-mpi21_0) inside-mpi_0))"
"(syntax-module-path-index-shift13.1"
" #f"
" temp19_0"
" outside-mpi20_0"
" inside-mpi21_0"
" #f))))"
"(root-expand-context/inner2.1"
" self-mpi17_0"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
" all-scopes-stx18_0"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)))"
"                                  (raise-argument-error 'struct-copy \"root-expand-context/inner?\" the-struct_1)))))"
"(root-expand-context/outer1.1"
" inner16_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)))"
"                (raise-argument-error 'struct-copy \"root-expand-context/outer?\" the-struct_0)))))))))"
"(define-values"
"(check-require-access9.1)"
"(lambda(skip-imports1_0"
" linklet3_0"
" import-module-uses4_0"
" import-module-instances5_0"
" insp6_0"
" extra-inspector7_0"
" extra-inspectorsss8_0)"
"(begin"
" 'check-require-access9"
"(let-values(((linklet_0) linklet3_0))"
"(let-values(((skip-num-imports_0) skip-imports1_0))"
"(let-values(((import-module-uses_0) import-module-uses4_0))"
"(let-values(((import-module-instances_0) import-module-instances5_0))"
"(let-values(((insp_0) insp6_0))"
"(let-values(((extra-inspector_0) extra-inspector7_0))"
"(let-values(((extra-inspectorsss_0) extra-inspectorsss8_0))"
"(let-values()"
"(begin"
"(let-values(((lst_0)(list-tail(1/linklet-import-variables linklet_0) skip-num-imports_0))"
"((lst_1) import-module-uses_0)"
"((lst_2) import-module-instances_0)"
"((lst_3)"
"(let-values(((or-part_0) extra-inspectorsss_0))"
"(if or-part_0 or-part_0 import-module-uses_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_3)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_4 lst_5 lst_6 lst_7)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_4)"
"(if(pair? lst_5)(if(pair? lst_6)(pair? lst_7) #f) #f)"
" #f)"
"(let-values(((import-syms_0)(unsafe-car lst_4))"
"((rest_0)(unsafe-cdr lst_4))"
"((mu_0)(unsafe-car lst_5))"
"((rest_1)(unsafe-cdr lst_5))"
"((mi_0)(unsafe-car lst_6))"
"((rest_2)(unsafe-cdr lst_6))"
"((extra-inspectorss_0)(unsafe-car lst_7))"
"((rest_3)(unsafe-cdr lst_7)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((m_0)"
"(module-instance-module"
" mi_0)))"
"(if(module-no-protected?"
" m_0)"
"(void)"
"(let-values()"
"(let-values(((access_0)"
"(let-values(((or-part_0)"
"(module-access"
" m_0)))"
"(if or-part_0"
" or-part_0"
"(module-compute-access!"
" m_0)))))"
"(begin"
"(let-values(((lst_8)"
" import-syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_8)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_9)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_9)"
"(let-values(((import-sym_0)"
"(unsafe-car"
" lst_9))"
"((rest_4)"
"(unsafe-cdr"
" lst_9)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((a_0)"
"(hash-ref"
"(hash-ref"
" access_0"
"(module-use-phase"
" mu_0)"
" '#hasheq())"
" import-sym_0"
" 'unexported)))"
"(if(let-values(((or-part_0)"
"(eq?"
" a_0"
" 'unexported)))"
"(if or-part_0"
" or-part_0"
"(eq?"
" a_0"
" 'protected)))"
"(let-values()"
"(let-values(((guard-insp_0)"
"(namespace-inspector"
"(module-instance-namespace"
" mi_0))))"
"(if(let-values(((or-part_0)"
"(inspector-superior?"
" insp_0"
" guard-insp_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if extra-inspector_0"
"(inspector-superior?"
" extra-inspector_0"
" guard-insp_0)"
" #f)))"
"(if or-part_1"
" or-part_1"
"(if extra-inspectorsss_0"
"(if extra-inspectorss_0"
"(extra-inspectors-allow?"
"(hash-ref"
" extra-inspectorss_0"
" import-sym_0"
" #f)"
" guard-insp_0)"
" #f)"
" #f)))))"
"(void)"
"(let-values()"
"(error"
" 'link"
"(string-append"
"                                                                                                                                                                                    \"access disallowed by code inspector to ~a variable\\n\""
"                                                                                                                                                                                    \"  variable: ~s\\n\""
"                                                                                                                                                                                    \"  from module: ~a\")"
" a_0"
" import-sym_0"
"(1/module-path-index-resolve"
"(namespace-mpi"
"(module-instance-namespace"
" mi_0))))))))"
"(void))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_4)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_8)))"
"(void)))))))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0 rest_0 rest_1 rest_2 rest_3)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" lst_1"
" lst_2"
" lst_3)))"
"(void)))))))))))))"
"(define-values"
"(check-single-require-access)"
"(lambda(mi_0 phase_0 sym_0 insp_0)"
"(begin"
"(let-values(((m_0)(module-instance-module mi_0)))"
"(if(module-no-protected? m_0)"
"(let-values() #t)"
"(let-values()"
"(let-values(((access_0)"
"(let-values(((or-part_0)(module-access m_0)))"
"(if or-part_0 or-part_0(module-compute-access! m_0)))))"
"(let-values(((a_0)(hash-ref(hash-ref access_0 phase_0 '#hasheq()) sym_0 'unexported)))"
"(if(let-values(((or-part_0)(eq? a_0 'unexported)))(if or-part_0 or-part_0(eq? a_0 'protected)))"
"(let-values()"
"(let-values(((guard-insp_0)(namespace-inspector(module-instance-namespace mi_0))))"
"(let-values(((or-part_0)(if insp_0(inspector-superior? insp_0 guard-insp_0) #f)))"
"(if or-part_0 or-part_0(inspector-superior?(current-code-inspector) guard-insp_0)))))"
"(let-values() #t))))))))))"
"(define-values(cell.1$2)(unsafe-make-place-local(make-weak-hasheq)))"
"(define-values(module-cache-place-init!)(lambda()(begin(unsafe-place-local-set! cell.1$2(make-weak-hasheq)))))"
"(define-values"
"(make-module-cache-key)"
"(lambda(hash-code_0)"
"    (begin (if hash-code_0 (string->symbol (format \"~s\" (list hash-code_0 (current-load-relative-directory)))) #f))))"
"(define-values"
"(module-cache-set!)"
"(lambda(key_0 proc_0)(begin(hash-set!(unsafe-place-local-ref cell.1$2) key_0(make-ephemeron key_0 proc_0)))))"
"(define-values"
"(module-cache-ref)"
"(lambda(key_0)"
"(begin"
"(let-values(((e_0)(hash-ref(unsafe-place-local-ref cell.1$2) key_0 #f)))(if e_0(ephemeron-value e_0) #f)))))"
"(define-values(current-module-declare-as-predefined)(make-parameter #f))"
"(define-values"
"(eval-module8.1)"
"(lambda(namespace1_0 supermodule-name3_0 with-submodules?2_0 c7_0)"
"(begin"
" 'eval-module8"
"(let-values(((c_0) c7_0))"
"(let-values(((ns_0)(if(eq? namespace1_0 unsafe-undefined)(1/current-namespace) namespace1_0)))"
"(let-values(((with-submodules?_0) with-submodules?2_0))"
"(let-values(((supermodule-name_0) supermodule-name3_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'eval 'module))(void))"
"(begin0"
"(let-values()"
"(let-values(((dh_0 h_0 data-instance_0 declaration-instance_0)"
"(compiled-module->dh+h+data-instance+declaration-instance c_0)))"
"(let-values(((syntax-literals-data-instance_0)"
"(if(compiled-in-memory? c_0)"
"(make-syntax-literal-data-instance-from-compiled-in-memory c_0)"
"(let-values(((l_0)(hash-ref h_0 'stx-data #f)))"
"(if l_0"
"(let-values()"
"(1/instantiate-linklet"
"(eval-linklet* l_0)"
"(list deserialize-instance data-instance_0)))"
"(if(eq?(hash-ref h_0 'module->namespace #f) 'empty)"
"(let-values() empty-syntax-literals-instance/empty-namespace)"
"(let-values() empty-syntax-literals-data-instance)))))))"
"(let-values(((decl_0)"
"(lambda(key_0)"
"(begin 'decl(1/instance-variable-value declaration-instance_0 key_0)))))"
"(let-values(((pre-submodule-names_0)(hash-ref h_0 'pre null)))"
"(let-values(((post-submodule-names_0)(hash-ref h_0 'post null)))"
"(let-values(((default-name_0)(hash-ref h_0 'name 'module)))"
"(let-values(((cache-key_0)"
"(make-module-cache-key"
"(if(null? pre-submodule-names_0)"
"(if(null? post-submodule-names_0)(hash-ref h_0 'hash-code #f) #f)"
" #f))))"
"(let-values(((cross-phase-persistent?_0)"
"(hash-ref h_0 'cross-phase-persistent? #f)))"
"(let-values(((min-phase_0)(hash-ref h_0 'min-phase 0)))"
"(let-values(((max-phase_0)(hash-ref h_0 'max-phase 0)))"
"(let-values(((language-info_0)(hash-ref h_0 'language-info #f)))"
"(let-values(((phases-h_0)"
"(let-values(((start_0) min-phase_0)"
"((end_0)(add1 max-phase_0))"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((phase-level_0)"
" pos_0))"
"(let-values(((table_1)"
"(let-values(((v_0)"
"(hash-ref"
" h_0"
" phase-level_0"
" #f)))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(table_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((table_2)"
"(let-values(((table_2)"
" table_1))"
"(if v_0"
"(let-values(((table_3)"
" table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase-level_0"
"(eval-linklet*"
" v_0)))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4)))"
" table_2))))"
" table_2))))))"
" for-loop_1)"
" table_0)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(+ pos_0 inc_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
" start_0)))))"
"(let-values(((syntax-literals-linklet_0)"
"(let-values(((l_0)(hash-ref h_0 'stx #f)))"
"(if l_0(eval-linklet* l_0) #f))))"
"(let-values(((extra-inspector_0)"
"(if(compiled-in-memory? c_0)"
"(compiled-in-memory-compile-time-inspector c_0)"
" #f)))"
"(let-values(((phase-to-link-extra-inspectorsss_0)"
"(if(compiled-in-memory? c_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss"
" c_0)"
" '#hasheqv())))"
"(let-values(((requires_0)(decl_0 'requires)))"
"(let-values(((provides_0)(decl_0 'provides)))"
"(let-values(((original-self_0)(decl_0 'self-mpi)))"
"(let-values(((phase-to-link-modules_0)"
"(decl_0 'phase-to-link-modules)))"
"(let-values(((create-root-expand-context-from-module_0)"
"(make-create-root-expand-context-from-module"
" requires_0"
" phases-h_0)))"
"(let-values(((declare-submodules_0)"
"(if dh_0"
"(lambda(ns_1"
" names_0"
" declare-name_0"
" pre?_0)"
"(begin"
" 'declare-submodules"
"(if(compiled-in-memory? c_0)"
"(begin"
"(let-values(((lst_0)"
"(if pre?_0"
"(compiled-in-memory-pre-compiled-in-memorys"
" c_0)"
"(compiled-in-memory-post-compiled-in-memorys"
" c_0))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((c_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((c12_0)"
" c_1)"
"((ns13_0)"
" ns_1)"
"((declare-name14_0)"
" declare-name_0))"
"(eval-module8.1"
" ns13_0"
" declare-name14_0"
" #t"
" c12_0)))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void))"
"(begin"
"(let-values(((lst_0) names_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((name_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((sm-cd_0)"
"(hash-ref"
" dh_0"
" name_0"
" #f)))"
"(begin"
"(if sm-cd_0"
"(void)"
"(let-values()"
"(error"
"                                                                                                                                                                 \"missing submodule declaration:\""
" name_0)))"
"(let-values(((sm-cd15_0)"
" sm-cd_0)"
"((ns16_0)"
" ns_1)"
"((declare-name17_0)"
" declare-name_0))"
"(eval-module8.1"
" ns16_0"
" declare-name17_0"
" #t"
" sm-cd15_0)))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))))"
" void)))"
"(let-values(((declare-this-module_0)"
"(lambda(ns_1)"
"(begin"
" 'declare-this-module"
"(let-values(((m_0)"
"(let-values(((temp22_0)"
"(1/current-module-declare-source))"
"((original-self23_0)"
" original-self_0)"
"((requires24_0)"
" requires_0)"
"((provides25_0)"
" provides_0)"
"((language-info26_0)"
" language-info_0)"
"((min-phase27_0)"
" min-phase_0)"
"((max-phase28_0)"
" max-phase_0)"
"((cross-phase-persistent?29_0)"
" cross-phase-persistent?_0)"
"((temp30_0)"
"(current-module-declare-as-predefined))"
"((temp31_0)"
"(append"
" pre-submodule-names_0"
" post-submodule-names_0))"
"((supermodule-name32_0)"
" supermodule-name_0)"
"((temp33_0)"
"(lambda()"
"(get-all-variables"
" phases-h_0)))"
"((temp34_0)"
"(lambda(phase-level_0"
" ns_2"
" insp_0)"
"(module-linklet-info2.1"
"(hash-ref"
" phases-h_0"
" phase-level_0"
" #f)"
"(hash-ref"
" phase-to-link-modules_0"
" phase-level_0"
" #f)"
" original-self_0"
" insp_0"
" extra-inspector_0"
"(hash-ref"
" phase-to-link-extra-inspectorsss_0"
" phase-level_0"
" #f))))"
"((temp35_0)"
"(lambda(bulk-binding-registry_0)"
"(force-syntax-deserialize"
" syntax-literals-data-instance_0"
" bulk-binding-registry_0)))"
"((temp36_0)"
"(lambda(data-box_0"
" ns_2"
" phase-shift_0"
" self_0"
" bulk-binding-registry_0"
" insp_0)"
"(if(unbox"
" data-box_0)"
"(void)"
"(let-values()"
"(init-instance-data!"
" data-box_0"
" cache-key_0"
" ns_2"
" syntax-literals-linklet_0"
" data-instance_0"
" syntax-literals-data-instance_0"
" phase-shift_0"
" original-self_0"
" self_0"
" bulk-binding-registry_0"
" insp_0"
" create-root-expand-context-from-module_0)))))"
"((temp37_0)"
"(lambda(data-box_0"
" ns_2"
" phase-shift_0"
" phase-level_0"
" self_0"
" bulk-binding-registry_0"
" insp_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'eval"
" 'instantiate))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((syntax-literals-instance_0)"
"(instance-data-syntax-literals-instance"
"(unbox"
" data-box_0))))"
"(let-values(((phase-linklet_0)"
"(hash-ref"
" phases-h_0"
" phase-level_0"
" #f)))"
"(if phase-linklet_0"
"(let-values()"
"(let-values(((module-uses_0)"
"(hash-ref"
" phase-to-link-modules_0"
" phase-level_0)))"
"(let-values(((import-module-instances_0"
" import-instances_0)"
"(let-values(((mis_0"
" is_0)"
"(let-values(((lst_0)"
" module-uses_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(mis_0"
" is_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((mu_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((mis_1"
" is_1)"
"(let-values(((mis_1)"
" mis_0)"
"((is_1)"
" is_0))"
"(let-values(((mis_2"
" is_2)"
"(let-values()"
"(let-values(((mis45_0"
" is46_0)"
"(let-values()"
"(let-values(((ns47_0)"
" ns_2)"
"((mu48_0)"
" mu_0)"
"((original-self49_0)"
" original-self_0)"
"((self50_0)"
" self_0)"
"((temp51_0)"
"(phase+"
"(phase-"
" phase-level_0"
"(module-use-phase"
" mu_0))"
" phase-shift_0)))"
"(namespace-module-use->module+linklet-instances144.1"
" temp51_0"
" original-self49_0"
" self50_0"
" ns47_0"
" mu48_0)))))"
"(values"
"(cons"
" mis45_0"
" mis_1)"
"(cons"
" is46_0"
" is_1))))))"
"(values"
" mis_2"
" is_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" mis_1"
" is_1"
" rest_0)"
"(values"
" mis_1"
" is_1))))"
"(values"
" mis_0"
" is_0))))))"
" for-loop_0)"
" null"
" null"
" lst_0)))))"
"(values"
"(reverse$1"
" mis_0)"
"(reverse$1"
" is_0)))))"
"(let-values((()"
"(begin"
"(let-values(((phase-linklet38_0)"
" phase-linklet_0)"
"((temp39_0)"
" 2)"
"((module-uses40_0)"
" module-uses_0)"
"((import-module-instances41_0)"
" import-module-instances_0)"
"((insp42_0)"
" insp_0)"
"((extra-inspector43_0)"
" extra-inspector_0)"
"((temp44_0)"
"(hash-ref"
" phase-to-link-extra-inspectorsss_0"
" phase-level_0"
" #f)))"
"(check-require-access9.1"
" temp39_0"
" phase-linklet38_0"
" module-uses40_0"
" import-module-instances41_0"
" insp42_0"
" extra-inspector43_0"
" temp44_0))"
"(values))))"
"(let-values(((module-body-instance-instance_0)"
"(let-values(((temp52_0)"
"(lambda(name_0"
" val_0)"
"(namespace-set-transformer!"
" ns_2"
"(sub1"
" phase-level_0)"
" name_0"
" val_0))))"
"(make-module-body-instance-instance18.1"
" temp52_0))))"
"(let-values(((instantiate-body_0)"
"(lambda()"
"(begin"
" 'instantiate-body"
"(1/instantiate-linklet"
" phase-linklet_0"
"(list*"
" syntax-literals-instance_0"
" module-body-instance-instance_0"
" import-instances_0)"
"(namespace->instance"
" ns_2"
" phase-level_0))))))"
"(if(zero-phase?"
" phase-level_0)"
"(let-values()"
"(if(zero-phase?"
" phase-shift_0)"
"(let-values()"
"(instantiate-body_0))"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" ns_2)"
"(let-values()"
"(instantiate-body_0))))))"
"(let-values()"
"(let-values(((ns-1_0)"
"(namespace->namespace-at-phase"
" ns_2"
"(phase+"
" phase-shift_0"
"(sub1"
" phase-level_0)))))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" ns_2)"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
"(promise1.1"
"(lambda()"
"(let-values(((ns-153_0)"
" ns-1_0))"
"(make-expand-context12.1"
" #f"
" #f"
" #f"
" #f"
" ns-153_0)))"
" #f)"
"(with-continuation-mark"
" current-module-code-inspector"
" insp_0"
"(let-values()"
"(instantiate-body_0)))))))))))))))"
"(void)))))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void)))))))"
"(make-module39.1"
" cross-phase-persistent?29_0"
" temp35_0"
" temp33_0"
" temp37_0"
" language-info26_0"
" max-phase28_0"
" min-phase27_0"
" #f"
" temp34_0"
" temp30_0"
" temp36_0"
" #f"
" provides25_0"
" requires24_0"
" original-self23_0"
" temp22_0"
" temp31_0"
" supermodule-name32_0))))"
"(let-values(((declare-name_0)"
"(substitute-module-declare-name"
" default-name_0)))"
"(begin"
"(if with-submodules?_0"
"(let-values()"
"(declare-submodules_0"
" ns_1"
" pre-submodule-names_0"
" declare-name_0"
" #t))"
"(void))"
"(let-values(((ns18_0) ns_1)"
"((m19_0) m_0)"
"((declare-name20_0)"
" declare-name_0)"
"((with-submodules?21_0)"
" with-submodules?_0))"
"(declare-module!58.1"
" with-submodules?21_0"
" ns18_0"
" m19_0"
" declare-name20_0))"
"(if with-submodules?_0"
"(let-values()"
"(declare-submodules_0"
" ns_1"
" post-submodule-names_0"
" declare-name_0"
" #f))"
"(void)))))))))"
"(begin"
"(if cache-key_0"
"(let-values()"
"(module-cache-set!"
" cache-key_0"
" declare-this-module_0))"
"(void))"
"(declare-this-module_0 ns_0)))))))))))))))))))))))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))))))"
"(define-values"
"(struct:instance-data instance-data11.1 instance-data? instance-data-syntax-literals-instance instance-data-cache-key)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'instance-data #f 2 0 #f null(current-inspector) #f '(0 1) #f 'instance-data)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'syntax-literals-instance)"
"(make-struct-field-accessor -ref_0 1 'cache-key))))"
"(define-values"
"(init-instance-data!)"
"(lambda(data-box_0"
" cache-key_0"
" ns_0"
" syntax-literals-linklet_0"
" data-instance_0"
" syntax-literals-data-instance_0"
" phase-shift_0"
" original-self_0"
" self_0"
" bulk-binding-registry_0"
" insp_0"
" create-root-expand-context-from-module_0)"
"(begin"
"(let-values((()"
"(begin"
"(if(not(load-on-demand-enabled))"
"(let-values()"
"(force-syntax-deserialize syntax-literals-data-instance_0 bulk-binding-registry_0))"
"(void))"
"(values))))"
"(let-values(((inst_0)"
"(let-values(((ns55_0) ns_0)"
"((phase-shift56_0) phase-shift_0)"
"((self57_0) self_0)"
"((insp58_0) insp_0)"
"((bulk-binding-registry59_0) bulk-binding-registry_0)"
"((temp60_0)"
"                                    (lambda (name_0 val_0) (error \"shouldn't get here for the root-ctx linklet\"))))"
"(make-instance-instance13.1"
" bulk-binding-registry59_0"
" insp58_0"
" ns55_0"
" phase-shift56_0"
" self57_0"
" temp60_0))))"
"(let-values(((syntax-literals-instance_0)"
"(if syntax-literals-linklet_0"
"(1/instantiate-linklet"
" syntax-literals-linklet_0"
"(list deserialize-instance data-instance_0 syntax-literals-data-instance_0 inst_0))"
" empty-syntax-literals-instance)))"
"(let-values((()"
"(begin"
"(set-box! data-box_0(instance-data11.1 syntax-literals-instance_0 cache-key_0))"
"(values))))"
"(let-values(((get-encoded-root-expand-ctx_0)"
"(1/instance-variable-value syntax-literals-instance_0 'get-encoded-root-expand-ctx)))"
"(if(eq? get-encoded-root-expand-ctx_0 'empty)"
"(let-values()"
"(namespace-set-root-expand-ctx!"
" ns_0"
"(promise1.1"
"(lambda()"
"(shift-to-inside-root-context"
"(let-values(((self61_0) self_0))"
"(make-root-expand-context13.1 #f null unsafe-undefined unsafe-undefined self61_0))))"
" #f)))"
"(if(procedure? get-encoded-root-expand-ctx_0)"
"(let-values()"
"(namespace-set-root-expand-ctx!"
" ns_0"
"(promise1.1"
"(lambda()"
"(shift-to-inside-root-context"
"(root-expand-context-decode-for-module(get-encoded-root-expand-ctx_0) self_0)))"
" #f)))"
"(let-values()"
"(namespace-set-root-expand-ctx!"
" ns_0"
"(promise1.1"
"(lambda()"
"(shift-to-inside-root-context"
"(create-root-expand-context-from-module_0 ns_0 phase-shift_0 original-self_0 self_0)))"
" #f)))))))))))))"
"(define-values"
"(force-syntax-deserialize)"
"(lambda(syntax-literals-data-instance_0 bulk-binding-registry_0)"
"(begin"
"(if(let-values(((or-part_0)(eq? syntax-literals-data-instance_0 empty-syntax-literals-data-instance)))"
"(if or-part_0"
" or-part_0"
"(eq? syntax-literals-data-instance_0 empty-syntax-literals-instance/empty-namespace)))"
"(void)"
"(let-values()"
"(let-values(((deserialize-syntax_0)"
"(1/instance-variable-value syntax-literals-data-instance_0 deserialize-syntax-id)))"
"(if deserialize-syntax_0(let-values()(deserialize-syntax_0 bulk-binding-registry_0))(void))))))))"
"(define-values"
"(compiled-module->dh+h)"
"(lambda(c_0)"
"(begin"
"(let-values(((ld/h_0)(if(compiled-in-memory? c_0)(compiled-in-memory-linklet-directory c_0) c_0)))"
"(let-values(((dh_0)"
"(if(linklet-directory? ld/h_0)"
"(let-values()(linklet-directory->hash ld/h_0))"
"(let-values() #f))))"
"(let-values(((h_0)(linklet-bundle->hash(if dh_0(hash-ref dh_0 #f) ld/h_0))))(values dh_0 h_0)))))))"
"(define-values(compiled-module->h)(lambda(c_0)(begin(let-values(((dh_0 h_0)(compiled-module->dh+h c_0))) h_0))))"
"(define-values"
"(compiled-module->dh+h+data-instance+declaration-instance)"
"(lambda(c_0)"
"(begin"
"(let-values(((dh_0 h_0)(compiled-module->dh+h c_0)))"
"(let-values(((data-instance_0)"
"(if(compiled-in-memory? c_0)"
"(make-data-instance-from-compiled-in-memory c_0)"
"(1/instantiate-linklet(eval-linklet*(hash-ref h_0 'data))(list deserialize-instance)))))"
"(let-values(((declaration-instance_0)"
"(if(if(compiled-in-memory? c_0)(compiled-in-memory-original-self c_0) #f)"
"(make-declaration-instance-from-compiled-in-memory c_0)"
"(1/instantiate-linklet"
"(eval-linklet*(hash-ref h_0 'decl))"
"(list deserialize-instance data-instance_0)))))"
"(values dh_0 h_0 data-instance_0 declaration-instance_0)))))))"
"(define-values"
"(compiled-module->declaration-instance)"
"(lambda(c_0)"
"(begin"
"(let-values(((dh_0 h_0 data-instance_0 declaration-instance_0)"
"(compiled-module->dh+h+data-instance+declaration-instance c_0)))"
" declaration-instance_0))))"
"(define-values"
"(compiled-module->h+declaration-instance)"
"(lambda(c_0)"
"(begin"
"(let-values(((dh_0 h_0 data-instance_0 declaration-instance_0)"
"(compiled-module->dh+h+data-instance+declaration-instance c_0)))"
"(values h_0 declaration-instance_0)))))"
"(define-values"
"(make-data-instance-from-compiled-in-memory)"
"(lambda(cim_0)(begin(1/make-instance 'data #f 'constant mpi-vector-id(compiled-in-memory-mpis cim_0)))))"
"(define-values"
"(make-declaration-instance-from-compiled-in-memory)"
"(lambda(cim_0)"
"(begin"
"(1/make-instance"
" 'decl"
" #f"
" 'constant"
" 'self-mpi"
"(compiled-in-memory-original-self cim_0)"
" 'requires"
"(compiled-in-memory-requires cim_0)"
" 'provides"
"(compiled-in-memory-provides cim_0)"
" 'phase-to-link-modules"
"(compiled-in-memory-phase-to-link-module-uses cim_0)))))"
"(define-values"
"(make-syntax-literal-data-instance-from-compiled-in-memory)"
"(lambda(cim_0)"
"(begin"
"(1/make-instance"
" 'syntax-literal-data"
" #f"
" #f"
" deserialize-syntax-id"
" void"
" deserialized-syntax-vector-id"
"(compiled-in-memory-syntax-literals cim_0)))))"
"(define-values"
"(empty-syntax-literals-instance/empty-namespace)"
"(1/make-instance"
" 'empty-stx/empty-ns"
" #f"
" 'constant"
" get-syntax-literal!-id"
"(lambda(pos_0) #f)"
" 'get-encoded-root-expand-ctx"
" 'empty))"
"(define-values"
"(get-all-variables)"
"(lambda(phases-h_0)"
"(begin"
"(let-values(((ht_0) phases-h_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 linklet_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" phase_0"
"(1/linklet-export-variables"
" linklet_0)))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1(hash-iterate-next ht_0 i_0)) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first ht_0)))))))"
"(define-values(eval-linklet*)(lambda(l_0)(begin(1/eval-linklet(force-compile-linklet l_0)))))"
"(define-values"
"(provides->api-provides)"
"(lambda(provides_0 self_0)"
"(begin"
"(let-values(((extract_0)"
"(lambda(ok?_0)"
"(begin"
" 'extract"
"(let-values(((result-l_0)"
"(reverse$1"
"(let-values(((ht_0) provides_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 at-phase_0)"
"(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((l_0)"
"(reverse$1"
"(let-values(((ht_1)"
" at-phase_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1"
" i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((sym_0"
" b/p_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" fold-var_1))"
"(if(ok?_0"
" b/p_0)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((b_0)"
"(provided-as-binding"
" b/p_0)))"
"(list"
" sym_0"
"(if(eq?"
" self_0"
"(module-binding-module"
" b_0))"
"(let-values()"
" null)"
"(let-values()"
"(reverse$1"
"(let-values(((lst_0)"
"(cons"
" b_0"
"(module-binding-extra-nominal-bindings"
" b_0))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_2)"
"(lambda(fold-var_4"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((b_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_5)"
"(let-values(((fold-var_5)"
" fold-var_4))"
"(let-values(((fold-var_6)"
"(let-values()"
"(cons"
"(let-values()"
"(if(if(eqv?"
"(module-binding-nominal-phase"
" b_1)"
" phase_0)"
"(eq?"
"(module-binding-nominal-sym"
" b_1)"
" sym_0)"
" #f)"
"(let-values()"
"(module-binding-nominal-module"
" b_1))"
"(let-values()"
"(list"
"(module-binding-nominal-module"
" b_1)"
"(module-binding-phase"
" b_1)"
"(module-binding-nominal-sym"
" b_1)"
"(module-binding-nominal-phase"
" b_1)))))"
" fold-var_5))))"
"(values"
" fold-var_6)))))"
"(if(not"
" #f)"
"(for-loop_2"
" fold-var_5"
" rest_0)"
" fold-var_5)))"
" fold-var_4)))))"
" for-loop_2)"
" null"
" lst_0)))))))))"
" fold-var_3))))"
"(values"
" fold-var_4)))"
" fold-var_2))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_2"
"(hash-iterate-next"
" ht_1"
" i_1))"
" fold-var_2)))"
" fold-var_1)))))"
" for-loop_1)"
" null"
"(hash-iterate-first"
" ht_1)))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((fold-var_2)"
"(let-values(((fold-var_2)"
" fold-var_1))"
"(if(null?"
" l_0)"
" fold-var_2"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
" phase_0"
"(let-values(((l4_0)"
" l_0)"
"((symbol<?5_0)"
" symbol<?)"
"((car6_0)"
" car))"
"(sort7.1"
" #f"
" car6_0"
" l4_0"
" symbol<?5_0))))"
" fold-var_3))))"
"(values"
" fold-var_4)))))))"
" fold-var_2))))))"
" for-loop_1)"
" fold-var_0)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
"(hash-iterate-next ht_0 i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(hash-iterate-first ht_0)))))))"
"(let-values(((result-l1_0) result-l_0)((phase<?2_0) phase<?)((car3_0) car))"
"(sort7.1 #f car3_0 result-l1_0 phase<?2_0)))))))"
"(values"
"(extract_0(lambda(b/p_0)(not(provided-as-transformer? b/p_0))))"
"(extract_0 provided-as-transformer?))))))"
"(define-values"
"(variables->api-nonprovides)"
"(lambda(provides_0 all-vars_0)"
"(begin"
"(let-values(((result-l_0)"
"(reverse$1"
"(let-values(((ht_0) all-vars_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 vars_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((l_0)"
"(let-values(((syms_0)"
"(hash-ref"
" provides_0"
" phase_0"
" '#hasheq())))"
"(reverse$1"
"(let-values(((lst_0) vars_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((var-sym_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(if(hash-ref"
" syms_0"
" var-sym_0"
" #f)"
" fold-var_3"
"(let-values(((fold-var_4)"
" fold-var_3))"
"(let-values(((fold-var_5)"
"(let-values()"
"(cons"
"(let-values()"
" var-sym_0)"
" fold-var_4))))"
"(values"
" fold-var_5)))))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_3"
" rest_0)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
" lst_0)))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(if(null?"
" l_0)"
" fold-var_3"
"(let-values(((fold-var_4)"
" fold-var_3))"
"(let-values(((fold-var_5)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
" phase_0"
"(let-values(((l10_0)"
" l_0)"
"((symbol<?11_0)"
" symbol<?))"
"(sort7.1"
" #f"
" #f"
" l10_0"
" symbol<?11_0))))"
" fold-var_4))))"
"(values"
" fold-var_5)))))))"
" fold-var_3))))))"
" for-loop_1)"
" fold-var_1))))))"
"(if(not #f)"
"(for-loop_0 fold-var_1(hash-iterate-next ht_0 i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(hash-iterate-first ht_0)))))))"
"(let-values(((result-l7_0) result-l_0)((phase<?8_0) phase<?)((car9_0) car))"
"(sort7.1 #f car9_0 result-l7_0 phase<?8_0))))))"
"(define-values"
"(1/compiled-expression?)"
"(lambda(c_0)"
"(begin"
" 'compiled-expression?"
"(let-values(((or-part_0)(compiled-in-memory? c_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(linklet-directory? c_0)))(if or-part_1 or-part_1(linklet-bundle? c_0))))))))"
"(define-values"
"(1/compiled-module-expression?)"
"(lambda(c_0)"
"(begin"
" 'compiled-module-expression?"
"(let-values(((ld_0)(compiled->linklet-directory-or-bundle c_0)))"
"(let-values(((or-part_0)"
"(if(linklet-directory? ld_0)"
"(if(let-values(((b_0)(hash-ref(linklet-directory->hash ld_0) #f #f)))"
"(if b_0(hash-ref(linklet-bundle->hash b_0) 'decl #f) #f))"
" #t"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(if(linklet-bundle? ld_0)(if(hash-ref(linklet-bundle->hash ld_0) 'decl #f) #t #f) #f)))))))"
"(define-values"
"(compiled->linklet-directory-or-bundle)"
"(lambda(c_0)(begin(if(compiled-in-memory? c_0)(compiled-in-memory-linklet-directory c_0) c_0))))"
"(define-values"
"(normalize-to-linklet-directory)"
"(lambda(c_0)"
"(begin"
"(if(linklet-directory?(compiled->linklet-directory-or-bundle c_0))"
"(let-values() c_0)"
"(if(linklet-bundle? c_0)"
"(let-values()(hash->linklet-directory(hasheq #f c_0)))"
"(let-values()"
"(let-values(((the-struct_0) c_0))"
"(if(compiled-in-memory? the-struct_0)"
"(let-values(((linklet-directory1_0)"
"(normalize-to-linklet-directory(compiled-in-memory-linklet-directory c_0))))"
"(compiled-in-memory1.1"
" linklet-directory1_0"
"(compiled-in-memory-original-self the-struct_0)"
"(compiled-in-memory-requires the-struct_0)"
"(compiled-in-memory-provides the-struct_0)"
"(compiled-in-memory-phase-to-link-module-uses the-struct_0)"
"(compiled-in-memory-compile-time-inspector the-struct_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss the-struct_0)"
"(compiled-in-memory-mpis the-struct_0)"
"(compiled-in-memory-syntax-literals the-struct_0)"
"(compiled-in-memory-pre-compiled-in-memorys the-struct_0)"
"(compiled-in-memory-post-compiled-in-memorys the-struct_0)"
"(compiled-in-memory-namespace-scopes the-struct_0)"
"(compiled-in-memory-purely-functional? the-struct_0)))"
"                (raise-argument-error 'struct-copy \"compiled-in-memory?\" the-struct_0)))))))))"
"(define-values"
"(1/module-compiled-name)"
"(let-values()"
"(let-values()"
"(case-lambda"
"((c_0)"
"(begin"
" 'module-compiled-name"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"              (let-values () (raise-argument-error 'module-compiled-name \"compiled-module-expression?\" c_0)))"
"(module-compiled-current-name c_0))))"
"((c_0 name_0)"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"                            (raise-argument-error 'module-compiled-name \"compiled-module-expression?\" c_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(symbol? name_0)))"
"(if or-part_0"
" or-part_0"
"(if(pair? name_0)(if(list? name_0)(andmap2 symbol? name_0) #f) #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-compiled-name"
"                               \"(or/c symbol? (cons/c symbol? (non-empty-listof symbol?)))\""
" name_0)))"
"(values))))"
"(let-values(((i-name_0 prefix_0)"
"(if(symbol? name_0)"
"(values name_0 null)"
"(let-values(((r_0)(reverse$1 name_0)))(values(car r_0)(reverse$1(cdr r_0)))))))"
"(change-module-name c_0 i-name_0 prefix_0)))))))))"
"(define-values"
"(module-compiled-current-name)"
"(lambda(c_0)"
"(begin"
"(let-values(((ld_0)(compiled->linklet-directory-or-bundle c_0)))"
"(let-values(((b_0)(if(linklet-bundle? ld_0) ld_0(hash-ref(linklet-directory->hash ld_0) #f))))"
"(hash-ref(linklet-bundle->hash b_0) 'name))))))"
"(define-values"
"(module-compiled-immediate-name)"
"(lambda(c_0)"
"(begin(let-values(((n_0)(module-compiled-current-name c_0)))(if(pair? n_0)(car(reverse$1 n_0)) n_0)))))"
"(define-values"
"(change-module-name)"
"(lambda(c_0 name_0 prefix_0)"
"(begin"
"(let-values(((full-name_0)(if(null? prefix_0) name_0(append prefix_0(list name_0)))))"
"(let-values(((next-prefix_0)(if(null? prefix_0)(list name_0) full-name_0)))"
"(let-values(((recur_0)"
"(lambda(sub-c_0 name_1)"
"(begin"
" 'recur"
"(if(equal?(module-compiled-current-name sub-c_0)(append next-prefix_0(list name_1)))"
" sub-c_0"
"(change-module-name sub-c_0 name_1 next-prefix_0))))))"
"(if(compiled-in-memory? c_0)"
"(let-values()"
"(let-values(((change-submodule-name_0)"
"(lambda(sub-c_0)"
"(begin"
" 'change-submodule-name"
"(recur_0 sub-c_0(module-compiled-immediate-name sub-c_0))))))"
"(let-values(((pre-compiled-in-memorys_0)"
"(map2 change-submodule-name_0(compiled-in-memory-pre-compiled-in-memorys c_0))))"
"(let-values(((post-compiled-in-memorys_0)"
"(map2 change-submodule-name_0(compiled-in-memory-post-compiled-in-memorys c_0))))"
"(let-values(((the-struct_0) c_0))"
"(if(compiled-in-memory? the-struct_0)"
"(let-values(((pre-compiled-in-memorys9_0) pre-compiled-in-memorys_0)"
"((post-compiled-in-memorys10_0) post-compiled-in-memorys_0)"
"((linklet-directory11_0)"
"(let-values(((temp12_0)"
"(update-one-name"
"(let-values(((ld_0)"
"(compiled->linklet-directory-or-bundle c_0)))"
"(if(linklet-bundle? ld_0)"
" ld_0"
"(hash-ref(linklet-directory->hash ld_0) #f)))"
" full-name_0))"
"((temp13_0)(symbol? full-name_0))"
"((temp14_0)"
"(append pre-compiled-in-memorys_0 post-compiled-in-memorys_0)))"
"(rebuild-linklet-directory5.1 temp13_0 temp12_0 temp14_0))))"
"(compiled-in-memory1.1"
" linklet-directory11_0"
"(compiled-in-memory-original-self the-struct_0)"
"(compiled-in-memory-requires the-struct_0)"
"(compiled-in-memory-provides the-struct_0)"
"(compiled-in-memory-phase-to-link-module-uses the-struct_0)"
"(compiled-in-memory-compile-time-inspector the-struct_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss the-struct_0)"
"(compiled-in-memory-mpis the-struct_0)"
"(compiled-in-memory-syntax-literals the-struct_0)"
" pre-compiled-in-memorys9_0"
" post-compiled-in-memorys10_0"
"(compiled-in-memory-namespace-scopes the-struct_0)"
"(compiled-in-memory-purely-functional? the-struct_0)))"
"                          (raise-argument-error 'struct-copy \"compiled-in-memory?\" the-struct_0)))))))"
"(if(linklet-directory? c_0)"
"(let-values()"
"(hash->linklet-directory"
"(let-values(((ht_0)(linklet-directory->hash c_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((key_0 val_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_1 val_1)"
"(let-values()"
"(values"
" key_0"
"(if(not key_0)"
"(update-one-name"
" val_0"
" full-name_0)"
"(recur_0"
" val_0"
" key_0))))))"
"(hash-set table_1 key_1 val_1)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first ht_0))))))"
"(let-values()(update-one-name c_0 full-name_0))))))))))"
"(define-values"
"(update-one-name)"
"(lambda(lb_0 name_0)(begin(hash->linklet-bundle(hash-set(linklet-bundle->hash lb_0) 'name name_0)))))"
"(define-values"
"(rebuild-linklet-directory5.1)"
"(lambda(bundle-ok?1_0 main3_0 submods4_0)"
"(begin"
" 'rebuild-linklet-directory5"
"(let-values(((main_0) main3_0))"
"(let-values(((submods_0) submods4_0))"
"(let-values(((bundle-ok?_0) bundle-ok?1_0))"
"(let-values()"
"(if(if(null? submods_0) bundle-ok?_0 #f)"
"(let-values() main_0)"
"(let-values()"
"(hash->linklet-directory"
"(hash-set"
"(let-values(((lst_0) submods_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((submod_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((ht_1)"
"(let-values(((ht_1) ht_0))"
"(let-values(((ht_2)"
"(let-values()"
"(let-values(((name_0)"
"(module-compiled-immediate-name"
" submod_0)))"
"(if(hash-ref ht_1 name_0 #f)"
"(let-values()"
"(raise-arguments-error"
" 'module-compiled-submodules"
"                                                                                         \"change would result in duplicate submodule name\""
"                                                                                         \"name\""
" name_0))"
"(let-values()"
"(hash-set"
" ht_1"
" name_0"
"(compiled->linklet-directory-or-bundle"
" submod_0))))))))"
"(values ht_2)))))"
"(if(not #f)(for-loop_0 ht_1 rest_0) ht_1)))"
" ht_0)))))"
" for-loop_0)"
" '#hasheq()"
" lst_0)))"
" #f"
" main_0)))))))))))"
"(define-values"
"(1/module-compiled-submodules)"
"(let-values()"
"(let-values()"
"(case-lambda"
"((c_0 non-star?_0)"
"(begin"
" 'module-compiled-submodules"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"              (let-values () (raise-argument-error 'module-compiled-submodules \"compiled-module-expression?\" c_0)))"
"(if(compiled-in-memory? c_0)"
"(let-values()"
"(if non-star?_0"
"(compiled-in-memory-pre-compiled-in-memorys c_0)"
"(compiled-in-memory-post-compiled-in-memorys c_0)))"
"(let-values()"
"(if(linklet-directory? c_0)"
"(let-values()"
"(let-values(((ht_0)(linklet-directory->hash c_0)))"
"(let-values(((bh_0)(linklet-bundle->hash(hash-ref ht_0 #f))))"
"(let-values(((names_0)(hash-ref bh_0(if non-star?_0 'pre 'post) null)))"
"(reverse$1"
"(let-values(((lst_0) names_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((name_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(hash-ref ht_0 name_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))"
"(let-values() null)))))))"
"((c_0 non-star?_0 submods_0)"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"            (let-values () (raise-argument-error 'module-compiled-submodules \"compiled-module-expression?\" c_0)))"
"(if(if(list? submods_0)(andmap2 1/compiled-module-expression? submods_0) #f)"
"(void)"
"(let-values()"
"              (raise-argument-error 'module-compiled-submodules \"(listof compiled-module-expression?)\" submods_0)))"
"(if(if(null? submods_0)"
"(let-values(((or-part_0)(linklet-bundle?(compiled->linklet-directory-or-bundle c_0))))"
"(if or-part_0"
" or-part_0"
"(if(compiled-in-memory? c_0)"
"(null?"
"(if non-star?_0"
"(compiled-in-memory-pre-compiled-in-memorys c_0)"
"(compiled-in-memory-post-compiled-in-memorys c_0)))"
" #f)))"
" #f)"
"(let-values() c_0)"
"(if(if(compiled-in-memory? c_0)(andmap2 compiled-in-memory? submods_0) #f)"
"(let-values()"
"(let-values(((pre-compiled-in-memorys_0)"
"(if non-star?_0 submods_0(compiled-in-memory-pre-compiled-in-memorys c_0))))"
"(let-values(((post-compiled-in-memorys_0)"
"(if non-star?_0(compiled-in-memory-post-compiled-in-memorys c_0) submods_0)))"
"(let-values(((n-c_0)(normalize-to-linklet-directory c_0)))"
"(fixup-submodule-names"
"(let-values(((the-struct_0) n-c_0))"
"(if(compiled-in-memory? the-struct_0)"
"(let-values(((pre-compiled-in-memorys2_0) pre-compiled-in-memorys_0)"
"((post-compiled-in-memorys3_0) post-compiled-in-memorys_0)"
"((linklet-directory4_0)"
"(let-values(((temp5_0)"
"(reset-submodule-names"
"(hash-ref"
"(linklet-directory->hash"
"(compiled->linklet-directory-or-bundle n-c_0))"
" #f)"
" non-star?_0"
" submods_0))"
"((temp6_0)(symbol?(module-compiled-current-name c_0)))"
"((temp7_0)"
"(append pre-compiled-in-memorys_0 post-compiled-in-memorys_0)))"
"(rebuild-linklet-directory5.1 temp6_0 temp5_0 temp7_0))))"
"(compiled-in-memory1.1"
" linklet-directory4_0"
"(compiled-in-memory-original-self the-struct_0)"
"(compiled-in-memory-requires the-struct_0)"
"(compiled-in-memory-provides the-struct_0)"
"(compiled-in-memory-phase-to-link-module-uses the-struct_0)"
"(compiled-in-memory-compile-time-inspector the-struct_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss the-struct_0)"
"(compiled-in-memory-mpis the-struct_0)"
"(compiled-in-memory-syntax-literals the-struct_0)"
" pre-compiled-in-memorys2_0"
" post-compiled-in-memorys3_0"
"(compiled-in-memory-namespace-scopes the-struct_0)"
"(compiled-in-memory-purely-functional? the-struct_0)))"
"                           (raise-argument-error 'struct-copy \"compiled-in-memory?\" the-struct_0))))))))"
"(let-values()"
"(let-values(((n-c_0)(normalize-to-linklet-directory c_0)))"
"(fixup-submodule-names"
"(let-values(((temp8_0)"
"(reset-submodule-names"
"(hash-ref(linklet-directory->hash(compiled->linklet-directory-or-bundle n-c_0)) #f)"
" non-star?_0"
" submods_0))"
"((temp9_0)"
"(map2"
" compiled->linklet-directory-or-bundle"
"(append"
"(if non-star?_0 submods_0(1/module-compiled-submodules c_0 #t))"
"(if non-star?_0(1/module-compiled-submodules c_0 #f) submods_0)))))"
"(rebuild-linklet-directory5.1 #f temp8_0 temp9_0)))))))))))))"
"(define-values"
"(fixup-submodule-names)"
"(lambda(c_0)(begin(1/module-compiled-name c_0(1/module-compiled-name c_0)))))"
"(define-values"
"(reset-submodule-names)"
"(lambda(b_0 pre?_0 submods_0)"
"(begin"
"(hash->linklet-bundle"
"(hash-set(linklet-bundle->hash b_0)(if pre?_0 'pre 'post)(map2 module-compiled-immediate-name submods_0))))))"
"(define-values"
"(1/module-compiled-language-info)"
"(lambda(c_0)"
"(begin"
" 'module-compiled-language-info"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'module-compiled-language-info \"compiled-module-expression?\" c_0)))"
"(values))))"
"(let-values(((h_0)(compiled-module->h c_0)))(hash-ref h_0 'language-info #f))))))))"
"(define-values"
"(1/module-compiled-imports)"
"(lambda(c_0)"
"(begin"
" 'module-compiled-imports"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'module-compiled-imports \"compiled-module-expression?\" c_0)))"
"(values))))"
"(let-values(((inst_0)(compiled-module->declaration-instance c_0)))"
"(1/instance-variable-value inst_0 'requires))))))))"
"(define-values"
"(1/module-compiled-exports)"
"(lambda(c_0)"
"(begin"
" 'module-compiled-exports"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'module-compiled-exports \"compiled-module-expression?\" c_0)))"
"(values))))"
"(let-values(((inst_0)(compiled-module->declaration-instance c_0)))"
"(provides->api-provides"
"(1/instance-variable-value inst_0 'provides)"
"(1/instance-variable-value inst_0 'self-mpi)))))))))"
"(define-values"
"(1/module-compiled-indirect-exports)"
"(lambda(c_0)"
"(begin"
" 'module-compiled-indirect-exports"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-compiled-indirect-exports"
"                               \"compiled-module-expression?\""
" c_0)))"
"(values))))"
"(let-values(((h_0 inst_0)(compiled-module->h+declaration-instance c_0)))"
"(let-values(((min-phase_0)(hash-ref h_0 'min-phase 0)))"
"(let-values(((max-phase_0)(hash-ref h_0 'max-phase 0)))"
"(variables->api-nonprovides"
"(1/instance-variable-value inst_0 'provides)"
"(let-values(((start_0) min-phase_0)((end_0)(add1 max-phase_0))((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((phase-level_0) pos_0))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(let-values(((linklet_0)"
"(hash-ref"
" h_0"
" phase-level_0"
" #f)))"
"(values"
" phase-level_0"
"(if linklet_0"
"(1/linklet-export-variables"
" linklet_0)"
" null))))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1(+ pos_0 inc_0)) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
" start_0)))))))))))))"
"(define-values"
"(1/module-compiled-cross-phase-persistent?)"
"(lambda(c_0)"
"(begin"
" 'module-compiled-cross-phase-persistent?"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/compiled-module-expression? c_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'module-compiled-cross-phase-persistent?"
"                               \"compiled-module-expression?\""
" c_0)))"
"(values))))"
"(let-values(((h_0)(compiled-module->h c_0)))(hash-ref h_0 'cross-phase-persistent? #f))))))))"
"(define-values"
"(compile-module13.1)"
"(lambda(force-linklet-directory?1_0"
" modules-being-compiled4_0"
" need-compiled-submodule-rename?5_0"
" serializable?2_0"
" to-correlated-linklet?3_0"
" p11_0"
" cctx12_0)"
"(begin"
" 'compile-module13"
"(let-values(((p_0) p11_0))"
"(let-values(((cctx_0) cctx12_0))"
"(let-values(((force-linklet-directory?_0) force-linklet-directory?1_0))"
"(let-values(((serializable?_0) serializable?2_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?3_0))"
"(let-values(((modules-being-compiled_0)"
"(if(eq? modules-being-compiled4_0 unsafe-undefined)"
"(make-hasheq)"
" modules-being-compiled4_0)))"
"(let-values(((need-compiled-submodule-rename?_0) need-compiled-submodule-rename?5_0))"
"(let-values()"
"(let-values(((full-module-name_0)"
"(let-values(((parent-full-name_0)(compile-context-full-module-name cctx_0))"
"((name_0)(syntax-e$1(parsed-module-name-id p_0))))"
"(if parent-full-name_0"
"(append"
"(if(list? parent-full-name_0) parent-full-name_0(list parent-full-name_0))"
"(list name_0))"
" name_0))))"
"(let-values(((compiled-submodules_0)(parsed-module-compiled-submodules p_0)))"
"(let-values(((get-submodules_0)"
"(lambda(star?_0)"
"(begin"
" 'get-submodules"
"(reverse$1"
"(let-values(((ht_0) compiled-submodules_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((name_0 star?+compiled_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(if(eq?"
" star?_0"
"(car star?+compiled_0))"
"(let-values(((fold-var_2)"
" fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
" name_0"
"(if(if need-compiled-submodule-rename?_0"
"(not"
"(parsed-module-compiled-module"
" p_0))"
" #f)"
"(update-submodule-names"
"(cdr"
" star?+compiled_0)"
" name_0"
" full-module-name_0)"
"(cdr"
" star?+compiled_0))))"
" fold-var_2))))"
"(values fold-var_3)))"
" fold-var_1))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
"(hash-iterate-next ht_0 i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(hash-iterate-first ht_0)))))))))"
"(let-values(((pre-submodules_0)(get-submodules_0 #f)))"
"(let-values(((post-submodules_0)(get-submodules_0 #t)))"
"(let-values(((c1_0)(parsed-module-compiled-module p_0)))"
"(if c1_0"
"((lambda(c_0)"
"(let-values(((name_0 prefix_0)"
"(if(symbol? full-module-name_0)"
"(values full-module-name_0 null)"
"(let-values(((r_0)(reverse$1 full-module-name_0)))"
"(values(car r_0)(reverse$1(cdr r_0)))))))"
"(let-values(((m_0)(change-module-name c_0 name_0 prefix_0)))"
"(1/module-compiled-submodules"
"(1/module-compiled-submodules m_0 #t(map2 cdr pre-submodules_0))"
" #f"
"(map2 cdr post-submodules_0)))))"
" c1_0)"
"(let-values()"
"(let-values(((p37_0) p_0)"
"((cctx38_0) cctx_0)"
"((full-module-name39_0) full-module-name_0)"
"((force-linklet-directory?40_0) force-linklet-directory?_0)"
"((serializable?41_0) serializable?_0)"
"((to-correlated-linklet?42_0) to-correlated-linklet?_0)"
"((modules-being-compiled43_0) modules-being-compiled_0)"
"((pre-submodules44_0) pre-submodules_0)"
"((post-submodules45_0) post-submodules_0)"
"((need-compiled-submodule-rename?46_0)"
" need-compiled-submodule-rename?_0))"
"(compile-module-from-parsed34.1"
" force-linklet-directory?40_0"
" full-module-name39_0"
" modules-being-compiled43_0"
" need-compiled-submodule-rename?46_0"
" post-submodules45_0"
" pre-submodules44_0"
" serializable?41_0"
" to-correlated-linklet?42_0"
" p37_0"
" cctx38_0)))))))))))))))))))))"
"(define-values"
"(compile-module-from-parsed34.1)"
"(lambda(force-linklet-directory?17_0"
" full-module-name16_0"
" modules-being-compiled20_0"
" need-compiled-submodule-rename?23_0"
" post-submodules22_0"
" pre-submodules21_0"
" serializable?18_0"
" to-correlated-linklet?19_0"
" p32_0"
" cctx33_0)"
"(begin"
" 'compile-module-from-parsed34"
"(let-values(((p_0) p32_0))"
"(let-values(((cctx_0) cctx33_0))"
"(let-values(((full-module-name_0) full-module-name16_0))"
"(let-values(((force-linklet-directory?_0) force-linklet-directory?17_0))"
"(let-values(((serializable?_0) serializable?18_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?19_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled20_0))"
"(let-values(((pre-submodules_0) pre-submodules21_0))"
"(let-values(((post-submodules_0) post-submodules22_0))"
"(let-values(((need-compiled-submodule-rename?_0) need-compiled-submodule-rename?23_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'compile 'module))(void))"
"(begin0"
"(let-values()"
"(let-values(((enclosing-self_0)(compile-context-module-self cctx_0)))"
"(let-values(((self_0)(parsed-module-self p_0)))"
"(let-values(((requires_0)(parsed-module-requires p_0)))"
"(let-values(((provides_0)(parsed-module-provides p_0)))"
"(let-values(((encoded-root-expand-ctx-box_0)"
"(box(parsed-module-encoded-root-ctx p_0))))"
"(let-values(((body-context-simple?_0)"
"(parsed-module-root-ctx-simple? p_0)))"
"(let-values(((language-info_0)"
"(filter-language-info"
"(syntax-property$1(parsed-s p_0) 'module-language))))"
"(let-values(((bodys_0)(parsed-module-body p_0)))"
"(let-values(((empty-result-for-module->namespace?_0) #f))"
"(let-values(((mpis_0)(make-module-path-index-table)))"
"(let-values(((body-cctx_0)"
"(let-values(((the-struct_0) cctx_0))"
"(if(compile-context? the-struct_0)"
"(let-values(((phase47_0) 0)"
"((self48_0) self_0)"
"((module-self49_0) self_0)"
"((full-module-name50_0)"
" full-module-name_0)"
"((lazy-syntax-literals?51_0) #t))"
"(compile-context1.1"
"(compile-context-namespace the-struct_0)"
" phase47_0"
" self48_0"
" module-self49_0"
" full-module-name50_0"
" lazy-syntax-literals?51_0"
"(compile-context-header the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                         \"compile-context?\""
" the-struct_0)))))"
"(let-values(((cross-phase-persistent?_0) #f))"
"(let-values(((side-effects_0)(make-hasheqv)))"
"(let-values(((check-side-effects!_0)"
"(lambda(e_0"
" expected-results_0"
" phase_0"
" required-reference?_0)"
"(begin"
" 'check-side-effects!"
"(if(hash-ref side-effects_0 phase_0 #f)"
"(void)"
"(let-values()"
"(if(let-values(((e52_0) e_0)"
"((expected-results53_0)"
" expected-results_0)"
"((required-reference?54_0)"
" required-reference?_0))"
"(any-side-effects?9.1"
" unsafe-undefined"
" unsafe-undefined"
" required-reference?54_0"
" e52_0"
" expected-results53_0))"
"(let-values()"
"(hash-set!"
" side-effects_0"
" phase_0"
" #t))"
"(void))))))))"
"(let-values((()"
"(begin"
"(if(if need-compiled-submodule-rename?_0"
" modules-being-compiled_0"
" #f)"
"(let-values()"
"(begin"
"(if(null? post-submodules_0)"
"(void)"
"(let-values()"
"(error"
"                                                                                         \"internal error: have post submodules, but not already compiled\")))"
"(register-compiled-submodules"
" modules-being-compiled_0"
" pre-submodules_0"
" self_0)))"
"(void))"
"(values))))"
"(let-values(((body-linklets_0"
" min-phase_0"
" max-phase_0"
" phase-to-link-module-uses_0"
" phase-to-link-module-uses-expr_0"
" phase-to-link-extra-inspectorsss_0"
" syntax-literals_0"
" root-ctx-pos_0)"
"(let-values(((bodys55_0) bodys_0)"
"((body-cctx56_0) body-cctx_0)"
"((mpis57_0) mpis_0)"
"((temp58_0)"
"(list"
"(list"
" get-syntax-literal!-id)"
"(list"
" set-transformer!-id)))"
"((temp59_0)"
"(list"
" empty-syntax-literals-instance"
" empty-module-body-instance))"
"((temp60_0) '((void)))"
"((temp61_0) '(0))"
"((encoded-root-expand-ctx-box62_0)"
" encoded-root-expand-ctx-box_0)"
"((body-context-simple?63_0)"
" body-context-simple?_0)"
"((check-side-effects!64_0)"
" check-side-effects!_0)"
"((temp65_0)"
"(lambda(body_0 cctx_1)"
"(if(parsed-#%declare?"
" body_0)"
"(let-values()"
"(let-values(((ok?_0"
" _70_0"
" kw71_0)"
"(let-values(((s_0)"
"(parsed-s"
" body_0)))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((_70_0"
" kw71_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((_72_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((kw73_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                               \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _72_0"
" kw73_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                       \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _70_0"
" kw71_0))))))"
"(begin"
"(let-values(((lst_0)"
" kw71_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((kw_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(if(eq?"
"(syntax-e$1"
" kw_0)"
" '#:cross-phase-persistent)"
"(let-values()"
"(set! cross-phase-persistent?_0"
" #t))"
"(void))"
"(if(eq?"
"(syntax-e$1"
" kw_0)"
" '#:empty-namespace)"
"(let-values()"
"(begin"
"(set! empty-result-for-module->namespace?_0"
" #t)"
"(set-box!"
" encoded-root-expand-ctx-box_0"
" #f)))"
"(void))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
" #f)))"
"(let-values() #f))))"
"((temp66_0)"
"(lambda(mod-name_0 phase_0)"
"(let-values(((ht_0)"
"(if modules-being-compiled_0"
"(hash-ref"
" modules-being-compiled_0"
" mod-name_0"
" #f)"
" #f)))"
"(if ht_0"
"(hash-ref"
" ht_0"
" phase_0"
" #f)"
" #f))))"
"((serializable?67_0)"
" serializable?_0)"
"((temp68_0) #t)"
"((to-correlated-linklet?69_0)"
" to-correlated-linklet?_0))"
"(compile-forms33.1"
" temp59_0"
" temp58_0"
" temp60_0"
" check-side-effects!64_0"
" #t"
" unsafe-undefined"
" encoded-root-expand-ctx-box62_0"
" temp61_0"
" temp66_0"
" temp68_0"
" temp65_0"
" body-context-simple?63_0"
" serializable?67_0"
" to-correlated-linklet?69_0"
" bodys55_0"
" body-cctx56_0"
" mpis57_0))))"
"(let-values((()"
"(begin"
"(if modules-being-compiled_0"
"(let-values()"
"(hash-set!"
" modules-being-compiled_0"
"(1/module-path-index-resolve"
" self_0)"
"(let-values(((ht_0)"
" body-linklets_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0"
" linklet_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_0"
"(module-linklet-info2.1"
" linklet_0"
"(hash-ref"
" phase-to-link-module-uses_0"
" phase_0"
" #f)"
" self_0"
" #f"
" #f"
"(if phase-to-link-extra-inspectorsss_0"
"(hash-ref"
" phase-to-link-extra-inspectorsss_0"
" phase_0"
" #f)"
" #f))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first"
" ht_0))))))"
"(void))"
"(values))))"
"(let-values(((declaration-linklet_0)"
"(if serializable?_0"
"((lambda(s_0)"
"(if to-correlated-linklet?_0"
"(make-correlated-linklet"
" s_0"
" 'decl)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'module"
" 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"(1/compile-linklet"
" s_0"
" 'decl))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(generate-module-declaration-linklet"
" mpis_0"
" self_0"
" requires_0"
" provides_0"
" phase-to-link-module-uses-expr_0))"
" #f)))"
"(let-values(((syntax-literals-linklet_0)"
"(if(not"
"(syntax-literals-empty?"
" syntax-literals_0))"
"((lambda(s_0)"
"(if to-correlated-linklet?_0"
"(make-correlated-linklet"
" s_0"
" 'syntax-literals)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'module"
" 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((linklet_0"
" new-keys_0)"
"(1/compile-linklet"
" s_0"
" 'syntax-literals"
"(vector"
" deserialize-instance"
" empty-top-syntax-literal-instance"
" empty-syntax-literals-data-instance"
" empty-instance-instance)"
"(lambda(inst_0)"
"(values"
" inst_0"
" #f))"
"(if serializable?_0"
" '(serializable)"
" '()))))"
" linklet_0))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(list*"
" 'linklet"
"(list"
" deserialize-imports"
"(list mpi-vector-id)"
"(list*"
" deserialized-syntax-vector-id"
"(if serializable?_0"
"(list deserialize-syntax-id)"
" '()))"
" instance-imports)"
"(list*"
" get-syntax-literal!-id"
" '(get-encoded-root-expand-ctx))"
"(qq-append"
"(let-values(((syntax-literals74_0)"
" syntax-literals_0)"
"((mpis75_0)"
" mpis_0)"
"((self76_0)"
" self_0)"
"((temp77_0)"
"(not"
" serializable?_0)))"
"(generate-lazy-syntax-literals!9.1"
" temp77_0"
" syntax-literals74_0"
" mpis75_0"
" self76_0))"
"(list"
"(list"
" 'define-values"
" '(get-encoded-root-expand-ctx)"
"(if root-ctx-pos_0"
"(let-values()"
"(list"
" 'lambda"
" '()"
"(generate-lazy-syntax-literal-lookup"
" root-ctx-pos_0)))"
"(if empty-result-for-module->namespace?_0"
"(let-values() ''empty)"
"(let-values()"
" ''#f))))))))"
" #f)))"
"(let-values(((syntax-literals-data-linklet_0)"
"(if serializable?_0"
"(if(not"
"(syntax-literals-empty?"
" syntax-literals_0))"
"((lambda(s_0)"
"(if to-correlated-linklet?_0"
"(make-correlated-linklet"
" s_0"
" 'syntax-literals-data)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'module"
" 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"(1/compile-linklet"
" s_0"
" 'syntax-literals-data"
" #f"
" #f"
" '(serializable"
" uninterned-literal)))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(list*"
" 'linklet"
"(list"
" deserialize-imports"
"(list mpi-vector-id))"
"(list"
" deserialized-syntax-vector-id"
" deserialize-syntax-id)"
"(list"
" 'define-values"
"(list"
" deserialized-syntax-vector-id)"
"(list*"
" 'make-vector"
"(syntax-literals-count"
" syntax-literals_0)"
" '(#f)))"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'module"
" 'serialize))"
"(void))"
"(begin0"
"(let-values()"
"(generate-lazy-syntax-literals-data!"
" syntax-literals_0"
" mpis_0))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
" #f)"
" #f)))"
"(let-values(((data-linklet_0)"
"(if serializable?_0"
"((lambda(s_0)"
"(if to-correlated-linklet?_0"
"(make-correlated-linklet"
" s_0"
" 'data)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'compile"
" 'module"
" 'linklet))"
"(void))"
"(begin0"
"(let-values()"
"(1/compile-linklet"
" s_0"
" 'data))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(generate-module-data-linklet"
" mpis_0))"
" #f)))"
"(let-values(((bundle_0)"
"(let-values(((bundle_0)"
"(hash-set"
" body-linklets_0"
" 'name"
" full-module-name_0)))"
"(let-values(((bundle_1)"
"(hash-set"
" bundle_0"
" 'decl"
"(let-values(((or-part_0)"
" declaration-linklet_0))"
"(if or-part_0"
" or-part_0"
" 'in-memory)))))"
"(let-values(((bundle_2)"
"(if data-linklet_0"
"(hash-set"
" bundle_1"
" 'data"
" data-linklet_0)"
" bundle_1)))"
"(let-values(((bundle_3)"
"(if syntax-literals-linklet_0"
"(hash-set"
" bundle_2"
" 'stx"
" syntax-literals-linklet_0)"
" bundle_2)))"
"(let-values(((bundle_4)"
"(if syntax-literals-data-linklet_0"
"(hash-set"
" bundle_3"
" 'stx-data"
" syntax-literals-data-linklet_0)"
" bundle_3)))"
"(let-values(((bundle_5)"
"(if(null?"
" pre-submodules_0)"
" bundle_4"
"(hash-set"
" bundle_4"
" 'pre"
"(map2"
" car"
" pre-submodules_0)))))"
"(let-values(((bundle_6)"
"(if(null?"
" post-submodules_0)"
" bundle_5"
"(hash-set"
" bundle_5"
" 'post"
"(map2"
" car"
" post-submodules_0)))))"
"(let-values(((bundle_7)"
"(if cross-phase-persistent?_0"
"(hash-set"
" bundle_6"
" 'cross-phase-persistent?"
" #t)"
" bundle_6)))"
"(let-values(((bundle_8)"
"(if language-info_0"
"(hash-set"
" bundle_7"
" 'language-info"
" language-info_0)"
" bundle_7)))"
"(let-values(((bundle_9)"
"(if(zero?"
" min-phase_0)"
" bundle_8"
"(hash-set"
" bundle_8"
" 'min-phase"
" min-phase_0))))"
"(let-values(((bundle_10)"
"(if(zero?"
" max-phase_0)"
" bundle_9"
"(hash-set"
" bundle_9"
" 'max-phase"
" max-phase_0))))"
"(let-values(((bundle_11)"
"(if(hash-count"
" side-effects_0)"
"(hash-set"
" bundle_10"
" 'side-effects"
"(let-values(((temp78_0)"
"(hash-keys"
" side-effects_0))"
"((<79_0)"
" <))"
"(sort7.1"
" #f"
" #f"
" temp78_0"
" <79_0)))"
" bundle_10)))"
"(let-values(((bundle_12)"
"(if empty-result-for-module->namespace?_0"
"(hash-set"
" bundle_11"
" 'module->namespace"
" 'empty)"
" bundle_11)))"
"(hash->linklet-bundle"
" bundle_12))))))))))))))))"
"(let-values(((ld_0)"
"(if(if(null?"
" pre-submodules_0)"
"(if(null?"
" post-submodules_0)"
"(not"
" force-linklet-directory?_0)"
" #f)"
" #f)"
"(let-values() bundle_0)"
"(let-values()"
"(let-values(((ht_0)"
"(let-values(((lst_0)"
"(append"
" pre-submodules_0"
" post-submodules_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((sm_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((ht_1)"
"(let-values(((ht_1)"
" ht_0))"
"(let-values(((ht_2)"
"(let-values()"
"(hash-set"
" ht_1"
"(car"
" sm_0)"
"(compiled-in-memory-linklet-directory"
"(cdr"
" sm_0))))))"
"(values"
" ht_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" ht_1"
" rest_0)"
" ht_1)))"
" ht_0)))))"
" for-loop_0)"
"(hasheq"
" #f"
" bundle_0)"
" lst_0)))))"
"(hash->linklet-directory"
" ht_0))))))"
"(compiled-in-memory1.1"
" ld_0"
" self_0"
" requires_0"
" provides_0"
" phase-to-link-module-uses_0"
"(current-code-inspector)"
" phase-to-link-extra-inspectorsss_0"
"(mpis-as-vector mpis_0)"
"(syntax-literals-as-vector"
" syntax-literals_0)"
"(map2 cdr pre-submodules_0)"
"(map2 cdr post-submodules_0)"
" #f"
" #f)))))))))))))))))))))))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))))))))))))"
"(define-values"
"(update-submodule-names)"
"(lambda(cim_0 name_0 full-module-name_0)"
"(begin"
"(change-module-name"
" cim_0"
" name_0"
"(if(symbol? full-module-name_0)(list full-module-name_0)(reverse$1(cdr(reverse$1 full-module-name_0))))))))"
"(define-values"
"(register-compiled-submodules)"
"(lambda(modules-being-compiled_0 pre-submodules_0 self_0)"
"(begin"
"(begin"
"(let-values(((lst_0) pre-submodules_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((name_0)(car s_0)))"
"(let-values(((cim_0)(cdr s_0)))"
"(let-values(((phase-to-link-module-uses_0)"
"(compiled-in-memory-phase-to-link-module-uses"
" cim_0)))"
"(let-values(((ld_0)"
"(compiled-in-memory-linklet-directory"
" cim_0)))"
"(let-values(((sm-self_0)"
"(1/module-path-index-join"
"(list"
" 'submod"
"                                                                                                  \".\""
" name_0)"
" self_0)))"
"(let-values(((phase-to-extra-inspectorsss_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss"
" cim_0)))"
"(hash-set!"
" modules-being-compiled_0"
"(1/module-path-index-resolve"
" sm-self_0)"
"(let-values(((ht_0)"
"(linklet-bundle->hash"
"(if(linklet-directory?"
" ld_0)"
"(hash-ref"
"(linklet-directory->hash"
" ld_0)"
" #f)"
" ld_0))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash ht_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(table_0"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0"
" linklet_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(if(number?"
" phase_0)"
"(let-values(((table_2)"
" table_1))"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_0"
"(module-linklet-info2.1"
" linklet_0"
"(hash-ref"
" phase-to-link-module-uses_0"
" phase_0"
" #f)"
"(compiled-in-memory-original-self"
" cim_0)"
" #f"
"(compiled-in-memory-compile-time-inspector"
" cim_0)"
"(if phase-to-extra-inspectorsss_0"
"(hash-ref"
" phase-to-extra-inspectorsss_0"
" phase_0"
" #f)"
" #f))))))"
"(hash-set"
" table_2"
" key_0"
" val_0)))))"
"(values"
" table_3)))"
" table_1))))"
"(if(not"
" #f)"
"(for-loop_1"
" table_1"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_1)))"
" table_0)))))"
" for-loop_1)"
" '#hasheq()"
"(hash-iterate-first"
" ht_0))))))))))))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))))"
"(define-values"
"(filter-language-info)"
"(lambda(li_0)"
"(begin"
"(if(vector? li_0)"
"(if(= 3(vector-length li_0))"
"(if(1/module-path?(vector-ref li_0 0))(if(symbol?(vector-ref li_0 1)) li_0 #f) #f)"
" #f)"
" #f))))"
"(define-values"
"(1/compiled-expression-recompile)"
"(lambda(c_0)"
"(begin"
" 'compiled-expression-recompile"
"(begin"
"(if(1/compiled-expression? c_0)"
"(void)"
"          (let-values () (raise-argument-error 'compiled-expression-recompile \"compiled-expression?\" c_0)))"
"(if(not(current-compile-target-machine))"
"(let-values() c_0)"
"(if(let-values(((or-part_0)(linklet-bundle? c_0)))(if or-part_0 or-part_0(linklet-directory? c_0)))"
"(let-values()"
"(let-values(((ns_0)(1/current-namespace)))"
"(let-values(((bundles_0)(extract-linklet-bundles c_0 '() '#hash())))"
"(let-values(((recompileds_0)(make-hash)))"
"(letrec-values(((force-recompile-bundle_0)"
"(lambda(k_0)"
"(begin"
" 'force-recompile-bundle"
"(begin"
"(if(hash-ref recompileds_0 k_0 #f)"
"(void)"
"(let-values()"
"(let-values((()"
"(begin"
"(hash-set! recompileds_0 k_0 'in-process)"
"(values))))"
"(let-values(((b_0)(hash-ref bundles_0 k_0 #f)))"
"(begin"
"(if b_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'compiled-expression-recompile"
"                                                          \"cannot find submodule\""
"                                                          \"submodule path\""
" k_0)))"
"(hash-set!"
" recompileds_0"
" k_0"
"(recompile-bundle b_0 force-recompile-bundle_0 ns_0)))))))"
"(hash-ref recompileds_0 k_0))))))"
"(begin"
"(let-values(((ht_0) bundles_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0)(hash-iterate-key ht_0 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(force-recompile-bundle_0"
" k_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(void)"
"(replace-linklet-bundles c_0 '() recompileds_0)))))))"
"(let-values()(1/compiled-expression-recompile(compiled-in-memory-linklet-directory c_0)))))))))"
"(define-values"
"(extract-linklet-bundles)"
"(lambda(c_0 rev-path_0 accum_0)"
"(begin"
"(if(linklet-bundle? c_0)"
"(let-values()(hash-set accum_0(reverse$1 rev-path_0) c_0))"
"(if(linklet-directory? c_0)"
"(let-values()"
"(let-values(((ht_0)(linklet-directory->hash c_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(accum_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((accum_2)"
"(let-values(((accum_2) accum_1))"
"(let-values(((accum_3)"
"(let-values()"
"(if(symbol? k_0)"
"(let-values()"
"(extract-linklet-bundles"
" v_0"
"(cons k_0 rev-path_0)"
" accum_2))"
"(if(not k_0)"
"(let-values()"
"(extract-linklet-bundles"
" v_0"
" rev-path_0"
" accum_2))"
"(let-values() accum_2))))))"
"(values accum_3)))))"
"(if(not #f)(for-loop_0 accum_2(hash-iterate-next ht_0 i_0)) accum_2)))"
" accum_1)))))"
" for-loop_0)"
" accum_0"
"(hash-iterate-first ht_0)))))"
"(let-values() accum_0))))))"
"(define-values"
"(replace-linklet-bundles)"
"(lambda(c_0 rev-path_0 recompileds_0)"
"(begin"
"(if(linklet-bundle? c_0)"
"(let-values()(recompiled-bundle(hash-ref recompileds_0(reverse$1 rev-path_0))))"
"(if(linklet-directory? c_0)"
"(let-values()"
"(hash->linklet-directory"
"(let-values(((ht_0)(linklet-directory->hash c_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" k_0"
"(if(symbol? k_0)"
"(let-values()"
"(replace-linklet-bundles"
" v_0"
"(cons k_0 rev-path_0)"
" recompileds_0))"
"(if(not k_0)"
"(let-values()"
"(replace-linklet-bundles"
" v_0"
" rev-path_0"
" recompileds_0))"
"(void)))))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1(hash-iterate-next ht_0 i_0)) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first ht_0))))))"
"(let-values() c_0))))))"
"(define-values"
"(struct:recompiled recompiled1.1 recompiled? recompiled-bundle recompiled-phase-to-link-module-uses recompiled-self)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'recompiled"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'recompiled)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'bundle)"
"(make-struct-field-accessor -ref_0 1 'phase-to-link-module-uses)"
"(make-struct-field-accessor -ref_0 2 'self))))"
"(define-values"
"(recompile-bundle)"
"(lambda(b_0 get-submodule-recompiled_0 ns_0)"
"(begin"
"(let-values(((orig-h_0)(linklet-bundle->hash b_0)))"
"(let-values(((h_0)"
"(let-values(((ht_0) orig-h_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(if(if(not"
"(exact-integer?"
" k_0))"
"(correlated-linklet?"
" v_0)"
" #f)"
"(let-values()"
"(values"
" k_0"
"(force-compile-linklet"
" v_0)))"
"(let-values()"
"(values"
" k_0"
" v_0))))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first ht_0))))))"
"(let-values(((data-instance_0)"
"(1/instantiate-linklet(1/eval-linklet(hash-ref h_0 'data))(list deserialize-instance))))"
"(let-values(((declaration-instance_0)"
"(1/instantiate-linklet"
"(1/eval-linklet(hash-ref h_0 'decl))"
"(list deserialize-instance data-instance_0))))"
"(let-values(((decl_0)"
"(lambda(key_0)(begin 'decl(1/instance-variable-value declaration-instance_0 key_0)))))"
"(let-values(((mpis_0)(make-module-path-index-table)))"
"(let-values((()"
"(begin"
"(let-values(((vec_0 len_0)"
"(let-values(((vec_0)"
"(1/instance-variable-value"
" data-instance_0"
" mpi-vector-id)))"
"(begin"
"(check-vector vec_0)"
"(values vec_0(unsafe-vector-length vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_0 len_0)"
"(let-values(((mpi_0)(unsafe-vector-ref vec_0 pos_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(add-module-path-index!"
" mpis_0"
" mpi_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(unsafe-fx+ 1 pos_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
" 0)))"
"(values))))"
"(let-values()"
"(let-values(((self_0)(decl_0 'self-mpi)))"
"(let-values(((phase-to-link-modules_0)(decl_0 'phase-to-link-modules)))"
"(let-values(((find-submodule_0)"
"(lambda(mod-name_0 phase_0)"
"(begin"
" 'find-submodule"
"(let-values(((find-l_0)(1/resolved-module-path-name mod-name_0)))"
"(let-values(((self-l_0)"
"(1/resolved-module-path-name"
"(1/module-path-index-resolve self_0))))"
"(let-values(((root-of_0)"
"(lambda(l_0)"
"(begin 'root-of(if(pair? l_0)(car l_0) l_0)))))"
"(if(equal?(root-of_0 find-l_0)(root-of_0 self-l_0))"
"(let-values()"
"(let-values(((r_0)"
"(get-submodule-recompiled_0"
"(if(pair? find-l_0)(cdr find-l_0) '()))))"
"(let-values((()"
"(begin"
"(if(eq? r_0 'in-process)"
"(let-values()"
"(raise-arguments-error"
" 'compiled-expression-recompile"
"                                                                             \"cycle in linklet imports\"))"
"(void))"
"(values))))"
"(let-values(((b_1)(recompiled-bundle r_0)))"
"(let-values(((linklet_0)"
"(let-values(((or-part_0)"
"(hash-ref"
"(linklet-bundle->hash b_1)"
" phase_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(raise-arguments-error"
" 'compiled-expression-recompile"
"                                                                               \"cannot find submodule at phase\""
"                                                                               \"submodule\""
" mod-name_0"
"                                                                               \"phase\""
" phase_0)))))"
"(module-linklet-info2.1"
" linklet_0"
"(hash-ref"
"(recompiled-phase-to-link-module-uses r_0)"
" phase_0"
" #f)"
"(recompiled-self r_0)"
" #f"
"(current-code-inspector)"
" #f))))))"
"(let-values() #f)))))))))"
"(let-values(((body-linklets+module-use*s_0)"
"(let-values(((ht_0) h_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 body-linklet_0)"
"(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(if(exact-integer? phase_0)"
"(let-values(((table_2)"
" table_1))"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values(((module-use*s_0)"
"(module-uses-add-extra-inspectorsss"
"(hash-ref"
" phase-to-link-modules_0"
" phase_0)"
" #f)))"
"(let-values(((linklet_0"
" new-module-use*s_0)"
"(let-values(((temp3_0)"
"(if(correlated-linklet?"
" body-linklet_0)"
"(correlated-linklet-expr"
" body-linklet_0)"
" body-linklet_0))"
"((temp4_0)"
"(if(correlated-linklet?"
" body-linklet_0)"
" 1/compile-linklet"
" 1/recompile-linklet))"
"((temp5_0)"
"(list"
"(list"
" get-syntax-literal!-id)"
"(list"
" set-transformer!-id)))"
"((temp6_0)"
"(list"
" empty-syntax-literals-instance"
" empty-module-body-instance))"
"((find-submodule7_0)"
" find-submodule_0)"
"((temp8_0)"
" #t)"
"((temp9_0)"
" #t)"
"((module-use*s10_0)"
" module-use*s_0)"
"((temp11_0)"
" #t)"
"((temp12_0)"
" #t)"
"((ns13_0)"
" ns_0))"
"(compile-module-linklet57.1"
" temp6_0"
" temp5_0"
" temp4_0"
" temp11_0"
" find-submodule7_0"
" temp12_0"
" temp9_0"
" module-use*s10_0"
" ns13_0"
" temp8_0"
" temp3_0))))"
"(values"
" phase_0"
"(cons"
" linklet_0"
" new-module-use*s_0)))))))"
"(hash-set"
" table_2"
" key_0"
" val_0)))))"
"(values table_3)))"
" table_1))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first ht_0))))))"
"(let-values(((h/new-body-linklets_0)"
"(let-values(((ht_0) body-linklets+module-use*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(h_1 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 l+mu*s_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((h_2)"
"(let-values(((h_2) h_1))"
"(let-values(((h_3)"
"(let-values()"
"(hash-set"
" h_2"
" phase_0"
"(car"
" l+mu*s_0)))))"
"(values h_3)))))"
"(if(not #f)"
"(for-loop_0"
" h_2"
"(hash-iterate-next ht_0 i_0))"
" h_2)))"
" h_1)))))"
" for-loop_0)"
" h_0"
"(hash-iterate-first ht_0))))))"
"(let-values(((phase-to-link-module-uses_0)"
"(let-values(((ht_0) body-linklets+module-use*s_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 l+mu*s_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" phase_0"
"(module-uses-strip-extra-inspectorsss"
"(cdr"
" l+mu*s_0))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first ht_0))))))"
"(let-values(((phase-to-link-module-uses-expr_0)"
"(serialize-phase-to-link-module-uses"
" phase-to-link-module-uses_0"
" mpis_0)))"
"(let-values(((data-linklet_0)"
"(1/compile-linklet(generate-module-data-linklet mpis_0) 'data)))"
"(let-values(((declaration-linklet_0)"
"(1/compile-linklet"
"(generate-module-declaration-linklet"
" mpis_0"
" self_0"
"(decl_0 'requires)"
"(decl_0 'provides)"
" phase-to-link-module-uses-expr_0)"
" 'decl)))"
"(let-values(((new-bundle_0)"
"(hash->linklet-bundle"
"(let-values(((h_1) h/new-body-linklets_0))"
"(let-values(((h_2)(hash-set h_1 'data data-linklet_0)))"
"(let-values(((h_3)"
"(hash-set h_2 'decl declaration-linklet_0)))"
" h_3))))))"
"(recompiled1.1"
" new-bundle_0"
" phase-to-link-module-uses_0"
" self_0))))))))))))))))))))))"
"(define-values"
"(create-compiled-in-memorys-using-shared-data)"
"(lambda(tops_0 data-linklet_0 ns_0)"
"(begin"
"(let-values(((data-instance_0)"
"(1/instantiate-linklet"
" data-linklet_0"
"(list"
" deserialize-instance"
"(let-values(((ns1_0) ns_0)"
"((temp2_0)(namespace-phase ns_0))"
"((temp3_0)(namespace-mpi ns_0))"
"((temp4_0)(namespace-bulk-binding-registry ns_0))"
"((temp5_0)(current-code-inspector)))"
"(make-eager-instance-instance11.1 temp4_0 temp2_0 temp5_0 ns1_0 temp3_0))))))"
"(let-values(((data_0)(lambda(key_0)(begin 'data(1/instance-variable-value data-instance_0 key_0)))))"
"(let-values(((mpi-vector_0)(data_0 mpi-vector-id)))"
"(let-values(((mpi-vector-trees_0)(data_0 'mpi-vector-trees)))"
"(let-values(((phase-to-link-modules-vector_0)(data_0 'phase-to-link-modules-vector)))"
"(let-values(((phase-to-link-modules-trees_0)(data_0 'phase-to-link-modules-trees)))"
"(let-values(((syntax-literals_0)(data_0 'syntax-literals)))"
"(let-values(((syntax-literals-trees_0)(data_0 'syntax-literals-trees)))"
"(let-values(((namespace-scopes_0)(extract-namespace-scopes ns_0)))"
"(letrec-values(((construct-compiled-in-memory_0)"
"(lambda(ld_0"
" mpi-vector-tree_0"
" phase-to-link-modules-tree_0"
" syntax-literals-tree_0)"
"(begin"
" 'construct-compiled-in-memory"
"(let-values(((is-module?_0)"
"(let-values(((or-part_0)(linklet-bundle? ld_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((b_0)"
"(hash-ref"
"(linklet-directory->hash ld_0)"
" #f"
" #f)))"
"(if b_0"
"(hash-ref(linklet-bundle->hash b_0) 'decl #f)"
" #f))))))"
"(let-values(((mpi-pos-vec_0)(vector-ref mpi-vector-tree_0 0)))"
"(let-values(((syntax-literals-spec_0)"
"(vector-ref syntax-literals-tree_0 0)))"
"(let-values(((pres_0)"
"(if is-module?_0"
"(extract-submodules ld_0 'pre)"
"(compiled-top->compiled-tops ld_0))))"
"(let-values(((posts_0)"
"(if is-module?_0"
"(extract-submodules ld_0 'post)"
" null)))"
"(let-values(((map-construct-compiled-in-memory_0)"
"(lambda(l_0 vec-pos_0)"
"(begin"
" 'map-construct-compiled-in-memory"
"(reverse$1"
"(let-values(((lst_0) l_0)"
"((lst_1)"
"(vector-ref"
" mpi-vector-tree_0"
" vec-pos_0))"
"((lst_2)"
"(vector-ref"
" phase-to-link-modules-tree_0"
" vec-pos_0))"
"((lst_3)"
"(vector-ref"
" syntax-literals-tree_0"
" vec-pos_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_3)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_4"
" lst_5"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_4)"
"(if(pair?"
" lst_5)"
"(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
" #f)"
" #f)"
"(let-values(((sub-ld_0)"
"(unsafe-car"
" lst_4))"
"((rest_0)"
"(unsafe-cdr"
" lst_4))"
"((mpi-vector-tree_1)"
"(unsafe-car"
" lst_5))"
"((rest_1)"
"(unsafe-cdr"
" lst_5))"
"((phase-to-link-modules-tree_1)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((syntax-literals-tree_1)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(construct-compiled-in-memory_0"
" sub-ld_0"
" mpi-vector-tree_1"
" phase-to-link-modules-tree_1"
" syntax-literals-tree_1))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0"
" rest_1"
" rest_2"
" rest_3)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1"
" lst_2"
" lst_3))))))))"
"(compiled-in-memory1.1"
" ld_0"
" #f"
" #f"
" #f"
"(vector-ref"
" phase-to-link-modules-vector_0"
"(vector-ref phase-to-link-modules-tree_0 0))"
" #f"
" '#hasheqv()"
"(let-values(((len_0)(vector-length mpi-pos-vec_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'for/vector"
"                                                                   \"exact-nonnegative-integer?\""
" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((vec_0 len_1)"
"(let-values(((vec_0)"
" mpi-pos-vec_0))"
"(begin"
"(check-vector vec_0)"
"(values"
" vec_0"
"(unsafe-vector-length"
" vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(i_0 pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx<"
" pos_0"
" len_1)"
"(let-values(((pos_1)"
"(unsafe-vector-ref"
" vec_0"
" pos_0)))"
"(let-values(((i_1)"
"(let-values(((i_1)"
" i_0))"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_1"
"(let-values()"
"(vector-ref"
" mpi-vector_0"
" pos_1)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values"
" i_2)))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_1"
" len_0))"
" pos_1))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_1"
"(unsafe-fx+"
" 1"
" pos_0))"
" i_1)))"
" i_0)))))"
" for-loop_0)"
" 0"
" 0)))))"
" v_0))))"
"(let-values(((len_0)(cdr syntax-literals-spec_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'for/vector"
"                                                                   \"exact-nonnegative-integer?\""
" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((start_0) 0)"
"((end_0)"
"(cdr syntax-literals-spec_0))"
"((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values(((i_1)"
" pos_0))"
"(let-values(((i_2)"
"(let-values(((i_2)"
" i_0))"
"(let-values(((i_3)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_2"
"(let-values()"
"(if syntax-literals_0"
"(vector-ref"
" syntax-literals_0"
"(+"
"(car"
" syntax-literals-spec_0)"
" i_1))"
" #f)))"
"(unsafe-fx+"
" 1"
" i_2)))))"
"(values"
" i_3)))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_2"
" len_0))"
" i_1))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_2"
"(+"
" pos_0"
" inc_0))"
" i_2)))"
" i_0)))))"
" for-loop_0)"
" 0"
" start_0)))))"
" v_0))))"
"(map-construct-compiled-in-memory_0 pres_0 1)"
"(map-construct-compiled-in-memory_0 posts_0 2)"
" namespace-scopes_0"
" #f)))))))))))"
"(map2"
" construct-compiled-in-memory_0"
" tops_0"
" mpi-vector-trees_0"
" phase-to-link-modules-trees_0"
" syntax-literals-trees_0))))))))))))))"
"(define-values"
"(extract-submodules)"
"(lambda(ld_0 names-key_0)"
"(begin"
"(if(linklet-bundle? ld_0)"
"(let-values() null)"
"(let-values()"
"(let-values(((h_0)(linklet-directory->hash ld_0)))"
"(let-values(((mod_0)(hash-ref h_0 #f #f)))"
"              (let-values ((() (begin (if mod_0 (void) (let-values () (error \"missing main module\"))) (values))))"
"(let-values(((mh_0)(linklet-bundle->hash mod_0)))"
"(let-values(((names_0)(hash-ref mh_0 names-key_0 null)))"
"(reverse$1"
"(let-values(((lst_0) names_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((name_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(hash-ref"
" h_0"
" name_0"
"(lambda()"
"(error"
"                                                                                          \"missing submodule declaration:\""
" name_0))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))))))))"
"(define-values"
"(eval-single-top)"
"(lambda(c_0 ns_0)"
"(begin(let-values(((c15_0) c_0)((ns16_0) ns_0)((temp17_0) #t))(eval-one-top12.1 temp17_0 c15_0 ns16_0 #t)))))"
"(define-values"
"(compiled-multiple-top?)"
"(lambda(c_0)"
"(begin"
"(let-values(((ld_0)(if(compiled-in-memory? c_0)(compiled-in-memory-linklet-directory c_0) c_0)))"
"(if(linklet-directory? ld_0)(not(hash-ref(linklet-directory->hash ld_0) #f #f)) #f)))))"
"(define-values"
"(eval-top)"
"(let-values(((eval-top5_0)"
"(lambda(c3_0 ns4_0 eval-compiled1_0 as-tail?2_0)"
"(begin"
" 'eval-top5"
"(let-values(((c_0) c3_0))"
"(let-values(((ns_0) ns4_0))"
"(let-values(((eval-compiled_0)"
"(if(eq? eval-compiled1_0 unsafe-undefined) eval-top eval-compiled1_0)))"
"(let-values(((as-tail?_0) as-tail?2_0))"
"(let-values()"
"(if(compiled-multiple-top? c_0)"
"(eval-multiple-tops c_0 ns_0 eval-compiled_0 as-tail?_0)"
"(let-values(((c18_0) c_0)((ns19_0) ns_0)((as-tail?20_0) as-tail?_0))"
"(eval-one-top12.1 #f c18_0 ns19_0 as-tail?20_0))))))))))))"
"(case-lambda"
"((c_0 ns_0)(begin(eval-top5_0 c_0 ns_0 unsafe-undefined #t)))"
"((c_0 ns_0 eval-compiled_0 as-tail?2_0)(eval-top5_0 c_0 ns_0 eval-compiled_0 as-tail?2_0))"
"((c_0 ns_0 eval-compiled1_0)(eval-top5_0 c_0 ns_0 eval-compiled1_0 #t)))))"
"(define-values"
"(eval-multiple-tops)"
"(lambda(c_0 ns_0 eval-compiled_0 as-tail?_0)"
"(begin"
"(let-values(((eval-compiled-parts_0)"
"(lambda(l_0)"
"(begin"
" 'eval-compiled-parts"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null? l_1)"
"(let-values() void)"
"(if(null?(cdr l_1))"
"(let-values()(eval-compiled_0(car l_1) ns_0 as-tail?_0))"
"(let-values()"
"(begin"
"(eval-compiled_0(car l_1) ns_0 #f)"
"(loop_0(cdr l_1))))))))))"
" loop_0)"
" l_0)))))"
"(if(compiled-in-memory? c_0)"
"(let-values()(eval-compiled-parts_0(compiled-in-memory-pre-compiled-in-memorys c_0)))"
"(let-values(((c1_0)(hash-ref(linklet-directory->hash c_0) 'data #f)))"
"(if c1_0"
"((lambda(data-ld_0)"
"(eval-compiled-parts_0"
"(create-compiled-in-memorys-using-shared-data"
"(compiled-top->compiled-tops c_0)"
"(hash-ref(linklet-bundle->hash(hash-ref(linklet-directory->hash data-ld_0) #f)) 0)"
" ns_0)))"
" c1_0)"
"(let-values()(eval-compiled-parts_0(compiled-top->compiled-tops c_0))))))))))"
"(define-values"
"(eval-one-top12.1)"
"(lambda(single-expression?7_0 c10_0 ns11_0 as-tail?9_0)"
"(begin"
" 'eval-one-top12"
"(let-values(((c_0) c10_0))"
"(let-values(((ns_0) ns11_0))"
"(let-values(((as-tail?_0) as-tail?9_0))"
"(let-values(((single-expression?_0) single-expression?7_0))"
"(let-values()"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'eval(if single-expression?_0 'transformer 'top)))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((ld_0)"
"(if(compiled-in-memory? c_0)(compiled-in-memory-linklet-directory c_0) c_0)))"
"(let-values(((h_0)(linklet-bundle->hash(hash-ref(linklet-directory->hash ld_0) #f))))"
"(let-values(((link-instance_0)"
"(if(compiled-in-memory? c_0)"
"(link-instance-from-compiled-in-memory"
" c_0"
"(if(not single-expression?_0) ns_0 #f))"
"(1/instantiate-linklet"
"(force-compile-linklet(hash-ref h_0 'link))"
"(list"
" deserialize-instance"
"(let-values(((ns21_0) ns_0)"
"((temp22_0)(namespace-phase ns_0))"
"((temp23_0)(namespace-mpi ns_0))"
"((temp24_0)(namespace-bulk-binding-registry ns_0))"
"((temp25_0)(current-code-inspector)))"
"(make-eager-instance-instance11.1"
" temp24_0"
" temp22_0"
" temp25_0"
" ns21_0"
" temp23_0)))))))"
"(let-values(((orig-phase_0)(hash-ref h_0 'original-phase)))"
"(let-values(((max-phase_0)(hash-ref h_0 'max-phase)))"
"(let-values(((phase-shift_0)(phase-(namespace-phase ns_0) orig-phase_0)))"
"(let-values(((extra-inspector_0)"
"(if(compiled-in-memory? c_0)"
"(compiled-in-memory-compile-time-inspector c_0)"
" #f)))"
"(let-values(((phase-to-link-extra-inspectorsss_0)"
"(if(compiled-in-memory? c_0)"
"(compiled-in-memory-phase-to-link-extra-inspectorsss c_0)"
" '#hasheqv())))"
"(let-values(((phase-to-link-modules_0)"
"(if(compiled-in-memory? c_0)"
"(compiled-in-memory-phase-to-link-module-uses c_0)"
"(1/instance-variable-value"
" link-instance_0"
" 'phase-to-link-modules))))"
"(let-values(((thunk_0)"
"(let-values(((start_0) max-phase_0)"
"((end_0)(sub1 orig-phase_0))"
"((inc_0) -1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(prev-thunk_0 pos_0)"
"(begin"
" 'for-loop"
"(if(> pos_0 end_0)"
"(let-values(((phase_0) pos_0))"
"(let-values(((prev-thunk_1)"
"(let-values(((prev-thunk_1)"
" prev-thunk_0))"
"(let-values(((prev-thunk_2)"
"(let-values()"
"(let-values((()"
"(begin"
"(prev-thunk_1"
" #f)"
"(values))))"
"(let-values(((module-uses_0)"
"(hash-ref"
" phase-to-link-modules_0"
" phase_0"
" null)))"
"(let-values(((import-module-instances_0"
" import-instances_0)"
"(let-values(((mis_0"
" is_0)"
"(let-values(((lst_0)"
" module-uses_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(mis_0"
" is_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((mu_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((mis_1"
" is_1)"
"(let-values(((mis_1)"
" mis_0)"
"((is_1)"
" is_0))"
"(let-values(((mis_2"
" is_2)"
"(let-values()"
"(let-values(((mis26_0"
" is27_0)"
"(let-values()"
"(let-values(((ns28_0)"
" ns_0)"
"((mu29_0)"
" mu_0)"
"((temp30_0)"
"(phase-"
"(phase+"
" phase_0"
" phase-shift_0)"
"(module-use-phase"
" mu_0))))"
"(namespace-module-use->module+linklet-instances144.1"
" temp30_0"
" #f"
" #f"
" ns28_0"
" mu29_0)))))"
"(values"
"(cons"
" mis26_0"
" mis_1)"
"(cons"
" is27_0"
" is_1))))))"
"(values"
" mis_2"
" is_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" mis_1"
" is_1"
" rest_0)"
"(values"
" mis_1"
" is_1))))"
"(values"
" mis_0"
" is_0))))))"
" for-loop_1)"
" null"
" null"
" lst_0)))))"
"(values"
"(reverse$1"
" mis_0)"
"(reverse$1"
" is_0)))))"
"(let-values(((phase-ns_0)"
"(namespace->namespace-at-phase"
" ns_0"
"(phase+"
" phase_0"
" phase-shift_0))))"
"(let-values(((inst_0)"
"(if single-expression?_0"
" link-instance_0"
"(let-values(((phase-ns31_0)"
" phase-ns_0)"
"((phase-shift32_0)"
" phase-shift_0)"
"((temp33_0)"
"(namespace-mpi"
" ns_0))"
"((temp34_0)"
"(namespace-inspector"
" ns_0))"
"((temp35_0)"
"(namespace-bulk-binding-registry"
" ns_0))"
"((temp36_0)"
"(lambda(name_0"
" val_0)"
"(namespace-set-transformer!"
" ns_0"
"(phase+"
"(sub1"
" phase_0)"
" phase-shift_0)"
" name_0"
" val_0))))"
"(make-instance-instance13.1"
" temp35_0"
" temp34_0"
" phase-ns31_0"
" phase-shift32_0"
" temp33_0"
" temp36_0)))))"
"(let-values(((linklet_0)"
"(force-compile-linklet"
"(hash-ref"
" h_0"
" phase_0"
" #f))))"
"(if linklet_0"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((linklet37_0)"
" linklet_0)"
"((temp38_0)"
" 3)"
"((module-uses39_0)"
" module-uses_0)"
"((import-module-instances40_0)"
" import-module-instances_0)"
"((temp41_0)"
"(current-code-inspector))"
"((extra-inspector42_0)"
" extra-inspector_0)"
"((temp43_0)"
"(hash-ref"
" phase-to-link-extra-inspectorsss_0"
" phase_0"
" #f)))"
"(check-require-access9.1"
" temp38_0"
" linklet37_0"
" module-uses39_0"
" import-module-instances40_0"
" temp41_0"
" extra-inspector42_0"
" temp43_0))"
"(values))))"
"(let-values(((instantiate_0)"
"(lambda(tail?_0)"
"(begin"
" 'instantiate"
"(1/instantiate-linklet"
" linklet_0"
"(list*"
" top-level-instance"
" link-instance_0"
" inst_0"
" import-instances_0)"
"(namespace->instance"
" ns_0"
"(phase-"
"(phase+"
" phase_0"
" phase-shift_0)"
"(namespace-0-phase"
" ns_0)))"
"(not"
" tail?_0))))))"
"(if(zero-phase?"
" phase_0)"
"(let-values()"
" instantiate_0)"
"(if single-expression?_0"
"(let-values()"
"(lambda(tail?_0)"
"(begin"
" 'prev-thunk"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" phase-ns_0)"
"(let-values()"
"(instantiate_0"
" tail?_0))))))"
"(let-values()"
"(let-values(((ns-1_0)"
"(namespace->namespace-at-phase"
" phase-ns_0"
"(sub1"
" phase_0))))"
"(lambda(tail?_0)"
"(begin"
" 'prev-thunk"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" phase-ns_0)"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
"(let-values(((ns-144_0)"
" ns-1_0))"
"(make-expand-context12.1"
" #f"
" #f"
" #f"
" #f"
" ns-144_0))"
"(let-values()"
"(instantiate_0"
" tail?_0))))))))))))))"
"(let-values()"
" void)))))))))))"
"(values"
" prev-thunk_2)))))"
"(if(not #f)"
"(for-loop_0"
" prev-thunk_1"
"(+ pos_0 inc_0))"
" prev-thunk_1)))"
" prev-thunk_0)))))"
" for-loop_0)"
" void"
" start_0)))))"
"(thunk_0 as-tail?_0))))))))))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))))))"
"(define-values"
"(link-instance-from-compiled-in-memory)"
"(lambda(cim_0 to-ns_0)"
"(begin"
"(let-values(((orig-syntax-literals_0)(compiled-in-memory-syntax-literals cim_0)))"
"(let-values(((syntax-literals_0)"
"(if(not to-ns_0)"
"(let-values() orig-syntax-literals_0)"
"(if(namespace-scopes=?"
"(compiled-in-memory-namespace-scopes cim_0)"
"(extract-namespace-scopes to-ns_0))"
"(let-values() orig-syntax-literals_0)"
"(let-values()"
"(let-values(((len_0)(vector-length orig-syntax-literals_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'for/vector \"exact-nonnegative-integer?\" len_0)))"
"(let-values(((v_0)(make-vector len_0 0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((vec_0 len_1)"
"(let-values(((vec_0) orig-syntax-literals_0))"
"(begin"
"(check-vector vec_0)"
"(values vec_0(unsafe-vector-length vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(i_0 pos_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_0 len_1)"
"(let-values(((s_0)"
"(unsafe-vector-ref vec_0 pos_0)))"
"(let-values(((i_1)"
"(let-values(((i_1) i_0))"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(unsafe-vector*-set!"
" v_0"
" i_1"
"(let-values()"
"(swap-top-level-scopes"
" s_0"
"(compiled-in-memory-namespace-scopes"
" cim_0)"
" to-ns_0)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values i_2)))))"
"(if(if(not"
"((lambda x_0(unsafe-fx= i_1 len_0))"
" s_0))"
"(not #f)"
" #f)"
"(for-loop_0 i_1(unsafe-fx+ 1 pos_0))"
" i_1)))"
" i_0)))))"
" for-loop_0)"
" 0"
" 0)))))"
" v_0)))))))))"
"(1/make-instance"
" 'link"
" #f"
" 'constant"
" mpi-vector-id"
"(compiled-in-memory-mpis cim_0)"
" syntax-literals-id"
" syntax-literals_0))))))"
"(define-values(not-available)(gensym 'not-available))"
"(define-values(get-not-available)(lambda()(begin not-available)))"
"(define-values"
"(can-direct-eval?)"
"(lambda(p_0 ns_0 self-mpi_0)"
"(begin"
"(if(parsed-app? p_0)"
"(let-values()"
"(if(can-direct-eval?(parsed-app-rator p_0) ns_0 self-mpi_0)"
"(let-values(((lst_0)(parsed-app-rands p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((r_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(can-direct-eval? r_0 ns_0 self-mpi_0)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) r_0))(not #f) #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
" #f))"
"(if(parsed-id? p_0)"
"(let-values()(not(eq?(get-id-value p_0 ns_0 self-mpi_0) not-available)))"
"(if(parsed-quote? p_0)"
"(let-values() #t)"
"(if(parsed-quote-syntax? p_0)(let-values() #t)(let-values() #f))))))))"
"(define-values"
"(direct-eval)"
"(lambda(p_0 ns_0 self-mpi_0)"
"(begin"
"(if(parsed-app? p_0)"
"(let-values()"
"(apply"
"(direct-eval(parsed-app-rator p_0) ns_0 self-mpi_0)"
"(reverse$1"
"(let-values(((lst_0)(parsed-app-rands p_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((r_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(direct-eval r_0 ns_0 self-mpi_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(if(parsed-id? p_0)"
"(let-values()(get-id-value p_0 ns_0 self-mpi_0))"
"(if(parsed-quote? p_0)"
"(let-values()(parsed-quote-datum p_0))"
"(if(parsed-quote-syntax? p_0)(let-values()(parsed-quote-syntax-datum p_0))(let-values() #f))))))))"
"(define-values"
"(get-id-value)"
"(lambda(p_0 ns_0 self-mpi_0)"
"(begin"
"(let-values(((b_0)(parsed-id-binding p_0)))"
"(if(parsed-primitive-id? p_0)"
"(let-values()(hash-ref(1/primitive-table '#%kernel)(module-binding-sym b_0) get-not-available))"
"(if(let-values(((or-part_0)(parsed-top-id? p_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(not b_0)))"
"(if or-part_1 or-part_1(eq? self-mpi_0(module-binding-module b_0))))))"
"(let-values()"
"(namespace-get-variable"
" ns_0"
"(if b_0(module-binding-phase b_0)(namespace-phase ns_0))"
"(if b_0(module-binding-sym b_0)(syntax-e$1(parsed-s p_0)))"
" get-not-available))"
"(let-values()"
"(let-values(((mi_0)"
"(let-values(((ns1_0) ns_0)"
"((temp2_0)(1/module-path-index-resolve(module-binding-module b_0)))"
"((temp3_0)(phase-(namespace-phase ns_0)(module-binding-phase b_0))))"
"(namespace->module-instance70.1 #f #f unsafe-undefined ns1_0 temp2_0 temp3_0))))"
"(if(not mi_0)"
"(let-values() not-available)"
"(if(check-single-require-access"
" mi_0"
"(module-binding-phase b_0)"
"(module-binding-sym b_0)"
"(module-binding-extra-inspector b_0))"
"(let-values()"
"(namespace-get-variable"
"(module-instance-namespace mi_0)"
"(module-binding-phase b_0)"
"(module-binding-sym b_0)"
" get-not-available))"
"(let-values() not-available)))))))))))"
"(define-values(runtime-scope)(new-multi-scope))"
"(define-values(runtime-stx)(add-scope empty-syntax runtime-scope))"
"(define-values(runtime-module-name)(1/make-resolved-module-path '#%runtime))"
"(define-values(runtime-mpi)(1/module-path-index-join ''#%runtime #f))"
"(define-values"
"(add-runtime-primitive!)"
"(lambda(sym_0)"
"(begin"
"(let-values(((temp1_0)(syntax-scope-set runtime-stx 0))"
"((sym2_0) sym_0)"
"((temp3_0)"
"(let-values(((runtime-mpi4_0) runtime-mpi)((temp5_0) 0)((sym6_0) sym_0))"
"(make-module-binding20.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" runtime-mpi4_0"
" temp5_0"
" sym6_0))))"
"(add-binding-in-scopes!20.1 #f temp1_0 sym2_0 temp3_0)))))"
"(void"
"(begin"
"(add-runtime-primitive! 'values)"
"(add-runtime-primitive! 'cons)"
"(add-runtime-primitive! 'list)"
"(add-runtime-primitive! 'make-struct-type)"
"(add-runtime-primitive! 'make-struct-type-property)"
"(add-runtime-primitive! 'gensym)"
"(add-runtime-primitive! 'string->uninterned-symbol)))"
"(define-values"
"(runtime-instances)"
" '(#%kernel #%paramz #%foreign #%unsafe #%flfxnum #%extfl #%network #%place #%futures))"
"(define-values(box-cons!)(lambda(b_0 v_0)(begin(set-box! b_0(cons v_0(unbox b_0))))))"
"(define-values(box-clear!)(lambda(b_0)(begin(begin0(reverse$1(unbox b_0))(set-box! b_0 null)))))"
"(define-values"
"(struct:lift-context lift-context1.1 lift-context? lift-context-convert lift-context-lifts lift-context-module*-ok?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'lift-context"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'lift-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'convert)"
"(make-struct-field-accessor -ref_0 1 'lifts)"
"(make-struct-field-accessor -ref_0 2 'module*-ok?))))"
"(define-values"
"(struct:lifted-bind lifted-bind2.1 lifted-bind? lifted-bind-ids lifted-bind-keys lifted-bind-rhs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'lifted-bind"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'lifted-bind)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'ids)"
"(make-struct-field-accessor -ref_0 1 'keys)"
"(make-struct-field-accessor -ref_0 2 'rhs))))"
"(define-values"
"(make-lift-context6.1)"
"(lambda(module*-ok?3_0 convert5_0)"
"(begin"
" 'make-lift-context6"
"(let-values(((convert_0) convert5_0))"
"(let-values(((module*-ok?_0) module*-ok?3_0))"
"(let-values()(lift-context1.1 convert_0(box null) module*-ok?_0)))))))"
"(define-values"
"(add-lifted!)"
"(lambda(lifts_0 ids_0 rhs_0 phase_0)"
"(begin"
"(let-values(((lifted-ids_0 lifted_0)((lift-context-convert lifts_0) ids_0 rhs_0 phase_0)))"
"(begin(box-cons!(lift-context-lifts lifts_0) lifted_0) lifted-ids_0)))))"
"(define-values(get-and-clear-lifts!)(lambda(lifts_0)(begin(box-clear!(lift-context-lifts lifts_0)))))"
"(define-values"
"(make-local-lift)"
"(lambda(lift-env_0 counter_0 local-sym_0)"
"(begin"
"(lambda(ids_0 rhs_0 phase_0)"
"(let-values(((keys_0)"
"(reverse$1"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((key_0)"
"(let-values(((id32_0)"
" id_0)"
"((phase33_0)"
" phase_0)"
"((counter34_0)"
" counter_0)"
"((local-sym35_0)"
" local-sym_0))"
"(add-local-binding!39.1"
" #f"
" #f"
" local-sym35_0"
" id32_0"
" phase33_0"
" counter34_0))))"
"(begin"
"(set-box!"
" lift-env_0"
"(env-extend"
"(unbox lift-env_0)"
" key_0"
" variable))"
" key_0)))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(values ids_0(lifted-bind2.1 ids_0 keys_0 rhs_0)))))))"
"(define-values"
"(make-top-level-lift)"
"(lambda(ctx_0)"
"(begin"
"(lambda(ids_0 rhs_0 phase_0)"
"(let-values(((post-scope_0)"
"(post-expansion-scope"
"(root-expand-context-post-expansion"
"(namespace-get-root-expand-ctx(expand-context-namespace ctx_0))))))"
"(let-values(((tl-ids_0)"
"(reverse$1"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope id_0 post-scope_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values(((syms_0)(select-defined-syms-and-bind!/ctx tl-ids_0 ctx_0)))"
"(values tl-ids_0(lifted-bind2.1 tl-ids_0 syms_0 rhs_0)))))))))"
"(define-values"
"(wrap-lifts-as-let)"
"(lambda(lifts_0 body_0 phase_0)"
"(begin"
"(datum->syntax$1"
" #f"
"(let-values(((lst_0)(reverse$1 lifts_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(body_1 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((lift_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((body_2)"
"(let-values(((body_2) body_1))"
"(let-values(((body_3)"
"(let-values()"
"(begin"
"(if(lifted-bind? lift_0)"
"(void)"
"(let-values()"
"                                                                           (error \"non-bindings in `lift-context`\")))"
"(list"
"(datum->syntax$1"
"(syntax-shift-phase-level$1 core-stx phase_0)"
" 'let-values)"
"(list"
"(list"
"(lifted-bind-ids lift_0)"
"(lifted-bind-rhs lift_0)))"
" body_2)))))"
"(values body_3)))))"
"(if(not #f)(for-loop_0 body_2 rest_0) body_2)))"
" body_1)))))"
" for-loop_0)"
" body_0"
" lst_0)))))))"
"(define-values"
"(wrap-lifts-as-begin16.1)"
"(lambda(adjust-body10_0 adjust-form9_0 lifts13_0 body14_0 phase15_0)"
"(begin"
" 'wrap-lifts-as-begin16"
"(let-values(((lifts_0) lifts13_0))"
"(let-values(((body_0) body14_0))"
"(let-values(((phase_0) phase15_0))"
"(let-values(((adjust-form_0)(if(eq? adjust-form9_0 unsafe-undefined) values adjust-form9_0)))"
"(let-values(((adjust-body_0)(if(eq? adjust-body10_0 unsafe-undefined) values adjust-body10_0)))"
"(let-values()"
"(datum->syntax$1"
" #f"
"(cons"
"(datum->syntax$1(syntax-shift-phase-level$1 core-stx phase_0) 'begin)"
"(append"
"(reverse$1"
"(let-values(((lst_0) lifts_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((lift_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(adjust-form_0"
"(if(lifted-bind? lift_0)"
"(let-values()"
"(datum->syntax$1"
" #f"
"(list"
"(datum->syntax$1"
"(syntax-shift-phase-level$1"
" core-stx"
" phase_0)"
" 'define-values)"
"(lifted-bind-ids lift_0)"
"(lifted-bind-rhs"
" lift_0))))"
"(let-values() lift_0))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
"(list(adjust-body_0 body_0))))))))))))))"
"(define-values"
"(get-lifts-as-lists)"
"(lambda(lifts_0)"
"(begin"
"(reverse$1"
"(let-values(((lst_0) lifts_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((lift_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(list"
"(lifted-bind-ids lift_0)"
"(lifted-bind-keys lift_0)"
"(lifted-bind-rhs lift_0)))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(define-values"
"(struct:module-lift-context"
" module-lift-context19.1"
" module-lift-context?"
" module-lift-context-wrt-phase"
" module-lift-context-lifts"
" module-lift-context-module*-ok?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'module-lift-context"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'module-lift-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'wrt-phase)"
"(make-struct-field-accessor -ref_0 1 'lifts)"
"(make-struct-field-accessor -ref_0 2 'module*-ok?))))"
"(define-values"
"(make-module-lift-context)"
"(lambda(phase_0 module*-ok?_0)(begin(module-lift-context19.1 phase_0(box null) module*-ok?_0))))"
"(define-values"
"(get-and-clear-module-lifts!)"
"(lambda(module-lifts_0)(begin(box-clear!(module-lift-context-lifts module-lifts_0)))))"
"(define-values"
"(add-lifted-module!)"
"(lambda(module-lifts_0 s_0 phase_0)"
"(begin"
"(begin"
"(if(let-values(((or-part_0)"
"(if(module-lift-context? module-lifts_0)"
"(module-lift-context-module*-ok? module-lifts_0)"
" #f)))"
"(if or-part_0 or-part_0(if(lift-context? module-lifts_0)(lift-context-module*-ok? module-lifts_0) #f)))"
"(void)"
"(let-values()"
"(let-values(((tmp_0)(core-form-sym s_0 phase_0)))"
"(if(equal? tmp_0 'module)"
"(let-values()(void))"
"(if(equal? tmp_0 'module*)"
"(let-values()"
"(raise-arguments-error"
" 'syntax-local-lift-module"
"                     \"cannot lift `module*' to a top-level context\""
"                     \"syntax\""
" s_0))"
"(let-values()"
"                    (raise-arguments-error 'syntax-local-lift-module \"not a `module' declaration\" \"syntax\" s_0)))))))"
"(if(module-lift-context? module-lifts_0)"
"(let-values()(box-cons!(module-lift-context-lifts module-lifts_0) s_0))"
"(if(lift-context? module-lifts_0)"
"(let-values()(box-cons!(lift-context-lifts module-lifts_0) s_0))"
"            (let-values () (error \"internal error: unrecognized lift-context type for module lift\"))))))))"
"(define-values"
"(struct:require-lift-context"
" require-lift-context20.1"
" require-lift-context?"
" require-lift-context-do-require"
" require-lift-context-wrt-phase"
" require-lift-context-requires)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'require-lift-context"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2)"
" #f"
" 'require-lift-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'do-require)"
"(make-struct-field-accessor -ref_0 1 'wrt-phase)"
"(make-struct-field-accessor -ref_0 2 'requires))))"
"(define-values"
"(make-require-lift-context)"
"(lambda(wrt-phase_0 do-require_0)(begin(require-lift-context20.1 do-require_0 wrt-phase_0(box null)))))"
"(define-values"
"(get-and-clear-require-lifts!)"
"(lambda(require-lifts_0)(begin(box-clear!(require-lift-context-requires require-lifts_0)))))"
"(define-values"
"(add-lifted-require!)"
"(lambda(require-lifts_0 s_0 phase_0)"
"(begin"
"(begin"
"((require-lift-context-do-require require-lifts_0) s_0 phase_0)"
"(box-cons!(require-lift-context-requires require-lifts_0) s_0)))))"
"(define-values"
"(struct:to-module-lift-context"
" to-module-lift-context21.1"
" to-module-lift-context?"
" to-module-lift-context-wrt-phase"
" to-module-lift-context-provides"
" to-module-lift-context-end-as-expressions?"
" to-module-lift-context-ends)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'to-module-lift-context"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'to-module-lift-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'wrt-phase)"
"(make-struct-field-accessor -ref_0 1 'provides)"
"(make-struct-field-accessor -ref_0 2 'end-as-expressions?)"
"(make-struct-field-accessor -ref_0 3 'ends))))"
"(define-values"
"(make-to-module-lift-context27.1)"
"(lambda(end-as-expressions?23_0 shared-module-ends22_0 phase26_0)"
"(begin"
" 'make-to-module-lift-context27"
"(let-values(((phase_0) phase26_0))"
"(let-values(((ends_0) shared-module-ends22_0))"
"(let-values(((end-as-expressions?_0) end-as-expressions?23_0))"
"(let-values()(to-module-lift-context21.1 phase_0(box null) end-as-expressions?_0 ends_0))))))))"
"(define-values(make-shared-module-ends)(lambda()(begin(box null))))"
"(define-values"
"(get-and-clear-end-lifts!)"
"(lambda(to-module-lifts_0)(begin(box-clear!(to-module-lift-context-ends to-module-lifts_0)))))"
"(define-values"
"(get-and-clear-provide-lifts!)"
"(lambda(to-module-lifts_0)(begin(box-clear!(to-module-lift-context-provides to-module-lifts_0)))))"
"(define-values"
"(add-lifted-to-module-provide!)"
"(lambda(to-module-lifts_0 s_0 phase_0)(begin(box-cons!(to-module-lift-context-provides to-module-lifts_0) s_0))))"
"(define-values"
"(add-lifted-to-module-end!)"
"(lambda(to-module-lifts_0 s_0 phase_0)(begin(box-cons!(to-module-lift-context-ends to-module-lifts_0) s_0))))"
"(define-values"
"(struct:already-expanded already-expanded1.1 already-expanded? already-expanded-s already-expanded-binding-layer)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'expanded-syntax"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'already-expanded)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 's)"
"(make-struct-field-accessor -ref_0 1 'binding-layer))))"
"(define-values"
"(1/prop:liberal-define-context has-liberal-define-context-property? liberal-define-context-value)"
"(make-struct-type-property 'liberal-define-context))"
"(define-values"
"(struct:liberal-define-context make-liberal-define-context 1/liberal-define-context?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'liberal-define-context"
" #f"
" 0"
" 0"
" #f"
"(list(cons 1/prop:liberal-define-context #t))"
" #f"
" #f"
" '()"
" #f"
" 'make-liberal-define-context)))))"
"(values struct:_0 make-_0 ?_0)))"
"(define-values"
"(1/prop:expansion-contexts expansion-contexts? expansion-contexts-ref)"
"(make-struct-type-property"
" 'expansion-contexts"
"(lambda(v_0 info_0)"
"(begin"
"(if(if(list? v_0)"
"(let-values(((lst_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(memq"
" s_0"
" '(expression"
" top-level"
" module"
" module-begin"
" definition-context))))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) s_0))(not #f) #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
" lst_0)))"
" #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'guard-for-prop:expansion-contexts"
"            \"(listof (or/c 'expression 'top-level 'module 'module-begin 'definition-context))\""
" v_0)))"
" v_0))))"
"(define-values"
"(not-in-this-expand-context?)"
"(lambda(t_0 ctx_0)"
"(begin"
"(if(expansion-contexts? t_0)"
"(not(memq(context->symbol(expand-context-context ctx_0))(expansion-contexts-ref t_0)))"
" #f))))"
"(define-values(context->symbol)(lambda(context_0)(begin(if(symbol? context_0) context_0 'definition-context))))"
"(define-values"
"(avoid-current-expand-context)"
"(lambda(s_0 t_0 ctx_0)"
"(begin"
"(let-values(((wrap_0)"
"(lambda(sym_0)"
"(begin"
" 'wrap"
"(datum->syntax$1"
" #f"
"(list"
"(syntax-shift-phase-level$1(datum->syntax$1 core-stx sym_0)(expand-context-phase ctx_0))"
" s_0))))))"
"(let-values(((fail_0)"
"(lambda()"
"(begin"
" 'fail"
"(raise-syntax-error$1"
" #f"
"(format"
"                            \"not allowed in context\\n  expansion context: ~a\""
"(context->symbol(expand-context-context ctx_0)))"
" s_0)))))"
"(let-values(((tmp_0)(context->symbol(expand-context-context ctx_0))))"
"(if(equal? tmp_0 'module-begin)"
"(let-values()(wrap_0 'begin))"
"(if(if(equal? tmp_0 'module) #t(if(equal? tmp_0 'top-level) #t(equal? tmp_0 'definition-context)))"
"(let-values()(if(memq 'expression(expansion-contexts-ref t_0))(wrap_0 '#%expression)(fail_0)))"
"(let-values()(fail_0))))))))))"
"(define-values"
"(struct:reference-record"
" reference-record1.1"
" reference-record?"
" reference-record-already-bound"
" reference-record-reference-before-bound"
" reference-record-all-referenced?"
" set-reference-record-already-bound!"
" set-reference-record-reference-before-bound!"
" set-reference-record-all-referenced?!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'reference-record"
" #f"
" 3"
" 0"
" #f"
"(list(cons prop:authentic #t))"
" #f"
" #f"
" '()"
" #f"
" 'reference-record)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'already-bound)"
"(make-struct-field-accessor -ref_0 1 'reference-before-bound)"
"(make-struct-field-accessor -ref_0 2 'all-referenced?)"
"(make-struct-field-mutator -set!_0 0 'already-bound)"
"(make-struct-field-mutator -set!_0 1 'reference-before-bound)"
"(make-struct-field-mutator -set!_0 2 'all-referenced?))))"
"(define-values(make-reference-record)(lambda()(begin(reference-record1.1(seteq)(seteq) #f))))"
"(define-values"
"(reference-record-used!)"
"(lambda(rr_0 key_0)"
"(begin"
"(if(set-member?(reference-record-already-bound rr_0) key_0)"
"(void)"
"(let-values()"
"(set-reference-record-reference-before-bound!"
" rr_0"
"(set-add(reference-record-reference-before-bound rr_0) key_0)))))))"
"(define-values"
"(reference-records-all-used!)"
"(lambda(rrs_0)"
"(begin"
"(begin"
"(let-values(((lst_0) rrs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((rr_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((post-guard-var_0)(lambda()(begin 'post-guard-var #t))))"
"(let-values()"
"(if(reference-record-all-referenced? rr_0)"
"(values)"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(set-reference-record-all-referenced?! rr_0 #t))"
"(values)))))"
"(if(post-guard-var_0)(for-loop_0 rest_0)(values))))))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))))"
"(define-values"
"(reference-record-bound!)"
"(lambda(rr_0 keys_0)"
"(begin"
"(begin"
"(set-reference-record-already-bound!"
" rr_0"
"(let-values(((lst_0) keys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ab_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((key_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((ab_1)"
"(let-values(((ab_1) ab_0))"
"(let-values(((ab_2)(let-values()(set-add ab_1 key_0))))"
"(values ab_2)))))"
"(if(not #f)(for-loop_0 ab_1 rest_0) ab_1)))"
" ab_0)))))"
" for-loop_0)"
"(reference-record-already-bound rr_0)"
" lst_0))))"
"(set-reference-record-reference-before-bound!"
" rr_0"
"(let-values(((lst_0) keys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(rbb_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((key_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((rbb_1)"
"(let-values(((rbb_1) rbb_0))"
"(let-values(((rbb_2)(let-values()(set-remove rbb_1 key_0))))"
"(values rbb_2)))))"
"(if(not #f)(for-loop_0 rbb_1 rest_0) rbb_1)))"
" rbb_0)))))"
" for-loop_0)"
"(reference-record-reference-before-bound rr_0)"
" lst_0))))))))"
"(define-values"
"(reference-record-forward-references?)"
"(lambda(rr_0)"
"(begin"
"(let-values(((or-part_0)(reference-record-all-referenced? rr_0)))"
"(if or-part_0 or-part_0(positive?(set-count(reference-record-reference-before-bound rr_0))))))))"
"(define-values"
"(reference-record-clear!)"
"(lambda(rr_0)"
"(begin"
"(begin(set-reference-record-already-bound! rr_0 #f)(set-reference-record-reference-before-bound! rr_0 #f)))))"
"(define-values"
"(call-expand-observe)"
"(lambda(obs_0 key_0 . args_0)"
"(begin"
"(begin"
"(let-values(((c1_0)(hash-ref key->arity key_0 #f)))"
"(if c1_0"
"((lambda(arity_0)"
"(if(let-values(((or-part_0)(eq? arity_0 'any)))"
"(if or-part_0 or-part_0(eqv?(length args_0) arity_0)))"
"(void)"
"                 (let-values () (error 'call-expand-observe \"wrong arity for ~s: ~e\" key_0 args_0))))"
" c1_0)"
"            (let-values () (error 'call-expand-observe \"bad key: ~s\" key_0))))"
"(obs_0 key_0(if(null? args_0)(let-values() #f)(let-values()(apply list* args_0))))))))"
"(define-values"
"(key->arity)"
" '#hash((block->letrec . 1)"
"(block->list . 1)"
"(block-renames . 2)"
"(enter-bind . 0)"
"(enter-block . 1)"
"(enter-check . 1)"
"(enter-list . 1)"
"(enter-local . 1)"
"(enter-macro . 1)"
"(enter-prim . 1)"
"(exit-bind . 0)"
"(exit-check . 1)"
"(exit-list . 1)"
"(exit-local . 1)"
"(exit-local-bind . 0)"
"(exit-macro . 1)"
"(exit-prim . 1)"
"(lambda-renames . 2)"
"(let-renames . any)"
"(letlift-loop . 1)"
"(letrec-syntaxes-renames . any)"
"(lift-expr . 2)"
"(lift-loop . 1)"
"(lift-provide . 1)"
"(lift-require . 3)"
"(lift-statement . 1)"
"(local-bind . 1)"
"(local-post . 1)"
"(local-pre . 1)"
"(local-value . 1)"
"(local-value-result . 1)"
"(macro-post-x . 2)"
"(macro-pre-x . 1)"
"(module-body . 1)"
"(module-lift-end-loop . 1)"
"(module-lift-loop . 1)"
"(next . 0)"
"(next-group . 0)"
"(opaque-expr . 1)"
"(phase-up . 0)"
"(prepare-env . 0)"
"(prim-#%app . 0)"
"(prim-#%datum . 0)"
"(prim-#%expression . 0)"
"(prim-#%stratified . 0)"
"(prim-#%top . 0)"
"(prim-#%variable-reference . 0)"
"(prim-begin . 0)"
"(prim-begin-for-syntax . 0)"
"(prim-begin0 . 0)"
"(prim-case-lambda . 0)"
"(prim-define-syntaxes . 0)"
"(prim-define-values . 0)"
"(prim-if . 0)"
"(prim-lambda . 0)"
"(prim-let-values . 0)"
"(prim-letrec-syntaxes+values . 0)"
"(prim-letrec-values . 0)"
"(prim-module . 0)"
"(prim-module-begin . 0)"
"(prim-provide . 0)"
"(prim-quote . 0)"
"(prim-quote-syntax . 0)"
"(prim-require . 0)"
"(prim-set! . 0)"
"(prim-stop . 0)"
"(prim-submodule . 0)"
"(prim-submodule* . 0)"
"(prim-with-continuation-mark . 0)"
"(rename-list . 1)"
"(rename-one . 1)"
"(resolve . 1)"
"(return . 1)"
"(splice . 1)"
"(start . 0)"
"(start-top . 0)"
"(tag . 1)"
"(track-origin . 2)"
"(variable . 2)"
"(visit . 1)))"
"(define-values"
"(rebuild5.1)"
"(lambda(track?1_0 orig-s3_0 new4_0)"
"(begin"
" 'rebuild5"
"(let-values(((orig-s_0) orig-s3_0))"
"(let-values(((new_0) new4_0))"
"(let-values(((track?_0) track?1_0))"
"(let-values()"
"(syntax-rearm$1"
"(datum->syntax$1(syntax-disarm$1 orig-s_0) new_0 orig-s_0(if track?_0 orig-s_0 #f))"
" orig-s_0))))))))"
"(define-values"
"(struct:expanded+parsed expanded+parsed1.1 expanded+parsed? expanded+parsed-s expanded+parsed-parsed)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'expanded+parsed"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'expanded+parsed)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 's)"
"(make-struct-field-accessor -ref_0 1 'parsed))))"
"(define-values"
"(struct:semi-parsed-define-values"
" semi-parsed-define-values2.1"
" semi-parsed-define-values?"
" semi-parsed-define-values-s"
" semi-parsed-define-values-syms"
" semi-parsed-define-values-ids"
" semi-parsed-define-values-rhs)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'semi-parsed-define-values"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'semi-parsed-define-values)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 's)"
"(make-struct-field-accessor -ref_0 1 'syms)"
"(make-struct-field-accessor -ref_0 2 'ids)"
"(make-struct-field-accessor -ref_0 3 'rhs))))"
"(define-values"
"(struct:semi-parsed-begin-for-syntax"
" semi-parsed-begin-for-syntax3.1"
" semi-parsed-begin-for-syntax?"
" semi-parsed-begin-for-syntax-s"
" semi-parsed-begin-for-syntax-body)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'semi-parsed-begin-for-syntax"
" #f"
" 2"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'semi-parsed-begin-for-syntax)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 's)"
"(make-struct-field-accessor -ref_0 1 'body))))"
"(define-values(extract-syntax)(lambda(s_0)(begin(if(expanded+parsed? s_0)(expanded+parsed-s s_0) s_0))))"
"(define-values"
"(parsed-only)"
"(lambda(l_0)"
"(begin"
"(reverse$1"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(if(let-values(((or-part_0)(parsed? i_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(expanded+parsed? i_0)))"
"(if or-part_1"
" or-part_1"
"(semi-parsed-begin-for-syntax? i_0)))))"
"(let-values(((fold-var_2) fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
"(if(expanded+parsed? i_0)"
"(let-values()"
"(expanded+parsed-parsed i_0))"
"(if(semi-parsed-begin-for-syntax? i_0)"
"(let-values()"
"(parsed-begin-for-syntax21.1"
"(semi-parsed-begin-for-syntax-s i_0)"
"(parsed-only"
"(semi-parsed-begin-for-syntax-body"
" i_0))))"
"(let-values() i_0))))"
" fold-var_2))))"
"(values fold-var_3)))"
" fold-var_1))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(define-values"
"(syntax-only)"
"(lambda(l_0)"
"(begin"
"(reverse$1"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(if(let-values(((or-part_0)(syntax?$1 i_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(expanded+parsed? i_0)))"
"(if or-part_1"
" or-part_1"
"(semi-parsed-begin-for-syntax? i_0)))))"
"(let-values(((fold-var_2) fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
"(if(expanded+parsed? i_0)"
"(let-values()(expanded+parsed-s i_0))"
"(if(semi-parsed-begin-for-syntax? i_0)"
"(let-values()"
"(let-values(((s_0)"
"(semi-parsed-begin-for-syntax-s"
" i_0)))"
"(let-values(((nested-bodys_0)"
"(semi-parsed-begin-for-syntax-body"
" i_0)))"
"(let-values(((disarmed-s_0)"
"(syntax-disarm$1"
" s_0)))"
"(let-values(((ok?_0"
" begin-for-syntax7_0"
" _8_0)"
"(let-values(((s_1)"
" disarmed-s_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((begin-for-syntax7_0"
" _8_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((begin-for-syntax9_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((_10_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_4)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin-for-syntax9_0"
" _10_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                             \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin-for-syntax7_0"
" _8_0))))))"
"(let-values(((s11_0) s_0)"
"((temp12_0)"
"(list*"
" begin-for-syntax7_0"
"(syntax-only"
" nested-bodys_0))))"
"(rebuild5.1"
" #t"
" s11_0"
" temp12_0)))))))"
"(let-values() i_0))))"
" fold-var_2))))"
"(values fold-var_3)))"
" fold-var_1))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(define-values"
"(expand9.1)"
"(lambda(alternate-id1_0 fail-non-transformer3_0 skip-log?2_0 s7_0 ctx8_0)"
"(begin"
" 'expand9"
"(let-values(((s_0) s7_0))"
"(let-values(((ctx_0) ctx8_0))"
"(let-values(((alternate-id_0) alternate-id1_0))"
"(let-values(((skip-log?_0) skip-log?2_0))"
"(let-values(((fail-non-transformer_0) fail-non-transformer3_0))"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(not skip-log?_0)"
"(let-values()"
"(call-expand-observe"
" obs_0"
"(if(expand-context-only-immediate? ctx_0) 'enter-check 'visit)"
" s_0))"
"(void)))"
"(void)))"
"(if(syntax-identifier? s_0)"
"(let-values()(expand-identifier s_0 ctx_0 alternate-id_0))"
"(if(if(pair?(syntax-content s_0))(syntax-identifier?(car(syntax-content s_0))) #f)"
"(let-values()"
"(let-values(((s122_0) s_0)"
"((ctx123_0) ctx_0)"
"((alternate-id124_0) alternate-id_0)"
"((fail-non-transformer125_0) fail-non-transformer_0))"
"(expand-id-application-form17.1"
" fail-non-transformer125_0"
" s122_0"
" ctx123_0"
" alternate-id124_0)))"
"(if(let-values(((or-part_0)(pair?(syntax-content s_0))))"
"(if or-part_0 or-part_0(null?(syntax-content s_0))))"
"(let-values()(expand-implicit '#%app s_0 ctx_0 #f))"
"(if(already-expanded?(syntax-content s_0))"
"(let-values()(expand-already-expanded s_0 ctx_0))"
"(let-values()(expand-implicit '#%datum s_0 ctx_0 #f))))))))))))))))"
"(define-values"
"(expand-identifier)"
"(lambda(s_0 ctx_0 alternate-id_0)"
"(begin"
"(let-values(((id_0)(let-values(((or-part_0) alternate-id_0))(if or-part_0 or-part_0 s_0))))"
"(if(if(not(free-id-set-empty?(expand-context-stops ctx_0)))"
"(free-id-set-member?(expand-context-stops ctx_0)(expand-context-phase ctx_0) id_0)"
" #f)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(not(expand-context-only-immediate? ctx_0))"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'resolve id_0)"
"(call-expand-observe obs_0 'enter-prim s_0)"
"(call-expand-observe obs_0 'prim-stop)"
"(call-expand-observe obs_0 'exit-prim s_0)"
"(call-expand-observe obs_0 'return s_0)))"
"(void)))"
"(void)))"
" s_0))"
"(let-values()"
"(let-values(((binding_0)"
"(let-values(((id126_0) id_0)"
"((temp127_0)(expand-context-phase ctx_0))"
"((temp128_0) 'ambiguous)"
"((temp129_0) #t))"
"(resolve+shift28.1 temp128_0 #f null temp129_0 #f id126_0 temp127_0))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(not(expand-context-only-immediate? ctx_0))"
"(let-values()(call-expand-observe obs_0 'resolve id_0))"
"(void)))"
"(void)))"
"(if(eq? binding_0 'ambiguous)"
"(let-values()(raise-ambiguous-error id_0 ctx_0))"
"(if(not binding_0)"
"(let-values()(expand-implicit '#%top(substitute-alternate-id s_0 alternate-id_0) ctx_0 s_0))"
"(let-values()"
"(let-values(((t_0 primitive?_0 insp-of-t_0 protected?_0)"
"(let-values(((binding138_0) binding_0)"
"((ctx139_0) ctx_0)"
"((id140_0) id_0)"
"((temp141_0)(if alternate-id_0 s_0 #f))"
"((temp142_0)(expand-context-in-local-expand? ctx_0)))"
"(lookup62.1 temp141_0 temp142_0 binding138_0 ctx139_0 id140_0))))"
"(let-values(((t130_0) t_0)"
"((insp-of-t131_0) insp-of-t_0)"
"((s132_0) s_0)"
"((id133_0) id_0)"
"((ctx134_0) ctx_0)"
"((binding135_0) binding_0)"
"((primitive?136_0) primitive?_0)"
"((protected?137_0) protected?_0))"
"(dispatch30.1"
" #f"
" t130_0"
" insp-of-t131_0"
" s132_0"
" id133_0"
" ctx134_0"
" binding135_0"
" primitive?136_0"
" protected?137_0))))))))))))))"
"(define-values"
"(expand-id-application-form17.1)"
"(lambda(fail-non-transformer12_0 s14_0 ctx15_0 alternate-id16_0)"
"(begin"
" 'expand-id-application-form17"
"(let-values(((s_0) s14_0))"
"(let-values(((ctx_0) ctx15_0))"
"(let-values(((alternate-id_0) alternate-id16_0))"
"(let-values(((fail-non-transformer_0) fail-non-transformer12_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((or-part_0) alternate-id_0))"
"(if or-part_0 or-part_0(car(syntax-e/no-taint s_0))))))"
"(if(if(not(free-id-set-empty?(expand-context-stops ctx_0)))"
"(free-id-set-member?(expand-context-stops ctx_0)(expand-context-phase ctx_0) id_0)"
" #f)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(not(expand-context-only-immediate? ctx_0))"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'resolve id_0)"
"(call-expand-observe obs_0 'enter-prim s_0)"
"(call-expand-observe obs_0 'prim-stop)"
"(call-expand-observe obs_0 'exit-prim s_0)"
"(call-expand-observe obs_0 'return s_0)))"
"(void)))"
"(void)))"
" s_0))"
"(let-values()"
"(let-values(((binding_0)"
"(let-values(((id143_0) id_0)"
"((temp144_0)(expand-context-phase ctx_0))"
"((temp145_0) 'ambiguous)"
"((temp146_0) #t))"
"(resolve+shift28.1 temp145_0 #f null temp146_0 #f id143_0 temp144_0))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(not(expand-context-only-immediate? ctx_0))"
"(let-values()(call-expand-observe obs_0 'resolve id_0))"
"(void)))"
"(void)))"
"(if(eq? binding_0 'ambiguous)"
"(let-values()"
"(begin"
"(if fail-non-transformer_0(let-values()(fail-non-transformer_0))(void))"
"(raise-ambiguous-error id_0 ctx_0)))"
"(if(not binding_0)"
"(let-values()"
"(begin"
"(if fail-non-transformer_0(let-values()(fail-non-transformer_0))(void))"
"(expand-implicit '#%app(substitute-alternate-id s_0 alternate-id_0) ctx_0 id_0)))"
"(let-values()"
"(let-values(((t_0 primitive?_0 insp-of-t_0 protected?_0)"
"(let-values(((binding147_0) binding_0)"
"((ctx148_0) ctx_0)"
"((id149_0) id_0)"
"((temp150_0)"
"(if alternate-id_0(car(syntax-e/no-taint s_0)) #f))"
"((temp151_0)(expand-context-in-local-expand? ctx_0)))"
"(lookup62.1 temp150_0 temp151_0 binding147_0 ctx148_0 id149_0))))"
"(if(variable? t_0)"
"(let-values()"
"(begin"
"(if fail-non-transformer_0(let-values()(fail-non-transformer_0))(void))"
"(expand-implicit"
" '#%app"
"(substitute-alternate-id s_0 alternate-id_0)"
" ctx_0"
" id_0)))"
"(let-values()"
"(let-values(((t152_0) t_0)"
"((insp-of-t153_0) insp-of-t_0)"
"((s154_0) s_0)"
"((id155_0) id_0)"
"((ctx156_0) ctx_0)"
"((binding157_0) binding_0)"
"((primitive?158_0) primitive?_0)"
"((protected?159_0) protected?_0)"
"((fail-non-transformer160_0) fail-non-transformer_0))"
"(dispatch30.1"
" fail-non-transformer160_0"
" t152_0"
" insp-of-t153_0"
" s154_0"
" id155_0"
" ctx156_0"
" binding157_0"
" primitive?158_0"
" protected?159_0)))))))))))))))))))))"
"(define-values"
"(expand-implicit)"
"(lambda(sym_0 s_0 ctx_0 trigger-id_0)"
"(begin"
"(if(expand-context-only-immediate? ctx_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'exit-check s_0)))(void)))"
" s_0))"
"(let-values()"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((id_0)(datum->syntax$1 disarmed-s_0 sym_0)))"
"(if(if(not(free-id-set-empty?(expand-context-stops ctx_0)))"
"(free-id-set-member?(expand-context-stops ctx_0)(expand-context-phase ctx_0) id_0)"
" #f)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(not(expand-context-only-immediate? ctx_0))"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'resolve id_0)"
"(call-expand-observe obs_0 'enter-prim s_0)"
"(call-expand-observe obs_0 'prim-stop)"
"(call-expand-observe obs_0 'exit-prim s_0)"
"(call-expand-observe obs_0 'return s_0)))"
"(void)))"
"(void)))"
" s_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'resolve id_0)))"
"(void)))"
"(values))))"
"(let-values(((b_0)"
"(let-values(((id161_0) id_0)"
"((temp162_0)(expand-context-phase ctx_0))"
"((temp163_0) 'ambiguous)"
"((temp164_0) #t))"
"(resolve+shift28.1 temp163_0 #f null temp164_0 #f id161_0 temp162_0))))"
"(if(eq? b_0 'ambiguous)"
"(let-values()(raise-ambiguous-error id_0 ctx_0))"
"(let-values()"
"(let-values(((t_0 primitive?_0 insp-of-t_0 protected?_0)"
"(if b_0"
"(let-values(((b165_0) b_0)((ctx166_0) ctx_0)((id167_0) id_0))"
"(lookup62.1 #f #f b165_0 ctx166_0 id167_0))"
"(values #f #f #f #f))))"
"(if(transformer? t_0)"
"(let-values()"
"(let-values(((fail-non-transformer_0)"
"(if(1/rename-transformer? t_0)"
"(lambda()"
"(begin"
" 'fail-non-transformer"
"(raise-syntax-implicit-error s_0 sym_0 trigger-id_0 ctx_0)))"
" #f)))"
"(let-values(((t168_0) t_0)"
"((insp-of-t169_0) insp-of-t_0)"
"((temp170_0)(make-explicit ctx_0 sym_0 s_0 disarmed-s_0))"
"((id171_0) id_0)"
"((ctx172_0) ctx_0)"
"((b173_0) b_0)"
"((fail-non-transformer174_0) fail-non-transformer_0))"
"(dispatch-transformer41.1"
" fail-non-transformer174_0"
" t168_0"
" insp-of-t169_0"
" temp170_0"
" id171_0"
" ctx172_0"
" b173_0))))"
"(if(core-form? t_0)"
"(let-values()"
"(if(if(eq? sym_0 '#%top)"
"(if(eq?(core-form-name t_0) '#%top)"
"(expand-context-in-local-expand? ctx_0)"
" #f)"
" #f)"
"(let-values()(dispatch-implicit-#%top-core-form t_0 s_0 ctx_0))"
"(let-values()"
"(dispatch-core-form t_0(make-explicit ctx_0 sym_0 s_0 disarmed-s_0) ctx_0))))"
"(let-values()"
"(let-values(((tl-id_0)"
"(if(eq? sym_0 '#%top)"
"(if(root-expand-context-top-level-bind-scope ctx_0)"
"(add-scope s_0(root-expand-context-top-level-bind-scope ctx_0))"
" #f)"
" #f)))"
"(let-values(((tl-b_0)"
"(if tl-id_0"
"(let-values(((tl-id175_0) tl-id_0)"
"((temp176_0)(expand-context-phase ctx_0)))"
"(resolve40.1 #f #f null #f tl-id175_0 temp176_0))"
" #f)))"
"(if tl-b_0"
"(let-values()"
"(if(if(expand-context-to-parsed? ctx_0)"
"(free-id-set-empty?(expand-context-stops ctx_0))"
" #f)"
"(parsed-id2.1 tl-id_0 tl-b_0 #f)"
" tl-id_0))"
"(let-values()"
"(raise-syntax-implicit-error"
" s_0"
" sym_0"
" trigger-id_0"
" ctx_0))))))))))))))))))))))"
"(define-values"
"(expand-already-expanded)"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((ae_0)(syntax-e$1 s_0)))"
"(let-values(((exp-s_0)(already-expanded-s ae_0)))"
"(begin"
"(if(let-values(((or-part_0)(syntax-any-macro-scopes? s_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(not"
"(eq?(expand-context-binding-layer ctx_0)(already-expanded-binding-layer ae_0)))))"
"(if or-part_1"
" or-part_1"
"(if(parsed? exp-s_0)"
"(not"
"(if(expand-context-to-parsed? ctx_0)(free-id-set-empty?(expand-context-stops ctx_0)) #f))"
" #f)))))"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"(string-append"
"                  \"expanded syntax not in its original lexical context;\\n\""
"                  \" extra bindings or scopes in the current context\")"
"(if(not(parsed? exp-s_0)) exp-s_0 #f)))"
"(void))"
"(if(expand-context-only-immediate? ctx_0)"
"(let-values() s_0)"
"(if(parsed? exp-s_0)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((result-s_0)(syntax-track-origin$1 exp-s_0 s_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'opaque-expr result-s_0)))"
"(void)))"
"(if(if(expand-context-to-parsed? ctx_0)(free-id-set-empty?(expand-context-stops ctx_0)) #f)"
"(let-values(((result-s177_0) result-s_0)((ctx178_0) ctx_0))"
"(expand9.1 #f #f #f result-s177_0 ctx178_0))"
" result-s_0))))))))))))"
"(define-values"
"(make-explicit)"
"(lambda(ctx_0 sym_0 s_0 disarmed-s_0)"
"(begin"
"(let-values(((new-s_0)(syntax-rearm$1(datum->syntax$1 disarmed-s_0(cons sym_0 disarmed-s_0) s_0 s_0) s_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'tag new-s_0)))(void)))"
" new-s_0)))))"
"(define-values"
"(dispatch30.1)"
"(lambda(fail-non-transformer20_0 t22_0 insp-of-t23_0 s24_0 id25_0 ctx26_0 binding27_0 primitive?28_0 protected?29_0)"
"(begin"
" 'dispatch30"
"(let-values(((t_0) t22_0))"
"(let-values(((insp-of-t_0) insp-of-t23_0))"
"(let-values(((s_0) s24_0))"
"(let-values(((id_0) id25_0))"
"(let-values(((ctx_0) ctx26_0))"
"(let-values(((binding_0) binding27_0))"
"(let-values(((primitive?_0) primitive?28_0))"
"(let-values(((protected?_0) protected?29_0))"
"(let-values(((fail-non-transformer_0) fail-non-transformer20_0))"
"(let-values()"
"(if(core-form? t_0)"
"(let-values()(dispatch-core-form t_0 s_0 ctx_0))"
"(if(transformer? t_0)"
"(let-values()"
"(let-values(((t179_0) t_0)"
"((insp-of-t180_0) insp-of-t_0)"
"((s181_0) s_0)"
"((id182_0) id_0)"
"((ctx183_0) ctx_0)"
"((binding184_0) binding_0)"
"((fail-non-transformer185_0) fail-non-transformer_0))"
"(dispatch-transformer41.1"
" fail-non-transformer185_0"
" t179_0"
" insp-of-t180_0"
" s181_0"
" id182_0"
" ctx183_0"
" binding184_0)))"
"(if(variable? t_0)"
"(let-values()"
"(dispatch-variable t_0 s_0 id_0 ctx_0 binding_0 primitive?_0 protected?_0))"
"                                (let-values () (raise-syntax-error$1 #f \"illegal use of syntax\" s_0))))))))))))))))))"
"(define-values"
"(dispatch-core-form)"
"(lambda(t_0 s_0 ctx_0)"
"(begin"
"(if(expand-context-only-immediate? ctx_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'exit-check s_0)))(void)))"
" s_0))"
"(if(expand-context-observer ctx_0)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'enter-prim s_0)))"
"(void)))"
"(values))))"
"(let-values(((result-s_0)((core-form-expander t_0) s_0 ctx_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'exit-prim(extract-syntax result-s_0))"
"(call-expand-observe obs_0 'return(extract-syntax result-s_0)))))"
"(void)))"
" result-s_0))))"
"(let-values()((core-form-expander t_0) s_0 ctx_0)))))))"
"(define-values"
"(dispatch-implicit-#%top-core-form)"
"(lambda(t_0 s_0 ctx_0)"
"(begin"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'enter-prim s_0)))(void)))"
"(values))))"
"(let-values(((result-s_0)((core-form-expander t_0) s_0 ctx_0 #t)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'exit-prim result-s_0)"
"(call-expand-observe obs_0 'return result-s_0))))"
"(void)))"
" result-s_0))))))"
"(define-values"
"(dispatch-transformer41.1)"
"(lambda(fail-non-transformer33_0 t35_0 insp-of-t36_0 s37_0 id38_0 ctx39_0 binding40_0)"
"(begin"
" 'dispatch-transformer41"
"(let-values(((t_0) t35_0))"
"(let-values(((insp-of-t_0) insp-of-t36_0))"
"(let-values(((s_0) s37_0))"
"(let-values(((id_0) id38_0))"
"(let-values(((ctx_0) ctx39_0))"
"(let-values(((binding_0) binding40_0))"
"(let-values(((fail-non-transformer_0) fail-non-transformer33_0))"
"(let-values()"
"(if(not-in-this-expand-context? t_0 ctx_0)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'enter-macro s_0)))"
"(void)))"
"(values))))"
"(let-values(((adj-s_0)"
"(avoid-current-expand-context(substitute-alternate-id s_0 id_0) t_0 ctx_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'exit-macro s_0)))"
"(void)))"
"(let-values(((adj-s186_0) adj-s_0)((ctx187_0) ctx_0))"
"(expand9.1 #f #f #f adj-s186_0 ctx187_0))))))"
"(if(if(expand-context-should-not-encounter-macros? ctx_0)"
"(not(1/rename-transformer? t_0))"
" #f)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                             \"encountered a macro binding in form that should be fully expanded\""
" s_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(if(expand-context-only-immediate? ctx_0)"
"(not(1/rename-transformer? t_0))"
" #f)"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'visit s_0)"
"(call-expand-observe obs_0 'resolve id_0)))"
"(void)))"
"(void)))"
"(values))))"
"(let-values(((exp-s_0 re-ctx_0)"
"(if(1/rename-transformer? t_0)"
"(values s_0 ctx_0)"
"(let-values(((t188_0) t_0)"
"((insp-of-t189_0) insp-of-t_0)"
"((s190_0) s_0)"
"((id191_0) id_0)"
"((ctx192_0) ctx_0)"
"((binding193_0) binding_0))"
"(apply-transformer52.1"
" #f"
" t188_0"
" insp-of-t189_0"
" s190_0"
" id191_0"
" ctx192_0"
" binding193_0)))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(if(expand-context-only-immediate? ctx_0)"
"(not(1/rename-transformer? t_0))"
" #f)"
"(let-values()(call-expand-observe obs_0 'return exp-s_0))"
"(void)))"
"(void)))"
"(if(expand-context-just-once? ctx_0)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((exp-s194_0) exp-s_0)"
"((re-ctx195_0) re-ctx_0)"
"((temp196_0)"
"(if(1/rename-transformer? t_0)"
"(syntax-track-origin$1"
"(transfer-srcloc"
"(rename-transformer-target-in-context t_0 ctx_0)"
" id_0)"
" id_0"
" id_0)"
" #f))"
"((temp197_0)"
"(let-values(((or-part_0)(expand-context-only-immediate? ctx_0)))"
"(if or-part_0 or-part_0(1/rename-transformer? t_0))))"
"((temp198_0)"
"(if(1/rename-transformer? t_0) fail-non-transformer_0 #f)))"
"(expand9.1"
" temp196_0"
" temp198_0"
" temp197_0"
" exp-s194_0"
" re-ctx195_0)))))))))))))))))))))"
"(define-values"
"(dispatch-variable)"
"(lambda(t_0 s_0 id_0 ctx_0 binding_0 primitive?_0 protected?_0)"
"(begin"
"(if(expand-context-only-immediate? ctx_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'exit-check s_0)))(void)))"
" id_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'variable s_0 id_0)))"
"(void)))"
"(values))))"
"(let-values((()(begin(register-variable-referenced-if-local! binding_0)(values))))"
"(let-values(((result-s_0)"
"(let-values(((id199_0) id_0)"
"((t200_0) t_0)"
"((temp201_0)"
"(free-id-set-empty-or-just-module*?(expand-context-stops ctx_0))))"
"(substitute-variable6.1 temp201_0 id199_0 t200_0))))"
"(if(if(expand-context-to-parsed? ctx_0)(free-id-set-empty?(expand-context-stops ctx_0)) #f)"
"(let-values()"
"(let-values(((prop-s_0)(keep-properties-only~ result-s_0)))"
"(let-values(((insp_0)(syntax-inspector result-s_0)))"
"(if primitive?_0"
"(parsed-primitive-id3.1 prop-s_0 binding_0 insp_0)"
"(parsed-id2.1 prop-s_0 binding_0 insp_0)))))"
"(let-values()"
"(let-values(((protected-result-s_0)"
"(if protected?_0(syntax-property$1 result-s_0 'protected #t) result-s_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'return protected-result-s_0)))"
"(void)))"
" protected-result-s_0))))))))))))"
"(define-values"
"(apply-transformer52.1)"
"(lambda(origin-id44_0 t46_0 insp-of-t47_0 s48_0 id49_0 ctx50_0 binding51_0)"
"(begin"
" 'apply-transformer52"
"(let-values(((t_0) t46_0))"
"(let-values(((insp-of-t_0) insp-of-t47_0))"
"(let-values(((s_0) s48_0))"
"(let-values(((id_0) id49_0))"
"(let-values(((ctx_0) ctx50_0))"
"(let-values(((binding_0) binding51_0))"
"(let-values(((origin-id_0) origin-id44_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'expand '_ 'macro))(void))"
"(begin0"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'enter-macro s_0)))"
"(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((intro-scope_0)(new-scope 'macro)))"
"(let-values(((intro-s_0)(flip-scope disarmed-s_0 intro-scope_0)))"
"(let-values(((use-s_0 use-scopes_0)"
"(maybe-add-use-site-scope intro-s_0 ctx_0 binding_0)))"
"(let-values(((cleaned-s_0)(syntax-remove-taint-dispatch-properties use-s_0)))"
"(let-values(((def-ctx-scopes_0)(box null)))"
"(let-values(((transformed-s_0)"
"(apply-transformer-in-context"
" t_0"
" cleaned-s_0"
" ctx_0"
" insp-of-t_0"
" intro-scope_0"
" use-scopes_0"
" def-ctx-scopes_0"
" id_0)))"
"(let-values(((result-s_0)(flip-scope transformed-s_0 intro-scope_0)))"
"(let-values(((post-s_0)(maybe-add-post-expansion result-s_0 ctx_0)))"
"(let-values(((tracked-s_0)"
"(syntax-track-origin$1"
" post-s_0"
" cleaned-s_0"
"(let-values(((or-part_0) origin-id_0))"
"(if or-part_0"
" or-part_0"
"(if(syntax-identifier? s_0)"
" s_0"
"(car(syntax-e$1 s_0))))))))"
"(let-values(((rearmed-s_0)"
"(taint-dispatch"
" tracked-s_0"
"(lambda(t-s_0)(syntax-rearm$1 t-s_0 s_0))"
"(expand-context-phase ctx_0))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'exit-macro rearmed-s_0)))"
"(void)))"
"(values"
" rearmed-s_0"
"(accumulate-def-ctx-scopes ctx_0 def-ctx-scopes_0))))))))))))))))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))))))))))"
"(define-values"
"(apply-transformer-in-context)"
"(lambda(t_0 cleaned-s_0 ctx_0 insp-of-t_0 intro-scope_0 use-scopes_0 def-ctx-scopes_0 id_0)"
"(begin"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'macro-pre-x cleaned-s_0)))"
"(void)))"
"(values))))"
"(let-values(((confine-def-ctx-scopes?_0)"
"(not"
"(let-values(((or-part_0)(expand-context-only-immediate? ctx_0)))"
"(if or-part_0"
" or-part_0"
"(not(free-id-set-empty-or-just-module*?(expand-context-stops ctx_0))))))))"
"(let-values(((accum-ctx_0)"
"(if(if confine-def-ctx-scopes?_0"
"(if(expand-context-def-ctx-scopes ctx_0)"
"(not(null?(unbox(expand-context-def-ctx-scopes ctx_0))))"
" #f)"
" #f)"
"(accumulate-def-ctx-scopes ctx_0(expand-context-def-ctx-scopes ctx_0))"
" ctx_0)))"
"(let-values(((m-ctx_0)"
"(let-values(((v_0) accum-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((current-introduction-scopes202_0)(list intro-scope_0))"
"((current-use-scopes203_0) use-scopes_0)"
"((def-ctx-scopes204_0)"
"(if confine-def-ctx-scopes?_0"
" def-ctx-scopes_0"
"(expand-context-def-ctx-scopes ctx_0)))"
"((inner205_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner205_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
" def-ctx-scopes204_0"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
" current-introduction-scopes202_0"
" current-use-scopes203_0"
"(expand-context/outer-name the-struct_0)))"
"                                (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0))))))"
"(let-values(((transformed-s_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
"(namespace->namespace-at-phase"
"(expand-context-namespace ctx_0)"
"(add1(expand-context-phase ctx_0))))"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
" m-ctx_0"
"(with-continuation-mark"
" current-module-code-inspector"
" insp-of-t_0"
"(let-values()"
"(call-with-continuation-barrier"
"(lambda()((transformer->procedure t_0) cleaned-s_0))))))))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'macro-post-x transformed-s_0 cleaned-s_0)))"
"(void)))"
"(if(syntax?$1 transformed-s_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
"(syntax-e$1 id_0)"
"                       \"received value from syntax expander was not syntax\""
"                       \"received\""
" transformed-s_0)))"
" transformed-s_0)))))))))"
"(define-values"
"(maybe-add-use-site-scope)"
"(lambda(s_0 ctx_0 binding_0)"
"(begin"
"(if(if(root-expand-context-use-site-scopes ctx_0)"
"(matching-frame?(root-expand-context-frame-id ctx_0)(binding-frame-id binding_0))"
" #f)"
"(let-values()"
"(let-values(((sc_0)(new-scope 'use-site)))"
"(let-values(((b_0)(root-expand-context-use-site-scopes ctx_0)))"
"(begin(set-box! b_0(cons sc_0(unbox b_0)))(values(add-scope s_0 sc_0)(list sc_0))))))"
"(let-values()(values s_0 null))))))"
"(define-values"
"(matching-frame?)"
"(lambda(current-frame-id_0 bind-frame-id_0)"
"(begin"
"(if current-frame-id_0"
"(let-values(((or-part_0)(eq? current-frame-id_0 bind-frame-id_0)))"
"(if or-part_0 or-part_0(eq? current-frame-id_0 'all)))"
" #f))))"
"(define-values"
"(maybe-add-post-expansion)"
"(lambda(s_0 ctx_0)(begin(apply-post-expansion(root-expand-context-post-expansion ctx_0) s_0))))"
"(define-values"
"(accumulate-def-ctx-scopes)"
"(lambda(ctx_0 def-ctx-scopes_0)"
"(begin"
"(if(null?(unbox def-ctx-scopes_0))"
" ctx_0"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((scopes206_0)(append(unbox def-ctx-scopes_0)(expand-context-scopes ctx_0)))"
"((inner207_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner207_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
" scopes206_0"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"              (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0))))))))"
"(define-values"
"(lookup62.1)"
"(lambda(in55_0 out-of-context-as-variable?56_0 b59_0 ctx60_0 id61_0)"
"(begin"
" 'lookup62"
"(let-values(((b_0) b59_0))"
"(let-values(((ctx_0) ctx60_0))"
"(let-values(((id_0) id61_0))"
"(let-values(((in-s_0) in55_0))"
"(let-values(((out-of-context-as-variable?_0) out-of-context-as-variable?56_0))"
"(let-values()"
"(let-values(((b208_0) b_0)"
"((temp209_0)(expand-context-env ctx_0))"
"((temp210_0)(expand-context-lift-envs ctx_0))"
"((temp211_0)(expand-context-namespace ctx_0))"
"((temp212_0)(expand-context-phase ctx_0))"
"((id213_0) id_0)"
"((in-s214_0) in-s_0)"
"((out-of-context-as-variable?215_0) out-of-context-as-variable?_0))"
"(binding-lookup52.1"
" in-s214_0"
" out-of-context-as-variable?215_0"
" b208_0"
" temp209_0"
" temp210_0"
" temp211_0"
" temp212_0"
" id213_0)))))))))))"
"(define-values"
"(substitute-alternate-id)"
"(lambda(s_0 alternate-id_0)"
"(begin"
"(if(not alternate-id_0)"
"(let-values() s_0)"
"(if(syntax-identifier? s_0)"
"(let-values()(syntax-rearm$1(syntax-track-origin$1 alternate-id_0 s_0) s_0))"
"(let-values()"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(syntax-rearm$1"
"(syntax-track-origin$1"
"(datum->syntax$1 disarmed-s_0(cons alternate-id_0(cdr(syntax-e$1 disarmed-s_0))) s_0)"
" s_0)"
" s_0))))))))"
"(define-values"
"(register-variable-referenced-if-local!)"
"(lambda(binding_0)"
"(begin"
"(if(if(local-binding? binding_0)(reference-record?(binding-frame-id binding_0)) #f)"
"(let-values()(reference-record-used!(binding-frame-id binding_0)(local-binding-key binding_0)))"
"(void)))))"
"(define-values"
"(expand/capture-lifts75.1)"
"(lambda(always-wrap?68_0 begin-form?66_0 expand-lifts?65_0 lift-key67_0 s73_0 ctx74_0)"
"(begin"
" 'expand/capture-lifts75"
"(let-values(((s_0) s73_0))"
"(let-values(((ctx_0) ctx74_0))"
"(let-values(((expand-lifts?_0) expand-lifts?65_0))"
"(let-values(((begin-form?_0) begin-form?66_0))"
"(let-values(((lift-key_0)(if(eq? lift-key67_0 unsafe-undefined)(generate-lift-key) lift-key67_0)))"
"(let-values(((always-wrap?_0) always-wrap?68_0))"
"(let-values()"
"(let-values(((context_0)(expand-context-context ctx_0)))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((local?_0)(not begin-form?_0)))"
"((letrec-values(((loop_0)"
"(lambda(s_1 always-wrap?_1 ctx_1)"
"(begin"
" 'loop"
"(let-values(((lift-env_0)(if local?_0(box empty-env) #f)))"
"(let-values(((lift-ctx_0)"
"(let-values(((temp216_0)"
"(if local?_0"
"(make-local-lift"
" lift-env_0"
"(root-expand-context-counter ctx_1)"
"(if(expand-context-normalize-locals?"
" ctx_1)"
" 'lift"
" #f))"
"(make-top-level-lift ctx_1)))"
"((temp217_0)"
"(if(not local?_0)"
"(eq? context_0 'module)"
" #f)))"
"(make-lift-context6.1 temp217_0 temp216_0))))"
"(let-values(((capture-ctx_0)"
"(let-values(((v_0) ctx_1))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner218_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((lift-key219_0)"
" lift-key_0)"
"((lifts220_0)"
" lift-ctx_0)"
"((lift-envs221_0)"
"(if local?_0"
"(cons"
" lift-env_0"
"(expand-context-lift-envs"
" ctx_1))"
"(expand-context-lift-envs"
" ctx_1)))"
"((module-lifts222_0)"
"(if(let-values(((or-part_0)"
" local?_0))"
"(if or-part_0"
" or-part_0"
"(not"
"(memq"
" context_0"
" '(top-level"
" module)))))"
"(expand-context-module-lifts"
" ctx_1)"
" lift-ctx_0)))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
" lift-key219_0"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
" lifts220_0"
" lift-envs221_0"
" module-lifts222_0"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                           \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner218_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                         \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((rebuild-s_0)(keep-properties-only s_1)))"
"(let-values(((exp-s_0)"
"(let-values(((s223_0) s_1)"
"((capture-ctx224_0) capture-ctx_0))"
"(expand9.1 #f #f #f s223_0 capture-ctx224_0))))"
"(let-values(((lifts_0)"
"(get-and-clear-lifts!"
"(expand-context-lifts capture-ctx_0))))"
"(let-values(((with-lifts-s_0)"
"(if(let-values(((or-part_0)"
"(pair? lifts_0)))"
"(if or-part_0 or-part_0 always-wrap?_1))"
"(let-values()"
"(if(expand-context-to-parsed? ctx_1)"
"(let-values()"
"(begin"
"(if expand-lifts?_0"
"(void)"
"(let-values()"
"(error"
"                                                                                         \"internal error: to-parsed mode without expanding lifts\")))"
"(wrap-lifts-as-parsed-let"
" lifts_0"
" exp-s_0"
" rebuild-s_0"
" ctx_1"
"(lambda(rhs_0 rhs-ctx_0)"
"(loop_0 rhs_0 #f rhs-ctx_0)))))"
"(let-values()"
"(if begin-form?_0"
"(let-values(((lifts225_0) lifts_0)"
"((exp-s226_0) exp-s_0)"
"((phase227_0) phase_0))"
"(wrap-lifts-as-begin16.1"
" unsafe-undefined"
" unsafe-undefined"
" lifts225_0"
" exp-s226_0"
" phase227_0))"
"(wrap-lifts-as-let"
" lifts_0"
" exp-s_0"
" phase_0)))))"
"(let-values() exp-s_0))))"
"(if(let-values(((or-part_0)(not expand-lifts?_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(null? lifts_0)))"
"(if or-part_1"
" or-part_1"
"(expand-context-to-parsed? ctx_1)))))"
"(let-values() with-lifts-s_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'letlift-loop"
" with-lifts-s_0)))"
"(void)))"
"(loop_0 with-lifts-s_0 #f ctx_1)))))))))))))))"
" loop_0)"
" s_0"
" always-wrap?_0"
" ctx_0))))))))))))))"
"(define-values"
"(expand-transformer92.1)"
"(lambda(always-wrap?82_0 begin-form?79_0 context78_0 expand-lifts?80_0 keep-stops?83_0 lift-key81_0 s90_0 ctx91_0)"
"(begin"
" 'expand-transformer92"
"(let-values(((s_0) s90_0))"
"(let-values(((ctx_0) ctx91_0))"
"(let-values(((context_0) context78_0))"
"(let-values(((begin-form?_0) begin-form?79_0))"
"(let-values(((expand-lifts?_0) expand-lifts?80_0))"
"(let-values(((lift-key_0)(if(eq? lift-key81_0 unsafe-undefined)(generate-lift-key) lift-key81_0)))"
"(let-values(((always-wrap?_0) always-wrap?82_0))"
"(let-values(((keep-stops?_0) keep-stops?83_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'expand 'transformer))(void))"
"(begin0"
"(let-values()"
"(let-values(((trans-ctx_0)"
"(let-values(((ctx234_0) ctx_0)"
"((context235_0) context_0)"
"((keep-stops?236_0) keep-stops?_0))"
"(context->transformer-context99.1"
" keep-stops?236_0"
" ctx234_0"
" context235_0))))"
"(let-values(((s228_0) s_0)"
"((trans-ctx229_0) trans-ctx_0)"
"((expand-lifts?230_0) expand-lifts?_0)"
"((begin-form?231_0) begin-form?_0)"
"((lift-key232_0) lift-key_0)"
"((always-wrap?233_0) always-wrap?_0))"
"(expand/capture-lifts75.1"
" always-wrap?233_0"
" begin-form?231_0"
" expand-lifts?230_0"
" lift-key232_0"
" s228_0"
" trans-ctx229_0))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))))))))))"
"(define-values"
"(context->transformer-context99.1)"
"(lambda(keep-stops?95_0 ctx98_0 context97_0)"
"(begin"
" 'context->transformer-context99"
"(let-values(((ctx_0) ctx98_0))"
"(let-values(((context_0) context97_0))"
"(let-values(((keep-stops?_0) keep-stops?95_0))"
"(let-values()"
"(let-values(((phase_0)(add1(expand-context-phase ctx_0))))"
"(let-values(((ns_0)(namespace->namespace-at-phase(expand-context-namespace ctx_0) phase_0)))"
"(begin"
"(namespace-visit-available-modules! ns_0 phase_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context237_0) context_0)"
"((scopes238_0) null)"
"((env239_0) empty-env)"
"((only-immediate?240_0)"
"(if keep-stops?_0(expand-context-only-immediate? ctx_0) #f))"
"((def-ctx-scopes241_0) #f)"
"((post-expansion242_0) #f)"
"((inner243_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((phase244_0) phase_0)"
"((namespace245_0) ns_0)"
"((stops246_0)"
"(if keep-stops?_0"
"(expand-context-stops ctx_0)"
" empty-free-id-set)))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)"
"(expand-context/inner-to-parsed? the-struct_1)"
" phase244_0"
" namespace245_0"
"(expand-context/inner-just-once? the-struct_1)"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
"(expand-context/inner-in-local-expand? the-struct_1)"
"(expand-context/inner-keep-#%expression? the-struct_1)"
" stops246_0"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-should-not-encounter-macros? the-struct_1)))"
"                                            (raise-argument-error 'struct-copy \"expand-context/inner?\" the-struct_1)))))"
"(expand-context/outer1.1"
" inner243_0"
" post-expansion242_0"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
" context237_0"
" env239_0"
" scopes238_0"
" def-ctx-scopes241_0"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
" only-immediate?240_0"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"                          (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0))))))))))))))"
"(define-values"
"(expand+eval-for-syntaxes-binding108.1)"
"(lambda(log-next?102_0 who104_0 rhs105_0 ids106_0 ctx107_0)"
"(begin"
" 'expand+eval-for-syntaxes-binding108"
"(let-values(((who_0) who104_0))"
"(let-values(((rhs_0) rhs105_0))"
"(let-values(((ids_0) ids106_0))"
"(let-values(((ctx_0) ctx107_0))"
"(let-values(((log-next?_0) log-next?102_0))"
"(let-values()"
"(let-values(((exp-rhs_0)"
"(let-values(((rhs247_0) rhs_0)((temp248_0)(as-named-context ctx_0 ids_0)))"
"(expand-transformer92.1"
" #f"
" #f"
" 'expression"
" #t"
" #f"
" unsafe-undefined"
" rhs247_0"
" temp248_0))))"
"(let-values(((phase_0)(add1(expand-context-phase ctx_0))))"
"(let-values(((parsed-rhs_0)"
"(if(expand-context-to-parsed? ctx_0)"
" exp-rhs_0"
"(let-values(((exp-rhs249_0) exp-rhs_0)"
"((temp250_0)"
"(let-values(((temp251_0)(as-to-parsed-context ctx_0)))"
"(context->transformer-context99.1 #f temp251_0 'expression))))"
"(expand9.1 #f #f #f exp-rhs249_0 temp250_0)))))"
"(begin"
"(if log-next?_0"
"(let-values()"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'next)))(void))))"
"(void))"
"(values"
" exp-rhs_0"
" parsed-rhs_0"
"(eval-for-bindings"
" who_0"
" ids_0"
" parsed-rhs_0"
" phase_0"
"(namespace->namespace-at-phase(expand-context-namespace ctx_0) phase_0)"
" ctx_0)))))))))))))))"
"(define-values"
"(eval-for-syntaxes-binding)"
"(lambda(who_0 rhs_0 ids_0 ctx_0)"
"(begin"
"(let-values(((exp-rhs_0 parsed-rhs_0 vals_0)"
"(let-values(((who252_0) who_0)((rhs253_0) rhs_0)((ids254_0) ids_0)((ctx255_0) ctx_0))"
"(expand+eval-for-syntaxes-binding108.1 #t who252_0 rhs253_0 ids254_0 ctx255_0))))"
" vals_0))))"
"(define-values"
"(eval-for-bindings)"
"(lambda(who_0 ids_0 p_0 phase_0 ns_0 ctx_0)"
"(begin"
"(let-values(((compiled_0)"
"(if(can-direct-eval? p_0 ns_0(root-expand-context-self-mpi ctx_0))"
" #f"
"(compile-single"
" p_0"
"(let-values(((ns256_0) ns_0)((phase257_0) phase_0))"
"(make-compile-context14.1 #f unsafe-undefined #f ns256_0 phase257_0 unsafe-undefined))))))"
"(let-values(((vals_0)"
"(call-with-values"
"(lambda()"
"(call-with-continuation-barrier"
"(lambda()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
" ns_0"
" eval-jit-enabled"
" #f)"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
" ctx_0"
"(let-values()"
"(if compiled_0"
"(eval-single-top compiled_0 ns_0)"
"(direct-eval p_0 ns_0(root-expand-context-self-mpi ctx_0))))))))))"
" list)))"
"(begin"
"(if(=(length vals_0)(length ids_0))"
"(void)"
"(let-values()"
"(apply"
" raise-result-arity-error"
" who_0"
"(length ids_0)"
"(if(null? ids_0)"
"                   (let-values () \"\")"
"(let-values()"
"                     (format \"\\n  in: definition of ~a~a\" (syntax-e$1 (car ids_0)) (if (pair? (cdr ids_0)) \" ...\" \"\"))))"
" vals_0)))"
" vals_0))))))"
"(define-values(keep-properties-only)(lambda(s_0)(begin(datum->syntax$1 #f 'props s_0 s_0))))"
"(define-values(keep-properties-only~)(lambda(s_0)(begin #f)))"
"(define-values"
"(keep-as-needed119.1)"
"(lambda(for-track?111_0 keep-for-error?113_0 keep-for-parsed?112_0 ctx117_0 s118_0)"
"(begin"
" 'keep-as-needed119"
"(let-values(((ctx_0) ctx117_0))"
"(let-values(((s_0) s118_0))"
"(let-values(((for-track?_0) for-track?111_0))"
"(let-values(((keep-for-parsed?_0) keep-for-parsed?112_0))"
"(let-values(((keep-for-error?_0) keep-for-error?113_0))"
"(let-values()"
"(let-values(((d_0)(syntax-e/no-taint s_0)))"
"(let-values(((keep-e_0)"
"(if(symbol? d_0)"
"(let-values() d_0)"
"(if(if(pair? d_0)(syntax-identifier?(car d_0)) #f)"
"(let-values()(syntax-e$1(car d_0)))"
"(let-values() #f)))))"
"(if(expand-context-to-parsed? ctx_0)"
"(let-values()"
"(if(let-values(((or-part_0) keep-for-parsed?_0))(if or-part_0 or-part_0 keep-for-error?_0))"
"(datum->syntax$1 #f keep-e_0 s_0 s_0)"
" #f))"
"(if(if for-track?_0(if(pair? d_0) keep-e_0 #f) #f)"
"(let-values()(datum->syntax$1 #f(list(car d_0)) s_0 s_0))"
"(let-values()"
"(syntax-rearm$1(datum->syntax$1(syntax-disarm$1 s_0) keep-e_0 s_0 s_0) s_0)))))))))))))))"
"(define-values"
"(attach-disappeared-transformer-bindings)"
"(lambda(s_0 trans-idss_0)"
"(begin"
"(if(null? trans-idss_0)"
"(let-values() s_0)"
"(let-values()"
"(syntax-property$1"
" s_0"
" 'disappeared-binding"
"(append"
"(apply append trans-idss_0)"
"(let-values(((or-part_0)(syntax-property$1 s_0 'disappeared-binding)))"
"(if or-part_0 or-part_0 null)))))))))"
"(define-values"
"(increment-binding-layer)"
"(lambda(ids_0 ctx_0 layer-val_0)"
"(begin"
"(if((letrec-values(((loop_0)"
"(lambda(ids_1)"
"(begin"
" 'loop"
"(let-values(((or-part_0)(identifier? ids_1)))"
"(if or-part_0"
" or-part_0"
"(if(pair? ids_1)"
"(let-values(((or-part_1)(loop_0(car ids_1))))"
"(if or-part_1 or-part_1(loop_0(cdr ids_1))))"
" #f)))))))"
" loop_0)"
" ids_0)"
" layer-val_0"
"(expand-context-binding-layer ctx_0)))))"
"(define-values"
"(wrap-lifts-as-parsed-let)"
"(lambda(lifts_0 exp-s_0 rebuild-s_0 ctx_0 parse-rhs_0)"
"(begin"
"(let-values(((idss+keyss+rhss_0)(get-lifts-as-lists lifts_0)))"
"((letrec-values(((lets-loop_0)"
"(lambda(idss+keyss+rhss_1 rhs-ctx_0)"
"(begin"
" 'lets-loop"
"(if(null? idss+keyss+rhss_1)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((ids_0)(caar idss+keyss+rhss_1)))"
"(let-values(((keys_0)(cadar idss+keyss+rhss_1)))"
"(let-values(((rhs_0)(caddar idss+keyss+rhss_1)))"
"(let-values(((exp-rhs_0)(parse-rhs_0 rhs_0 rhs-ctx_0)))"
"(parsed-let-values17.1"
" rebuild-s_0"
"(list ids_0)"
"(list(list keys_0 exp-rhs_0))"
"(list"
"(lets-loop_0"
"(cdr idss+keyss+rhss_1)"
"(let-values(((v_0) rhs-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((env258_0)"
"(let-values(((lst_0) ids_0)((lst_1) keys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)"
"(pair? lst_3)"
" #f)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((key_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((env_1)"
"(let-values(((env_1)"
" env_0))"
"(let-values(((env_2)"
"(let-values()"
"(env-extend"
" env_1"
" key_0"
"(local-variable1.1"
" id_0)))))"
"(values"
" env_2)))))"
"(if(not #f)"
"(for-loop_0"
" env_1"
" rest_0"
" rest_1)"
" env_1)))"
" env_0)))))"
" for-loop_0)"
"(expand-context-env rhs-ctx_0)"
" lst_0"
" lst_1))))"
"((inner259_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner259_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
" env258_0"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                    \"expand-context/outer?\""
" the-struct_0)))))))))))))))))"
" lets-loop_0)"
" idss+keyss+rhss_0"
" ctx_0)))))"
"(define-values"
"(rename-transformer-target-in-context)"
"(lambda(t_0 ctx_0)"
"(begin(with-continuation-mark current-expand-context ctx_0(let-values()(1/rename-transformer-target t_0))))))"
"(define-values"
"(maybe-install-free=id-in-context!)"
"(lambda(val_0 id_0 phase_0 ctx_0)"
"(begin"
"(if(1/rename-transformer? val_0)"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
" ctx_0"
"(let-values()(maybe-install-free=id! val_0 id_0 phase_0))))"
"(void)))))"
"(define-values"
"(transfer-srcloc)"
"(lambda(new-s_0 old-s_0)"
"(begin"
"(let-values(((srcloc_0)(syntax-srcloc old-s_0)))"
"(if srcloc_0"
"(let-values(((the-struct_0) new-s_0))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((srcloc260_0) srcloc_0))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
" srcloc260_0"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0)))"
" new-s_0)))))"
"(define-values"
"(stop-ids->all-stop-ids)"
"(lambda(stop-ids_0 phase_0)"
"(begin"
"(if(null? stop-ids_0)"
"(let-values() stop-ids_0)"
"(let-values()"
"(let-values(((p-core-stx_0)(syntax-shift-phase-level$1 core-stx phase_0)))"
"(if(if(= 1(length stop-ids_0))"
"(free-identifier=?$1(car stop-ids_0)(datum->syntax$1 p-core-stx_0 'module*) phase_0 phase_0)"
" #f)"
"(let-values() stop-ids_0)"
"(let-values()"
"(append"
" stop-ids_0"
"(reverse$1"
"(let-values(((lst_0) auto-stop-syms))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((sym_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(datum->syntax$1 p-core-stx_0 sym_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))))))))"
"(define-values"
"(auto-stop-syms)"
" '(begin"
" quote"
" set!"
" lambda"
" case-lambda"
" let-values"
" letrec-values"
" if"
" begin0"
" with-continuation-mark"
" letrec-syntaxes+values"
" #%app"
" #%expression"
" #%top"
" #%variable-reference))"
"(define-values"
"(module-expand-stop-ids)"
"(lambda(phase_0)"
"(begin"
"(let-values(((p-core-stx_0)(syntax-shift-phase-level$1 core-stx phase_0)))"
"(reverse$1"
"(let-values(((lst_0) module-stop-syms))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((sym_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(datum->syntax$1 p-core-stx_0 sym_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))"
"(define-values"
"(module-stop-syms)"
"(append"
" auto-stop-syms"
" '(define-values define-syntaxes begin-for-syntax #%require #%provide module module* #%declare #%stratified-body)))"
"(define-values"
"(struct:internal-definition-context"
" internal-definition-context1.1"
" 1/internal-definition-context?"
" internal-definition-context-frame-id"
" internal-definition-context-scope"
" internal-definition-context-add-scope?"
" internal-definition-context-env-mixins"
" internal-definition-context-parent-ctx)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'internal-definition-context"
" #f"
" 5"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1 2 3 4)"
" #f"
" 'internal-definition-context)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'frame-id)"
"(make-struct-field-accessor -ref_0 1 'scope)"
"(make-struct-field-accessor -ref_0 2 'add-scope?)"
"(make-struct-field-accessor -ref_0 3 'env-mixins)"
"(make-struct-field-accessor -ref_0 4 'parent-ctx))))"
"(define-values"
"(struct:env-mixin env-mixin2.1 env-mixin? env-mixin-id env-mixin-sym env-mixin-value env-mixin-cache)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'env-mixin #f 4 0 #f null(current-inspector) #f '(0 1 2 3) #f 'env-mixin)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'id)"
"(make-struct-field-accessor -ref_0 1 'sym)"
"(make-struct-field-accessor -ref_0 2 'value)"
"(make-struct-field-accessor -ref_0 3 'cache))))"
"(define-values"
"(1/syntax-local-make-definition-context)"
"(let-values(((syntax-local-make-definition-context5_0)"
"(lambda(parent-ctx3_0 add-scope?4_0)"
"(begin"
" 'syntax-local-make-definition-context5"
"(let-values(((parent-ctx_0) parent-ctx3_0))"
"(let-values(((add-scope?_0) add-scope?4_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not parent-ctx_0)))"
"(if or-part_0 or-part_0(1/internal-definition-context? parent-ctx_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-make-definition-context"
"                                               \"(or/c #f internal-definition-context?)\""
" parent-ctx_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp47_0) 'syntax-local-make-definition-context))"
"(get-current-expand-context18.1 #f temp47_0))))"
"(let-values(((frame-id_0)"
"(let-values(((or-part_0)(root-expand-context-frame-id ctx_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if parent-ctx_0"
"(internal-definition-context-frame-id parent-ctx_0)"
" #f)))"
"(if or-part_1 or-part_1(gensym)))))))"
"(let-values(((sc_0)(new-scope 'intdef)))"
"(let-values(((def-ctx-scopes_0)(expand-context-def-ctx-scopes ctx_0)))"
"(begin"
"(if def-ctx-scopes_0"
"(let-values()(set-box! def-ctx-scopes_0(cons sc_0(unbox def-ctx-scopes_0))))"
"(void))"
"(internal-definition-context1.1"
" frame-id_0"
" sc_0"
" add-scope?_0"
"(box null)"
" parent-ctx_0))))))))))))))"
"(case-lambda"
"(()(begin 'syntax-local-make-definition-context(syntax-local-make-definition-context5_0 #f #t)))"
"((parent-ctx_0 add-scope?4_0)(syntax-local-make-definition-context5_0 parent-ctx_0 add-scope?4_0))"
"((parent-ctx3_0)(syntax-local-make-definition-context5_0 parent-ctx3_0 #t)))))"
"(define-values"
"(1/syntax-local-bind-syntaxes)"
"(let-values(((syntax-local-bind-syntaxes11_0)"
"(lambda(ids8_0 s9_0 intdef10_0 extra-intdefs7_0)"
"(begin"
" 'syntax-local-bind-syntaxes11"
"(let-values(((ids_0) ids8_0))"
"(let-values(((s_0) s9_0))"
"(let-values(((intdef_0) intdef10_0))"
"(let-values(((extra-intdefs_0) extra-intdefs7_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(if(list? ids_0)(andmap2 identifier? ids_0) #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-bind-syntaxes"
"                                                   \"(listof identifier?)\""
" ids_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not s_0)))"
"(if or-part_0 or-part_0(syntax?$1 s_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-bind-syntaxes"
"                                                     \"(or/c syntax? #f)\""
" s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/internal-definition-context? intdef_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-bind-syntaxes"
"                                                       \"internal-definition-context?\""
" intdef_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(intdefs? extra-intdefs_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-bind-syntaxes"
" intdefs?-string"
" extra-intdefs_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp48_0) 'local-expand))"
"(get-current-expand-context18.1 #f temp48_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'local-bind ids_0)))"
"(void)))"
"(values))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((all-intdefs_0)"
"(if(list? extra-intdefs_0)"
"(cons intdef_0 extra-intdefs_0)"
"(list intdef_0 extra-intdefs_0))))"
"(let-values(((intdef-ids_0)"
"(reverse$1"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((pre-id_0)"
"(remove-use-site-scopes"
"(flip-introduction-scopes"
" id_0"
" ctx_0)"
" ctx_0)))"
"(let-values(((temp49_0)"
"(let-values(((pre-id51_0)"
" pre-id_0)"
"((intdef52_0)"
" intdef_0)"
"((temp53_0)"
" #t))"
"(add-intdef-scopes24.1"
" unsafe-undefined"
" temp53_0"
" pre-id51_0"
" intdef52_0)))"
"((extra-intdefs50_0)"
" extra-intdefs_0))"
"(add-intdef-scopes24.1"
" unsafe-undefined"
" #f"
" temp49_0"
" extra-intdefs50_0))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-list"
" intdef-ids_0)))"
"(void)))"
"(values))))"
"(let-values(((counter_0)(root-expand-context-counter ctx_0)))"
"(let-values(((local-sym_0)"
"(if(expand-context-normalize-locals? ctx_0)"
" 'loc"
" #f)))"
"(let-values(((syms_0)"
"(reverse$1"
"(let-values(((lst_0) intdef-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((intdef-id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((intdef-id54_0)"
" intdef-id_0)"
"((phase55_0)"
" phase_0)"
"((counter56_0)"
" counter_0)"
"((temp57_0)"
"(internal-definition-context-frame-id"
" intdef_0))"
"((local-sym58_0)"
" local-sym_0))"
"(add-local-binding!39.1"
" temp57_0"
" #f"
" local-sym58_0"
" intdef-id54_0"
" phase55_0"
" counter56_0)))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values(((vals_0)"
"(if s_0"
"(let-values()"
"(let-values(((input-s_0)"
"(flip-introduction-scopes"
"(let-values(((s59_0) s_0)"
"((all-intdefs60_0)"
" all-intdefs_0))"
"(add-intdef-scopes24.1"
" unsafe-undefined"
" #f"
" s59_0"
" all-intdefs60_0))"
" ctx_0)))"
"(let-values(((tmp-env_0)"
"(let-values(((lst_0) syms_0)"
"((lst_1)"
" intdef-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_0"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_2)"
"(pair?"
" lst_3)"
" #f)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((intdef-id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((env_1)"
"(let-values(((env_1)"
" env_0))"
"(let-values(((env_2)"
"(let-values()"
"(env-extend"
" env_1"
" sym_0"
"(local-variable1.1"
" intdef-id_0)))))"
"(values"
" env_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" env_1"
" rest_0"
" rest_1)"
" env_1)))"
" env_0)))))"
" for-loop_0)"
"(expand-context-env"
" ctx_0)"
" lst_0"
" lst_1)))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-bind)))"
"(void)))"
"(values))))"
"(let-values(((vals_0)"
"(eval-for-syntaxes-binding"
" 'syntax-local-bind-syntaxes"
" input-s_0"
" ids_0"
"(let-values(((temp61_0)"
"(let-values(((v_0)"
" ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((env64_0)"
" tmp-env_0)"
"((inner65_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner65_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
" env64_0"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                    \"expand-context/outer?\""
" the-struct_0)))))"
"((temp62_0)"
" 'expression)"
"((all-intdefs63_0)"
" all-intdefs_0))"
"(make-local-expand-context42.1"
" temp62_0"
" all-intdefs63_0"
" #t"
" unsafe-undefined"
" #f"
" #f"
" #f"
" temp61_0)))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-bind)))"
"(void)))"
" vals_0))))))"
"(let-values()"
"(reverse$1"
"(let-values(((lst_0) intdef-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((intdef-id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(local-variable1.1"
" intdef-id_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))"
"(let-values(((env-mixins_0)"
"(internal-definition-context-env-mixins"
" intdef_0)))"
"(begin"
"(set-box!"
" env-mixins_0"
"(append"
"(reverse$1"
"(let-values(((lst_0) intdef-ids_0)"
"((lst_1) syms_0)"
"((lst_2) vals_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_3"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_3)"
"(if(pair? lst_4)"
"(pair? lst_5)"
" #f)"
" #f)"
"(let-values(((intdef-id_0)"
"(unsafe-car"
" lst_3))"
"((rest_0)"
"(unsafe-cdr"
" lst_3))"
"((sym_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((val_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(begin"
"(maybe-install-free=id-in-context!"
" val_0"
" intdef-id_0"
" phase_0"
" ctx_0)"
"(env-mixin2.1"
" intdef-id_0"
" sym_0"
" val_0"
"(make-weak-hasheq))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0"
" rest_1"
" rest_2)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1"
" lst_2))))"
"(unbox env-mixins_0)))"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'exit-local-bind)))"
"(void))))))))))))))))))))))))))))"
"(case-lambda"
"((ids_0 s_0 intdef_0)(begin 'syntax-local-bind-syntaxes(syntax-local-bind-syntaxes11_0 ids_0 s_0 intdef_0 '())))"
"((ids_0 s_0 intdef_0 extra-intdefs7_0)(syntax-local-bind-syntaxes11_0 ids_0 s_0 intdef_0 extra-intdefs7_0)))))"
"(define-values"
"(1/internal-definition-context-binding-identifiers)"
"(lambda(intdef_0)"
"(begin"
" 'internal-definition-context-binding-identifiers"
"(begin"
"(if(1/internal-definition-context? intdef_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'internal-definition-context-binding-identifiers"
"             \"internal-definition-context?\""
" intdef_0)))"
"(reverse$1"
"(let-values(((lst_0)(unbox(internal-definition-context-env-mixins intdef_0))))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((env-mixin_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()(env-mixin-id env-mixin_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))"
"(define-values"
"(1/internal-definition-context-introduce)"
"(let-values(((internal-definition-context-introduce16_0)"
"(lambda(intdef14_0 s15_0 mode13_0)"
"(begin"
" 'internal-definition-context-introduce16"
"(let-values(((intdef_0) intdef14_0))"
"(let-values(((s_0) s15_0))"
"(let-values(((mode_0) mode13_0))"
"(let-values()"
"(begin"
"(if(1/internal-definition-context? intdef_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'internal-definition-context-introduce"
"                                   \"internal-definition-context?\""
" intdef_0)))"
"(if(syntax?$1 s_0)"
"(void)"
"(let-values()"
"                                  (raise-argument-error 'internal-definition-context-introduce \"syntax?\" s_0)))"
"(let-values(((s66_0) s_0)"
"((intdef67_0) intdef_0)"
"((temp68_0) #t)"
"((temp69_0)"
"(let-values(((tmp_0) mode_0))"
"(if(equal? tmp_0 'add)"
"(let-values() add-scope)"
"(if(equal? tmp_0 'remove)"
"(let-values() remove-scope)"
"(if(equal? tmp_0 'flip)"
"(let-values() flip-scope)"
"(let-values()"
"(raise-argument-error"
" 'internal-definition-context-introduce"
"                                                       \"(or/c 'add 'remove 'flip)\""
" mode_0))))))))"
"(add-intdef-scopes24.1 temp69_0 temp68_0 s66_0 intdef67_0)))))))))))"
"(case-lambda"
"((intdef_0 s_0)"
"(begin 'internal-definition-context-introduce(internal-definition-context-introduce16_0 intdef_0 s_0 'flip)))"
"((intdef_0 s_0 mode13_0)(internal-definition-context-introduce16_0 intdef_0 s_0 mode13_0)))))"
"(define-values"
"(1/internal-definition-context-seal)"
"(lambda(intdef_0)"
"(begin"
" 'internal-definition-context-seal"
"(begin"
"(if(1/internal-definition-context? intdef_0)"
"(void)"
"(let-values()"
"            (raise-argument-error 'internal-definition-context-seal \"internal-definition-context?\" intdef_0)))"
"(void)))))"
"(define-values"
"(1/identifier-remove-from-definition-context)"
"(lambda(id_0 intdef_0)"
"(begin"
" 'identifier-remove-from-definition-context"
"(begin"
"(if(identifier? id_0)"
"(void)"
"          (let-values () (raise-argument-error 'identifier-remove-from-definition-context \"identifier?\" id_0)))"
"(if(let-values(((or-part_0)(1/internal-definition-context? intdef_0)))"
"(if or-part_0 or-part_0(if(list? intdef_0)(andmap2 1/internal-definition-context? intdef_0) #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'identifier-remove-from-definition-context"
"             \"(or/c internal-definition-context? (listof internal-definition-context?))\""
" intdef_0)))"
"(let-values(((x_0)"
"(let-values(((a_0) intdef_0))"
"(if(list? a_0)"
"(let-values()(reverse$1 a_0))"
"(if(not a_0)(let-values() null)(let-values()(list a_0)))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(id_1 a_0)"
"(begin"
" 'for-loop"
"(if(pair? a_0)"
"(let-values(((intdef_1)(car a_0)))"
"(let-values(((id_2)"
"(let-values(((id_2) id_1))"
"(let-values(((id_3)"
"(let-values()"
"(1/internal-definition-context-introduce"
" intdef_1"
" id_2"
" 'remove))))"
"(values id_3)))))"
"(if(not #f)(for-loop_0 id_2(cdr a_0)) id_2)))"
" id_1)))))"
" for-loop_0)"
" id_0"
" x_0)))))))"
"(define-values"
"(intdefs?)"
"(lambda(x_0)"
"(begin"
"(let-values(((or-part_0)(1/internal-definition-context? x_0)))"
"(if or-part_0 or-part_0(if(list? x_0)(andmap2 1/internal-definition-context? x_0) #f))))))"
" (define-values (intdefs?-string) \"(or/c internal-definition-context? (listof internal-definition-context?))\")"
"(define-values"
"(intdefs-or-false?)"
"(lambda(x_0)(begin(let-values(((or-part_0)(not x_0)))(if or-part_0 or-part_0(intdefs? x_0))))))"
"(define-values"
"(intdefs-or-false?-string)"
"  \"(or/c internal-definition-context? (listof internal-definition-context?) #f)\")"
"(define-values"
"(add-intdef-bindings)"
"(lambda(env_0 intdefs_0)"
"(begin"
"(let-values(((x_0)"
"(let-values(((a_0) intdefs_0))"
"(if(list? a_0)"
"(let-values()(reverse$1 a_0))"
"(if(not a_0)(let-values() null)(let-values()(list a_0)))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(env_1 a_0)"
"(begin"
" 'for-loop"
"(if(pair? a_0)"
"(let-values(((intdef_0)(car a_0)))"
"(let-values(((env_2)"
"(let-values(((env_2) env_1))"
"(let-values(((env_3)"
"(let-values()"
"(let-values(((parent-ctx_0)"
"(internal-definition-context-parent-ctx"
" intdef_0)))"
"(let-values(((parent-env_0)"
"(if parent-ctx_0"
"(add-intdef-bindings"
" env_2"
" parent-ctx_0)"
" env_2)))"
"(let-values(((env-mixins_0)"
"(unbox"
"(internal-definition-context-env-mixins"
" intdef_0))))"
"((letrec-values(((loop_0)"
"(lambda(env_3 env-mixins_1)"
"(begin"
" 'loop"
"(if(null? env-mixins_1)"
"(let-values() env_3)"
"(let-values()"
"(let-values(((env-mixin_0)"
"(car"
" env-mixins_1)))"
"(let-values(((or-part_0)"
"(hash-ref"
"(env-mixin-cache"
" env-mixin_0)"
" env_3"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((new-env_0)"
"(env-extend"
"(loop_0"
" env_3"
"(cdr"
" env-mixins_1))"
"(env-mixin-sym"
" env-mixin_0)"
"(env-mixin-value"
" env-mixin_0))))"
"(begin"
"(hash-set!"
"(env-mixin-cache"
" env-mixin_0)"
" env_3"
" new-env_0)"
" new-env_0)))))))))))"
" loop_0)"
" parent-env_0"
" env-mixins_0)))))))"
"(values env_3)))))"
"(if(not #f)(for-loop_0 env_2(cdr a_0)) env_2)))"
" env_1)))))"
" for-loop_0)"
" env_0"
" x_0))))))"
"(define-values"
"(add-intdef-scopes24.1)"
"(lambda(action19_0 always?18_0 s22_0 intdefs23_0)"
"(begin"
" 'add-intdef-scopes24"
"(let-values(((s_0) s22_0))"
"(let-values(((intdefs_0) intdefs23_0))"
"(let-values(((always?_0) always?18_0))"
"(let-values(((action_0)(if(eq? action19_0 unsafe-undefined) add-scope action19_0)))"
"(let-values()"
"(let-values(((x_0)"
"(let-values(((a_0) intdefs_0))"
"(if(list? a_0)"
"(let-values()(reverse$1 a_0))"
"(if(not a_0)(let-values() null)(let-values()(list a_0)))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(s_1 a_0)"
"(begin"
" 'for-loop"
"(if(pair? a_0)"
"(let-values(((intdef_0)(car a_0)))"
"(let-values(((s_2)"
"(let-values(((s_2) s_1))"
"(if(let-values(((or-part_0) always?_0))"
"(if or-part_0"
" or-part_0"
"(internal-definition-context-add-scope?"
" intdef_0)))"
"(let-values(((s_3) s_2))"
"(let-values(((s_4)"
"(let-values()"
"(action_0"
" s_3"
"(internal-definition-context-scope"
" intdef_0)))))"
"(values s_4)))"
" s_2))))"
"(if(not #f)(for-loop_0 s_2(cdr a_0)) s_2)))"
" s_1)))))"
" for-loop_0)"
" s_0"
" x_0)))))))))))"
"(define-values"
"(make-local-expand-context42.1)"
"(lambda(context27_0"
" intdefs29_0"
" keep-#%expression?33_0"
" phase28_0"
" stop-ids30_0"
" to-parsed-ok?31_0"
" track-to-be-defined?32_0"
" ctx41_0)"
"(begin"
" 'make-local-expand-context42"
"(let-values(((ctx_0) ctx41_0))"
"(let-values(((context_0) context27_0))"
"(let-values(((phase_0)(if(eq? phase28_0 unsafe-undefined)(expand-context-phase ctx_0) phase28_0)))"
"(let-values(((intdefs_0) intdefs29_0))"
"(let-values(((stop-ids_0) stop-ids30_0))"
"(let-values(((to-parsed-ok?_0) to-parsed-ok?31_0))"
"(let-values(((track-to-be-defined?_0) track-to-be-defined?32_0))"
"(let-values(((keep-#%expression?_0) keep-#%expression?33_0))"
"(let-values()"
"(let-values(((same-kind?_0)"
"(let-values(((or-part_0)(eq? context_0(expand-context-context ctx_0))))"
"(if or-part_0"
" or-part_0"
"(if(list? context_0)(list?(expand-context-context ctx_0)) #f)))))"
"(let-values(((all-stop-ids_0)"
"(if stop-ids_0(stop-ids->all-stop-ids stop-ids_0 phase_0) #f)))"
"(let-values(((def-ctx-scopes_0)"
"(if(expand-context-def-ctx-scopes ctx_0)"
"(unbox(expand-context-def-ctx-scopes ctx_0))"
" null)))"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context70_0) context_0)"
"((env71_0)(add-intdef-bindings(expand-context-env ctx_0) intdefs_0))"
"((use-site-scopes72_0)"
"(if(let-values(((or-part_0)(eq? context_0 'module)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eq? context_0 'module-begin)))"
"(if or-part_1 or-part_1(list? context_0)))))"
"(let-values(((or-part_0)"
"(root-expand-context-use-site-scopes ctx_0)))"
"(if or-part_0 or-part_0(box null)))"
" #f))"
"((frame-id73_0)"
"(let-values(((x_0)"
"(let-values(((a_0) intdefs_0))"
"(if(list? a_0)"
"(let-values()(reverse$1 a_0))"
"(if(not a_0)"
"(let-values() null)"
"(let-values()(list a_0)))))))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(frame-id_0 a_0)"
"(begin"
" 'for-loop"
"(if(pair? a_0)"
"(let-values(((intdef_0)(car a_0)))"
"(let-values(((frame-id_1)"
"(let-values(((frame-id_1)"
" frame-id_0))"
"(let-values(((frame-id_2)"
"(let-values()"
"(let-values(((i-frame-id_0)"
"(internal-definition-context-frame-id"
" intdef_0)))"
"(if(if frame-id_1"
"(if i-frame-id_0"
"(not"
"(eq?"
" frame-id_1"
" i-frame-id_0))"
" #f)"
" #f)"
"(let-values()"
" 'all)"
"(let-values()"
"(let-values(((or-part_0)"
" frame-id_1))"
"(if or-part_0"
" or-part_0"
" i-frame-id_0))))))))"
"(values"
" frame-id_2)))))"
"(if(not #f)"
"(for-loop_0 frame-id_1(cdr a_0))"
" frame-id_1)))"
" frame-id_0)))))"
" for-loop_0)"
"(root-expand-context-frame-id ctx_0)"
" x_0))))"
"((post-expansion74_0)"
"(let-values(((pe_0)"
"(if same-kind?_0"
"(if(let-values(((or-part_0)(pair? context_0)))"
"(if or-part_0"
" or-part_0"
"(memq"
" context_0"
" '(module module-begin top-level))))"
"(root-expand-context-post-expansion ctx_0)"
" #f)"
" #f)))"
"(if(if intdefs_0(not(null? intdefs_0)) #f)"
"(let-values()"
"(lambda(s_0)"
"(begin"
" 'post-expansion74"
"(let-values(((temp80_0)(apply-post-expansion pe_0 s_0))"
"((intdefs81_0) intdefs_0))"
"(add-intdef-scopes24.1"
" unsafe-undefined"
" #f"
" temp80_0"
" intdefs81_0)))))"
"(let-values() pe_0))))"
"((scopes75_0)(append def-ctx-scopes_0(expand-context-scopes ctx_0)))"
"((only-immediate?76_0)(not stop-ids_0))"
"((current-introduction-scopes77_0) null)"
"((need-eventually-defined78_0)"
"(let-values(((ht_0)(expand-context-need-eventually-defined ctx_0)))"
"(if track-to-be-defined?_0"
"(let-values() ht_0)"
"(if ht_0(let-values()(make-hasheqv))(let-values() #f)))))"
"((inner79_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((to-parsed?82_0)"
"(if to-parsed-ok?_0"
"(expand-context-to-parsed? ctx_0)"
" #f))"
"((just-once?83_0) #f)"
"((in-local-expand?84_0) #t)"
"((keep-#%expression?85_0) keep-#%expression?_0)"
"((stops86_0)"
"(free-id-set"
" phase_0"
"(let-values(((or-part_0) all-stop-ids_0))"
"(if or-part_0 or-part_0 null)))))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)"
" to-parsed?82_0"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
" just-once?83_0"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
" in-local-expand?84_0"
" keep-#%expression?85_0"
" stops86_0"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                       \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner79_0"
" post-expansion74_0"
" use-site-scopes72_0"
" frame-id73_0"
" context70_0"
" env71_0"
" scopes75_0"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
" only-immediate?76_0"
" need-eventually-defined78_0"
" current-introduction-scopes77_0"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                     \"expand-context/outer?\""
" the-struct_0)))))))))))))))))))"
"(define-values"
"(flip-introduction-scopes)"
"(lambda(s_0 ctx_0)(begin(flip-scopes s_0(expand-context-current-introduction-scopes ctx_0)))))"
"(define-values"
"(flip-introduction-and-use-scopes)"
"(lambda(s_0 ctx_0)"
"(begin(flip-scopes(flip-introduction-scopes s_0 ctx_0)(expand-context-current-use-scopes ctx_0)))))"
"(define-values"
"(1/syntax-transforming?)"
"(lambda()"
"(begin"
" 'syntax-transforming?"
"(if(let-values(((temp55_0) #t))(get-current-expand-context18.1 temp55_0 'unexpected)) #t #f))))"
"(define-values"
"(1/syntax-transforming-with-lifts?)"
"(lambda()"
"(begin"
" 'syntax-transforming-with-lifts?"
"(let-values(((ctx_0)(let-values(((temp56_0) #t))(get-current-expand-context18.1 temp56_0 'unexpected))))"
"(if ctx_0(if(expand-context-lifts ctx_0) #t #f) #f)))))"
"(define-values"
"(1/syntax-transforming-module-expression?)"
"(lambda()"
"(begin"
" 'syntax-transforming-module-expression?"
"(let-values(((ctx_0)(let-values(((temp57_0) #t))(get-current-expand-context18.1 temp57_0 'unexpected))))"
"(if ctx_0(if(expand-context-to-module-lifts ctx_0) #t #f) #f)))))"
"(define-values"
"(1/syntax-local-transforming-module-provides?)"
"(lambda()"
"(begin"
" 'syntax-local-transforming-module-provides?"
"(let-values(((ctx_0)(let-values(((temp58_0) #t))(get-current-expand-context18.1 temp58_0 'unexpected))))"
"(if ctx_0(if(expand-context-requires+provides ctx_0) #t #f) #f)))))"
"(define-values"
"(1/syntax-local-context)"
"(lambda()"
"(begin"
" 'syntax-local-context"
"(let-values(((ctx_0)"
"(let-values(((temp59_0) 'syntax-local-context))(get-current-expand-context18.1 #f temp59_0))))"
"(expand-context-context ctx_0)))))"
"(define-values"
"(1/syntax-local-introduce)"
"(lambda(s_0)"
"(begin"
" 'syntax-local-introduce"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                            (let-values () (raise-argument-error 'syntax-local-introduce \"syntax?\" s_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp61_0) 'syntax-local-introduce))"
"(get-current-expand-context18.1 #f temp61_0))))"
"(flip-introduction-and-use-scopes s_0 ctx_0))))))))"
"(define-values"
"(1/syntax-local-identifier-as-binding)"
"(lambda(id_0)"
"(begin"
" 'syntax-local-identifier-as-binding"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'syntax-local-identifier-as-binding \"identifier?\" id_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp63_0) 'syntax-local-identifier-as-binding))"
"(get-current-expand-context18.1 #f temp63_0))))"
"(remove-use-site-scopes id_0 ctx_0))))))))"
"(define-values"
"(1/syntax-local-phase-level)"
"(lambda()"
"(begin"
" 'syntax-local-phase-level"
"(let-values(((ctx_0)(let-values(((temp64_0) #t))(get-current-expand-context18.1 temp64_0 'unexpected))))"
"(if ctx_0(expand-context-phase ctx_0) 0)))))"
"(define-values"
"(1/syntax-local-name)"
"(lambda()"
"(begin"
" 'syntax-local-name"
"(let-values()"
"(let-values()"
"(let-values(((ctx_0)"
"(let-values(((who66_0) 'syntax-local-name))(get-current-expand-context18.1 #f who66_0))))"
"(let-values(((id_0)(expand-context-name ctx_0)))"
"(if id_0(datum->syntax$1 #f(syntax-e$1 id_0) id_0) #f))))))))"
"(define-values"
"(1/make-syntax-introducer)"
"(let-values(((make-syntax-introducer2_0)"
"(lambda(as-use-site?1_0)"
"(begin"
" 'make-syntax-introducer2"
"(let-values(((as-use-site?_0) as-use-site?1_0))"
"(let-values()(do-make-syntax-introducer(new-scope(if as-use-site?_0 'use-site 'macro)))))))))"
"(case-lambda"
"(()(begin 'make-syntax-introducer(make-syntax-introducer2_0 #f)))"
"((as-use-site?1_0)(make-syntax-introducer2_0 as-use-site?1_0)))))"
"(define-values"
"(1/make-interned-syntax-introducer)"
"(lambda(sym-key_0)"
"(begin"
" 'make-interned-syntax-introducer"
"(let-values()"
"(let-values()"
"(begin"
"(if(symbol? sym-key_0)"
"(void)"
"              (let-values () (raise-argument-error 'make-interned-syntax-introducer \"symbol?\" sym-key_0)))"
"(do-make-syntax-introducer(make-interned-scope sym-key_0))))))))"
"(define-values"
"(do-make-syntax-introducer)"
"(lambda(sc_0)"
"(begin"
"(let-values(((core70_0)"
"(lambda(s69_0 mode68_0)"
"(begin"
" 'core70"
"(let-values(((s_0) s69_0))"
"(let-values(((mode_0) mode68_0))"
"(let-values()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'syntax-introducer \"syntax?\" s_0)))"
"(let-values(((tmp_0) mode_0))"
"(if(equal? tmp_0 'add)"
"(let-values()(add-scope s_0 sc_0))"
"(if(equal? tmp_0 'remove)"
"(let-values()(remove-scope s_0 sc_0))"
"(if(equal? tmp_0 'flip)"
"(let-values()(flip-scope s_0 sc_0))"
"(let-values()"
"(raise-argument-error"
" 'syntax-introducer"
"                                           \"(or/c 'add 'remove 'flip)\""
" mode_0))))))))))))))"
"(case-lambda((s_0)(core70_0 s_0 'flip))((s_0 mode68_0)(core70_0 s_0 mode68_0)))))))"
"(define-values"
"(1/make-syntax-delta-introducer)"
"(let-values(((make-syntax-delta-introducer7_0)"
"(lambda(ext-s5_0 base-s6_0 phase4_0)"
"(begin"
" 'make-syntax-delta-introducer7"
"(let-values(((ext-s_0) ext-s5_0))"
"(let-values(((base-s_0) base-s6_0))"
"(let-values(((phase_0)"
"(if(eq? phase4_0 unsafe-undefined)(1/syntax-local-phase-level) phase4_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 ext-s_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-syntax-delta-introducer"
"                                                     \"syntax?\""
" ext-s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(syntax?$1 x_0))))"
" base-s_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-syntax-delta-introducer"
"                                                       \"(or/c syntax? #f)\""
" base-s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(phase? phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-syntax-delta-introducer"
" phase?-string"
" phase_0)))"
"(values))))"
"(let-values(((ext-scs_0)(syntax-scope-set ext-s_0 phase_0)))"
"(let-values(((base-scs_0)"
"(syntax-scope-set"
"(let-values(((or-part_0) base-s_0))"
"(if or-part_0 or-part_0 empty-syntax))"
" phase_0)))"
"(let-values(((use-base-scs_0)"
"(if(subset? base-scs_0 ext-scs_0)"
" base-scs_0"
"(let-values(((or-part_0)"
"(if(identifier? base-s_0)"
"(let-values(((base-s73_0) base-s_0)"
"((phase74_0) phase_0)"
"((temp75_0) #t))"
"(resolve40.1"
" #f"
" #f"
" null"
" temp75_0"
" base-s73_0"
" phase74_0))"
" #f)))"
"(if or-part_0 or-part_0(seteq))))))"
"(let-values(((delta-scs_0)"
"(set->list(set-subtract ext-scs_0 use-base-scs_0))))"
"(let-values(((maybe-taint_0)"
"(if(syntax-clean? ext-s_0) values syntax-taint$1)))"
"(let-values(((core78_0)"
"(lambda(s77_0 mode76_0)"
"(begin"
" 'core78"
"(let-values(((s_0) s77_0))"
"(let-values(((mode_0) mode76_0))"
"(let-values()"
"(maybe-taint_0"
"(let-values(((tmp_0) mode_0))"
"(if(equal? tmp_0 'add)"
"(let-values()"
"(add-scopes s_0 delta-scs_0))"
"(if(equal? tmp_0 'remove)"
"(let-values()"
"(remove-scopes s_0 delta-scs_0))"
"(if(equal? tmp_0 'flip)"
"(let-values()"
"(flip-scopes s_0 delta-scs_0))"
"(let-values()"
"(raise-argument-error"
" 'syntax-introducer"
"                                                                                    \"(or/c 'add 'remove 'flip)\""
" mode_0))))))))))))))"
"(case-lambda"
"((s_0)(core78_0 s_0 'add))"
"((s_0 mode76_0)(core78_0 s_0 mode76_0))))))))))))))))))))))"
"(case-lambda"
"((ext-s_0 base-s_0)"
"(begin 'make-syntax-delta-introducer(make-syntax-delta-introducer7_0 ext-s_0 base-s_0 unsafe-undefined)))"
"((ext-s_0 base-s_0 phase4_0)(make-syntax-delta-introducer7_0 ext-s_0 base-s_0 phase4_0)))))"
"(define-values"
"(1/syntax-local-make-delta-introducer)"
"(lambda(id-stx_0)"
"(begin"
" 'syntax-local-make-delta-introducer"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id-stx_0)"
"(void)"
"              (let-values () (raise-argument-error 'syntax-local-make-delta-introducer \"identifier?\" id-stx_0)))"
"(raise"
"(exn:fail:unsupported"
"              \"syntax-local-make-delta-introducer: not supported anymore\""
"(current-continuation-marks)))))))))"
"(define-values"
"(do-syntax-local-value15.1)"
"(lambda(immediate?9_0 who11_0 id12_0 intdefs13_0 failure-thunk14_0)"
"(begin"
" 'do-syntax-local-value15"
"(let-values(((who_0) who11_0))"
"(let-values(((id_0) id12_0))"
"(let-values(((intdefs_0) intdefs13_0))"
"(let-values(((failure-thunk_0) failure-thunk14_0))"
"(let-values(((immediate?_0) immediate?9_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"                                    (let-values () (raise-argument-error who_0 \"identifier?\" id_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0"
" or-part_0"
"((lambda(p_0)"
"(if(procedure? p_0)(procedure-arity-includes? p_0 0) #f))"
" x_0))))"
" failure-thunk_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                         \"(or/c #f (procedure-arity-includes/c 0))\""
" failure-thunk_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(intdefs-or-false? intdefs_0)"
"(void)"
"(let-values()(raise-argument-error who_0 intdefs-or-false?-string intdefs_0)))"
"(values))))"
"(let-values(((current-ctx_0)"
"(let-values(((who81_0) who_0))(get-current-expand-context18.1 #f who81_0))))"
"(let-values(((ctx_0)"
"(if intdefs_0"
"(let-values(((v_0) current-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((env82_0)"
"(add-intdef-bindings"
"(expand-context-env current-ctx_0)"
" intdefs_0))"
"((inner83_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner83_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
" env82_0"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                 \"expand-context/outer?\""
" the-struct_0))))"
" current-ctx_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'local-value id_0)))"
"(void)))"
"(values))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"((letrec-values(((loop_0)"
"(lambda(id_1)"
"(begin"
" 'loop"
"(let-values(((b_0)"
"(if immediate?_0"
"(let-values(((id84_0) id_1)"
"((phase85_0) phase_0)"
"((temp86_0) #t))"
"(resolve+shift28.1"
" #f"
" #f"
" null"
" temp86_0"
" #f"
" id84_0"
" phase85_0))"
"(resolve+shift/extra-inspector"
" id_1"
" phase_0"
"(expand-context-namespace ctx_0)))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'resolve id_1)))"
"(void)))"
"(if(not b_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'local-value-result"
" #f)))"
"(void)))"
"(if failure-thunk_0"
"(failure-thunk_0)"
"                                                                  (error who_0 \"unbound identifier: ~v\" id_1))))"
"(let-values()"
"(let-values(((v_0 primitive?_0 insp_0 protected?_0)"
"(let-values(((b87_0) b_0)"
"((ctx88_0) ctx_0)"
"((id89_0) id_1)"
"((temp90_0) #t))"
"(lookup62.1"
" #f"
" temp90_0"
" b87_0"
" ctx88_0"
" id89_0))))"
"(if(let-values(((or-part_0)(variable? v_0)))"
"(if or-part_0 or-part_0(core-form? v_0)))"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'local-value-result"
" #f)))"
"(void)))"
"(if failure-thunk_0"
"(failure-thunk_0)"
"(error"
" who_0"
"                                                                         \"identifier is not bound to syntax: ~v\""
" id_1))))"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(not"
"(if(1/rename-transformer? v_0)"
"(not immediate?_0)"
" #f))"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'local-value-result"
" #t))"
"(void)))"
"(void)))"
"(if(1/rename-transformer? v_0)"
"(let-values()"
"(if immediate?_0"
"(values"
" v_0"
"(1/rename-transformer-target v_0))"
"(loop_0(1/rename-transformer-target v_0))))"
"(if immediate?_0"
"(let-values()(values v_0 #f))"
"(let-values() v_0)))))))))))))))"
" loop_0)"
"(flip-introduction-scopes id_0 ctx_0))))))))))))))))))"
"(define-values"
"(1/syntax-local-value)"
"(let-values(((syntax-local-value21_0)"
"(lambda(id20_0 failure-thunk18_0 intdef19_0)"
"(begin"
" 'syntax-local-value21"
"(let-values(((id_0) id20_0))"
"(let-values(((failure-thunk_0) failure-thunk18_0))"
"(let-values(((intdef_0) intdef19_0))"
"(let-values()"
"(let-values(((temp91_0) 'syntax-local-value)"
"((temp92_0) #f)"
"((id93_0) id_0)"
"((intdef94_0) intdef_0)"
"((failure-thunk95_0) failure-thunk_0))"
"(do-syntax-local-value15.1 temp92_0 temp91_0 id93_0 intdef94_0 failure-thunk95_0))))))))))"
"(case-lambda"
"((id_0)(begin 'syntax-local-value(syntax-local-value21_0 id_0 #f #f)))"
"((id_0 failure-thunk_0 intdef19_0)(syntax-local-value21_0 id_0 failure-thunk_0 intdef19_0))"
"((id_0 failure-thunk18_0)(syntax-local-value21_0 id_0 failure-thunk18_0 #f)))))"
"(define-values"
"(1/syntax-local-value/immediate)"
"(let-values(((syntax-local-value/immediate26_0)"
"(lambda(id25_0 failure-thunk23_0 intdef24_0)"
"(begin"
" 'syntax-local-value/immediate26"
"(let-values(((id_0) id25_0))"
"(let-values(((failure-thunk_0) failure-thunk23_0))"
"(let-values(((intdef_0) intdef24_0))"
"(let-values()"
"(let-values(((temp96_0) 'syntax-local-value/immediate)"
"((temp97_0) #t)"
"((id98_0) id_0)"
"((intdef99_0) intdef_0)"
"((failure-thunk100_0) failure-thunk_0))"
"(do-syntax-local-value15.1"
" temp97_0"
" temp96_0"
" id98_0"
" intdef99_0"
" failure-thunk100_0))))))))))"
"(case-lambda"
"((id_0)(begin 'syntax-local-value/immediate(syntax-local-value/immediate26_0 id_0 #f #f)))"
"((id_0 failure-thunk_0 intdef24_0)(syntax-local-value/immediate26_0 id_0 failure-thunk_0 intdef24_0))"
"((id_0 failure-thunk23_0)(syntax-local-value/immediate26_0 id_0 failure-thunk23_0 #f)))))"
"(define-values"
"(do-lift-values-expression)"
"(lambda(who_0 n_0 s_0)"
"(begin"
"(let-values((()"
"(begin"
"                      (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error who_0 \"syntax?\" s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(exact-nonnegative-integer? n_0)"
"(void)"
"                          (let-values () (raise-argument-error who_0 \"exact-nonnegative-integer?\" n_0)))"
"(values))))"
"(let-values(((ctx_0)(let-values(((who101_0) who_0))(get-current-expand-context18.1 #f who101_0))))"
"(let-values(((lifts_0)(expand-context-lifts ctx_0)))"
"(let-values((()"
"(begin"
"                              (if lifts_0 (void) (let-values () (raise-arguments-error who_0 \"no lift target\")))"
"(values))))"
"(let-values(((counter_0)(root-expand-context-counter ctx_0)))"
"(let-values(((ids_0)"
"(reverse$1"
"(let-values(((start_0) 0)((end_0) n_0)((inc_0) 1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 pos_0)"
"(begin"
" 'for-loop"
"(if(< pos_0 end_0)"
"(let-values()"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values((()"
"(begin"
"(set-box!"
" counter_0"
"(add1"
"(unbox"
" counter_0)))"
"(values))))"
"(let-values(((name_0)"
"(string->unreadable-symbol"
"(format"
"                                                                                                                    \"lifted/~a\""
"(unbox"
" counter_0)))))"
"(add-scope"
"(datum->syntax$1"
" #f"
" name_0)"
"(new-scope"
" 'macro)))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1(+ pos_0 inc_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" start_0))))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'lift-expr ids_0 s_0)))"
"(void)))"
"(map2"
"(lambda(id_0)(flip-introduction-scopes id_0 ctx_0))"
"(add-lifted!"
" lifts_0"
" ids_0"
"(flip-introduction-scopes s_0 ctx_0)"
"(expand-context-phase ctx_0))))))))))))))"
"(define-values"
"(1/syntax-local-lift-expression)"
"(lambda(s_0)"
"(begin"
" 'syntax-local-lift-expression"
"(let-values()(let-values()(car(do-lift-values-expression 'syntax-local-lift-expression 1 s_0)))))))"
"(define-values"
"(1/syntax-local-lift-values-expression)"
"(lambda(n_0 s_0)"
"(begin"
" 'syntax-local-lift-values-expression"
"(let-values()(let-values()(do-lift-values-expression 'syntax-local-lift-values-expression n_0 s_0))))))"
"(define-values"
"(1/syntax-local-lift-context)"
"(lambda()"
"(begin"
" 'syntax-local-lift-context"
"(let-values()"
"(let-values()"
"(let-values(((ctx_0)"
"(let-values(((who105_0) 'syntax-local-lift-context))"
"(get-current-expand-context18.1 #f who105_0))))"
"(root-expand-context-lift-key ctx_0)))))))"
"(define-values"
"(1/syntax-local-lift-module)"
"(lambda(s_0)"
"(begin"
" 'syntax-local-lift-module"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                            (let-values () (raise-argument-error 'syntax-local-lift-module \"syntax?\" s_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((who107_0) 'syntax-local-lift-module))"
"(get-current-expand-context18.1 #f who107_0))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(begin"
"(let-values(((tmp_0)(core-form-sym s_0 phase_0)))"
"(if(if(equal? tmp_0 'module) #t(equal? tmp_0 'module*))"
"(let-values()"
"(let-values(((lifts_0)(expand-context-module-lifts ctx_0)))"
"(begin"
"(if lifts_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'syntax-local-lift-module"
"                                 \"not currently transforming within a module declaration or top level\""
"                                 \"form to lift\""
" s_0)))"
"(add-lifted-module! lifts_0(flip-introduction-scopes s_0 ctx_0) phase_0))))"
"(let-values()"
"                        (raise-arguments-error 'syntax-local-lift-module \"not a module form\" \"given form\" s_0))))"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'lift-statement s_0)))"
"(void))))))))))))"
"(define-values"
"(do-local-lift-to-module48.1)"
"(lambda(add-lifted!32_0"
" get-lift-ctx31_0"
" get-wrt-phase33_0"
" intro?29_0"
" more-checks30_0"
" no-target-msg28_0"
" post-wrap36_0"
" pre-wrap34_0"
" shift-wrap35_0"
" who46_0"
" s47_0)"
"(begin"
" 'do-local-lift-to-module48"
"(let-values(((who_0) who46_0))"
"(let-values(((s_0) s47_0))"
"(let-values(((no-target-msg_0) no-target-msg28_0))"
"(let-values(((intro?_0) intro?29_0))"
"(let-values(((more-checks_0)(if(eq? more-checks30_0 unsafe-undefined) void more-checks30_0)))"
"(let-values(((get-lift-ctx_0) get-lift-ctx31_0))"
"(let-values(((add-lifted!_0) add-lifted!32_0))"
"(let-values(((get-wrt-phase_0) get-wrt-phase33_0))"
"(let-values(((pre-wrap_0)"
"(if(eq? pre-wrap34_0 unsafe-undefined)"
"(lambda(s_1 phase_0 lift-ctx_0)(begin 'pre-wrap s_1))"
" pre-wrap34_0)))"
"(let-values(((shift-wrap_0)"
"(if(eq? shift-wrap35_0 unsafe-undefined)"
"(lambda(s_1 phase_0 lift-ctx_0)(begin 'shift-wrap s_1))"
" shift-wrap35_0)))"
"(let-values(((post-wrap_0)"
"(if(eq? post-wrap36_0 unsafe-undefined)"
"(lambda(s_1 phase_0 lift-ctx_0)(begin 'post-wrap s_1))"
" post-wrap36_0)))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                                (let-values () (raise-argument-error who_0 \"syntax?\" s_0)))"
"(values))))"
"(let-values((()(begin(more-checks_0)(values))))"
"(let-values(((ctx_0)"
"(let-values(((who108_0) who_0))"
"(get-current-expand-context18.1 #f who108_0))))"
"(let-values(((lift-ctx_0)(get-lift-ctx_0 ctx_0)))"
"(let-values((()"
"(begin"
"(if lift-ctx_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" who_0"
" no-target-msg_0"
"                                                           \"form to lift\""
" s_0)))"
"(values))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((wrt-phase_0)(get-wrt-phase_0 lift-ctx_0)))"
"(let-values(((added-s_0)"
"(if intro?_0(flip-introduction-scopes s_0 ctx_0) s_0)))"
"(let-values(((pre-s_0)(pre-wrap_0 added-s_0 phase_0 lift-ctx_0)))"
"(let-values(((shift-s_0)"
"(let-values(((start_0) phase_0)"
"((end_0) wrt-phase_0)"
"((inc_0) -1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-range start_0 end_0 inc_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(s_1 pos_0)"
"(begin"
" 'for-loop"
"(if(> pos_0 end_0)"
"(let-values(((phase_1)"
" pos_0))"
"(let-values(((s_2)"
"(let-values(((s_2)"
" s_1))"
"(let-values(((s_3)"
"(let-values()"
"(shift-wrap_0"
" s_2"
"(sub1"
" phase_1)"
" lift-ctx_0))))"
"(values"
" s_3)))))"
"(if(not #f)"
"(for-loop_0"
" s_2"
"(+ pos_0 inc_0))"
" s_2)))"
" s_1)))))"
" for-loop_0)"
" pre-s_0"
" start_0)))))"
"(let-values(((post-s_0)"
"(post-wrap_0 shift-s_0 wrt-phase_0 lift-ctx_0)))"
"(begin"
"(add-lifted!_0 lift-ctx_0 post-s_0 wrt-phase_0)"
"(values ctx_0 post-s_0))))))))))))))))))))))))))))"
"(define-values"
"(1/syntax-local-lift-require)"
"(lambda(s_0 use-s_0)"
"(begin"
" 'syntax-local-lift-require"
"(let-values()"
"(let-values()"
"(let-values(((sc_0)(new-scope 'lifted-require)))"
"(let-values(((ctx_0 added-s_0)"
"(let-values(((who110_0) 'syntax-local-lift-require)"
"((temp111_0)(datum->syntax$1 #f s_0))"
"                                       ((temp112_0) \"could not find target context\")"
"((temp113_0) #f)"
"((temp114_0)"
"(lambda()"
"(if(syntax?$1 use-s_0)"
"(void)"
"(let-values()"
"                                              (raise-argument-error 'syntax-local-lift-require \"syntax?\" use-s_0)))))"
"((expand-context-require-lifts115_0) expand-context-require-lifts)"
"((require-lift-context-wrt-phase116_0) require-lift-context-wrt-phase)"
"((add-lifted-require!117_0) add-lifted-require!)"
"((temp118_0)"
"(lambda(s_1 phase_0 require-lift-ctx_0)(require-spec-shift-for-syntax s_1)))"
"((temp119_0)"
"(lambda(s_1 phase_0 require-lift-ctx_0)"
"(wrap-form '#%require(add-scope s_1 sc_0) phase_0))))"
"(do-local-lift-to-module48.1"
" add-lifted-require!117_0"
" expand-context-require-lifts115_0"
" require-lift-context-wrt-phase116_0"
" temp113_0"
" temp114_0"
" temp112_0"
" temp119_0"
" unsafe-undefined"
" temp118_0"
" who110_0"
" temp111_0))))"
"(let-values((()"
"(begin"
"(namespace-visit-available-modules!"
"(expand-context-namespace ctx_0)"
"(expand-context-phase ctx_0))"
"(values))))"
"(let-values(((result-s_0)(add-scope use-s_0 sc_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'lift-require added-s_0 use-s_0 result-s_0)))"
"(void)))"
" result-s_0))))))))))"
"(define-values"
"(1/syntax-local-lift-provide)"
"(lambda(s_0)"
"(begin"
" 'syntax-local-lift-provide"
"(let-values()"
"(let-values()"
"(let-values(((ctx_0 result-s_0)"
"(let-values(((who121_0) 'syntax-local-lift-provide)"
"((s122_0) s_0)"
"                                     ((temp123_0) \"not expanding in a module run-time body\")"
"((expand-context-to-module-lifts124_0) expand-context-to-module-lifts)"
"((to-module-lift-context-wrt-phase125_0) to-module-lift-context-wrt-phase)"
"((add-lifted-to-module-provide!126_0) add-lifted-to-module-provide!)"
"((temp127_0)"
"(lambda(s_1 phase_0 to-module-lift-ctx_0)(wrap-form 'for-syntax s_1 #f)))"
"((temp128_0)"
"(lambda(s_1 phase_0 to-module-lift-ctx_0)(wrap-form '#%provide s_1 phase_0))))"
"(do-local-lift-to-module48.1"
" add-lifted-to-module-provide!126_0"
" expand-context-to-module-lifts124_0"
" to-module-lift-context-wrt-phase125_0"
" #t"
" unsafe-undefined"
" temp123_0"
" temp128_0"
" unsafe-undefined"
" temp127_0"
" who121_0"
" s122_0))))"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'lift-provide result-s_0)))"
"(void)))))))))"
"(define-values"
"(1/syntax-local-lift-module-end-declaration)"
"(lambda(s_0)"
"(begin"
" 'syntax-local-lift-module-end-declaration"
"(let-values()"
"(let-values()"
"(let-values(((ctx_0 also-s_0)"
"(let-values(((who130_0) 'syntax-local-lift-module-end-declaration)"
"((s131_0) s_0)"
"((temp132_0)"
"                                      \"not currently transforming an expression within a module declaration\")"
"((expand-context-to-module-lifts133_0) expand-context-to-module-lifts)"
"((temp134_0)(lambda(lift-ctx_0) 0))"
"((add-lifted-to-module-end!135_0) add-lifted-to-module-end!)"
"((temp136_0)"
"(lambda(orig-s_0 phase_0 to-module-lift-ctx_0)"
"(if(to-module-lift-context-end-as-expressions? to-module-lift-ctx_0)"
"(wrap-form '#%expression orig-s_0 phase_0)"
" orig-s_0)))"
"((temp137_0)"
"(lambda(s_1 phase_0 to-module-lift-ctx_0)"
"(wrap-form 'begin-for-syntax s_1 phase_0))))"
"(do-local-lift-to-module48.1"
" add-lifted-to-module-end!135_0"
" expand-context-to-module-lifts133_0"
" temp134_0"
" #t"
" unsafe-undefined"
" temp132_0"
" unsafe-undefined"
" temp136_0"
" temp137_0"
" who130_0"
" s131_0))))"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'lift-statement s_0)))(void)))))))))"
"(define-values"
"(wrap-form)"
"(lambda(sym_0 s_0 phase_0)"
"(begin"
"(datum->syntax$1"
" #f"
"(list(datum->syntax$1(if phase_0(syntax-shift-phase-level$1 core-stx phase_0) #f) sym_0) s_0)))))"
"(define-values"
"(1/syntax-local-module-defined-identifiers)"
"(lambda()"
"(begin"
" 'syntax-local-module-defined-identifiers"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/syntax-local-transforming-module-provides?)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'syntax-local-module-defined-identifiers"
"                               \"not currently transforming module provides\")))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp139_0) 'syntax-local-module-defined-identifiers))"
"(get-current-expand-context18.1 #f temp139_0))))"
"(requireds->phase-ht(extract-module-definitions(expand-context-requires+provides ctx_0))))))))))"
"(define-values"
"(1/syntax-local-module-required-identifiers)"
"(lambda(mod-path_0 phase-level_0)"
"(begin"
" 'syntax-local-module-required-identifiers"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not mod-path_0)))"
"(if or-part_0 or-part_0(1/module-path? mod-path_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-module-required-identifiers"
"                               \"(or/c module-path? #f)\""
" mod-path_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(eq? phase-level_0 #t)))"
"(if or-part_0 or-part_0(phase? phase-level_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-module-required-identifiers"
"                                 (format \"(or/c ~a #t)\" phase?-string)"
" phase-level_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/syntax-local-transforming-module-provides?)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'syntax-local-module-required-identifiers"
"                                   \"not currently transforming module provides\")))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp141_0) 'syntax-local-module-required-identifiers))"
"(get-current-expand-context18.1 #f temp141_0))))"
"(let-values(((requires+provides_0)(expand-context-requires+provides ctx_0)))"
"(let-values(((mpi_0)(if mod-path_0(module-path->mpi/context mod-path_0 ctx_0) #f)))"
"(let-values(((requireds_0)"
"(extract-all-module-requires"
" requires+provides_0"
" mpi_0"
"(if(eq? phase-level_0 #t) 'all phase-level_0))))"
"(if requireds_0"
"(reverse$1"
"(let-values(((ht_0)(requireds->phase-ht requireds_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 ids_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(cons phase_0 ids_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1(hash-iterate-next ht_0 i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(hash-iterate-first ht_0)))))"
" #f)))))))))))))"
"(define-values"
"(requireds->phase-ht)"
"(lambda(requireds_0)"
"(begin"
"(let-values(((lst_0) requireds_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((r_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((ht_1)"
"(let-values(((ht_1) ht_0))"
"(let-values(((ht_2)"
"(let-values()"
"(hash-update"
" ht_1"
"(required-phase r_0)"
"(lambda(l_0)(cons(required-id r_0) l_0))"
" null))))"
"(values ht_2)))))"
"(if(not #f)(for-loop_0 ht_1 rest_0) ht_1)))"
" ht_0)))))"
" for-loop_0)"
"(hasheqv)"
" lst_0))))))"
"(define-values"
"(1/syntax-local-module-exports)"
"(lambda(mod-path_0)"
"(begin"
" 'syntax-local-module-exports"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(1/module-path? mod-path_0)))"
"(if or-part_0"
" or-part_0"
"(if(syntax?$1 mod-path_0)(1/module-path?(syntax->datum$1 mod-path_0)) #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-local-module-exports"
"(string-append"
"                                \"(or/c module-path?\\n\""
"                                \"      (and/c syntax?\\n\""
"                                \"             (lambda (stx)\\n\""
"                                \"               (module-path? (syntax->datum stx)))))\")"
" mod-path_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((temp143_0) 'syntax-local-module-exports))"
"(get-current-expand-context18.1 #f temp143_0))))"
"(let-values(((ns_0)(expand-context-namespace ctx_0)))"
"(let-values(((mod-name_0)"
"(1/module-path-index-resolve"
"(module-path->mpi/context"
"(if(syntax?$1 mod-path_0)(syntax->datum$1 mod-path_0) mod-path_0)"
" ctx_0)"
" #t)))"
"(let-values(((m_0)(namespace->module ns_0 mod-name_0)))"
"(begin"
"(if m_0"
"(void)"
"(let-values()(raise-unknown-module-error 'syntax-local-module-exports mod-name_0)))"
"(reverse$1"
"(let-values(((ht_0)(module-provides m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 syms_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(cons"
" phase_0"
"(reverse$1"
"(let-values(((ht_1) syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash-keys"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((sym_0)"
"(hash-iterate-key"
" ht_1"
" i_1)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
" sym_0)"
" fold-var_3))))"
"(values"
" fold-var_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_3"
"(hash-iterate-next"
" ht_1"
" i_1))"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
"(hash-iterate-first"
" ht_1)))))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1(hash-iterate-next ht_0 i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(hash-iterate-first ht_0))))))))))))))))"
"(define-values"
"(1/syntax-local-submodules)"
"(lambda()"
"(begin"
" 'syntax-local-submodules"
"(let-values()"
"(let-values()"
"(let-values(((ctx_0)"
"(let-values(((who145_0) 'syntax-local-submodules))"
"(get-current-expand-context18.1 #f who145_0))))"
"(let-values(((submods_0)(expand-context-declared-submodule-names ctx_0)))"
"(reverse$1"
"(let-values(((ht_0) submods_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((name_0 kind_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(if(eq? kind_0 'module)"
"(let-values(((fold-var_2) fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values() name_0)"
" fold-var_2))))"
"(values fold-var_3)))"
" fold-var_1))))"
"(if(not #f)"
"(for-loop_0 fold-var_1(hash-iterate-next ht_0 i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(hash-iterate-first ht_0))))))))))))"
"(define-values"
"(1/syntax-local-get-shadower)"
"(let-values(((syntax-local-get-shadower53_0)"
"(lambda(id52_0 only-generated?51_0)"
"(begin"
" 'syntax-local-get-shadower53"
"(let-values(((id_0) id52_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"                                                  (raise-argument-error 'syntax-local-get-shadower \"identifier?\" id_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((who147_0) 'syntax-local-get-shadower))"
"(get-current-expand-context18.1 #f who147_0))))"
"(let-values(((new-id_0)(add-scopes id_0(expand-context-scopes ctx_0))))"
"(if(syntax-clean? id_0) new-id_0(syntax-taint$1 new-id_0))))))))))))))"
"(case-lambda"
"((id_0)(begin 'syntax-local-get-shadower(syntax-local-get-shadower53_0 id_0 #f)))"
"((id_0 only-generated?51_0)(syntax-local-get-shadower53_0 id_0 only-generated?51_0)))))"
"(define-values"
"(syntax-source-accessor)"
"(lambda(who_0 srcloc-accessor_0)"
"(begin"
"(lambda(s_0)"
"(let-values((()"
"(begin"
"                        (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error who_0 \"syntax?\" s_0)))"
"(values))))"
"(let-values(((srcloc_0)(syntax-srcloc s_0)))(if srcloc_0(srcloc-accessor_0 srcloc_0) #f)))))))"
"(define-values(1/syntax-source)(syntax-source-accessor 'syntax-source srcloc-source))"
"(define-values(1/syntax-line)(syntax-source-accessor 'syntax-line srcloc-line))"
"(define-values(1/syntax-column)(syntax-source-accessor 'syntax-column srcloc-column))"
"(define-values(1/syntax-position)(syntax-source-accessor 'syntax-position srcloc-position))"
"(define-values(1/syntax-span)(syntax-source-accessor 'syntax-span srcloc-span))"
"(define-values"
"(encoded-srcloc?)"
"(lambda(v_0)"
"(begin"
"(let-values(((or-part_0)(if(list? v_0)(if(=(length v_0) 5)(srcloc-vector?(list->vector v_0)) #f) #f)))"
"(if or-part_0 or-part_0(if(vector? v_0)(if(=(vector-length v_0) 5)(srcloc-vector? v_0) #f) #f))))))"
"(define-values"
"(srcloc-vector?)"
"(lambda(v_0)"
"(begin"
"(if(let-values(((or-part_0)(not(vector-ref v_0 1))))"
"(if or-part_0 or-part_0(exact-positive-integer?(vector-ref v_0 1))))"
"(if(let-values(((or-part_0)(not(vector-ref v_0 2))))"
"(if or-part_0 or-part_0(exact-nonnegative-integer?(vector-ref v_0 2))))"
"(if(let-values(((or-part_0)(not(vector-ref v_0 3))))"
"(if or-part_0 or-part_0(exact-positive-integer?(vector-ref v_0 3))))"
"(let-values(((or-part_0)(not(vector-ref v_0 4))))"
"(if or-part_0 or-part_0(exact-nonnegative-integer?(vector-ref v_0 4))))"
" #f)"
" #f)"
" #f))))"
"(define-values"
"(to-srcloc-stx)"
"(lambda(v_0)"
"(begin"
"(if(srcloc? v_0)"
"(let-values()"
"(let-values(((the-struct_0) empty-syntax))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((srcloc1_0) v_0))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
" srcloc1_0"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"              (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))"
"(if(pair? v_0)"
"(let-values()(to-srcloc-stx(list->vector v_0)))"
"(if(vector? v_0)"
"(let-values()"
"(let-values(((the-struct_0) empty-syntax))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((srcloc2_0)"
"(srcloc"
"(vector-ref v_0 0)"
"(vector-ref v_0 1)"
"(vector-ref v_0 2)"
"(vector-ref v_0 3)"
"(vector-ref v_0 4))))"
"(syntax1.1"
"(syntax-content the-struct_0)"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
" srcloc2_0"
"(syntax-props the-struct_0)"
"(syntax-inspector the-struct_0)))"
"                  (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))"
"(let-values() v_0)))))))"
"(define-values"
"(1/syntax-e)"
"(lambda(s_0)"
"(begin"
" 'syntax-e"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-e \"syntax?\" s_0)))"
"(syntax-e$1 s_0)))))))"
"(define-values"
"(1/syntax->datum)"
"(lambda(s_0)"
"(begin"
" 'syntax->datum"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax->datum \"syntax?\" s_0)))"
"(syntax->datum$1 s_0)))))))"
"(define-values(maybe-syntax->datum)(lambda(s_0)(begin(if(syntax?$1 s_0)(syntax->datum$1 s_0) s_0))))"
"(define-values"
"(1/datum->syntax)"
"(let-values(((datum->syntax6_0)"
"(lambda(stx-c4_0 s5_0 stx-l1_0 stx-p2_0 ignored3_0)"
"(begin"
" 'datum->syntax6"
"(let-values(((stx-c_0) stx-c4_0))"
"(let-values(((s_0) s5_0))"
"(let-values(((stx-l_0) stx-l1_0))"
"(let-values(((stx-p_0) stx-p2_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(let-values(((or-part_0)(not stx-c_0)))"
"(if or-part_0 or-part_0(syntax?$1 stx-c_0)))"
"(void)"
"                                        (let-values () (raise-argument-error 'datum->syntax \"(or #f syntax?)\" stx-c_0)))"
"(if(let-values(((or-part_0)(not stx-l_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(syntax?$1 stx-l_0)))"
"(if or-part_1 or-part_1(encoded-srcloc? stx-l_0)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'datum->syntax"
"(string-append"
"                                            \"(or #f syntax?\\n\""
"                                            \"       (list/c any/c\\n\""
"                                            \"               (or/c exact-positive-integer? #f)\\n\""
"                                            \"               (or/c exact-nonnegative-integer? #f)\\n\""
"                                            \"               (or/c exact-positive-integer? #f)\\n\""
"                                            \"               (or/c exact-nonnegative-integer? #f))\\n\""
"                                            \"       (vector/c any/c\\n\""
"                                            \"                 (or/c exact-positive-integer? #f)\\n\""
"                                            \"                 (or/c exact-nonnegative-integer? #f)\\n\""
"                                            \"                 (or/c exact-positive-integer? #f)\\n\""
"                                            \"                 (or/c exact-nonnegative-integer? #f)))\")"
" stx-l_0)))"
"(if(let-values(((or-part_0)(not stx-p_0)))"
"(if or-part_0 or-part_0(syntax?$1 stx-p_0)))"
"(void)"
"                                        (let-values () (raise-argument-error 'datum->syntax \"(or #f syntax?)\" stx-p_0)))"
"(datum->syntax$1 stx-c_0 s_0(to-srcloc-stx stx-l_0) stx-p_0))))))))))))))"
"(case-lambda"
"((stx-c_0 s_0)(begin 'datum->syntax(datum->syntax6_0 stx-c_0 s_0 #f #f #f)))"
"((stx-c_0 s_0 stx-l_0 stx-p_0 ignored3_0)(datum->syntax6_0 stx-c_0 s_0 stx-l_0 stx-p_0 ignored3_0))"
"((stx-c_0 s_0 stx-l_0 stx-p2_0)(datum->syntax6_0 stx-c_0 s_0 stx-l_0 stx-p2_0 #f))"
"((stx-c_0 s_0 stx-l1_0)(datum->syntax6_0 stx-c_0 s_0 stx-l1_0 #f #f)))))"
"(define-values"
"(1/syntax-binding-set)"
"(lambda()(begin 'syntax-binding-set(let-values()(let-values()(syntax-binding-set1.1 null))))))"
"(define-values"
"(1/syntax-binding-set-extend)"
"(let-values(((syntax-binding-set-extend19_0)"
"(lambda(bs15_0"
" as-sym16_0"
" as-phase17_0"
" mpi18_0"
" sym8_0"
" phase9_0"
" nominal-mpi10_0"
" nominal-phase11_0"
" nominal-sym12_0"
" nominal-require-phase13_0"
" insp14_0)"
"(begin"
" 'syntax-binding-set-extend19"
"(let-values(((bs_0) bs15_0))"
"(let-values(((as-sym_0) as-sym16_0))"
"(let-values(((as-phase_0) as-phase17_0))"
"(let-values(((mpi_0) mpi18_0))"
"(let-values(((sym_0)(if(eq? sym8_0 unsafe-undefined) as-sym_0 sym8_0)))"
"(let-values(((phase_0)(if(eq? phase9_0 unsafe-undefined) as-phase_0 phase9_0)))"
"(let-values(((nominal-mpi_0)"
"(if(eq? nominal-mpi10_0 unsafe-undefined) mpi_0 nominal-mpi10_0)))"
"(let-values(((nominal-phase_0)"
"(if(eq? nominal-phase11_0 unsafe-undefined)"
" phase_0"
" nominal-phase11_0)))"
"(let-values(((nominal-sym_0)"
"(if(eq? nominal-sym12_0 unsafe-undefined) sym_0 nominal-sym12_0)))"
"(let-values(((nominal-require-phase_0) nominal-require-phase13_0))"
"(let-values(((insp_0) insp14_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/syntax-binding-set? bs_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"syntax-binding-set?\""
" bs_0)))"
"(if(symbol? as-sym_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"symbol?\""
" as-sym_0)))"
"(if(phase? as-phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
" phase?-string"
" as-phase_0)))"
"(if(1/module-path-index? mpi_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"module-path-index?\""
" mpi_0)))"
"(if(symbol? sym_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"symbol?\""
" sym_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
" phase?-string"
" phase_0)))"
"(if(1/module-path-index? nominal-mpi_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"module-path-index?\""
" nominal-mpi_0)))"
"(if(phase? nominal-phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
" phase?-string"
" nominal-phase_0)))"
"(if(symbol? nominal-sym_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"symbol?\""
" nominal-sym_0)))"
"(if(phase? nominal-require-phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
" phase?-string"
" nominal-require-phase_0)))"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(inspector? x_0))))"
" insp_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-binding-set-extend"
"                                                       \"(or/c inspector? #f)\""
" insp_0)))"
"(syntax-binding-set-extend$1"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase_0"
" nominal-sym_0"
" nominal-require-phase_0"
" insp_0))))))))))))))))))))"
"(case-lambda"
"((bs_0 as-sym_0 as-phase_0 mpi_0)"
"(begin"
" 'syntax-binding-set-extend"
"(syntax-binding-set-extend19_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" #f)))"
"((bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase_0"
" nominal-sym_0"
" nominal-require-phase_0"
" insp14_0)"
"(syntax-binding-set-extend19_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase_0"
" nominal-sym_0"
" nominal-require-phase_0"
" insp14_0))"
"((bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase_0"
" nominal-sym_0"
" nominal-require-phase13_0)"
"(syntax-binding-set-extend19_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase_0"
" nominal-sym_0"
" nominal-require-phase13_0"
" #f))"
"((bs_0 as-sym_0 as-phase_0 mpi_0 sym_0 phase_0 nominal-mpi_0 nominal-phase_0 nominal-sym12_0)"
"(syntax-binding-set-extend19_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase_0"
" nominal-sym12_0"
" 0"
" #f))"
"((bs_0 as-sym_0 as-phase_0 mpi_0 sym_0 phase_0 nominal-mpi_0 nominal-phase11_0)"
"(syntax-binding-set-extend19_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi_0"
" nominal-phase11_0"
" unsafe-undefined"
" 0"
" #f))"
"((bs_0 as-sym_0 as-phase_0 mpi_0 sym_0 phase_0 nominal-mpi10_0)"
"(syntax-binding-set-extend19_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase_0"
" nominal-mpi10_0"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" #f))"
"((bs_0 as-sym_0 as-phase_0 mpi_0 sym_0 phase9_0)"
"(syntax-binding-set-extend19_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym_0"
" phase9_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" #f))"
"((bs_0 as-sym_0 as-phase_0 mpi_0 sym8_0)"
"(syntax-binding-set-extend19_0"
" bs_0"
" as-sym_0"
" as-phase_0"
" mpi_0"
" sym8_0"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" #f)))))"
"(define-values"
"(1/syntax-binding-set->syntax)"
"(lambda(bs_0 datum_0)"
"(begin"
" 'syntax-binding-set->syntax"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/syntax-binding-set? bs_0)"
"(void)"
"              (let-values () (raise-argument-error 'syntax-binding-set->syntax \"syntax-binding-set?\" bs_0)))"
"(syntax-binding-set->syntax$1 bs_0 datum_0)))))))"
"(define-values"
"(1/syntax->list)"
"(lambda(s_0)"
"(begin"
" 'syntax->list"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax->list \"syntax?\" s_0)))"
"(syntax->list$1 s_0)))))))"
"(define-values"
"(1/syntax-original?)"
"(lambda(s_0)"
"(begin"
" 'syntax-original?"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-original? \"syntax?\" s_0)))"
"(if(syntax-property$1 s_0 original-property-sym)(not(syntax-any-macro-scopes? s_0)) #f)))))))"
"(define-values"
"(1/bound-identifier=?)"
"(let-values(((bound-identifier=?24_0)"
"(lambda(a22_0 b23_0 phase21_0)"
"(begin"
" 'bound-identifier=?24"
"(let-values(((a_0) a22_0))"
"(let-values(((b_0) b23_0))"
"(let-values(((phase_0)"
"(if(eq? phase21_0 unsafe-undefined)(1/syntax-local-phase-level) phase21_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? a_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'bound-identifier=? \"identifier?\" a_0)))"
"(if(identifier? b_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'bound-identifier=? \"identifier?\" b_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()(raise-argument-error 'bound-identifier=? phase?-string phase_0)))"
"(bound-identifier=?$1 a_0 b_0 phase_0))))))))))))"
"(case-lambda"
"((a_0 b_0)(begin 'bound-identifier=?(bound-identifier=?24_0 a_0 b_0 unsafe-undefined)))"
"((a_0 b_0 phase21_0)(bound-identifier=?24_0 a_0 b_0 phase21_0)))))"
"(define-values"
"(1/free-identifier=?)"
"(let-values(((free-identifier=?30_0)"
"(lambda(a28_0 b29_0 a-phase26_0 b-phase27_0)"
"(begin"
" 'free-identifier=?30"
"(let-values(((a_0) a28_0))"
"(let-values(((b_0) b29_0))"
"(let-values(((a-phase_0)"
"(if(eq? a-phase26_0 unsafe-undefined)(1/syntax-local-phase-level) a-phase26_0)))"
"(let-values(((b-phase_0)(if(eq? b-phase27_0 unsafe-undefined) a-phase_0 b-phase27_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? a_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'free-identifier=? \"identifier?\" a_0)))"
"(if(identifier? b_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'free-identifier=? \"identifier?\" b_0)))"
"(if(phase? a-phase_0)"
"(void)"
"(let-values()(raise-argument-error 'free-identifier=? phase?-string a-phase_0)))"
"(if(phase? b-phase_0)"
"(void)"
"(let-values()(raise-argument-error 'free-identifier=? phase?-string b-phase_0)))"
"(free-identifier=?$1 a_0 b_0 a-phase_0 b-phase_0)))))))))))))"
"(case-lambda"
"((a_0 b_0)(begin 'free-identifier=?(free-identifier=?30_0 a_0 b_0 unsafe-undefined unsafe-undefined)))"
"((a_0 b_0 a-phase_0 b-phase27_0)(free-identifier=?30_0 a_0 b_0 a-phase_0 b-phase27_0))"
"((a_0 b_0 a-phase26_0)(free-identifier=?30_0 a_0 b_0 a-phase26_0 unsafe-undefined)))))"
"(define-values"
"(1/free-transformer-identifier=?)"
"(lambda(a_0 b_0)"
"(begin"
" 'free-transformer-identifier=?"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(identifier? a_0)"
"(void)"
"                            (let-values () (raise-argument-error 'free-transformer-identifier=? \"identifier?\" a_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(identifier? b_0)"
"(void)"
"                              (let-values () (raise-argument-error 'free-transformer-identifier=? \"identifier?\" b_0)))"
"(values))))"
"(let-values(((phase_0)(add1(1/syntax-local-phase-level))))"
"(free-identifier=?$1 a_0 b_0 phase_0 phase_0)))))))))"
"(define-values"
"(1/free-template-identifier=?)"
"(lambda(a_0 b_0)"
"(begin"
" 'free-template-identifier=?"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(identifier? a_0)"
"(void)"
"                            (let-values () (raise-argument-error 'free-template-identifier=? \"identifier?\" a_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(identifier? b_0)"
"(void)"
"                              (let-values () (raise-argument-error 'free-template-identifier=? \"identifier?\" b_0)))"
"(values))))"
"(let-values(((phase_0)(sub1(1/syntax-local-phase-level))))"
"(free-identifier=?$1 a_0 b_0 phase_0 phase_0)))))))))"
"(define-values"
"(1/free-label-identifier=?)"
"(lambda(a_0 b_0)"
"(begin"
" 'free-label-identifier=?"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? a_0)"
"(void)"
"              (let-values () (raise-argument-error 'free-label-identifier=? \"identifier?\" a_0)))"
"(if(identifier? b_0)"
"(void)"
"              (let-values () (raise-argument-error 'free-label-identifier=? \"identifier?\" b_0)))"
"(free-identifier=?$1 a_0 b_0 #f #f)))))))"
"(define-values"
"(1/identifier-binding)"
"(let-values(((identifier-binding35_0)"
"(lambda(id34_0 phase32_0 top-level-symbol?33_0)"
"(begin"
" 'identifier-binding35"
"(let-values(((id_0) id34_0))"
"(let-values(((phase_0)"
"(if(eq? phase32_0 unsafe-undefined)(1/syntax-local-phase-level) phase32_0)))"
"(let-values(((top-level-symbol?_0) top-level-symbol?33_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'identifier-binding \"identifier?\" id_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()(raise-argument-error 'identifier-binding phase?-string phase_0)))"
"(identifier-binding$1 id_0 phase_0 top-level-symbol?_0))))))))))))"
"(case-lambda"
"((id_0)(begin 'identifier-binding(identifier-binding35_0 id_0 unsafe-undefined #f)))"
"((id_0 phase_0 top-level-symbol?33_0)(identifier-binding35_0 id_0 phase_0 top-level-symbol?33_0))"
"((id_0 phase32_0)(identifier-binding35_0 id_0 phase32_0 #f)))))"
"(define-values"
"(1/identifier-transformer-binding)"
"(let-values(((identifier-transformer-binding39_0)"
"(lambda(id38_0 phase37_0)"
"(begin"
" 'identifier-transformer-binding39"
"(let-values(((id_0) id38_0))"
"(let-values(((phase_0)"
"(if(eq? phase37_0 unsafe-undefined)(1/syntax-local-phase-level) phase37_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"                                    (raise-argument-error 'identifier-transformer-binding \"identifier?\" id_0)))"
"(identifier-binding$1 id_0(if phase_0(add1 phase_0) #f))))))))))))"
"(case-lambda"
"((id_0)(begin 'identifier-transformer-binding(identifier-transformer-binding39_0 id_0 unsafe-undefined)))"
"((id_0 phase37_0)(identifier-transformer-binding39_0 id_0 phase37_0)))))"
"(define-values"
"(1/identifier-template-binding)"
"(lambda(id_0)"
"(begin"
" 'identifier-template-binding"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"              (let-values () (raise-argument-error 'identifier-template-binding \"identifier?\" id_0)))"
"(identifier-binding$1 id_0(sub1(1/syntax-local-phase-level)))))))))"
"(define-values"
"(1/identifier-label-binding)"
"(lambda(id_0)"
"(begin"
" 'identifier-label-binding"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"              (let-values () (raise-argument-error 'identifier-label-binding \"identifier?\" id_0)))"
"(identifier-binding$1 id_0 #f)))))))"
"(define-values"
"(1/identifier-binding-symbol)"
"(let-values(((identifier-binding-symbol43_0)"
"(lambda(id42_0 phase41_0)"
"(begin"
" 'identifier-binding-symbol43"
"(let-values(((id_0) id42_0))"
"(let-values(((phase_0)"
"(if(eq? phase41_0 unsafe-undefined)(1/syntax-local-phase-level) phase41_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'identifier-binding-symbol \"identifier?\" id_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()"
"(raise-argument-error 'identifier-binding-symbol phase?-string phase_0)))"
"(identifier-binding-symbol$1 id_0 phase_0)))))))))))"
"(case-lambda"
"((id_0)(begin 'identifier-binding-symbol(identifier-binding-symbol43_0 id_0 unsafe-undefined)))"
"((id_0 phase41_0)(identifier-binding-symbol43_0 id_0 phase41_0)))))"
"(define-values"
"(1/identifier-prune-lexical-context)"
"(let-values(((identifier-prune-lexical-context47_0)"
"(lambda(id46_0 syms45_0)"
"(begin"
" 'identifier-prune-lexical-context47"
"(let-values(((id_0) id46_0))"
"(let-values(((syms_0) syms45_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"(let-values()"
"                                    (raise-argument-error 'identifier-prune-lexical-context \"identifier?\" id_0)))"
"(if(if(list? syms_0)(andmap2 symbol? syms_0) #f)"
"(void)"
"(let-values()"
"                                    (raise-argument-error 'identifier-prune-lexical-context \"(listof symbol?)\" syms_0)))"
" id_0))))))))))"
"(case-lambda"
"((id_0)(begin 'identifier-prune-lexical-context(identifier-prune-lexical-context47_0 id_0 null)))"
"((id_0 syms45_0)(identifier-prune-lexical-context47_0 id_0 syms45_0)))))"
"(define-values"
"(1/syntax-debug-info)"
"(let-values(((syntax-debug-info52_0)"
"(lambda(s51_0 phase49_0 all-bindings?50_0)"
"(begin"
" 'syntax-debug-info52"
"(let-values(((s_0) s51_0))"
"(let-values(((phase_0)"
"(if(eq? phase49_0 unsafe-undefined)(1/syntax-local-phase-level) phase49_0)))"
"(let-values(((all-bindings?_0) all-bindings?50_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'syntax-debug-info \"syntax?\" s_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()(raise-argument-error 'syntax-debug-info phase?-string phase_0)))"
"(syntax-debug-info$1 s_0 phase_0 all-bindings?_0))))))))))))"
"(case-lambda"
"((s_0)(begin 'syntax-debug-info(syntax-debug-info52_0 s_0 unsafe-undefined #f)))"
"((s_0 phase_0 all-bindings?50_0)(syntax-debug-info52_0 s_0 phase_0 all-bindings?50_0))"
"((s_0 phase49_0)(syntax-debug-info52_0 s_0 phase49_0 #f)))))"
"(define-values"
"(1/syntax-shift-phase-level)"
"(lambda(s_0 phase_0)"
"(begin"
" 'syntax-shift-phase-level"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-shift-phase-level \"syntax?\" s_0)))"
"(if(phase? phase_0)"
"(void)"
"(let-values()(raise-argument-error 'syntax-shift-phase-level phase?-string phase_0)))"
"(syntax-shift-phase-level$1 s_0 phase_0)))))))"
"(define-values"
"(1/syntax-track-origin)"
"(lambda(new-stx_0 old-stx_0 id_0)"
"(begin"
" 'syntax-track-origin"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 new-stx_0)"
"(void)"
"                            (let-values () (raise-argument-error 'syntax-track-origin \"syntax?\" new-stx_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(syntax?$1 old-stx_0)"
"(void)"
"                              (let-values () (raise-argument-error 'syntax-track-origin \"syntax?\" old-stx_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(identifier? id_0)"
"(void)"
"                                (let-values () (raise-argument-error 'syntax-track-origin \"identifier?\" id_0)))"
"(values))))"
"(let-values(((s_0)(syntax-track-origin$1 new-stx_0 old-stx_0 id_0)))"
"(let-values(((ctx_0)"
"(let-values(((temp76_0) #t))(get-current-expand-context18.1 temp76_0 'unexpected))))"
"(begin"
"(if ctx_0"
"(let-values()"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'track-origin new-stx_0 s_0)))"
"(void))))"
"(void))"
" s_0)))))))))))"
"(define-values"
"(1/namespace-attach-module)"
"(let-values(((namespace-attach-module4_0)"
"(lambda(src-namespace2_0 mod-path3_0 dest-namespace1_0)"
"(begin"
" 'namespace-attach-module4"
"(let-values(((src-namespace_0) src-namespace2_0))"
"(let-values(((mod-path_0) mod-path3_0))"
"(let-values(((dest-namespace_0)"
"(if(eq? dest-namespace1_0 unsafe-undefined)"
"(1/current-namespace)"
" dest-namespace1_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who21_0) 'namespace-attach-module)"
"((src-namespace22_0) src-namespace_0)"
"((mod-path23_0) mod-path_0)"
"((dest-namespace24_0) dest-namespace_0)"
"((temp25_0) #t))"
"(do-attach-module17.1"
" temp25_0"
" who21_0"
" src-namespace22_0"
" mod-path23_0"
" dest-namespace24_0))))))))))))"
"(case-lambda"
"((src-namespace_0 mod-path_0)"
"(begin 'namespace-attach-module(namespace-attach-module4_0 src-namespace_0 mod-path_0 unsafe-undefined)))"
"((src-namespace_0 mod-path_0 dest-namespace1_0)"
"(namespace-attach-module4_0 src-namespace_0 mod-path_0 dest-namespace1_0)))))"
"(define-values"
"(1/namespace-attach-module-declaration)"
"(let-values(((namespace-attach-module-declaration9_0)"
"(lambda(src-namespace7_0 mod-path8_0 dest-namespace6_0)"
"(begin"
" 'namespace-attach-module-declaration9"
"(let-values(((src-namespace_0) src-namespace7_0))"
"(let-values(((mod-path_0) mod-path8_0))"
"(let-values(((dest-namespace_0)"
"(if(eq? dest-namespace6_0 unsafe-undefined)"
"(1/current-namespace)"
" dest-namespace6_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who27_0) 'namespace-attach-module-declaration)"
"((src-namespace28_0) src-namespace_0)"
"((mod-path29_0) mod-path_0)"
"((dest-namespace30_0) dest-namespace_0)"
"((temp31_0) #f))"
"(do-attach-module17.1"
" temp31_0"
" who27_0"
" src-namespace28_0"
" mod-path29_0"
" dest-namespace30_0))))))))))))"
"(case-lambda"
"((src-namespace_0 mod-path_0)"
"(begin"
" 'namespace-attach-module-declaration"
"(namespace-attach-module-declaration9_0 src-namespace_0 mod-path_0 unsafe-undefined)))"
"((src-namespace_0 mod-path_0 dest-namespace6_0)"
"(namespace-attach-module-declaration9_0 src-namespace_0 mod-path_0 dest-namespace6_0)))))"
"(define-values"
"(do-attach-module17.1)"
"(lambda(attach-instances?11_0 who13_0 src-namespace14_0 mod-path15_0 dest-namespace16_0)"
"(begin"
" 'do-attach-module17"
"(let-values(((who_0) who13_0))"
"(let-values(((src-namespace_0) src-namespace14_0))"
"(let-values(((mod-path_0) mod-path15_0))"
"(let-values(((dest-namespace_0) dest-namespace16_0))"
"(let-values(((attach-instances?_0) attach-instances?11_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/namespace? src-namespace_0)"
"(void)"
"                                    (let-values () (raise-argument-error who_0 \"namespace?\" src-namespace_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(1/module-path? mod-path_0)))"
"(if or-part_0 or-part_0(1/resolved-module-path? mod-path_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                         \"(or/c module-path? resolved-module-path?)\""
" mod-path_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/namespace? dest-namespace_0)"
"(void)"
"                                        (let-values () (raise-argument-error who_0 \"namespace?\" dest-namespace_0)))"
"(values))))"
"(let-values(((phase_0)(namespace-phase src-namespace_0)))"
"(let-values((()"
"(begin"
"(if(eqv? phase_0(namespace-phase dest-namespace_0))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                               \"source and destination namespace phases do not match\""
"                                               \"source phase\""
" phase_0"
"                                               \"destination phase\""
"(namespace-phase dest-namespace_0))))"
"(values))))"
"(let-values(((todo_0)(make-hasheq)))"
"(let-values(((missing_0) '#:missing))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(mpi_0"
" phase_1"
" attach-instances?_1"
" attach-phase_0)"
"(begin"
" 'loop"
"(let-values(((mod-name_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" src-namespace_0)"
"(let-values()"
"(1/module-path-index-resolve"
" mpi_0)))))"
"(let-values(((attach-this-instance?_0)"
"(if attach-instances?_1"
"(eqv? phase_1 attach-phase_0)"
" #f)))"
"(let-values(((m-ns_0)"
"(hash-ref"
"(hash-ref"
" todo_0"
" mod-name_0"
" '#hasheqv())"
" phase_1"
" missing_0)))"
"(if(let-values(((or-part_0)"
"(eq? missing_0 m-ns_0)))"
"(if or-part_0"
" or-part_0"
"(if attach-this-instance?_0"
"(not m-ns_0)"
" #f)))"
"(let-values()"
"(let-values(((m_0)"
"(namespace->module"
" src-namespace_0"
" mod-name_0)))"
"(begin"
"(if m_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                                                                         \"module not declared (in the source namespace)\""
"                                                                                         \"module name\""
" mod-name_0)))"
"(if(if(module-cross-phase-persistent?"
" m_0)"
"(if(not"
"(label-phase? phase_1))"
"(not(zero-phase? phase_1))"
" #f)"
" #f)"
"(let-values()"
"(loop_0"
" mpi_0"
" 0"
" attach-instances?_1"
" 0))"
"(let-values()"
"(let-values(((already-m_0)"
"(namespace->module"
" dest-namespace_0"
" mod-name_0)))"
"(let-values((()"
"(begin"
"(if(if already-m_0"
"(not"
"(eq?"
" already-m_0"
" m_0))"
" #f)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                                                                                               \"a different declaration is already in the destination namespace\""
"                                                                                                               \"module name\""
" mod-name_0))"
"(void))"
"(values))))"
"(let-values(((m-ns_1"
" already?_0)"
"(if(let-values(((or-part_0)"
" attach-this-instance?_0))"
"(if or-part_0"
" or-part_0"
"(module-cross-phase-persistent?"
" m_0)))"
"(let-values()"
"(let-values(((m-ns_1)"
"(let-values(((src-namespace32_0)"
" src-namespace_0)"
"((mod-name33_0)"
" mod-name_0)"
"((phase34_0)"
" phase_1))"
"(namespace->module-namespace82.1"
" #f"
" #f"
" unsafe-undefined"
" src-namespace32_0"
" mod-name33_0"
" phase34_0))))"
"(let-values((()"
"(begin"
"(if m-ns_1"
"(void)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                                                                                                                     \"module not instantiated (in the source namespace)\""
"                                                                                                                                     \"module name\""
" mod-name_0)))"
"(values))))"
"(let-values(((already-m-ns_0)"
"(if already-m_0"
"(let-values(((dest-namespace35_0)"
" dest-namespace_0)"
"((mod-name36_0)"
" mod-name_0)"
"((phase37_0)"
" phase_1))"
"(namespace->module-namespace82.1"
" #f"
" #f"
" unsafe-undefined"
" dest-namespace35_0"
" mod-name36_0"
" phase37_0))"
" #f)))"
"(begin"
"(if(if already-m-ns_0"
"(if(not"
"(eq?"
" m-ns_1"
" already-m-ns_0))"
"(not"
"(namespace-same-instance?"
" m-ns_1"
" already-m-ns_0))"
" #f)"
" #f)"
"(let-values()"
"(raise-arguments-error"
" who_0"
"                                                                                                                           \"a different instance is already in the destination namespace\""
"                                                                                                                           \"module name\""
" mod-name_0))"
"(void))"
"(values"
" m-ns_1"
"(if already-m-ns_0"
" #t"
" #f)))))))"
"(let-values()"
"(begin"
"(if(if(label-phase?"
" phase_1)"
"(not"
"(let-values(((src-namespace38_0)"
" src-namespace_0)"
"((mod-name39_0)"
" mod-name_0)"
"((phase40_0)"
" phase_1))"
"(namespace->module-namespace82.1"
" #f"
" #f"
" unsafe-undefined"
" src-namespace38_0"
" mod-name39_0"
" phase40_0)))"
" #f)"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" src-namespace_0)"
"(let-values()"
"(let-values(((src-namespace41_0)"
" src-namespace_0)"
"((mpi42_0)"
" mpi_0)"
"((phase43_0)"
" phase_1))"
"(namespace-module-instantiate!96.1"
" #t"
" unsafe-undefined"
" unsafe-undefined"
" #f"
" src-namespace41_0"
" mpi42_0"
" phase43_0)))))"
"(void))"
"(values"
" #f"
"(if already-m_0"
" #t"
" #f)))))))"
"(begin"
"(hash-update!"
" todo_0"
" mod-name_0"
"(lambda(ht_0)"
"(hash-set"
" ht_0"
" phase_1"
" m-ns_1))"
" '#hasheqv())"
"(if already?_0"
"(void)"
"(let-values()"
"(begin"
"(let-values(((lst_0)"
"(module-requires"
" m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((phase+reqs_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values(((lst_2)"
"(cdr"
" phase+reqs_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((req_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
"(module-path-index-shift"
" req_0"
"(module-self"
" m_0)"
" mpi_0)"
"(phase+"
" phase_1"
"(car"
" phase+reqs_0))"
" attach-instances?_1"
" attach-phase_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(let-values(((lst_0)"
"(module-submodule-names"
" m_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((submod-name_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(loop_0"
"(1/module-path-index-join"
"(list"
" 'submod"
"                                                                                                                                                                           \".\""
" submod-name_0)"
" mpi_0)"
" #f"
" #f"
" attach-phase_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(if(module-supermodule-name"
" m_0)"
"(let-values()"
"(loop_0"
"(1/module-path-index-join"
" '(submod"
"                                                                                                              \"..\")"
" mpi_0)"
" #f"
" #f"
" attach-phase_0))"
"(void))))))))))))))"
"(void)))))))))"
" loop_0)"
"(1/module-path-index-join"
"(if(1/resolved-module-path? mod-path_0)"
"(resolved-module-path->module-path mod-path_0)"
" mod-path_0)"
" #f)"
" phase_0"
" attach-instances?_0"
" phase_0)"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((ht_0) todo_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((mod-name_0 phases_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values((()"
"(let-values(((ht_1)"
" phases_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_1)))"
"((letrec-values(((for-loop_1)"
"(lambda(i_1)"
"(begin"
" 'for-loop"
"(if i_1"
"(let-values(((phase_1"
" m-ns_0)"
"(hash-iterate-key+value"
" ht_1"
" i_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((m_0)"
"(namespace->module"
" src-namespace_0"
" mod-name_0)))"
"(begin"
"(module-force-bulk-binding!"
" m_0"
" src-namespace_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" dest-namespace_0)"
"(let-values()"
"(let-values(((dest-namespace44_0)"
" dest-namespace_0)"
"((m45_0)"
" m_0)"
"((mod-name46_0)"
" mod-name_0))"
"(declare-module!58.1"
" #t"
" dest-namespace44_0"
" m45_0"
" mod-name46_0))))"
"(if m-ns_0"
"(let-values()"
"(begin"
"(namespace-record-module-instance-attached!"
" src-namespace_0"
" mod-name_0"
" phase_1)"
"(let-values(((or-part_0)"
"(let-values(((dest-namespace47_0)"
" dest-namespace_0)"
"((mod-name48_0)"
" mod-name_0)"
"((phase49_0)"
" phase_1))"
"(namespace->module-namespace82.1"
" #f"
" #f"
" unsafe-undefined"
" dest-namespace47_0"
" mod-name48_0"
" phase49_0))))"
"(if or-part_0"
" or-part_0"
"(namespace-install-module-namespace!"
" dest-namespace_0"
" mod-name_0"
" phase_1"
" m_0"
" m-ns_0)))))"
"(void)))))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_1"
"(hash-iterate-next"
" ht_1"
" i_1))"
"(values))))"
"(values))))))"
" for-loop_1)"
"(hash-iterate-first"
" ht_1))))))"
"(if(not #f)"
"(for-loop_0"
"(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(values))))"
"(let-values()"
"(let-values(((mnr_0)(1/current-module-name-resolver)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
" dest-namespace_0)"
"(let-values()"
"(begin"
"(let-values(((ht_0) todo_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((mod-name_0)"
"(hash-iterate-key ht_0 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(mnr_0"
" mod-name_0"
" src-namespace_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(void))))))))))))))))))))))))"
"(define-values"
"(1/make-empty-namespace)"
"(lambda()"
"(begin"
" 'make-empty-namespace"
"(let-values(((current-ns_0)(1/current-namespace)))"
"(let-values(((phase_0)(namespace-phase current-ns_0)))"
"(let-values(((ns_0)(namespace->namespace-at-phase(make-namespace) phase_0)))"
"(begin"
"(1/namespace-attach-module current-ns_0 ''#%kernel ns_0)"
"(namespace-primitive-module-visit! ns_0 '#%kernel)"
" ns_0)))))))"
"(define-values"
"(1/namespace-syntax-introduce)"
"(let-values(((namespace-syntax-introduce3_0)"
"(lambda(s2_0 ns1_0)"
"(begin"
" 'namespace-syntax-introduce3"
"(let-values(((s_0) s2_0))"
"(let-values(((ns_0)(if(eq? ns1_0 unsafe-undefined)(1/current-namespace) ns1_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"(let-values()"
"                                                  (raise-argument-error 'namespace-syntax-introduce \"syntax?\" s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-syntax-introduce"
"                                                     \"namespace?\""
" ns_0)))"
"(values))))"
"(let-values(((root-ctx_0)(namespace-get-root-expand-ctx ns_0)))"
"(let-values(((post-scope_0)"
"(post-expansion-scope"
"(root-expand-context-post-expansion root-ctx_0))))"
"(let-values(((other-namespace-scopes_0)"
"(reverse$1"
"(let-values(((ht_0)"
"(syntax-scope-set"
"(root-expand-context-all-scopes-stx root-ctx_0)"
" 0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-immutable-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sc_0)"
"(unsafe-immutable-hash-iterate-key"
" ht_0"
" i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(if(equal?"
" sc_0"
" post-scope_0)"
" fold-var_1"
"(let-values(((fold-var_2)"
" fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons"
"(let-values()"
" sc_0)"
" fold-var_2))))"
"(values"
" fold-var_3)))))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
"(unsafe-immutable-hash-iterate-next"
" ht_0"
" i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(unsafe-immutable-hash-iterate-first ht_0)))))))"
"(let-values(((add-ns-scopes_0)"
"(lambda(s_1)"
"(begin"
" 'add-ns-scopes"
"(let-values(((temp64_0)"
"(add-scopes"
"(push-scope s_1 post-scope_0)"
" other-namespace-scopes_0))"
"((temp65_0)"
"(root-expand-context-all-scopes-stx root-ctx_0))"
"((temp66_0)"
"(let-values(((or-part_0)"
"(namespace-declaration-inspector"
" ns_0)))"
"(if or-part_0"
" or-part_0"
"(current-code-inspector))))"
"((temp67_0) #t))"
"(syntax-transfer-shifts36.1"
" temp67_0"
" temp64_0"
" temp65_0"
" temp66_0))))))"
"(let-values(((maybe-module-id_0)"
"(if(pair?(1/syntax-e s_0))"
"(if(identifier?(car(1/syntax-e s_0)))"
"(add-ns-scopes_0(car(1/syntax-e s_0)))"
" #f)"
" #f)))"
"(if(if maybe-module-id_0"
"(1/free-identifier=?"
" maybe-module-id_0"
"(1/namespace-module-identifier ns_0)"
"(namespace-phase ns_0))"
" #f)"
"(let-values()"
"(1/datum->syntax"
" s_0"
"(cons maybe-module-id_0(cdr(1/syntax-e s_0)))"
" s_0"
" s_0))"
"(let-values()(add-ns-scopes_0 s_0)))))))))))))))))))"
"(case-lambda"
"((s_0)(begin 'namespace-syntax-introduce(namespace-syntax-introduce3_0 s_0 unsafe-undefined)))"
"((s_0 ns1_0)(namespace-syntax-introduce3_0 s_0 ns1_0)))))"
"(define-values"
"(namespace-datum-introduce)"
"(lambda(s_0)(begin(1/namespace-syntax-introduce(1/datum->syntax #f s_0)))))"
"(define-values"
"(1/namespace-module-identifier)"
"(let-values(((namespace-module-identifier6_0)"
"(lambda(where5_0)"
"(begin"
" 'namespace-module-identifier6"
"(let-values(((where_0)(if(eq? where5_0 unsafe-undefined)(1/current-namespace) where5_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(let-values(((or-part_0)(1/namespace? where_0)))"
"(if or-part_0 or-part_0(phase? where_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-module-identifier"
"                                   (string-append \"(or/c namespace? \" phase?-string \")\")"
" where_0)))"
"(1/datum->syntax"
"(1/syntax-shift-phase-level"
" core-stx"
"(if(1/namespace? where_0)(namespace-phase where_0) where_0))"
" 'module))))))))))"
"(case-lambda"
"(()(begin 'namespace-module-identifier(namespace-module-identifier6_0 unsafe-undefined)))"
"((where5_0)(namespace-module-identifier6_0 where5_0)))))"
"(define-values"
"(1/namespace-symbol->identifier)"
"(lambda(sym_0)"
"(begin"
" 'namespace-symbol->identifier"
"(let-values()"
"(let-values()"
"(begin"
"(if(symbol? sym_0)"
"(void)"
"              (let-values () (raise-argument-error 'namespace-symbol->identifier \"symbol?\" sym_0)))"
"(1/namespace-syntax-introduce(1/datum->syntax #f sym_0))))))))"
"(define-values"
"(do-namespace-require21.1)"
"(lambda(copy-variable-as-constant?11_0"
" copy-variable-phase-level10_0"
" run?8_0"
" skip-variable-phase-level12_0"
" visit?9_0"
" who18_0"
" req19_0"
" ns20_0)"
"(begin"
" 'do-namespace-require21"
"(let-values(((run?_0) run?8_0))"
"(let-values(((visit?_0) visit?9_0))"
"(let-values(((who_0) who18_0))"
"(let-values(((req_0) req19_0))"
"(let-values(((ns_0) ns20_0))"
"(let-values(((copy-variable-phase-level_0) copy-variable-phase-level10_0))"
"(let-values(((copy-variable-as-constant?_0) copy-variable-as-constant?11_0))"
"(let-values(((skip-variable-phase-level_0) skip-variable-phase-level12_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"                                          (let-values () (raise-argument-error who_0 \"namespace?\" ns_0)))"
"(values))))"
"(let-values(((ctx-stx_0)"
"(add-scopes"
" empty-syntax"
"(root-expand-context-module-scopes(namespace-get-root-expand-ctx ns_0)))))"
"(if(let-values(((or-part_0)(1/module-path-index? req_0)))"
"(if or-part_0 or-part_0(1/module-path? req_0)))"
"(let-values()"
"(let-values(((temp70_0)"
"(if(1/module-path-index? req_0)"
" req_0"
"(1/module-path-index-join req_0 #f)))"
"((temp71_0) #f)"
"((temp72_0) #f)"
"((ctx-stx73_0) ctx-stx_0)"
"((ns74_0) ns_0)"
"((run?75_0) run?_0)"
"((visit?76_0) visit?_0)"
"((temp77_0)(namespace-phase ns_0))"
"((temp78_0)(namespace-phase ns_0))"
"((copy-variable-phase-level79_0) copy-variable-phase-level_0)"
"((copy-variable-as-constant?80_0) copy-variable-as-constant?_0)"
"((skip-variable-phase-level81_0) skip-variable-phase-level_0)"
"((who82_0) who_0))"
"(perform-require!78.1"
" #f"
" #t"
" #f"
" copy-variable-as-constant?80_0"
" copy-variable-phase-level79_0"
" #f"
" 'all"
" temp77_0"
" #f"
" temp78_0"
" run?75_0"
" skip-variable-phase-level81_0"
" visit?76_0"
" who82_0"
" temp70_0"
" temp71_0"
" temp72_0"
" ctx-stx73_0"
" ns74_0)))"
"(let-values()"
"(let-values(((run?83_0) run?_0)"
"((visit?84_0) visit?_0)"
"((temp85_0)(list(1/datum->syntax ctx-stx_0 req_0)))"
"((temp86_0) #f)"
"((ns87_0) ns_0)"
"((temp88_0)(namespace-phase ns_0))"
"((temp89_0)"
"(let-values(((temp92_0) #f))(make-requires+provides8.1 #f temp92_0)))"
"((skip-variable-phase-level90_0) skip-variable-phase-level_0)"
"((who91_0) who_0))"
"(parse-and-perform-requires!30.1"
" #f"
" #f"
" unsafe-undefined"
" #f"
" unsafe-undefined"
" run?83_0"
" #f"
" skip-variable-phase-level90_0"
" visit?84_0"
" who91_0"
" temp85_0"
" temp86_0"
" ns87_0"
" temp88_0"
" temp89_0))))))))))))))))))"
"(define-values"
"(1/namespace-require)"
"(let-values(((namespace-require26_0)"
"(lambda(req25_0 ns24_0)"
"(begin"
" 'namespace-require26"
"(let-values(((req_0) req25_0))"
"(let-values(((ns_0)(if(eq? ns24_0 unsafe-undefined)(1/current-namespace) ns24_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who94_0) 'namespace-require)((req95_0) req_0)((ns96_0) ns_0))"
"(do-namespace-require21.1 #f #f #t #f #f who94_0 req95_0 ns96_0)))))))))))"
"(case-lambda"
"((req_0)(begin 'namespace-require(namespace-require26_0 req_0 unsafe-undefined)))"
"((req_0 ns24_0)(namespace-require26_0 req_0 ns24_0)))))"
"(define-values"
"(1/namespace-require/expansion-time)"
"(let-values(((namespace-require/expansion-time30_0)"
"(lambda(req29_0 ns28_0)"
"(begin"
" 'namespace-require/expansion-time30"
"(let-values(((req_0) req29_0))"
"(let-values(((ns_0)(if(eq? ns28_0 unsafe-undefined)(1/current-namespace) ns28_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((temp98_0) #f)"
"((temp99_0) #t)"
"((who100_0) 'namespace-require/expansion-time)"
"((req101_0) req_0)"
"((ns102_0) ns_0))"
"(do-namespace-require21.1"
" #f"
" #f"
" temp98_0"
" #f"
" temp99_0"
" who100_0"
" req101_0"
" ns102_0)))))))))))"
"(case-lambda"
"((req_0)(begin 'namespace-require/expansion-time(namespace-require/expansion-time30_0 req_0 unsafe-undefined)))"
"((req_0 ns28_0)(namespace-require/expansion-time30_0 req_0 ns28_0)))))"
"(define-values"
"(1/namespace-require/constant)"
"(let-values(((namespace-require/constant34_0)"
"(lambda(req33_0 ns32_0)"
"(begin"
" 'namespace-require/constant34"
"(let-values(((req_0) req33_0))"
"(let-values(((ns_0)(if(eq? ns32_0 unsafe-undefined)(1/current-namespace) ns32_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who104_0) 'namespace-require/constant)"
"((req105_0) req_0)"
"((ns106_0) ns_0)"
"((temp107_0) 0)"
"((temp108_0) #t))"
"(do-namespace-require21.1"
" temp108_0"
" temp107_0"
" #t"
" #f"
" #f"
" who104_0"
" req105_0"
" ns106_0)))))))))))"
"(case-lambda"
"((req_0)(begin 'namespace-require/constant(namespace-require/constant34_0 req_0 unsafe-undefined)))"
"((req_0 ns32_0)(namespace-require/constant34_0 req_0 ns32_0)))))"
"(define-values"
"(1/namespace-require/copy)"
"(let-values(((namespace-require/copy38_0)"
"(lambda(req37_0 ns36_0)"
"(begin"
" 'namespace-require/copy38"
"(let-values(((req_0) req37_0))"
"(let-values(((ns_0)(if(eq? ns36_0 unsafe-undefined)(1/current-namespace) ns36_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values(((who110_0) 'namespace-require/copy)"
"((req111_0) req_0)"
"((ns112_0) ns_0)"
"((temp113_0) 0)"
"((temp114_0) 0))"
"(do-namespace-require21.1"
" #f"
" temp113_0"
" #t"
" temp114_0"
" #f"
" who110_0"
" req111_0"
" ns112_0)))))))))))"
"(case-lambda"
"((req_0)(begin 'namespace-require/copy(namespace-require/copy38_0 req_0 unsafe-undefined)))"
"((req_0 ns36_0)(namespace-require/copy38_0 req_0 ns36_0)))))"
"(define-values"
"(1/namespace-variable-value)"
"(let-values(((namespace-variable-value44_0)"
"(lambda(sym43_0 use-mapping?40_0 failure-thunk41_0 ns42_0)"
"(begin"
" 'namespace-variable-value44"
"(let-values(((sym_0) sym43_0))"
"(let-values(((use-mapping?_0) use-mapping?40_0))"
"(let-values(((failure-thunk_0) failure-thunk41_0))"
"(let-values(((ns_0)(if(eq? ns42_0 unsafe-undefined)(1/current-namespace) ns42_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(symbol? sym_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'namespace-variable-value \"symbol?\" sym_0)))"
"(if(let-values(((or-part_0)(not failure-thunk_0)))"
"(if or-part_0"
" or-part_0"
"(if(procedure? failure-thunk_0)"
"(procedure-arity-includes? failure-thunk_0 0)"
" #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-variable-value"
"                                         \"(or/c #f (procedure-arity-includes/c 0))\""
" failure-thunk_0)))"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"                                        (raise-argument-error 'namespace-variable-value \"namespace?\" ns_0)))"
"((call/ec"
"(lambda(escape_0)"
"(let-values(((var-ns_0 var-phase-level_0 var-sym_0)"
"(if use-mapping?_0"
"(let-values()"
"(let-values(((id_0)(1/datum->syntax #f sym_0)))"
"(let-values(((b_0)"
"(resolve+shift/extra-inspector"
"(1/namespace-syntax-introduce id_0 ns_0)"
"(namespace-phase ns_0)"
" ns_0)))"
"(let-values((()"
"(begin"
"(if b_0"
"(let-values()"
"(namespace-visit-available-modules!"
" ns_0))"
"(void))"
"(values))))"
"(let-values(((v_0"
" primitive?_0"
" extra-inspector_0"
" protected?_0)"
"(if b_0"
"(let-values(((b116_0) b_0)"
"((empty-env117_0)"
" empty-env)"
"((null118_0) null)"
"((ns119_0) ns_0)"
"((temp120_0)"
"(namespace-phase ns_0))"
"((id121_0) id_0))"
"(binding-lookup52.1"
" #f"
" #f"
" b116_0"
" empty-env117_0"
" null118_0"
" ns119_0"
" temp120_0"
" id121_0))"
"(values variable #f #f #f))))"
"(begin"
"(if(variable? v_0)"
"(void)"
"(let-values()"
"(escape_0"
"(let-values(((or-part_0) failure-thunk_0))"
"(if or-part_0"
" or-part_0"
"(lambda()"
"(raise"
"(make-exn:fail:syntax$1"
"(format"
"(string-append"
"                                                                                   \"namespace-variable-value: bound to syntax\\n\""
"                                                                                   \"  in: ~s\")"
" sym_0)"
"(current-continuation-marks)"
" null))))))))"
"(if(module-binding? b_0)"
"(values"
"(if(top-level-module-path-index?"
"(module-binding-module b_0))"
" ns_0"
"(module-instance-namespace"
"(binding->module-instance"
" b_0"
" ns_0"
"(namespace-phase ns_0)"
" id_0)))"
"(module-binding-phase b_0)"
"(module-binding-sym b_0))"
"(values ns_0(namespace-phase ns_0) sym_0))))))))"
"(let-values()(values ns_0(namespace-phase ns_0) sym_0)))))"
"(let-values(((val_0)"
"(namespace-get-variable"
" var-ns_0"
" var-phase-level_0"
" var-sym_0"
"(lambda()"
"(escape_0"
"(let-values(((or-part_0) failure-thunk_0))"
"(if or-part_0"
" or-part_0"
"(raise"
"(exn:fail:contract:variable"
"(format"
"(string-append"
"                                                                    \"namespace-variable-value: given name is not defined\\n\""
"                                                                    \"  name: ~s\")"
" sym_0)"
"(current-continuation-marks)"
" sym_0)))))))))"
"(lambda() val_0))))))))))))))))))"
"(case-lambda"
"((sym_0)(begin 'namespace-variable-value(namespace-variable-value44_0 sym_0 #t #f unsafe-undefined)))"
"((sym_0 use-mapping?_0 failure-thunk_0 ns42_0)"
"(namespace-variable-value44_0 sym_0 use-mapping?_0 failure-thunk_0 ns42_0))"
"((sym_0 use-mapping?_0 failure-thunk41_0)"
"(namespace-variable-value44_0 sym_0 use-mapping?_0 failure-thunk41_0 unsafe-undefined))"
"((sym_0 use-mapping?40_0)(namespace-variable-value44_0 sym_0 use-mapping?40_0 #f unsafe-undefined)))))"
"(define-values"
"(1/namespace-set-variable-value!)"
"(let-values(((namespace-set-variable-value!51_0)"
"(lambda(sym49_0 val50_0 map?46_0 ns47_0 as-constant?48_0)"
"(begin"
" 'namespace-set-variable-value!51"
"(let-values(((sym_0) sym49_0))"
"(let-values(((val_0) val50_0))"
"(let-values(((map?_0) map?46_0))"
"(let-values(((ns_0)(if(eq? ns47_0 unsafe-undefined)(1/current-namespace) ns47_0)))"
"(let-values(((as-constant?_0) as-constant?48_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(symbol? sym_0)"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'namespace-set-variable-value! \"symbol?\" sym_0)))"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'namespace-set-variable-value! \"namespace?\" ns_0)))"
"(namespace-set-variable! ns_0(namespace-phase ns_0) sym_0 val_0 as-constant?_0)"
"(if map?_0"
"(let-values()"
"(let-values((()"
"(begin"
"(namespace-unset-transformer!"
" ns_0"
"(namespace-phase ns_0)"
" sym_0)"
"(values))))"
"(let-values(((id_0)(1/datum->syntax #f sym_0)))"
"(let-values(((temp123_0)(1/namespace-syntax-introduce id_0 ns_0))"
"((temp124_0)"
"(let-values(((temp126_0)(namespace-mpi ns_0))"
"((temp127_0)(namespace-phase ns_0))"
"((sym128_0) sym_0))"
"(make-module-binding20.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" temp126_0"
" temp127_0"
" sym128_0)))"
"((temp125_0)(namespace-phase ns_0)))"
"(add-binding!17.1 #f #f temp123_0 temp124_0 temp125_0)))))"
"(void)))))))))))))))"
"(case-lambda"
"((sym_0 val_0)"
"(begin 'namespace-set-variable-value!(namespace-set-variable-value!51_0 sym_0 val_0 #f unsafe-undefined #f)))"
"((sym_0 val_0 map?_0 ns_0 as-constant?48_0)"
"(namespace-set-variable-value!51_0 sym_0 val_0 map?_0 ns_0 as-constant?48_0))"
"((sym_0 val_0 map?_0 ns47_0)(namespace-set-variable-value!51_0 sym_0 val_0 map?_0 ns47_0 #f))"
"((sym_0 val_0 map?46_0)(namespace-set-variable-value!51_0 sym_0 val_0 map?46_0 unsafe-undefined #f)))))"
"(define-values"
"(1/namespace-undefine-variable!)"
"(let-values(((namespace-undefine-variable!55_0)"
"(lambda(sym54_0 ns53_0)"
"(begin"
" 'namespace-undefine-variable!55"
"(let-values(((sym_0) sym54_0))"
"(let-values(((ns_0)(if(eq? ns53_0 unsafe-undefined)(1/current-namespace) ns53_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(symbol? sym_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'namespace-undefine-variable! \"symbol?\" sym_0)))"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"                                    (raise-argument-error 'namespace-undefine-variable! \"namespace?\" ns_0)))"
"(namespace-unset-variable! ns_0(namespace-phase ns_0) sym_0)))))))))))"
"(case-lambda"
"((sym_0)(begin 'namespace-undefine-variable!(namespace-undefine-variable!55_0 sym_0 unsafe-undefined)))"
"((sym_0 ns53_0)(namespace-undefine-variable!55_0 sym_0 ns53_0)))))"
"(define-values"
"(1/namespace-mapped-symbols)"
"(let-values(((namespace-mapped-symbols58_0)"
"(lambda(ns57_0)"
"(begin"
" 'namespace-mapped-symbols58"
"(let-values(((ns_0)(if(eq? ns57_0 unsafe-undefined)(1/current-namespace) ns57_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"                                (let-values () (raise-argument-error 'namespace-mapped-symbols \"namespace?\" ns_0)))"
"(set->list"
"(set-union"
"(syntax-mapped-names"
"(root-expand-context-all-scopes-stx(namespace-get-root-expand-ctx ns_0))"
"(namespace-phase ns_0))"
"(list->set(1/instance-variable-names(namespace->instance ns_0 0))))))))))))))"
"(case-lambda"
"(()(begin 'namespace-mapped-symbols(namespace-mapped-symbols58_0 unsafe-undefined)))"
"((ns57_0)(namespace-mapped-symbols58_0 ns57_0)))))"
"(define-values"
"(1/namespace-base-phase)"
"(let-values(((namespace-base-phase61_0)"
"(lambda(ns60_0)"
"(begin"
" 'namespace-base-phase61"
"(let-values(((ns_0)(if(eq? ns60_0 unsafe-undefined)(1/current-namespace) ns60_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"                                (let-values () (raise-argument-error 'namespace-base-phase \"namespace?\" ns_0)))"
"(namespace-phase ns_0))))))))))"
"(case-lambda"
"(()(begin 'namespace-base-phase(namespace-base-phase61_0 unsafe-undefined)))"
"((ns60_0)(namespace-base-phase61_0 ns60_0)))))"
"(define-values"
"(1/eval)"
"(let-values(((eval4_0)"
"(lambda(s3_0 ns1_0 compile2_0)"
"(begin"
" 'eval4"
"(let-values(((s_0) s3_0))"
"(let-values(((ns_0)(if(eq? ns1_0 unsafe-undefined)(1/current-namespace) ns1_0)))"
"(let-values(((compile_0)"
"(if(eq? compile2_0 unsafe-undefined)"
"(lambda(s_1 ns_1)(begin 'compile(1/compile s_1 ns_1 #f)))"
" compile2_0)))"
"(let-values()"
"(if(let-values(((or-part_0)(compiled-in-memory? s_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(linklet-directory? s_0)))"
"(if or-part_1 or-part_1(linklet-bundle? s_0)))))"
"(let-values()(eval-compiled s_0 ns_0))"
"(if(if(syntax?$1 s_0)"
"(let-values(((or-part_0)(compiled-in-memory?(1/syntax-e s_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(linklet-directory?(1/syntax-e s_0))))"
"(if or-part_1 or-part_1(linklet-bundle?(1/syntax-e s_0))))))"
" #f)"
"(let-values()(eval-compiled(1/syntax->datum s_0) ns_0))"
"(let-values()"
"(let-values(((s83_0) s_0)"
"((ns84_0) ns_0)"
"((temp85_0)"
"(lambda(s_1 ns_1 tail?_0)"
"(eval-compiled(compile_0 s_1 ns_1) ns_1 tail?_0)))"
"((temp86_0) #f))"
"(per-top-level71.1 #f #f temp86_0 #t #f temp85_0 #f s83_0 ns84_0)))))))))))))"
"(case-lambda"
"((s_0)(begin 'eval(eval4_0 s_0 unsafe-undefined unsafe-undefined)))"
"((s_0 ns_0 compile2_0)(eval4_0 s_0 ns_0 compile2_0))"
"((s_0 ns1_0)(eval4_0 s_0 ns1_0 unsafe-undefined)))))"
"(define-values"
"(eval-compiled)"
"(let-values(((eval-compiled9_0)"
"(lambda(c7_0 ns8_0 as-tail?6_0)"
"(begin"
" 'eval-compiled9"
"(let-values(((c_0) c7_0))"
"(let-values(((ns_0) ns8_0))"
"(let-values(((as-tail?_0) as-tail?6_0))"
"(let-values()"
"(if(1/compiled-module-expression? c_0)"
"(let-values()"
"(let-values(((c87_0) c_0)((ns88_0) ns_0))(eval-module8.1 ns88_0 #f #t c87_0)))"
"(let-values()(eval-top c_0 ns_0 eval-compiled as-tail?_0)))))))))))"
"(case-lambda"
"((c_0 ns_0)(begin(eval-compiled9_0 c_0 ns_0 #t)))"
"((c_0 ns_0 as-tail?6_0)(eval-compiled9_0 c_0 ns_0 as-tail?6_0)))))"
"(define-values"
"(1/compile)"
"(let-values(((compile15_0)"
"(lambda(s14_0 ns11_0 serializable?12_0 expand13_0)"
"(begin"
" 'compile15"
"(let-values(((s_0) s14_0))"
"(let-values(((ns_0)(if(eq? ns11_0 unsafe-undefined)(1/current-namespace) ns11_0)))"
"(let-values(((serializable?_0) serializable?12_0))"
"(let-values(((expand_0)(if(eq? expand13_0 unsafe-undefined) expand$1 expand13_0)))"
"(let-values()"
"(let-values(((to-correlated-linklet?_0)"
"(if serializable?_0(not(current-compile-target-machine)) #f)))"
"(let-values(((cs_0)"
"(if(1/compiled-expression? s_0)"
"(let-values()(list s_0))"
"(if(if(syntax?$1 s_0)(1/compiled-expression?(1/syntax-e s_0)) #f)"
"(let-values()(list(1/syntax-e s_0)))"
"(let-values()"
"(let-values(((s89_0) s_0)"
"((ns90_0) ns_0)"
"((temp91_0)"
"(lambda(s_1 ns_1 as-tail?_0)"
"(list"
"(let-values(((s94_0) s_1)"
"((ns95_0) ns_1)"
"((expand96_0) expand_0)"
"((serializable?97_0) serializable?_0)"
"((to-correlated-linklet?98_0)"
" to-correlated-linklet?_0))"
"(compile-single25.1"
" serializable?97_0"
" to-correlated-linklet?98_0"
" s94_0"
" ns95_0"
" expand96_0)))))"
"((append92_0) append)"
"((temp93_0) #f))"
"(per-top-level71.1"
" append92_0"
" #f"
" temp93_0"
" #t"
" #f"
" temp91_0"
" #f"
" s89_0"
" ns90_0)))))))"
"(if(if(= 1(length cs_0))(not(compiled-multiple-top?(car cs_0))) #f)"
"(car cs_0)"
"(let-values(((cs99_0) cs_0)"
"((to-correlated-linklet?100_0) to-correlated-linklet?_0)"
"((serializable?101_0) serializable?_0)"
"((ns102_0) ns_0))"
"(compiled-tops->compiled-top8.1"
" serializable?101_0"
" ns102_0"
" to-correlated-linklet?100_0"
" cs99_0))))))))))))))"
"(case-lambda"
"((s_0)(begin 'compile(compile15_0 s_0 unsafe-undefined #t unsafe-undefined)))"
"((s_0 ns_0 serializable?_0 expand13_0)(compile15_0 s_0 ns_0 serializable?_0 expand13_0))"
"((s_0 ns_0 serializable?12_0)(compile15_0 s_0 ns_0 serializable?12_0 unsafe-undefined))"
"((s_0 ns11_0)(compile15_0 s_0 ns11_0 #t unsafe-undefined)))))"
"(define-values"
"(struct:lifted-parsed-begin"
" lifted-parsed-begin17.1"
" lifted-parsed-begin?"
" lifted-parsed-begin-seq"
" lifted-parsed-begin-last)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'lifted-parsed-begin"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '(0 1)"
" #f"
" 'lifted-parsed-begin)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'seq)"
"(make-struct-field-accessor -ref_0 1 'last))))"
"(define-values"
"(compile-single25.1)"
"(lambda(serializable?18_0 to-correlated-linklet?19_0 s22_0 ns23_0 expand24_0)"
"(begin"
" 'compile-single25"
"(let-values(((s_0) s22_0))"
"(let-values(((ns_0) ns23_0))"
"(let-values(((expand_0) expand24_0))"
"(let-values(((serializable?_0) serializable?18_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?19_0))"
"(let-values()"
"(let-values(((exp-s_0)(expand_0 s_0 ns_0 #f #t serializable?_0 to-correlated-linklet?_0)))"
"((letrec-values(((loop_0)"
"(lambda(exp-s_1)"
"(begin"
" 'loop"
"(if(parsed-module? exp-s_1)"
"(let-values()"
"(let-values(((exp-s104_0) exp-s_1)"
"((temp105_0)"
"(let-values(((ns108_0) ns_0))"
"(make-compile-context14.1"
" #f"
" unsafe-undefined"
" #f"
" ns108_0"
" unsafe-undefined"
" unsafe-undefined)))"
"((serializable?106_0) serializable?_0)"
"((to-correlated-linklet?107_0) to-correlated-linklet?_0))"
"(compile-module13.1"
" #f"
" unsafe-undefined"
" #t"
" serializable?106_0"
" to-correlated-linklet?107_0"
" exp-s104_0"
" temp105_0)))"
"(if(lifted-parsed-begin? exp-s_1)"
"(let-values()"
"(let-values(((to-correlated-linklet?109_0) to-correlated-linklet?_0)"
"((temp110_0)"
"(reverse$1"
"(let-values(((lst_0)"
"(append"
"(lifted-parsed-begin-seq exp-s_1)"
"(list"
"(lifted-parsed-begin-last exp-s_1)))))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(loop_0"
" e_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(compiled-tops->compiled-top8.1"
" #f"
" #f"
" to-correlated-linklet?109_0"
" temp110_0)))"
"(let-values()"
"(let-values(((exp-s111_0) exp-s_1)"
"((temp112_0)"
"(let-values(((ns115_0) ns_0))"
"(make-compile-context14.1"
" #f"
" unsafe-undefined"
" #f"
" ns115_0"
" unsafe-undefined"
" unsafe-undefined)))"
"((serializable?113_0) serializable?_0)"
"((to-correlated-linklet?114_0) to-correlated-linklet?_0))"
"(compile-top9.1"
" serializable?113_0"
" #f"
" to-correlated-linklet?114_0"
" exp-s111_0"
" temp112_0)))))))))"
" loop_0)"
" exp-s_0)))))))))))"
"(define-values"
"(expand$1)"
"(let-values(((expand34_0)"
"(lambda(s33_0 ns28_0 observable?29_0 to-parsed?30_0 serializable?31_0 to-correlated-linklet?32_0)"
"(begin"
" 'expand34"
"(let-values(((s_0) s33_0))"
"(let-values(((ns_0)(if(eq? ns28_0 unsafe-undefined)(1/current-namespace) ns28_0)))"
"(let-values(((observable?_0) observable?29_0))"
"(let-values(((to-parsed?_0) to-parsed?30_0))"
"(let-values(((serializable?_0) serializable?31_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?32_0))"
"(let-values()"
"(let-values(((observer_0)(if observable?_0(current-expand-observe) #f)))"
"(begin"
"(if observer_0(let-values()(call-expand-observe observer_0 'start-top))(void))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" current-expand-observe"
" #f)"
"(let-values()"
"(let-values(((s116_0) s_0)"
"((ns117_0) ns_0)"
"((temp118_0)"
"(lambda(s_1 ns_1 as-tail?_0)"
"(let-values(((s122_0) s_1)"
"((ns123_0) ns_1)"
"((observer124_0) observer_0)"
"((to-parsed?125_0) to-parsed?_0)"
"((serializable?126_0) serializable?_0)"
"((to-correlated-linklet?127_0)"
" to-correlated-linklet?_0))"
"(expand-single44.1"
" serializable?126_0"
" to-correlated-linklet?127_0"
" s122_0"
" ns123_0"
" observer124_0"
" to-parsed?125_0))))"
"((cons119_0) cons)"
"((re-pair120_0) re-pair)"
"((observer121_0) observer_0))"
"(per-top-level71.1"
" cons119_0"
" #f"
" observer121_0"
" #t"
" #f"
" temp118_0"
" re-pair120_0"
" s116_0"
" ns117_0)))))))))))))))))"
"(case-lambda"
"((s_0)(begin 'expand(expand34_0 s_0 unsafe-undefined #f #f #f #f)))"
"((s_0 ns_0 observable?_0 to-parsed?_0 serializable?_0 to-correlated-linklet?32_0)"
"(expand34_0 s_0 ns_0 observable?_0 to-parsed?_0 serializable?_0 to-correlated-linklet?32_0))"
"((s_0 ns_0 observable?_0 to-parsed?_0 serializable?31_0)"
"(expand34_0 s_0 ns_0 observable?_0 to-parsed?_0 serializable?31_0 #f))"
"((s_0 ns_0 observable?_0 to-parsed?30_0)(expand34_0 s_0 ns_0 observable?_0 to-parsed?30_0 #f #f))"
"((s_0 ns_0 observable?29_0)(expand34_0 s_0 ns_0 observable?29_0 #f #f #f))"
"((s_0 ns28_0)(expand34_0 s_0 ns28_0 #f #f #f #f)))))"
"(define-values"
"(expand-single44.1)"
"(lambda(serializable?36_0 to-correlated-linklet?37_0 s40_0 ns41_0 observer42_0 to-parsed?43_0)"
"(begin"
" 'expand-single44"
"(let-values(((s_0) s40_0))"
"(let-values(((ns_0) ns41_0))"
"(let-values(((observer_0) observer42_0))"
"(let-values(((to-parsed?_0) to-parsed?43_0))"
"(let-values(((serializable?_0) serializable?36_0))"
"(let-values(((to-correlated-linklet?_0) to-correlated-linklet?37_0))"
"(let-values()"
"(let-values(((rebuild-s_0)(keep-properties-only s_0)))"
"(let-values(((ctx_0)"
"(let-values(((ns128_0) ns_0)"
"((to-parsed?129_0) to-parsed?_0)"
"((serializable?130_0) serializable?_0)"
"((to-correlated-linklet?131_0) to-correlated-linklet?_0)"
"((observer132_0) observer_0))"
"(make-expand-context12.1"
" serializable?130_0"
" observer132_0"
" to-correlated-linklet?131_0"
" to-parsed?129_0"
" ns128_0))))"
"(let-values(((require-lifts_0 lifts_0 exp-s_0)(expand-capturing-lifts s_0 ctx_0)))"
"(if(if(null? require-lifts_0)(null? lifts_0) #f)"
"(let-values() exp-s_0)"
"(if to-parsed?_0"
"(let-values()"
"(let-values(((require-lifts133_0) require-lifts_0)"
"((lifts134_0) lifts_0)"
"((exp-s135_0) exp-s_0)"
"((rebuild-s136_0) rebuild-s_0)"
"((temp137_0)"
"(lambda(form_0)"
"(let-values(((form138_0) form_0)"
"((ns139_0) ns_0)"
"((observer140_0) observer_0)"
"((to-parsed?141_0) to-parsed?_0)"
"((serializable?142_0) serializable?_0))"
"(expand-single44.1"
" serializable?142_0"
" #f"
" form138_0"
" ns139_0"
" observer140_0"
" to-parsed?141_0)))))"
"(wrap-lifts-as-lifted-parsed-begin80.1"
" temp137_0"
" require-lifts133_0"
" lifts134_0"
" exp-s135_0"
" rebuild-s136_0)))"
"(let-values()"
"(let-values((()"
"(begin"
"(log-top-lift-begin-before ctx_0 require-lifts_0 lifts_0 exp-s_0 ns_0)"
"(values))))"
"(let-values(((new-s_0)"
"(let-values(((temp143_0)(append require-lifts_0 lifts_0))"
"((temp144_0)"
"(lambda(form_0)"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(let-values(((form148_0) form_0)"
"((ns149_0) ns_0)"
"((observer150_0) observer_0)"
"((to-parsed?151_0) to-parsed?_0)"
"((serializable?152_0) serializable?_0))"
"(expand-single44.1"
" serializable?152_0"
" #f"
" form148_0"
" ns149_0"
" observer150_0"
" to-parsed?151_0)))))"
"((temp145_0)"
"(lambda(form_0)"
"(if to-parsed?_0"
"(let-values() form_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(let-values(((form153_0) form_0)"
"((ns154_0) ns_0)"
"((observer155_0) observer_0)"
"((to-parsed?156_0) to-parsed?_0)"
"((serializable?157_0)"
" serializable?_0))"
"(expand-single44.1"
" serializable?157_0"
" #f"
" form153_0"
" ns154_0"
" observer155_0"
" to-parsed?156_0)))))))"
"((exp-s146_0) exp-s_0)"
"((temp147_0)(namespace-phase ns_0)))"
"(wrap-lifts-as-begin16.1"
" temp145_0"
" temp144_0"
" temp143_0"
" exp-s146_0"
" temp147_0))))"
"(begin(log-top-begin-after ctx_0 new-s_0) new-s_0)))))))))))))))))))"
"(define-values"
"(expand-once$1)"
"(let-values(((expand-once49_0)"
"(lambda(s48_0 ns47_0)"
"(begin"
" 'expand-once49"
"(let-values(((s_0) s48_0))"
"(let-values(((ns_0)(if(eq? ns47_0 unsafe-undefined)(1/current-namespace) ns47_0)))"
"(let-values()"
"(let-values(((s158_0) s_0)"
"((ns159_0) ns_0)"
"((temp160_0)(lambda(s_1 ns_1 as-tail?_0)(expand-single-once s_1 ns_1)))"
"((cons161_0) cons)"
"((re-pair162_0) re-pair)"
"((temp163_0) #t)"
"((temp164_0) #f))"
"(per-top-level71.1"
" cons161_0"
" temp163_0"
" temp164_0"
" #t"
" #f"
" temp160_0"
" re-pair162_0"
" s158_0"
" ns159_0)))))))))"
"(case-lambda"
"((s_0)(begin 'expand-once(expand-once49_0 s_0 unsafe-undefined)))"
"((s_0 ns47_0)(expand-once49_0 s_0 ns47_0)))))"
"(define-values"
"(expand-single-once)"
"(lambda(s_0 ns_0)"
"(begin"
"(let-values(((require-lifts_0 lifts_0 exp-s_0)"
"(expand-capturing-lifts"
" s_0"
"(let-values(((v_0)(let-values(((ns165_0) ns_0))(make-expand-context12.1 #f #f #f #f ns165_0))))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner166_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((just-once?167_0) #t))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)"
"(expand-context/inner-to-parsed? the-struct_1)"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
" just-once?167_0"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
"(expand-context/inner-in-local-expand? the-struct_1)"
"(expand-context/inner-keep-#%expression? the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-should-not-encounter-macros? the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                              \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner166_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"                           (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))"
"(if(if(null? require-lifts_0)(null? lifts_0) #f)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((temp168_0)(append require-lifts_0 lifts_0))"
"((exp-s169_0) exp-s_0)"
"((temp170_0)(namespace-phase ns_0)))"
"(wrap-lifts-as-begin16.1 unsafe-undefined unsafe-undefined temp168_0 exp-s169_0 temp170_0))))))))"
"(define-values"
"(expand-to-top-form$1)"
"(let-values(((expand-to-top-form53_0)"
"(lambda(s52_0 ns51_0)"
"(begin"
" 'expand-to-top-form53"
"(let-values(((s_0) s52_0))"
"(let-values(((ns_0)(if(eq? ns51_0 unsafe-undefined)(1/current-namespace) ns51_0)))"
"(let-values()"
"(let-values(((observer_0)(current-expand-observe)))"
"(begin"
"(if observer_0(let-values()(call-expand-observe observer_0 'start-top))(void))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" current-expand-observe"
" #f)"
"(let-values()"
"(let-values(((s171_0) s_0)"
"((ns172_0) ns_0)"
"((temp173_0) #f)"
"((temp174_0) #f)"
"((observer175_0) observer_0))"
"(per-top-level71.1"
" #f"
" #f"
" observer175_0"
" temp174_0"
" #f"
" temp173_0"
" #f"
" s171_0"
" ns172_0)))))))))))))"
"(case-lambda"
"((s_0)(begin 'expand-to-top-form(expand-to-top-form53_0 s_0 unsafe-undefined)))"
"((s_0 ns51_0)(expand-to-top-form53_0 s_0 ns51_0)))))"
"(define-values"
"(per-top-level71.1)"
"(lambda(combine56_0"
" just-once?58_0"
" observer61_0"
" quick-immediate?59_0"
" serializable?60_0"
" single55_0"
" wrap57_0"
" given-s69_0"
" ns70_0)"
"(begin"
" 'per-top-level71"
"(let-values(((given-s_0) given-s69_0))"
"(let-values(((ns_0) ns70_0))"
"(let-values(((single_0) single55_0))"
"(let-values(((combine_0) combine56_0))"
"(let-values(((wrap_0) wrap57_0))"
"(let-values(((just-once?_0) just-once?58_0))"
"(let-values(((quick-immediate?_0) quick-immediate?59_0))"
"(let-values(((serializable?_0) serializable?60_0))"
"(let-values(((observer_0) observer61_0))"
"(let-values()"
"(let-values(((s_0)(maybe-intro given-s_0 ns_0)))"
"(let-values(((ctx_0)"
"(let-values(((ns176_0) ns_0)((observer177_0) observer_0))"
"(make-expand-context12.1 #f observer177_0 #f #f ns176_0))))"
"(let-values(((phase_0)(namespace-phase ns_0)))"
"((letrec-values(((loop_0)"
"(lambda(s_1 phase_1 ns_1 as-tail?_0)"
"(begin"
" 'loop"
"(let-values(((tl-ctx_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner178_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((phase179_0)"
" phase_1)"
"((namespace180_0)"
" ns_1)"
"((just-once?181_0)"
" just-once?_0)"
"((for-serializable?182_0)"
" serializable?_0))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
" phase179_0"
" namespace180_0"
" just-once?181_0"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
" for-serializable?182_0"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                             \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner178_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                           \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((wb-s_0)(if just-once?_0 s_1 #f)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'visit"
" s_1)))"
"(void)))"
"(values))))"
"(let-values(((require-lifts_0 lifts_0 exp-s_0)"
"(expand-capturing-lifts"
" s_1"
"(let-values(((v_0) tl-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((only-immediate?183_0)"
" #t)"
"((inner184_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((phase185_0)"
" phase_1)"
"((namespace186_0)"
" ns_1))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
" phase185_0"
" namespace186_0"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                    \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner184_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
" only-immediate?183_0"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                  \"expand-context/outer?\""
" the-struct_0)))))))"
"(let-values(((disarmed-exp-s_0)"
"(syntax-disarm$1 exp-s_0)))"
"(if(let-values(((or-part_0)(pair? require-lifts_0)))"
"(if or-part_0 or-part_0(pair? lifts_0)))"
"(let-values()"
"(let-values(((new-s_0)"
"(let-values(((temp187_0)"
"(append"
" require-lifts_0"
" lifts_0))"
"((exp-s188_0) exp-s_0)"
"((phase189_0) phase_1))"
"(wrap-lifts-as-begin16.1"
" unsafe-undefined"
" unsafe-undefined"
" temp187_0"
" exp-s188_0"
" phase189_0))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'lift-loop"
" new-s_0)))"
"(void)))"
"(if just-once?_0"
" new-s_0"
"(loop_0 new-s_0 phase_1 ns_1 as-tail?_0)))))"
"(if(not single_0)"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'return"
" exp-s_0)))"
"(void)))"
" exp-s_0))"
"(if(if just-once?_0(not(eq? exp-s_0 wb-s_0)) #f)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((tmp_0)"
"(core-form-sym"
" disarmed-exp-s_0"
" phase_1)))"
"(if(equal? tmp_0 'begin)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-begin)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 begin190_0 e191_0)"
"(let-values(((s_2)"
" disarmed-exp-s_0))"
"(let-values(((orig-s_0)"
" s_2))"
"(let-values(((begin190_0"
" e191_0)"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((begin192_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((e193_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                             \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin192_0"
" e193_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                     \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin190_0"
" e191_0))))))"
"(letrec-values(((begin-loop_0)"
"(lambda(es_0)"
"(begin"
" 'begin-loop"
"(if(null? es_0)"
"(let-values()"
"(if combine_0"
" null"
"(void)))"
"(if(if(not"
" combine_0)"
"(null?"
"(cdr"
" es_0))"
" #f)"
"(let-values()"
"(loop_0"
"(car es_0)"
" phase_1"
" ns_1"
" as-tail?_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((a_0)"
"(if combine_0"
"(loop_0"
"(car"
" es_0)"
" phase_1"
" ns_1"
" #f)"
"(begin"
"(loop_0"
"(car"
" es_0)"
" phase_1"
" ns_1"
" #f)"
"(void)))))"
"(if combine_0"
"(combine_0"
" a_0"
"(begin-loop_0"
"(cdr"
" es_0)))"
"(begin-loop_0"
"(cdr"
" es_0))))))))))))"
"(if wrap_0"
"(let-values()"
"(let-values(((new-s_0)"
"(wrap_0"
" begin190_0"
" exp-s_0"
"(begin-loop_0"
" e191_0))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'return"
" new-s_0)))"
"(void)))"
" new-s_0)))"
"(let-values()"
"(begin-loop_0 e191_0)))))))"
"(if(equal? tmp_0 'begin-for-syntax)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-begin-for-syntax)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" begin-for-syntax194_0"
" e195_0)"
"(let-values(((s_2)"
" disarmed-exp-s_0))"
"(let-values(((orig-s_0)"
" s_2))"
"(let-values(((begin-for-syntax194_0"
" e195_0)"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((begin-for-syntax196_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((e197_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                               \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin-for-syntax196_0"
" e197_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                       \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin-for-syntax194_0"
" e195_0))))))"
"(let-values(((next-phase_0)"
"(add1 phase_1)))"
"(let-values(((next-ns_0)"
"(namespace->namespace-at-phase"
" ns_1"
" next-phase_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prepare-env)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if quick-immediate?_0"
"(let-values()"
"(namespace-visit-available-modules!"
" ns_1))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(namespace-visit-available-modules!"
" next-ns_0)"
"(values))))"
"(let-values(((l_0)"
"(reverse$1"
"(let-values(((lst_0)"
" e195_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_2)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(loop_0"
" s_2"
" next-phase_0"
" next-ns_0"
" #f)))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(if wrap_0"
"(let-values()"
"(let-values(((new-s_0)"
"(wrap_0"
" begin-for-syntax194_0"
" exp-s_0"
" l_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" tl-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'return"
" new-s_0)))"
"(void)))"
" new-s_0)))"
"(if combine_0"
"(let-values()"
"(apply"
" append"
" l_0))"
"(let-values()"
"(void)))))))))))))"
"(let-values()"
"(single_0"
" exp-s_0"
" ns_1"
" as-tail?_0))))))))))))))))))"
" loop_0)"
" s_0"
" phase_0"
" ns_0"
" #t)))))))))))))))))"
"(define-values"
"(maybe-intro)"
"(lambda(s_0 ns_0)(begin(if(syntax?$1 s_0) s_0(1/namespace-syntax-introduce(1/datum->syntax #f s_0) ns_0)))))"
"(define-values"
"(re-pair)"
"(lambda(form-id_0 s_0 r_0)"
"(begin(syntax-rearm$1(1/datum->syntax(syntax-disarm$1 s_0)(cons form-id_0 r_0) s_0 s_0) s_0))))"
"(define-values"
"(expand-capturing-lifts)"
"(lambda(s_0 ctx_0)"
"(begin"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'expand 'top))(void))"
"(begin0"
"(let-values()"
"(let-values(((ns_0)(expand-context-namespace ctx_0)))"
"(let-values((()(begin(namespace-visit-available-modules! ns_0)(values))))"
"(let-values(((lift-ctx_0)"
"(let-values(((temp198_0)(make-top-level-lift ctx_0)))"
"(make-lift-context6.1 #f temp198_0))))"
"(let-values(((require-lift-ctx_0)"
"(make-require-lift-context"
"(namespace-phase ns_0)"
"(make-parse-top-lifted-require ns_0))))"
"(let-values(((exp-s_0)"
"(let-values(((s199_0) s_0)"
"((temp200_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner201_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((lifts202_0) lift-ctx_0)"
"((module-lifts203_0) lift-ctx_0)"
"((require-lifts204_0)"
" require-lift-ctx_0))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
" lifts202_0"
"(expand-context/inner-lift-envs the-struct_1)"
" module-lifts203_0"
" require-lifts204_0"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                         \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner201_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                       \"expand-context/outer?\""
" the-struct_0))))))"
"(expand9.1 #f #f #f s199_0 temp200_0))))"
"(values"
"(get-and-clear-require-lifts! require-lift-ctx_0)"
"(get-and-clear-lifts! lift-ctx_0)"
" exp-s_0)))))))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))"
"(define-values"
"(make-parse-top-lifted-require)"
"(lambda(ns_0)"
"(begin"
"(lambda(s_0 phase_0)"
"(let-values(((ok?_0 #%require205_0 req206_0)"
"(let-values(((s_1)(syntax-disarm$1 s_0)))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%require205_0 req206_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%require207_0)(let-values(((s_3)(car s_2))) s_3))"
"((req208_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((req209_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(null? s_6)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values req209_0))"
"                                                                (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values #%require207_0 req208_0))"
"                                            (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%require205_0 req206_0))))))"
"(let-values(((temp210_0)(list req206_0))"
"((s211_0) s_0)"
"((ns212_0) ns_0)"
"((phase213_0) phase_0)"
"((phase214_0) phase_0)"
"((temp215_0)(let-values(((temp217_0) #f))(make-requires+provides8.1 #f temp217_0)))"
"((temp216_0) 'require))"
"(parse-and-perform-requires!30.1"
" #f"
" #f"
" unsafe-undefined"
" #f"
" phase214_0"
" #f"
" #f"
" #f"
" #t"
" temp216_0"
" temp210_0"
" s211_0"
" ns212_0"
" phase213_0"
" temp215_0)))))))"
"(define-values"
"(wrap-lifts-as-lifted-parsed-begin80.1)"
"(lambda(adjust-form74_0 require-lifts76_0 lifts77_0 exp-s78_0 rebuild-s79_0)"
"(begin"
" 'wrap-lifts-as-lifted-parsed-begin80"
"(let-values(((require-lifts_0) require-lifts76_0))"
"(let-values(((lifts_0) lifts77_0))"
"(let-values(((exp-s_0) exp-s78_0))"
"(let-values(((rebuild-s_0) rebuild-s79_0))"
"(let-values(((adjust-form_0) adjust-form74_0))"
"(let-values()"
"(lifted-parsed-begin17.1"
"(append"
"(reverse$1"
"(let-values(((lst_0) require-lifts_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((req_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(parsed-require23.1 req_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
"(reverse$1"
"(let-values(((lst_0)(get-lifts-as-lists lifts_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((ids+syms+rhs_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((exp-rhs_0)"
"(adjust-form_0"
"(caddr"
" ids+syms+rhs_0))))"
"(let-values(((just-rhs_0)"
"(if(lifted-parsed-begin?"
" exp-rhs_0)"
"(lifted-parsed-begin-last"
" exp-rhs_0)"
" exp-rhs_0)))"
"(let-values(((dv_0)"
"(parsed-define-values19.1"
" rebuild-s_0"
"(car"
" ids+syms+rhs_0)"
"(cadr"
" ids+syms+rhs_0)"
" just-rhs_0)))"
"(if(lifted-parsed-begin?"
" exp-rhs_0)"
"(let-values(((the-struct_0)"
" exp-rhs_0))"
"(if(lifted-parsed-begin?"
" the-struct_0)"
"(let-values(((last218_0)"
" dv_0))"
"(lifted-parsed-begin17.1"
"(lifted-parsed-begin-seq"
" the-struct_0)"
" last218_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                   \"lifted-parsed-begin?\""
" the-struct_0)))"
" dv_0)))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
" exp-s_0))))))))))"
"(define-values"
"(log-top-lift-begin-before)"
"(lambda(ctx_0 require-lifts_0 lifts_0 exp-s_0 ns_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values(((new-s_0)"
"(let-values(((temp219_0)(append require-lifts_0 lifts_0))"
"((exp-s220_0) exp-s_0)"
"((temp221_0)(namespace-phase ns_0)))"
"(wrap-lifts-as-begin16.1"
" unsafe-undefined"
" unsafe-undefined"
" temp219_0"
" exp-s220_0"
" temp221_0))))"
"(begin(call-expand-observe obs_0 'lift-loop new-s_0)(log-top-begin-before ctx_0 new-s_0))))"
"(void))))))"
"(define-values"
"(log-top-begin-before)"
"(lambda(ctx_0 new-s_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values(((ok?_0 begin222_0 e223_0)"
"(let-values(((s_0) new-s_0))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((begin222_0 e223_0)"
"(let-values(((s_1)(if(syntax?$1 s_0)(syntax-e$1 s_0) s_0)))"
"(if(pair? s_1)"
"(let-values(((begin224_0)(let-values(((s_2)(car s_1))) s_2))"
"((e225_0)"
"(let-values(((s_2)(cdr s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1 s_2)"
"(syntax-e$1 s_2)"
" s_2)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_3)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                        (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0)))))))"
"(values begin224_0 e225_0))"
"                                                (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t begin222_0 e223_0))))))"
"(begin"
"(call-expand-observe obs_0 'visit new-s_0)"
"(call-expand-observe obs_0 'resolve begin222_0)"
"(call-expand-observe obs_0 'enter-prim new-s_0)"
"(call-expand-observe obs_0 'prim-begin)"
"(call-expand-observe obs_0 'enter-list(1/datum->syntax #f e223_0 new-s_0)))))"
"(void))))))"
"(define-values"
"(log-top-begin-after)"
"(lambda(ctx_0 new-s_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values(((ok?_0 begin226_0 e227_0)"
"(let-values(((s_0) new-s_0))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((begin226_0 e227_0)"
"(let-values(((s_1)(if(syntax?$1 s_0)(syntax-e$1 s_0) s_0)))"
"(if(pair? s_1)"
"(let-values(((begin228_0)(let-values(((s_2)(car s_1))) s_2))"
"((e229_0)"
"(let-values(((s_2)(cdr s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1 s_2)"
"(syntax-e$1 s_2)"
" s_2)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_3)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                        (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0)))))))"
"(values begin228_0 e229_0))"
"                                                (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t begin226_0 e227_0))))))"
"(let-values(((obs_1)(expand-context-observer ctx_0)))"
"(if obs_1"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe obs_1 'exit-list(1/datum->syntax #f e227_0 new-s_0))"
"(call-expand-observe obs_1 'exit-prim new-s_0)"
"(call-expand-observe obs_1 'return new-s_0))))"
"(void)))))"
"(void))))))"
" (define-values (replace-me) (lambda (who_0) (begin (lambda args_0 (error who_0 \"this stub must be replaced\")))))"
"(define-values"
"(1/current-eval)"
"(let-values()"
"(let-values()"
"(make-parameter"
"(replace-me 'current-eval)"
"(lambda(p_0)"
"(begin"
"(if((lambda(p_1)(if(procedure? p_1)(procedure-arity-includes? p_1 1) #f)) p_0)"
"(void)"
"             (let-values () (raise-argument-error 'current-eval \"(procedure-arity-includes/c 1)\" p_0)))"
" p_0))))))"
"(define-values"
"(1/current-compile)"
"(let-values()"
"(let-values()"
"(make-parameter"
"(replace-me 'current-compile)"
"(lambda(p_0)"
"(begin"
"(if((lambda(p_1)(if(procedure? p_1)(procedure-arity-includes? p_1 2) #f)) p_0)"
"(void)"
"             (let-values () (raise-argument-error 'current-compile \"(procedure-arity-includes/c 2)\" p_0)))"
" p_0))))))"
"(define-values"
"(1/current-load)"
"(let-values()"
"(let-values()"
"(make-parameter"
"(replace-me 'current-load)"
"(lambda(p_0)"
"(begin"
"(if((lambda(p_1)(if(procedure? p_1)(procedure-arity-includes? p_1 2) #f)) p_0)"
"(void)"
"             (let-values () (raise-argument-error 'current-load \"(procedure-arity-includes/c 2)\" p_0)))"
" p_0))))))"
"(define-values"
"(1/current-load/use-compiled)"
"(let-values()"
"(let-values()"
"(make-parameter"
"(replace-me 'current-load/use-compiled)"
"(lambda(p_0)"
"(begin"
"(if((lambda(p_1)(if(procedure? p_1)(procedure-arity-includes? p_1 2) #f)) p_0)"
"(void)"
"             (let-values () (raise-argument-error 'current-load/use-compiled \"(procedure-arity-includes/c 2)\" p_0)))"
" p_0))))))"
"(define-values"
"(1/current-library-collection-paths)"
"(let-values()"
"(let-values()"
"(make-parameter"
" null"
"(lambda(l_0)"
"(begin"
"(if((lambda(l_1)(if(list? l_1)(andmap2 complete-path-string? l_1) #f)) l_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'current-library-collection-paths"
"                \"(listof (and/c path-string? complete-path?))\""
" l_0)))"
"(map2 to-path l_0)))))))"
"(define-values"
"(1/current-library-collection-links)"
"(let-values()"
"(let-values()"
"(make-parameter"
" null"
"(lambda(l_0)"
"(begin"
"(if((lambda(l_1)"
"(if(list? l_1)"
"(andmap2"
"(lambda(p_0)"
"(let-values(((or-part_0)(not p_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(complete-path-string? p_0)))"
"(if or-part_1"
" or-part_1"
"(if(hash? p_0)"
"(let-values(((ht_0) p_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(if(let-values(((or-part_2)"
"(not"
" k_0)))"
"(if or-part_2"
" or-part_2"
"(if(symbol?"
" k_0)"
"(1/module-path?"
" k_0)"
" #f)))"
"(if(list? v_0)"
"(andmap2"
" complete-path-string?"
" v_0)"
" #f)"
" #f)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0(not result_1)) k_0 v_0))"
"(not #f)"
" #f)"
"(for-loop_0 result_1(hash-iterate-next ht_0 i_0))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #t"
"(hash-iterate-first ht_0))))"
" #f))))))"
" l_1)"
" #f))"
" l_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'current-library-collection-links"
"(string-append"
"                 \"(listof (or/c #f\\n\""
"                 \"              (and/c path-string? complete-path?)\\n\""
"                 \"              (hash/c (or/c (and/c symbol? module-path?) #f)\\n\""
"                 \"                      (listof (and/c path-string? complete-path?)))))\")"
" l_0)))"
"(map2"
"(lambda(p_0)"
"(if(not p_0)"
"(let-values() #f)"
"(if(path? p_0)"
"(let-values() p_0)"
"(if(string? p_0)"
"(let-values()(string->path p_0))"
"(let-values()"
"(let-values(((ht_0) p_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
" k_0"
"(to-path v_0)))))"
"(hash-set table_1 key_0 val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first ht_0)))))))))"
" l_0)))))))"
"(define-values"
"(1/use-compiled-file-paths)"
"(let-values()"
"(let-values()"
"(make-parameter"
"       (list (string->path \"compiled\"))"
"(lambda(l_0)"
"(begin"
"(if((lambda(l_1)(if(list? l_1)(andmap2 relative-path-string?$1 l_1) #f)) l_0)"
"(void)"
"(let-values()"
"               (raise-argument-error 'use-compiled-file-paths \"(listof (and/c path-string? relative-path?))\" l_0)))"
"(map2 to-path l_0)))))))"
"(define-values"
"(1/current-compiled-file-roots)"
"(let-values()"
"(let-values()"
"(make-parameter"
" '(same)"
"(lambda(l_0)"
"(begin"
"(if((lambda(l_1)"
"(if(list? l_1)"
"(andmap2"
"(lambda(p_0)"
"(let-values(((or-part_0)(path-string? p_0)))(if or-part_0 or-part_0(eq? p_0 'same))))"
" l_1)"
" #f))"
" l_0)"
"(void)"
"(let-values()"
"               (raise-argument-error 'current-compiled-file-roots \"(listof (or/c path-string? 'same))\" l_0)))"
"(map2 to-path l_0)))))))"
"(define-values"
"(1/use-compiled-file-check)"
"(let-values()"
"(let-values()"
"(make-parameter"
" 'modify-seconds"
"(lambda(v_0)"
"(begin"
"(if((lambda(v_1)"
"(let-values(((or-part_0)(eq? v_1 'modify-seconds)))(if or-part_0 or-part_0(eq? v_1 'exists))))"
" v_0)"
"(void)"
"             (let-values () (raise-argument-error 'use-compiled-file-check \"(or/c 'modify-seconds 'exists)\" v_0)))"
" v_0))))))"
"(define-values(1/use-collection-link-paths)(make-parameter #t(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/use-user-specific-search-paths)(make-parameter #t(lambda(v_0)(if v_0 #t #f))))"
"(define-values(complete-path-string?)(lambda(p_0)(begin(if(path-string? p_0)(complete-path? p_0) #f))))"
"(define-values"
"(relative-path-string?$1)"
"(lambda(p_0)(begin 'relative-path-string?(if(path-string? p_0)(relative-path? p_0) #f))))"
"(define-values(to-path)(lambda(p_0)(begin(if(string? p_0)(string->path p_0) p_0))))"
"(define-values"
"(eval$1)"
"(let-values()"
"(let-values()"
"(case-lambda"
"((s_0)(begin 'eval((1/current-eval)(intro s_0))))"
"((s_0 ns_0)"
"(begin"
"          (if (1/namespace? ns_0) (void) (let-values () (raise-argument-error 'eval \"namespace?\" ns_0)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization(continuation-mark-set-first #f parameterization-key) 1/current-namespace ns_0)"
"(let-values()((1/current-eval)(intro s_0 ns_0))))))))))"
"(define-values"
"(1/eval-syntax)"
"(let-values()"
"(let-values()"
"(case-lambda"
"((s_0)"
"(begin"
" 'eval-syntax"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'eval-syntax \"syntax?\" s_0)))"
"((1/current-eval) s_0))))"
"((s_0 ns_0)"
"(begin"
"          (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'eval-syntax \"syntax?\" s_0)))"
"          (if (1/namespace? ns_0) (void) (let-values () (raise-argument-error 'eval-syntax \"namespace?\" ns_0)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization(continuation-mark-set-first #f parameterization-key) 1/current-namespace ns_0)"
"(let-values()((1/current-eval) s_0)))))))))"
"(define-values(compile$1)(lambda(s_0)(begin 'compile((1/current-compile)(intro s_0) #f))))"
"(define-values"
"(1/compile-syntax)"
"(lambda(s_0)"
"(begin"
" 'compile-syntax"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'compile-syntax \"syntax?\" s_0)))"
"((1/current-compile) s_0 #f)))))))"
"(define-values(1/expand)(lambda(s_0)(begin 'expand(expand$1(intro s_0)(1/current-namespace) #t))))"
"(define-values"
"(1/expand-syntax)"
"(lambda(s_0)"
"(begin"
" 'expand-syntax"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'expand-syntax \"syntax?\" s_0)))"
"(expand$1 s_0(1/current-namespace) #t)))))))"
"(define-values(1/expand-once)(lambda(s_0)(begin 'expand-once(expand-once$1(intro s_0)))))"
"(define-values"
"(1/expand-syntax-once)"
"(lambda(s_0)"
"(begin"
" 'expand-syntax-once"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'expand-syntax-once \"syntax?\" s_0)))"
"(expand-once$1 s_0)))))))"
"(define-values(1/expand-to-top-form)(lambda(s_0)(begin 'expand-to-top-form(expand-to-top-form$1(intro s_0)))))"
"(define-values"
"(1/expand-syntax-to-top-form)"
"(lambda(s_0)"
"(begin"
" 'expand-syntax-to-top-form"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'expand-syntax-to-top-form \"syntax?\" s_0)))"
"(expand-to-top-form$1 s_0)))))))"
"(define-values"
"(intro)"
"(let-values(((intro3_0)"
"(lambda(given-s2_0 ns1_0)"
"(begin"
" 'intro3"
"(let-values(((given-s_0) given-s2_0))"
"(let-values(((ns_0)(if(eq? ns1_0 unsafe-undefined)(1/current-namespace) ns1_0)))"
"(let-values()"
"(let-values(((s_0)(if(syntax?$1 given-s_0) given-s_0(1/datum->syntax #f given-s_0))))"
"(1/namespace-syntax-introduce s_0 ns_0)))))))))"
"(case-lambda"
"((given-s_0)(begin(intro3_0 given-s_0 unsafe-undefined)))"
"((given-s_0 ns1_0)(intro3_0 given-s_0 ns1_0)))))"
"(define-values"
"(do-dynamic-require)"
"(let-values(((do-dynamic-require5_0)"
"(lambda(who2_0 mod-path3_0 sym4_0 fail-k1_0)"
"(begin"
" 'do-dynamic-require5"
"(let-values(((who_0) who2_0))"
"(let-values(((mod-path_0) mod-path3_0))"
"(let-values(((sym_0) sym4_0))"
"(let-values(((fail-k_0)"
"(if(eq? fail-k1_0 unsafe-undefined)"
" default-dynamic-require-fail-thunk"
" fail-k1_0)))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(1/module-path? mod-path_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(1/module-path-index? mod-path_0)))"
"(if or-part_1 or-part_1(1/resolved-module-path? mod-path_0)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                   \"(or/c module-path? module-path-index? resolved-module-path?)\""
" mod-path_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(symbol? sym_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(not sym_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(equal? sym_0 0)))"
"(if or-part_2 or-part_2(void? sym_0)))))))"
"(void)"
"(let-values()"
"                                                    (raise-argument-error who_0 \"(or/c symbol? #f 0 void?)\" sym_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(if(procedure? fail-k_0)"
"(procedure-arity-includes? fail-k_0 0)"
" #f)"
"(void)"
"                                                    (let-values () (raise-argument-error who_0 \"(-> any)\" fail-k_0)))"
"(values))))"
"(let-values(((ns_0)(1/current-namespace)))"
"(let-values(((mpi_0)"
"(if(1/module-path? mod-path_0)"
"(let-values()(1/module-path-index-join mod-path_0 #f))"
"(if(1/module-path-index? mod-path_0)"
"(let-values() mod-path_0)"
"(let-values()"
"(1/module-path-index-join"
"(resolved-module-path->module-path mod-path_0)"
" #f))))))"
"(let-values(((mod-name_0)(1/module-path-index-resolve mpi_0 #t)))"
"(let-values(((phase_0)(namespace-phase ns_0)))"
"(if(not sym_0)"
"(let-values()"
"(let-values(((ns17_0) ns_0)"
"((mpi18_0) mpi_0)"
"((phase19_0) phase_0)"
"((phase20_0) phase_0)"
"((temp21_0) #f))"
"(namespace-module-instantiate!96.1"
" temp21_0"
" phase20_0"
" unsafe-undefined"
" #f"
" ns17_0"
" mpi18_0"
" phase19_0)))"
"(if(equal? sym_0 0)"
"(let-values()"
"(let-values(((ns22_0) ns_0)"
"((mpi23_0) mpi_0)"
"((phase24_0) phase_0)"
"((phase25_0) phase_0))"
"(namespace-module-instantiate!96.1"
" #t"
" phase25_0"
" unsafe-undefined"
" #f"
" ns22_0"
" mpi23_0"
" phase24_0)))"
"(if(void? sym_0)"
"(let-values()"
"(let-values(((ns26_0) ns_0)"
"((mpi27_0) mpi_0)"
"((phase28_0) phase_0)"
"((phase29_0) phase_0))"
"(namespace-module-visit!104.1"
" phase29_0"
" ns26_0"
" mpi27_0"
" phase28_0)))"
"(let-values()"
"(let-values(((m_0)(namespace->module ns_0 mod-name_0)))"
"(let-values((()"
"(begin"
"(if m_0"
"(void)"
"(let-values()"
"(raise-unknown-module-error"
" 'dynamic-require"
" mod-name_0)))"
"(values))))"
"(let-values(((binding/p_0)"
"(hash-ref"
"(hash-ref(module-provides m_0) 0 '#hasheq())"
" sym_0"
" #f)))"
"(if(not binding/p_0)"
"(let-values()"
"(if(eq? fail-k_0 default-dynamic-require-fail-thunk)"
"(raise-arguments-error"
" 'dynamic-require"
"                                                                 \"name is not provided\""
"                                                                 \"name\""
" sym_0"
"                                                                 \"module\""
" mod-name_0)"
"(fail-k_0)))"
"(let-values()"
"(let-values(((binding_0)"
"(provided-as-binding binding/p_0)))"
"(let-values(((ex-sym_0)"
"(module-binding-sym binding_0)))"
"(let-values(((ex-phase_0)"
"(module-binding-phase binding_0)))"
"(let-values((()"
"(begin"
"(let-values(((ns30_0) ns_0)"
"((mpi31_0) mpi_0)"
"((phase32_0) phase_0)"
"((phase33_0) phase_0)"
"((temp34_0) #f))"
"(namespace-module-instantiate!96.1"
" temp34_0"
" phase33_0"
" unsafe-undefined"
" #f"
" ns30_0"
" mpi31_0"
" phase32_0))"
"(values))))"
"(let-values(((ex-mod-name_0)"
"(1/module-path-index-resolve"
"(module-path-index-shift"
"(module-binding-module binding_0)"
"(module-self m_0)"
" mpi_0))))"
"(let-values(((m-ns_0)"
"(let-values(((ns35_0) ns_0)"
"((ex-mod-name36_0)"
" ex-mod-name_0)"
"((temp37_0)"
"(phase-"
" phase_0"
" ex-phase_0))"
"((temp38_0) #t))"
"(namespace->module-namespace82.1"
" #f"
" temp38_0"
" unsafe-undefined"
" ns35_0"
" ex-mod-name36_0"
" temp37_0))))"
"(let-values(((ex-m_0)"
"(namespace->module"
" ns_0"
" ex-mod-name_0)))"
"(let-values(((access_0)"
"(let-values(((or-part_0)"
"(module-access"
" ex-m_0)))"
"(if or-part_0"
" or-part_0"
"(module-compute-access!"
" ex-m_0)))))"
"(let-values((()"
"(begin"
"(if(if(not"
"(eq?"
" 'provided"
"(hash-ref"
"(hash-ref"
" access_0"
" ex-phase_0"
" '#hasheq())"
" ex-sym_0"
" #f)))"
"(if(not"
"(inspector-superior?"
"(current-code-inspector)"
"(namespace-inspector"
" m-ns_0)))"
"(not"
"(if(module-binding-extra-inspector"
" binding_0)"
"(inspector-superior?"
"(module-binding-extra-inspector"
" binding_0)"
"(namespace-inspector"
" m-ns_0))"
" #f))"
" #f)"
" #f)"
"(let-values()"
"(raise-arguments-error"
" 'dynamic-require"
"                                                                                                   \"name is protected\""
"                                                                                                   \"name\""
" sym_0"
"                                                                                                   \"module\""
" mod-name_0))"
"(void))"
"(values))))"
"(let-values(((fail_0)"
"(lambda()"
"(begin"
" 'fail"
"(if(eq?"
" fail-k_0"
" default-dynamic-require-fail-thunk)"
"(raise-arguments-error"
" 'dynamic-require"
"                                                                                                     \"name's binding is missing\""
"                                                                                                     \"name\""
" sym_0"
"                                                                                                     \"module\""
" mod-name_0)"
"(fail-k_0))))))"
"(if(not"
"(provided-as-transformer?"
" binding/p_0))"
"(let-values()"
"(namespace-get-variable"
" m-ns_0"
" ex-phase_0"
" ex-sym_0"
" fail_0))"
"(let-values()"
"(let-values(((missing_0)"
"(gensym 'missing)))"
"(let-values((()"
"(begin"
"(let-values(((ns39_0)"
" ns_0)"
"((mpi40_0)"
" mpi_0)"
"((phase41_0)"
" phase_0)"
"((phase42_0)"
" phase_0))"
"(namespace-module-visit!104.1"
" phase42_0"
" ns39_0"
" mpi40_0"
" phase41_0))"
"(values))))"
"(let-values(((t_0)"
"(namespace-get-transformer"
" m-ns_0"
" ex-phase_0"
" ex-sym_0"
" missing_0)))"
"(if(eq? t_0 missing_0)"
"(let-values()(fail_0))"
"(let-values()"
"(let-values(((tmp-ns_0)"
"(let-values(((ns43_0)"
" ns_0))"
"(new-namespace8.1"
" #t"
" unsafe-undefined"
" ns43_0))))"
"(let-values(((mod-path_1)"
"(resolved-module-path->module-path"
" mod-name_0)))"
"(begin"
"(1/namespace-require"
" mod-path_1"
" tmp-ns_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" tmp-ns_0)"
"(let-values()"
"(1/eval"
" sym_0"
" tmp-ns_0))))))))))))))))))))))))))))))))))))))))))))))))"
"(case-lambda"
"((who_0 mod-path_0 sym_0)(begin(do-dynamic-require5_0 who_0 mod-path_0 sym_0 unsafe-undefined)))"
"((who_0 mod-path_0 sym_0 fail-k1_0)(do-dynamic-require5_0 who_0 mod-path_0 sym_0 fail-k1_0)))))"
" (define-values (default-dynamic-require-fail-thunk) (lambda () (begin (error \"failed\"))))"
"(define-values"
"(1/dynamic-require)"
"(let-values(((dynamic-require10_0)"
"(lambda(mod-path8_0 sym9_0 fail-k7_0)"
"(begin"
" 'dynamic-require10"
"(let-values(((mod-path_0) mod-path8_0))"
"(let-values(((sym_0) sym9_0))"
"(let-values(((fail-k_0)"
"(if(eq? fail-k7_0 unsafe-undefined)"
" default-dynamic-require-fail-thunk"
" fail-k7_0)))"
"(let-values()"
"(let-values()"
"(let-values()(do-dynamic-require 'dynamic-require mod-path_0 sym_0 fail-k_0)))))))))))"
"(case-lambda"
"((mod-path_0 sym_0)(begin 'dynamic-require(dynamic-require10_0 mod-path_0 sym_0 unsafe-undefined)))"
"((mod-path_0 sym_0 fail-k7_0)(dynamic-require10_0 mod-path_0 sym_0 fail-k7_0)))))"
"(define-values"
"(1/dynamic-require-for-syntax)"
"(let-values(((dynamic-require-for-syntax15_0)"
"(lambda(mod-path13_0 sym14_0 fail-k12_0)"
"(begin"
" 'dynamic-require-for-syntax15"
"(let-values(((mod-path_0) mod-path13_0))"
"(let-values(((sym_0) sym14_0))"
"(let-values(((fail-k_0)"
"(if(eq? fail-k12_0 unsafe-undefined)"
" default-dynamic-require-fail-thunk"
" fail-k12_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
"(let-values(((ns_0)(1/current-namespace)))"
"(namespace->namespace-at-phase ns_0(add1(namespace-phase ns_0)))))"
"(let-values()"
"(do-dynamic-require"
" 'dynamic-require-for-syntax"
" mod-path_0"
" sym_0"
" fail-k_0)))))))))))))"
"(case-lambda"
"((mod-path_0 sym_0)"
"(begin 'dynamic-require-for-syntax(dynamic-require-for-syntax15_0 mod-path_0 sym_0 unsafe-undefined)))"
"((mod-path_0 sym_0 fail-k12_0)(dynamic-require-for-syntax15_0 mod-path_0 sym_0 fail-k12_0)))))"
"(define-values"
"(1/load)"
"(lambda(s_0)"
"(begin"
" 'load"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"                          (if (path-string? s_0) (void) (let-values () (raise-argument-error 'load \"path-string?\" s_0)))"
"(values))))"
"(let-values(((p_0)(->path s_0)))"
"(call-with-current-load-relative-directory p_0(lambda()((1/current-load) p_0 #f))))))))))"
"(define-values"
"(1/load-extension)"
"(lambda(s_0)"
"(begin"
" 'load-extension"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(path-string? s_0)"
"(void)"
"                            (let-values () (raise-argument-error 'load-extension \"path-string?\" s_0)))"
"(values))))"
"(let-values(((p_0)(->path s_0)))"
"(call-with-current-load-relative-directory p_0(lambda()((current-load-extension) p_0 #f))))))))))"
"(define-values"
"(call-with-current-load-relative-directory)"
"(lambda(p_0 thunk_0)"
"(begin"
"(let-values(((base_0 name_0 dir?_0)(split-path p_0)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" current-load-relative-directory"
"(if(eq? base_0 'relative)(current-directory)(path->complete-path base_0)))"
"(let-values()(thunk_0)))))))"
"(define-values"
"(1/load/use-compiled)"
"(lambda(f_0)"
"(begin"
" 'load/use-compiled"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(path-string? f_0)"
"(void)"
"                            (let-values () (raise-argument-error 'load/use-compiled \"path-string?\" f_0)))"
"(values))))"
"(let-values(((p_0)(->path f_0)))((1/current-load/use-compiled) p_0 #f))))))))"
"(define-values"
"(embedded-load)"
"(lambda(start_0 end_0 str_0 as-predefined?_0)"
"(begin"
"(let-values(((s_0)"
"(if str_0"
" str_0"
"(let-values(((sp_0)(find-system-path 'exec-file)))"
"(let-values(((exe_0)(find-executable-path sp_0 #f)))"
"(let-values(((start_1)"
"(let-values(((or-part_0)(1/string->number start_0)))"
"(if or-part_0 or-part_0 0))))"
"(let-values(((end_1)"
"(let-values(((or-part_0)(1/string->number end_0)))"
"(if or-part_0 or-part_0 0))))"
"(let-values(((exe4_0) exe_0)"
"((temp5_0)"
"(lambda()"
"(begin"
" 'temp5"
"(begin"
"(file-position(current-input-port) start_1)"
"(read-bytes(max 0(- end_1 start_1))))))))"
"(with-input-from-file45.1 'binary exe4_0 temp5_0)))))))))"
"(let-values(((p_0)(open-input-bytes s_0)))"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((e_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/read-accept-compiled"
" #t"
" 1/read-accept-reader"
" #t"
" 1/read-accept-lang"
" #t"
" read-on-demand-source"
" #t)"
"(let-values()(1/read p_0)))))"
"(if(eof-object? e_0)"
"(void)"
"(let-values()"
"(begin"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" current-module-declare-as-predefined"
" as-predefined?_0)"
"(let-values()((1/current-eval) e_0)))"
"(loop_0)))))))))"
" loop_0)))))))"
"(define-values(->path)(lambda(s_0)(begin(if(string? s_0)(string->path s_0) s_0))))"
"(define-values"
"(find-main-collects)"
"(lambda()"
"(begin(cache-configuration 0(lambda()(exe-relative-path->complete-path(find-system-path 'collects-dir)))))))"
"(define-values"
"(find-main-config)"
"(lambda()"
"(begin(cache-configuration 1(lambda()(exe-relative-path->complete-path(find-system-path 'config-dir)))))))"
"(define-values"
"(exe-relative-path->complete-path)"
"(lambda(collects-path_0)"
"(begin"
"(if(complete-path? collects-path_0)"
"(let-values()(simplify-path collects-path_0))"
"(if(absolute-path? collects-path_0)"
"(let-values()"
"(let-values(((exec_0)"
"(path->complete-path"
"(find-executable-path(find-system-path 'exec-file))"
"(find-system-path 'orig-dir))))"
"(let-values(((base_0 name_0 dir?_0)(split-path exec_0)))"
"(simplify-path(path->complete-path collects-path_0 base_0)))))"
"(let-values()"
"(let-values(((p_0)(find-executable-path(find-system-path 'exec-file) collects-path_0 #t)))"
"(if p_0(simplify-path p_0) #f))))))))"
"(define-values(relative-path-string?)(lambda(s_0)(begin(if(path-string? s_0)(relative-path? s_0) #f))))"
"(define-values"
"(check-collection)"
"(lambda(who_0 s_0 l_0)"
"(begin"
"(begin"
"(if(relative-path-string? s_0)"
"(void)"
"          (let-values () (raise-argument-error who_0 \"(and/c path-string? relative-path?)\" s_0)))"
"(if((lambda(l_1)(if(list? l_1)(andmap2 relative-path-string? l_1) #f)) l_0)"
"(void)"
"          (let-values () (raise-argument-error who_0 \"(listof (and/c path-string? relative-path?))\" l_0)))))))"
"(define-values"
"(check-fail)"
"(lambda(who_0 fail_0)"
"(begin"
"(if((lambda(p_0)(if(procedure? p_0)(procedure-arity-includes? p_0 1) #f)) fail_0)"
"(void)"
"        (let-values () (raise-argument-error who_0 \"(procedure-arity-includes/c 1)\" fail_0))))))"
"(define-values"
"(1/collection-path)"
"(lambda(fail_0 collection_0 collection-path_0)"
"(begin"
" 'collection-path"
"(let-values()"
"(let-values()"
"(begin"
"(check-collection 'collection-path collection_0 collection-path_0)"
"(check-fail 'collection-path fail_0)"
"(find-col-file fail_0 collection_0 collection-path_0 #f #f)))))))"
"(define-values"
"(1/collection-file-path)"
"(lambda(fail_0 check-compiled?_0 file-name_0 collection_0 collection-path_0)"
"(begin"
" 'collection-file-path"
"(let-values()"
"(let-values()"
"(begin"
"(if(relative-path-string? file-name_0)"
"(void)"
"(let-values()"
"                (raise-argument-error 'collection-file-path \"(and/c path-string? relative-path?)\" file-name_0)))"
"(check-collection 'collection-file-path collection_0 collection-path_0)"
"(check-fail 'collection-file-path fail_0)"
"(find-col-file fail_0 collection_0 collection-path_0 file-name_0 check-compiled?_0)))))))"
"(define-values"
"(get-config-table)"
"(lambda(d_0)"
"(begin"
"      (let-values (((p_0) (if d_0 (build-path d_0 \"config.rktd\") #f)))"
"(let-values(((or-part_0)"
"(if p_0"
"(if(file-exists? p_0)"
"(let-values(((p7_0) p_0)"
"((temp8_0)"
"(lambda()"
"(begin"
" 'temp8"
"(let-values(((v_0)(call-with-default-reading-parameterization 1/read)))"
"(if(hash? v_0) v_0 #f))))))"
"(with-input-from-file45.1 'binary p7_0 temp8_0))"
" #f)"
" #f)))"
"(if or-part_0 or-part_0 '#hash()))))))"
"(define-values"
"(get-installation-name)"
"(lambda(config-table_0)(begin(hash-ref config-table_0 'installation-name(version)))))"
"(define-values"
"(coerce-to-path)"
"(lambda(p_0)"
"(begin"
"(if(string? p_0)"
"(let-values()(collects-relative-path->complete-path(string->path p_0)))"
"(if(bytes? p_0)"
"(let-values()(collects-relative-path->complete-path(bytes->path p_0)))"
"(if(path? p_0)(let-values()(collects-relative-path->complete-path p_0))(let-values() p_0)))))))"
"(define-values"
"(collects-relative-path->complete-path)"
"(lambda(p_0)"
"(begin"
"(if(complete-path? p_0)"
"(let-values() p_0)"
"(let-values()"
"(path->complete-path"
" p_0"
"(let-values(((or-part_0)(find-main-collects)))(if or-part_0 or-part_0(current-directory)))))))))"
"(define-values"
"(add-config-search)"
"(lambda(ht_0 key_0 orig-l_0)"
"(begin"
"(let-values(((l_0)(hash-ref ht_0 key_0 #f)))"
"(if l_0"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null? l_1)"
"(let-values() null)"
"(if(not(car l_1))"
"(let-values()(append orig-l_0(loop_0(cdr l_1))))"
"(let-values()(cons(coerce-to-path(car l_1))(loop_0(cdr l_1))))))))))"
" loop_0)"
" l_0)"
" orig-l_0)))))"
"(define-values"
"(1/find-library-collection-links)"
"(lambda()"
"(begin"
" 'find-library-collection-links"
"(let-values(((ht_0)(get-config-table(find-main-config))))"
"(let-values(((lf_0)"
"(coerce-to-path"
"(let-values(((or-part_0)(hash-ref ht_0 'links-file #f)))"
"(if or-part_0"
" or-part_0"
"(build-path"
"(let-values(((or-part_1)(hash-ref ht_0 'share-dir #f)))"
"                              (if or-part_1 or-part_1 (build-path 'up \"share\")))"
"                            \"links.rktd\"))))))"
"(append"
"(list #f)"
"(if(if(1/use-user-specific-search-paths)(1/use-collection-link-paths) #f)"
"             (list (build-path (find-system-path 'addon-dir) (get-installation-name ht_0) \"links.rktd\"))"
" null)"
"(if(1/use-collection-link-paths)(add-config-search ht_0 'links-search-files(list lf_0)) null)))))))"
"(define-values(cell.1$1)(unsafe-make-place-local(make-weak-hash)))"
"(define-values(collection-place-init!)(lambda()(begin(unsafe-place-local-set! cell.1$1(make-weak-hash)))))"
"(define-values(stamp-prompt-tag)(make-continuation-prompt-tag 'stamp))"
"(define-values"
"(file->stamp)"
"(lambda(path_0 old-stamp_0)"
"(begin"
"(if(if old-stamp_0(if(cdr old-stamp_0)(not(sync/timeout 0(cdr old-stamp_0))) #f) #f)"
"(let-values() old-stamp_0)"
"(let-values()"
"(call-with-continuation-prompt"
"(lambda()"
"(call-with-exception-handler"
"(lambda(exn_0)"
"(abort-current-continuation"
" stamp-prompt-tag"
"(if(exn:fail:filesystem? exn_0)(lambda() #f)(lambda()(raise exn_0)))))"
"(lambda()"
"(let-values(((dir-evt_0)"
"(if(vector-ref(system-type 'fs-change) 2)"
"((letrec-values(((loop_0)"
"(lambda(path_1)"
"(begin"
" 'loop"
"(let-values(((base_0 name_0 dir?_0)(split-path path_1)))"
"(if(path? base_0)"
"(if(directory-exists? base_0)"
"(filesystem-change-evt base_0(lambda() #f))"
"(loop_0 base_0))"
" #f))))))"
" loop_0)"
" path_0)"
" #f)))"
"(if(not(file-exists? path_0))"
"(let-values()(cons #f dir-evt_0))"
"(let-values()"
"(let-values(((evt_0)"
"(if(vector-ref(system-type 'fs-change) 2)"
"(filesystem-change-evt path_0(lambda() #f))"
" #f)))"
"(begin"
"(if dir-evt_0(let-values()(filesystem-change-evt-cancel dir-evt_0))(void))"
"(cons(file->bytes path_0) evt_0)))))))))"
" stamp-prompt-tag))))))"
"(define-values"
"(file->bytes)"
"(lambda(path_0)"
"(begin"
"(let-values(((path9_0) path_0)"
"((temp10_0)"
"(lambda(p_0)"
"(begin"
" 'temp10"
"(let-values(((bstr_0)(read-bytes 8192 p_0)))"
"(if(if(bytes? bstr_0)(>=(bytes-length bstr_0) 8192) #f)"
"(apply"
" bytes-append"
"(cons"
" bstr_0"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((bstr_1)(read-bytes 8192 p_0)))"
"(if(eof-object? bstr_1) null(cons bstr_1(loop_0))))))))"
" loop_0))))"
" bstr_0))))))"
"(call-with-input-file*61.1 'binary path9_0 temp10_0)))))"
"(define-values"
"(no-file-stamp?)"
"(lambda(a_0)(begin(let-values(((or-part_0)(not a_0)))(if or-part_0 or-part_0(not(car a_0)))))))"
"(define-values"
"(get-linked-collections)"
"(lambda(links-path_0)"
"(begin"
"(call/ec"
"(lambda(esc_0)"
"(let-values(((make-handler_0)"
"(lambda(ts_0)"
"(begin"
" 'make-handler"
"(lambda(exn_0)"
"(begin"
"(if(exn:fail? exn_0)"
"(let-values(((l_0)(current-logger)))"
"(if(log-level? l_0 'error)"
"(let-values()"
"(log-message"
" l_0"
" 'error"
"(format"
"                                         \"error reading collection links file ~s: ~a\""
" links-path_0"
"(exn-message exn_0))"
"(current-continuation-marks)))"
"(void)))"
"(void))"
"(if ts_0"
"(let-values()"
"(hash-set!(unsafe-place-local-ref cell.1$1) links-path_0(cons ts_0 '#hasheq())))"
"(void))"
"(if(exn:fail? exn_0)(esc_0(make-hasheq)) exn_0)))))))"
"(call-with-exception-handler"
"(make-handler_0 #f)"
"(lambda()"
"(let-values(((links-stamp+cache_0)"
"(hash-ref(unsafe-place-local-ref cell.1$1) links-path_0 '(#f . #hasheq()))))"
"(let-values(((a-links-stamp_0)(car links-stamp+cache_0)))"
"(let-values(((ts_0)(file->stamp links-path_0 a-links-stamp_0)))"
"(if(equal? ts_0 a-links-stamp_0)"
"(let-values()(cdr links-stamp+cache_0))"
"(let-values()"
"(call-with-exception-handler"
"(make-handler_0 ts_0)"
"(lambda()"
"(call-with-default-reading-parameterization"
"(lambda()"
"(let-values(((v_0)"
"(if(no-file-stamp? ts_0)"
" null"
"(let-values(((links-path11_0) links-path_0)"
"((temp12_0)"
"(lambda(p_0)"
"(begin"
" 'temp12"
"(begin0"
"(1/read p_0)"
"(if(eof-object?(1/read p_0))"
"(void)"
"(let-values()"
"                                                                      (error \"expected a single S-expression\"))))))))"
"(call-with-input-file*61.1 'binary links-path11_0 temp12_0)))))"
"(let-values((()"
"(begin"
"(if(if(list? v_0)"
"(andmap2"
"(lambda(p_0)"
"(if(list? p_0)"
"(if(let-values(((or-part_0)(= 2(length p_0))))"
"(if or-part_0 or-part_0(= 3(length p_0))))"
"(if(let-values(((or-part_0)(string?(car p_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eq? 'root(car p_0))))"
"(if or-part_1"
" or-part_1"
"(eq? 'static-root(car p_0))))))"
"(if(path-string?(cadr p_0))"
"(let-values(((or-part_0)(null?(cddr p_0))))"
"(if or-part_0 or-part_0(regexp?(caddr p_0))))"
" #f)"
" #f)"
" #f)"
" #f))"
" v_0)"
" #f)"
"(void)"
"                                                  (let-values () (error \"ill-formed content\")))"
"(values))))"
"(let-values(((ht_0)(make-hasheq)))"
"(let-values(((dir_0)"
"(let-values(((base_0 name_0 dir?_0)(split-path links-path_0)))"
" base_0)))"
"(begin"
"(for-each2"
"(lambda(p_0)"
"(if(let-values(((or-part_0)(null?(cddr p_0))))"
"(if or-part_0 or-part_0(regexp-match?(caddr p_0)(version))))"
"(let-values()"
"(let-values(((dir_1)"
"(simplify-path(path->complete-path(cadr p_0) dir_0))))"
"(if(eq?(car p_0) 'static-root)"
"(let-values()"
"(for-each2"
"(lambda(sub_0)"
"(if(directory-exists?(build-path dir_1 sub_0))"
"(let-values()"
"(let-values(((k_0)(string->symbol(path->string sub_0))))"
"(hash-set!"
" ht_0"
" k_0"
"(cons dir_1(hash-ref ht_0 k_0 null)))))"
"(void)))"
"(directory-list dir_1)))"
"(if(eq?(car p_0) 'root)"
"(let-values()"
"(begin"
"(if(hash-ref ht_0 #f #f)"
"(void)"
"(let-values()(hash-set! ht_0 #f null)))"
"(hash-for-each"
" ht_0"
"(lambda(k_0 v_1)(hash-set! ht_0 k_0(cons dir_1 v_1))))))"
"(let-values()"
"(let-values(((s_0)(string->symbol(car p_0))))"
"(hash-set!"
" ht_0"
" s_0"
"(cons(box dir_1)(hash-ref ht_0 s_0 null)))))))))"
"(void)))"
" v_0)"
"(hash-for-each ht_0(lambda(k_0 v_1)(hash-set! ht_0 k_0(reverse$1 v_1))))"
"(hash-set!(unsafe-place-local-ref cell.1$1) links-path_0(cons ts_0 ht_0))"
" ht_0))))))))))))))))))))))"
"(define-values"
"(normalize-collection-reference)"
"(lambda(collection_0 collection-path_0)"
"(begin"
"(if(string? collection_0)"
"(let-values()"
"          (let-values (((m_0) (regexp-match-positions '#rx\"/+\" collection_0)))"
"(if m_0"
"(if(=(caar m_0)(sub1(string-length collection_0)))"
"(let-values()(values(substring collection_0 0(caar m_0)) collection-path_0))"
"(let-values()"
"(values"
"(substring collection_0 0(caar m_0))"
"(cons(substring collection_0(cdar m_0)) collection-path_0))))"
"(values collection_0 collection-path_0))))"
"(let-values()"
"(let-values(((base_0 name_0 dir?_0)(split-path collection_0)))"
"(if(eq? base_0 'relative)"
"(values name_0 collection-path_0)"
"(normalize-collection-reference base_0(cons name_0 collection-path_0)))))))))"
"(define-values"
"(find-col-file)"
"(lambda(fail_0 collection-in_0 collection-path-in_0 file-name_0 check-compiled?_0)"
"(begin"
"(let-values(((collection_0 collection-path_0)"
"(normalize-collection-reference collection-in_0 collection-path-in_0)))"
"(let-values(((all-paths_0)"
"(let-values(((sym_0)"
"(string->symbol"
"(if(path? collection_0)(path->string collection_0) collection_0))))"
"((letrec-values(((loop_0)"
"(lambda(l_0)"
"(begin"
" 'loop"
"(if(null? l_0)"
"(let-values() null)"
"(if(not(car l_0))"
"(let-values()"
"(append(1/current-library-collection-paths)(loop_0(cdr l_0))))"
"(if(hash?(car l_0))"
"(let-values()"
"(append"
"(map2 box(hash-ref(car l_0) sym_0 null))"
"(hash-ref(car l_0) #f null)"
"(loop_0(cdr l_0))))"
"(let-values()"
"(let-values(((ht_0)(get-linked-collections(car l_0))))"
"(append"
"(hash-ref ht_0 sym_0 null)"
"(hash-ref ht_0 #f null)"
"(loop_0(cdr l_0))))))))))))"
" loop_0)"
"(1/current-library-collection-links)))))"
"(let-values(((done_0)(lambda(p_0)(begin 'done(if file-name_0(build-path p_0 file-name_0) p_0)))))"
"(let-values(((*build-path-rep_0)"
"(lambda(p_0 c_0)"
"(begin '*build-path-rep(if(path? p_0)(build-path p_0 c_0)(unbox p_0))))))"
"(let-values(((*directory-exists?_0)"
"(lambda(orig_0 p_0)"
"(begin '*directory-exists?(if(path? orig_0)(directory-exists? p_0) #t)))))"
"(let-values(((to-string_0)(lambda(p_0)(begin 'to-string(if(path? p_0)(path->string p_0) p_0)))))"
"((letrec-values(((cloop_0)"
"(lambda(paths_0 found-col_0)"
"(begin"
" 'cloop"
"(if(null? paths_0)"
"(if found-col_0"
"(done_0 found-col_0)"
"(let-values(((rest-coll_0)"
"(if(null? collection-path_0)"
"                                                            \"\""
"(apply"
" string-append"
"((letrec-values(((loop_0)"
"(lambda(cp_0)"
"(begin"
" 'loop"
"(if(null?(cdr cp_0))"
"(list(to-string_0(car cp_0)))"
"(list*"
"(to-string_0(car cp_0))"
"                                                                                      \"/\""
"(loop_0(cdr cp_0))))))))"
" loop_0)"
" collection-path_0)))))"
"(letrec-values(((filter_0)"
"(lambda(f_0 l_0)"
"(begin"
" 'filter"
"(if(null? l_0)"
" null"
"(if(f_0(car l_0))"
"(cons(car l_0)(filter_0 f_0(cdr l_0)))"
"(filter_0 f_0(cdr l_0))))))))"
"(fail_0"
"(format"
"                                                  \"collection not found\\n  collection: ~s\\n  in collection directories:~a~a\""
"(if(null? collection-path_0)"
"(to-string_0 collection_0)"
"                                                    (string-append (to-string_0 collection_0) \"/\" rest-coll_0))"
"(apply"
" string-append"
"(map2"
"                                                    (lambda (p_0) (format \"\\n ~a ~a\" \" \" p_0))"
"(let-values(((len_0)(length all-paths_0))"
"((clen_0)"
"(length(1/current-library-collection-paths))))"
"(if(<(- len_0 clen_0) 5)"
" all-paths_0"
"(append"
"(1/current-library-collection-paths)"
"(list"
"(format"
"                                                           \"... [~a additional linked and package directories]\""
"(- len_0 clen_0))))))))"
"(if(ormap2 box? all-paths_0)"
"(format"
"                                                     \"\\n   sub-collection: ~s\\n  in parent directories:~a\""
" rest-coll_0"
"(apply"
" string-append"
"(map2"
"                                                       (lambda (p_0) (format \"\\n   ~a\" (unbox p_0)))"
"(filter_0 box? all-paths_0))))"
"                                                    \"\"))))))"
"(let-values(((dir_0)(*build-path-rep_0(car paths_0) collection_0)))"
"(if(*directory-exists?_0(car paths_0) dir_0)"
"(let-values(((cpath_0)(apply build-path dir_0 collection-path_0)))"
"(if(if(null? collection-path_0) #t(directory-exists? cpath_0))"
"(if file-name_0"
"(if(let-values(((or-part_0)"
"(file-exists?/maybe-compiled"
" cpath_0"
" file-name_0"
" check-compiled?_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((alt-file-name_0)"
"(let-values(((file-name_1)"
"(if(path? file-name_0)"
"(path->string file-name_0)"
" file-name_0)))"
"(let-values(((len_0)"
"(string-length file-name_1)))"
"(if(>= len_0 4)"
"(if(string=?"
"                                                                                     \".rkt\""
"(substring"
" file-name_1"
"(- len_0 4)))"
"(string-append"
"(substring file-name_1 0(- len_0 4))"
"                                                                                   \".ss\")"
" #f)"
" #f)))))"
"(if alt-file-name_0"
"(file-exists?/maybe-compiled"
" cpath_0"
" alt-file-name_0"
" check-compiled?_0)"
" #f))))"
"(done_0 cpath_0)"
"(cloop_0"
"(cdr paths_0)"
"(let-values(((or-part_0) found-col_0))"
"(if or-part_0 or-part_0 cpath_0))))"
"(done_0 cpath_0))"
"(cloop_0(cdr paths_0) found-col_0)))"
"(cloop_0(cdr paths_0) found-col_0))))))))"
" cloop_0)"
" all-paths_0"
" #f))))))))))"
"(define-values"
"(file-exists?/maybe-compiled)"
"(lambda(dir_0 path_0 check-compiled?_0)"
"(begin"
"(let-values(((or-part_0)(file-exists?(build-path dir_0 path_0))))"
"(if or-part_0"
" or-part_0"
"(if check-compiled?_0"
"            (let-values (((try-path_0) (path-add-extension path_0 #\".zo\"))"
"((modes_0)(1/use-compiled-file-paths))"
"((roots_0)(1/current-compiled-file-roots)))"
"(ormap2"
"(lambda(d_0)"
"(ormap2"
"(lambda(mode_0)"
"(file-exists?"
"(let-values(((p_0)(build-path dir_0 mode_0 try-path_0)))"
"(if(eq? d_0 'same)"
"(let-values() p_0)"
"(if(relative-path? d_0)"
"(let-values()(build-path p_0 d_0))"
"(let-values()(reroot-path p_0 d_0)))))))"
" modes_0))"
" roots_0))"
" #f))))))"
"(define-values"
"(1/find-library-collection-paths)"
"(let-values(((find-library-collection-paths3_0)"
"(lambda(extra-collects-dirs1_0 post-collects-dirs2_0)"
"(begin"
" 'find-library-collection-paths3"
"(let-values(((extra-collects-dirs_0) extra-collects-dirs1_0))"
"(let-values(((post-collects-dirs_0) post-collects-dirs2_0))"
"(let-values()"
"(let-values(((user-too?_0)(1/use-user-specific-search-paths))"
"((cons-if_0)(lambda(f_0 r_0)(begin 'cons-if(if f_0(cons f_0 r_0) r_0))))"
"((config-table_0)(get-config-table(find-main-config))))"
"(path-list-string->path-list"
"(if user-too?_0"
"(let-values(((c_0)"
"(environment-variables-ref"
"(current-environment-variables)"
"                                              #\"PLTCOLLECTS\")))"
"                                 (if c_0 (bytes->string/locale c_0 '#\\?) \"\"))"
"                               \"\")"
"(add-config-search"
" config-table_0"
" 'collects-search-dirs"
"(cons-if_0"
"(if user-too?_0"
"(build-path"
"(find-system-path 'addon-dir)"
"(get-installation-name config-table_0)"
"                                  \"collects\")"
" #f)"
"((letrec-values(((loop_0)"
"(lambda(l_0)"
"(begin"
" 'loop"
"(if(null? l_0)"
" null"
"(let-values(((collects-path_0)(car l_0)))"
"(let-values(((v_0)"
"(exe-relative-path->complete-path"
" collects-path_0)))"
"(if v_0"
"(cons"
"(simplify-path"
"(path->complete-path v_0(current-directory)))"
"(loop_0(cdr l_0)))"
"(loop_0(cdr l_0))))))))))"
" loop_0)"
"(append"
" extra-collects-dirs_0"
"(list(find-system-path 'collects-dir))"
" post-collects-dirs_0)))))))))))))"
"(case-lambda"
"(()(begin 'find-library-collection-paths(find-library-collection-paths3_0 null null)))"
"((extra-collects-dirs_0 post-collects-dirs2_0)"
"(find-library-collection-paths3_0 extra-collects-dirs_0 post-collects-dirs2_0))"
"((extra-collects-dirs1_0)(find-library-collection-paths3_0 extra-collects-dirs1_0 null)))))"
"(define-values(prop:readtable prop:readtable? prop:readtable-ref)(make-struct-type-property 'readtable))"
"(define-values"
"(1/current-readtable)"
"(let-values()"
"(let-values()"
"(make-parameter"
" #f"
"(lambda(v_0)"
"(begin"
"(if((lambda(x_0)(let-values(((or-part_0)(not x_0)))(if or-part_0 or-part_0(prop:readtable? x_0))))"
" v_0)"
"(void)"
"             (let-values () (raise-argument-error 'current-readtable \"(or/c prop:readtable? #f)\" v_0)))"
" v_0))))))"
"(define-values"
"(struct:read-config/outer"
" read-config/outer1.1"
" read-config/outer?"
" read-config/outer-inner"
" read-config/outer-wrap"
" read-config/outer-line"
" read-config/outer-col"
" read-config/outer-pos"
" read-config/outer-indentations"
" read-config/outer-keep-comment?)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'read-config"
" #f"
" 7"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6)"
" #f"
" 'read-config/outer)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'inner)"
"(make-struct-field-accessor -ref_0 1 'wrap)"
"(make-struct-field-accessor -ref_0 2 'line)"
"(make-struct-field-accessor -ref_0 3 'col)"
"(make-struct-field-accessor -ref_0 4 'pos)"
"(make-struct-field-accessor -ref_0 5 'indentations)"
"(make-struct-field-accessor -ref_0 6 'keep-comment?))))"
"(define-values"
"(struct:read-config/inner"
" read-config/inner2.1"
" read-config/inner?"
" read-config/inner-readtable"
" read-config/inner-next-readtable"
" read-config/inner-for-syntax?"
" read-config/inner-source"
" read-config/inner-read-compiled"
" read-config/inner-call-with-root-namespace"
" read-config/inner-dynamic-require"
" read-config/inner-module-declared?"
" read-config/inner-coerce"
" read-config/inner-coerce-key"
" read-config/inner-parameter-override"
" read-config/inner-parameter-cache"
" read-config/inner-st)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'read-config/inner"
" #f"
" 13"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3 4 5 6 7 8 9 10 11 12)"
" #f"
" 'read-config/inner)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'readtable)"
"(make-struct-field-accessor -ref_0 1 'next-readtable)"
"(make-struct-field-accessor -ref_0 2 'for-syntax?)"
"(make-struct-field-accessor -ref_0 3 'source)"
"(make-struct-field-accessor -ref_0 4 'read-compiled)"
"(make-struct-field-accessor -ref_0 5 'call-with-root-namespace)"
"(make-struct-field-accessor -ref_0 6 'dynamic-require)"
"(make-struct-field-accessor -ref_0 7 'module-declared?)"
"(make-struct-field-accessor -ref_0 8 'coerce)"
"(make-struct-field-accessor -ref_0 9 'coerce-key)"
"(make-struct-field-accessor -ref_0 10 'parameter-override)"
"(make-struct-field-accessor -ref_0 11 'parameter-cache)"
"(make-struct-field-accessor -ref_0 12 'st))))"
"(define-values"
"(read-config/make)"
"(lambda(readtable_0"
" next-readtable_0"
" for-syntax?_0"
" source_0"
" wrap_0"
" read-compiled_0"
" call-with-root-namespace_0"
" dynamic-require_0"
" module-declared?_0"
" coerce_0"
" coerce-key_0"
" line_0"
" col_0"
" pos_0"
" indentations_0"
" keep-comment?_0"
" parameter-override_0"
" parameter-cache_0"
" st_0)"
"(begin"
"(read-config/outer1.1"
"(read-config/inner2.1"
" readtable_0"
" next-readtable_0"
" for-syntax?_0"
" source_0"
" read-compiled_0"
" call-with-root-namespace_0"
" dynamic-require_0"
" module-declared?_0"
" coerce_0"
" coerce-key_0"
" parameter-override_0"
" parameter-cache_0"
" st_0)"
" wrap_0"
" line_0"
" col_0"
" pos_0"
" indentations_0"
" keep-comment?_0))))"
"(define-values(read-config-wrap)(lambda(v_0)(begin(read-config/outer-wrap v_0))))"
"(define-values(read-config-line)(lambda(v_0)(begin(read-config/outer-line v_0))))"
"(define-values(read-config-col)(lambda(v_0)(begin(read-config/outer-col v_0))))"
"(define-values(read-config-pos)(lambda(v_0)(begin(read-config/outer-pos v_0))))"
"(define-values(read-config-indentations)(lambda(v_0)(begin(read-config/outer-indentations v_0))))"
"(define-values(read-config-keep-comment?)(lambda(v_0)(begin(read-config/outer-keep-comment? v_0))))"
"(define-values"
"(read-config-readtable)"
"(lambda(v_0)(begin(read-config/inner-readtable(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-next-readtable)"
"(lambda(v_0)(begin(read-config/inner-next-readtable(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-for-syntax?)"
"(lambda(v_0)(begin(read-config/inner-for-syntax?(read-config/outer-inner v_0)))))"
"(define-values(read-config-source)(lambda(v_0)(begin(read-config/inner-source(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-read-compiled)"
"(lambda(v_0)(begin(read-config/inner-read-compiled(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-call-with-root-namespace)"
"(lambda(v_0)(begin(read-config/inner-call-with-root-namespace(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-dynamic-require)"
"(lambda(v_0)(begin(read-config/inner-dynamic-require(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-module-declared?)"
"(lambda(v_0)(begin(read-config/inner-module-declared?(read-config/outer-inner v_0)))))"
"(define-values(read-config-coerce)(lambda(v_0)(begin(read-config/inner-coerce(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-coerce-key)"
"(lambda(v_0)(begin(read-config/inner-coerce-key(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-parameter-override)"
"(lambda(v_0)(begin(read-config/inner-parameter-override(read-config/outer-inner v_0)))))"
"(define-values"
"(read-config-parameter-cache)"
"(lambda(v_0)(begin(read-config/inner-parameter-cache(read-config/outer-inner v_0)))))"
"(define-values(read-config-st)(lambda(v_0)(begin(read-config/inner-st(read-config/outer-inner v_0)))))"
"(define-values"
"(struct:read-config-state"
" read-config-state3.1"
" read-config-state?"
" read-config-state-accum-str"
" read-config-state-graph"
" set-read-config-state-accum-str!"
" set-read-config-state-graph!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'read-config-state"
" #f"
" 2"
" 0"
" #f"
" null"
"(current-inspector)"
" #f"
" '()"
" #f"
" 'read-config-state)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'accum-str)"
"(make-struct-field-accessor -ref_0 1 'graph)"
"(make-struct-field-mutator -set!_0 0 'accum-str)"
"(make-struct-field-mutator -set!_0 1 'graph))))"
"(define-values(default-val.1) #f)"
"(define-values"
"(current-read-config)"
"(lambda()(begin(continuation-mark-set-first #f current-read-config default-val.1 root-tag))))"
"(define-values"
"(make-read-config28.1)"
"(lambda(call-with-root-namespace10_0"
" coerce13_0"
" coerce-key14_0"
" dynamic-require11_0"
" for-syntax?5_0"
" keep-comment?15_0"
" module-declared?12_0"
" next-readtable7_0"
" read-compiled9_0"
" readtable6_0"
" source4_0"
" wrap8_0)"
"(begin"
" 'make-read-config28"
"(let-values(((source_0) source4_0))"
"(let-values(((for-syntax?_0) for-syntax?5_0))"
"(let-values(((readtable_0)(if(eq? readtable6_0 unsafe-undefined)(1/current-readtable) readtable6_0)))"
"(let-values(((next-readtable_0)"
"(if(eq? next-readtable7_0 unsafe-undefined) readtable_0 next-readtable7_0)))"
"(let-values(((wrap_0) wrap8_0))"
"(let-values(((read-compiled_0) read-compiled9_0))"
"(let-values(((call-with-root-namespace_0) call-with-root-namespace10_0))"
"(let-values(((dynamic-require_0) dynamic-require11_0))"
"(let-values(((module-declared?_0) module-declared?12_0))"
"(let-values(((coerce_0) coerce13_0))"
"(let-values(((coerce-key_0) coerce-key14_0))"
"(let-values(((keep-comment?_0) keep-comment?15_0))"
"(let-values()"
"(read-config/make"
" readtable_0"
" next-readtable_0"
" for-syntax?_0"
" source_0"
" wrap_0"
"(let-values(((or-part_0) read-compiled_0))"
"                                   (if or-part_0 or-part_0 (lambda (in_0) (error 'read \"no `read-compiled` provided\"))))"
"(let-values(((or-part_0) call-with-root-namespace_0))"
"(if or-part_0"
" or-part_0"
"                                     (lambda (thunk_0) (error 'read \"no `call-with-root-namespace` provided\"))))"
"(let-values(((or-part_0) dynamic-require_0))"
"(if or-part_0"
" or-part_0"
"(lambda(mod-path_0 sym_0 failure-k_0)"
"                                       (error 'read \"no `dynamic-require` provided\"))))"
"(let-values(((or-part_0) module-declared?_0))"
"(if or-part_0"
" or-part_0"
"                                     (lambda (mod-path_0) (error 'read \"no `module-declare?` provided\"))))"
"(let-values(((or-part_0) coerce_0))"
"(if or-part_0 or-part_0(lambda(for-syntax?_1 v_0 srcloc_0) v_0)))"
"(let-values(((or-part_0) coerce-key_0))"
"(if or-part_0 or-part_0(lambda(for-syntax?_1 v_0) v_0)))"
" #f"
" #f"
" #f"
" null"
" keep-comment?_0"
" '#hasheq()"
"(make-hasheq)"
"(read-config-state3.1 #f #f))))))))))))))))))"
"(define-values"
"(read-config-update44.1)"
"(lambda(for-syntax?31_0 keep-comment?36_0 next-readtable34_0 readtable33_0 reset-graph?35_0 wrap32_0 config43_0)"
"(begin"
" 'read-config-update44"
"(let-values(((config_0) config43_0))"
"(let-values(((for-syntax?_0) for-syntax?31_0))"
"(let-values(((wrap_0) wrap32_0))"
"(let-values(((readtable_0) readtable33_0))"
"(let-values(((next-readtable_0)"
"(if(eq? next-readtable34_0 unsafe-undefined)"
"(read-config-readtable config_0)"
" next-readtable34_0)))"
"(let-values(((local-graph?_0) reset-graph?35_0))"
"(let-values(((keep-comment?_0) keep-comment?36_0))"
"(let-values()"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((wrap57_0) wrap_0)"
"((keep-comment?58_0) keep-comment?_0)"
"((inner59_0)"
"(let-values(((the-struct_1)(read-config/outer-inner v_0)))"
"(if(read-config/inner? the-struct_1)"
"(let-values(((for-syntax?60_0) for-syntax?_0)"
"((readtable61_0) readtable_0)"
"((next-readtable62_0) next-readtable_0)"
"((st63_0)"
"(if local-graph?_0"
"(read-config-state3.1 #f #f)"
"(read-config-st config_0))))"
"(read-config/inner2.1"
" readtable61_0"
" next-readtable62_0"
" for-syntax?60_0"
"(read-config/inner-source the-struct_1)"
"(read-config/inner-read-compiled the-struct_1)"
"(read-config/inner-call-with-root-namespace the-struct_1)"
"(read-config/inner-dynamic-require the-struct_1)"
"(read-config/inner-module-declared? the-struct_1)"
"(read-config/inner-coerce the-struct_1)"
"(read-config/inner-coerce-key the-struct_1)"
"(read-config/inner-parameter-override the-struct_1)"
"(read-config/inner-parameter-cache the-struct_1)"
" st63_0))"
"                                              (raise-argument-error 'struct-copy \"read-config/inner?\" the-struct_1)))))"
"(read-config/outer1.1"
" inner59_0"
" wrap57_0"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
" keep-comment?58_0))"
"                            (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))))))))))"
"(define-values"
"(port+config->srcloc51.1)"
"(lambda(end-pos47_0 in49_0 config50_0)"
"(begin"
" 'port+config->srcloc51"
"(let-values(((in_0) in49_0))"
"(let-values(((config_0) config50_0))"
"(let-values(((given-end-pos_0) end-pos47_0))"
"(let-values()"
"(let-values(((end-pos_0)"
"(let-values(((or-part_0) given-end-pos_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((end-line_0 end-col_0 end-pos_0)(port-next-location in_0)))"
" end-pos_0)))))"
"(srcloc"
"(let-values(((or-part_0)(read-config-source config_0)))"
"(if or-part_0"
" or-part_0"
"                     (let-values (((or-part_1) (object-name in_0))) (if or-part_1 or-part_1 \"UNKNOWN\"))))"
"(read-config-line config_0)"
"(read-config-col config_0)"
"(read-config-pos config_0)"
"(if(read-config-pos config_0)"
"(if end-pos_0(max 0(- end-pos_0(read-config-pos config_0))) #f)"
" #f))))))))))"
"(define-values"
"(reading-at)"
"(lambda(config_0 line_0 col_0 pos_0)"
"(begin"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((line64_0) line_0)"
"((col65_0) col_0)"
"((pos66_0) pos_0)"
"((inner67_0)(read-config/outer-inner v_0)))"
"(read-config/outer1.1"
" inner67_0"
"(read-config/outer-wrap the-struct_0)"
" line64_0"
" col65_0"
" pos66_0"
"(read-config/outer-indentations the-struct_0)"
"(read-config/outer-keep-comment? the-struct_0)))"
"            (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))"
"(define-values"
"(disable-wrapping)"
"(lambda(config_0)"
"(begin"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((wrap68_0) #f)((inner69_0)(read-config/outer-inner v_0)))"
"(read-config/outer1.1"
" inner69_0"
" wrap68_0"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
"(read-config/outer-keep-comment? the-struct_0)))"
"            (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))"
"(define-values"
"(keep-comment)"
"(lambda(config_0)"
"(begin"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((keep-comment?70_0) #t)((inner71_0)(read-config/outer-inner v_0)))"
"(read-config/outer1.1"
" inner71_0"
"(read-config/outer-wrap the-struct_0)"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
" keep-comment?70_0))"
"            (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))"
"(define-values"
"(discard-comment)"
"(lambda(config_0)"
"(begin"
"(if(not(read-config-keep-comment? config_0))"
"(let-values() config_0)"
"(let-values()"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((keep-comment?72_0) #f)((inner73_0)(read-config/outer-inner v_0)))"
"(read-config/outer1.1"
" inner73_0"
"(read-config/outer-wrap the-struct_0)"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
" keep-comment?72_0))"
"                (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))))"
"(define-values"
"(next-readtable)"
"(lambda(config_0)"
"(begin"
"(if(eq?(read-config-readtable config_0)(read-config-next-readtable config_0))"
"(let-values() config_0)"
"(let-values()"
"(let-values(((v_0) config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((inner74_0)"
"(let-values(((the-struct_1)(read-config/outer-inner v_0)))"
"(if(read-config/inner? the-struct_1)"
"(let-values(((readtable75_0)(read-config-next-readtable config_0)))"
"(read-config/inner2.1"
" readtable75_0"
"(read-config/inner-next-readtable the-struct_1)"
"(read-config/inner-for-syntax? the-struct_1)"
"(read-config/inner-source the-struct_1)"
"(read-config/inner-read-compiled the-struct_1)"
"(read-config/inner-call-with-root-namespace the-struct_1)"
"(read-config/inner-dynamic-require the-struct_1)"
"(read-config/inner-module-declared? the-struct_1)"
"(read-config/inner-coerce the-struct_1)"
"(read-config/inner-coerce-key the-struct_1)"
"(read-config/inner-parameter-override the-struct_1)"
"(read-config/inner-parameter-cache the-struct_1)"
"(read-config/inner-st the-struct_1)))"
"                                  (raise-argument-error 'struct-copy \"read-config/inner?\" the-struct_1)))))"
"(read-config/outer1.1"
" inner74_0"
"(read-config/outer-wrap the-struct_0)"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
"(read-config/outer-keep-comment? the-struct_0)))"
"                (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))))"
"(define-values"
"(coerce)"
"(lambda(val_0 in_0 config_0)"
"(begin"
"(let-values(((for-syntax?_0)(read-config-for-syntax? config_0)))"
"((read-config-coerce config_0)"
" for-syntax?_0"
" val_0"
"(if for-syntax?_0"
"(let-values(((in1_0) in_0)((config2_0) config_0))(port+config->srcloc51.1 #f in1_0 config2_0))"
" #f))))))"
"(define-values(default-reader-guard$1)(lambda(v_0)(begin 'default-reader-guard v_0)))"
"(define-values"
"(1/current-reader-guard)"
"(make-parameter"
" default-reader-guard$1"
"(lambda(v_0)"
"(begin"
"(if(if(procedure? v_0)(procedure-arity-includes? v_0 1) #f)"
"(void)"
"         (let-values () (raise-argument-error 'current-reader-guard \"(procedure-arity-includes/c 1)\" v_0)))"
" v_0))))"
"(define-values(1/read-square-bracket-as-paren)(make-parameter #t(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-curly-brace-as-paren)(make-parameter #t(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-square-bracket-with-tag)(make-parameter #f(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-curly-brace-with-tag)(make-parameter #f(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-cdot)(make-parameter #f(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-accept-graph)(make-parameter #t(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-accept-compiled)(make-parameter #f(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-accept-box)(make-parameter #t(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-decimal-as-inexact)(make-parameter #t(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-accept-dot)(make-parameter #t(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-accept-infix-dot)(make-parameter #t(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-accept-quasiquote)(make-parameter #t(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-accept-reader)(make-parameter #f(lambda(v_0)(if v_0 #t #f))))"
"(define-values(1/read-accept-lang)(make-parameter #t(lambda(v_0)(if v_0 #t #f))))"
"(define-values(unknown)(gensym 'unknown))"
"(define-values"
"(check-parameter)"
"(lambda(param_0 config_0)"
"(begin"
"(let-values(((cache_0)(read-config-parameter-cache config_0)))"
"(let-values(((v_0)"
"(hash-ref(read-config-parameter-override config_0) param_0(hash-ref cache_0 param_0 unknown))))"
"(if(eq? v_0 unknown)"
"(let-values()(let-values(((v_1)(param_0)))(begin(hash-set! cache_0 param_0 v_1) v_1)))"
"(let-values() v_0)))))))"
"(define-values"
"(override-parameter)"
"(lambda(param_0 config_0 v_0)"
"(begin"
"(let-values(((v_1) config_0))"
"(let-values(((the-struct_0) v_1))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((inner1_0)"
"(let-values(((the-struct_1)(read-config/outer-inner v_1)))"
"(if(read-config/inner? the-struct_1)"
"(let-values(((parameter-override2_0)"
"(hash-set(read-config-parameter-override config_0) param_0 v_0)))"
"(read-config/inner2.1"
"(read-config/inner-readtable the-struct_1)"
"(read-config/inner-next-readtable the-struct_1)"
"(read-config/inner-for-syntax? the-struct_1)"
"(read-config/inner-source the-struct_1)"
"(read-config/inner-read-compiled the-struct_1)"
"(read-config/inner-call-with-root-namespace the-struct_1)"
"(read-config/inner-dynamic-require the-struct_1)"
"(read-config/inner-module-declared? the-struct_1)"
"(read-config/inner-coerce the-struct_1)"
"(read-config/inner-coerce-key the-struct_1)"
" parameter-override2_0"
"(read-config/inner-parameter-cache the-struct_1)"
"(read-config/inner-st the-struct_1)))"
"                              (raise-argument-error 'struct-copy \"read-config/inner?\" the-struct_1)))))"
"(read-config/outer1.1"
" inner1_0"
"(read-config/outer-wrap the-struct_0)"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
"(read-config/outer-indentations the-struct_0)"
"(read-config/outer-keep-comment? the-struct_0)))"
"            (raise-argument-error 'struct-copy \"read-config/outer?\" the-struct_0)))))))"
"(define-values"
"(force-parameters!)"
"(lambda(config_0)"
"(begin"
"(let-values(((cache_0)(read-config-parameter-cache config_0)))"
"(if(hash-ref cache_0 'all-forced #f)"
"(void)"
"(let-values()"
"(begin"
"(hash-set! cache_0 'all-forced #t)"
"(check-parameter read-case-sensitive config_0)"
"(check-parameter 1/read-square-bracket-as-paren config_0)"
"(check-parameter 1/read-curly-brace-as-paren config_0)"
"(check-parameter 1/read-square-bracket-with-tag config_0)"
"(check-parameter 1/read-curly-brace-with-tag config_0)"
"(check-parameter 1/read-cdot config_0)"
"(check-parameter 1/read-accept-graph config_0)"
"(check-parameter 1/read-accept-compiled config_0)"
"(check-parameter 1/read-accept-box config_0)"
"(check-parameter read-accept-bar-quote config_0)"
"(check-parameter 1/read-decimal-as-inexact config_0)"
"(check-parameter 1/read-accept-dot config_0)"
"(check-parameter 1/read-accept-infix-dot config_0)"
"(check-parameter 1/read-accept-quasiquote config_0)"
"(check-parameter 1/read-accept-reader config_0)"
"(check-parameter 1/read-accept-lang config_0))))))))"
"(define-values"
"(struct:special-comment 1/make-special-comment 1/special-comment? 1/special-comment-value)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'special-comment"
" #f"
" 1"
" 0"
" #f"
"(list(cons prop:authentic #t))"
"(current-inspector)"
" #f"
" '(0)"
" #f"
" 'make-special-comment)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'value))))"
"(define-values"
"(struct:readtable"
" readtable1.1"
" 1/readtable?"
" readtable-symbol-parser"
" readtable-char-ht"
" readtable-dispatch-ht"
" readtable-delimiter-ht)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'readtable"
" #f"
" 4"
" 0"
" #f"
"(list(cons prop:authentic #t)(cons prop:readtable #t))"
"(current-inspector)"
" #f"
" '(0 1 2 3)"
" #f"
" 'readtable)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'symbol-parser)"
"(make-struct-field-accessor -ref_0 1 'char-ht)"
"(make-struct-field-accessor -ref_0 2 'dispatch-ht)"
"(make-struct-field-accessor -ref_0 3 'delimiter-ht))))"
"(define-values"
"(1/make-readtable)"
"(lambda(rt_0 . args_0)"
"(begin"
" 'make-readtable"
"(begin"
"(if(let-values(((or-part_0)(not rt_0)))(if or-part_0 or-part_0(1/readtable? rt_0)))"
"(void)"
"          (let-values () (raise-argument-error 'make-readtable \"(or/c readtable? #f)\" rt_0)))"
"((letrec-values(((loop_0)"
"(lambda(args_1 symbol-parser_0 char-ht_0 dispatch-ht_0 delimiter-ht_0)"
"(begin"
" 'loop"
"(if(null? args_1)"
"(let-values()(readtable1.1 symbol-parser_0 char-ht_0 dispatch-ht_0 delimiter-ht_0))"
"(let-values()"
"(let-values(((key_0)(car args_1)))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not key_0)))"
"(if or-part_0 or-part_0(char? key_0)))"
"(void)"
"(let-values()"
"                                                        (raise-argument-error 'make-readtable \"(or/c char? #f)\" key_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(null? args_1)"
"(let-values()"
"(if key_0"
"(let-values()"
"(raise-arguments-error"
" 'make-readtable"
"(string-append"
"                                                                \"expected 'terminating-macro, 'non-terminating-macro, 'dispatch-macro,\""
"                                                                \" or character argument after character argument\")"
"                                                               \"character\""
" key_0))"
"(let-values()"
"(raise-arguments-error"
" 'make-readtable"
"                                                               \"expected 'non-terminating-macro after #f\"))))"
"(void))"
"(values))))"
"(let-values(((mode_0)(cadr args_1)))"
"(let-values((()"
"(begin"
"(if key_0"
"(let-values()"
"(if(let-values(((or-part_0)"
"(eq? mode_0 'terminating-macro)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(eq?"
" mode_0"
" 'non-terminating-macro)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(eq? mode_0 'dispatch-macro)))"
"(if or-part_2 or-part_2(char? mode_0)))))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-readtable"
"                                                                   \"(or/c 'terminating-macro 'non-terminating-macro 'dispatch-macro char?)\""
" mode_0))))"
"(let-values()"
"(if(eq? mode_0 'non-terminating-macro)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'make-readtable"
"                                                                   \"expected 'non-terminating-macro after #f\")))))"
"(values))))"
"(let-values((()"
"(begin"
"(if(null?(cddr args_1))"
"(let-values()"
"(raise-arguments-error"
" 'make-readtable"
"(if key_0"
"                                                                   \"expected readtable or #f argument after character argument\""
"                                                                   \"expected procedure argument after symbol argument\")"
"                                                                 \"given\""
" mode_0))"
"(void))"
"(values))))"
"(let-values(((target_0)(caddr args_1)))"
"(let-values(((rest-args_0)(cdddr args_1)))"
"(if(not key_0)"
"(let-values()"
"(begin"
"(if(if(procedure? target_0)"
"(procedure-arity-includes? target_0 6)"
" #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-readtable"
"                                                             \"(procedure-arity-includes/c 6)\""
" target_0)))"
"(loop_0"
" rest-args_0"
" target_0"
" char-ht_0"
" dispatch-ht_0"
" delimiter-ht_0)))"
"(if(eq? mode_0 'dispatch-macro)"
"(let-values()"
"(begin"
"(if(if(procedure? target_0)"
"(procedure-arity-includes? target_0 6)"
" #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-readtable"
"                                                               \"(procedure-arity-includes/c 6)\""
" target_0)))"
"(loop_0"
" rest-args_0"
" symbol-parser_0"
" char-ht_0"
"(hash-set dispatch-ht_0 key_0 target_0)"
" delimiter-ht_0)))"
"(if(char? mode_0)"
"(let-values()"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not target_0)))"
"(if or-part_0"
" or-part_0"
"(1/readtable? target_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-readtable"
"                                                                               \"(or/c readtable? #f)\""
" target_0)))"
"(values))))"
"(let-values(((actual-target_0)"
"(let-values(((or-part_0)"
"(if target_0"
"(hash-ref"
"(readtable-char-ht target_0)"
" mode_0"
" #f)"
" #f)))"
"(if or-part_0 or-part_0 mode_0))))"
"(let-values(((new-char-ht_0)"
"(if actual-target_0"
"(hash-set char-ht_0 key_0 actual-target_0)"
"(hash-remove char-ht_0 key_0))))"
"(let-values(((new-delimiter-ht_0)"
"(hash-set"
" delimiter-ht_0"
" key_0"
"(if target_0"
"(hash-ref"
"(readtable-delimiter-ht target_0)"
" mode_0"
" mode_0)"
" mode_0))))"
"(loop_0"
" rest-args_0"
" symbol-parser_0"
" new-char-ht_0"
" dispatch-ht_0"
" new-delimiter-ht_0))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(if(procedure? target_0)"
"(procedure-arity-includes? target_0 6)"
" #f)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'make-readtable"
"                                                                               \"(procedure-arity-includes/c 6)\""
" target_0)))"
"(values))))"
"(let-values(((new-char-ht_0)"
"(hash-set char-ht_0 key_0 target_0)))"
"(let-values(((new-delimiter-ht_0)"
"(hash-set"
" delimiter-ht_0"
" key_0"
"(if(eq? mode_0 'terminating-macro)"
" 'delimit"
" 'no-delimit))))"
"(loop_0"
" rest-args_0"
" symbol-parser_0"
" new-char-ht_0"
" dispatch-ht_0"
" new-delimiter-ht_0))))))))))))))))))))))"
" loop_0)"
" args_0"
"(if rt_0(readtable-symbol-parser rt_0) #f)"
"(if rt_0(readtable-char-ht rt_0) '#hasheqv())"
"(if rt_0(readtable-dispatch-ht rt_0) '#hasheqv())"
"(if rt_0(readtable-delimiter-ht rt_0) '#hasheqv()))))))"
"(define-values"
"(*readtable-effective-char)"
"(lambda(rt_0 c_0)"
"(begin"
"(let-values(((target_0)(hash-ref(readtable-char-ht rt_0) c_0 #f)))"
"(if(not target_0)(let-values() c_0)(if(char? target_0)(let-values() target_0)(let-values() '#\\x)))))))"
"(define-values"
"(effective-char)"
"(lambda(c_0 config_0)"
"(begin"
"(let-values(((rt_0)(read-config-readtable config_0))((c_1) c_0))"
"(if(let-values(((or-part_0)(not rt_0)))(if or-part_0 or-part_0(not(char? c_1))))"
"(let-values() c_1)"
"(let-values()(*readtable-effective-char rt_0 c_1)))))))"
"(define-values"
"(readtable-handler)"
"(lambda(config_0 c_0)"
"(begin"
"(let-values(((rt_0)(read-config-readtable config_0)))"
"(if rt_0"
"(let-values(((target_0)(hash-ref(readtable-char-ht rt_0) c_0 #f)))"
"(if target_0(if(not(char? target_0)) target_0 #f) #f))"
" #f)))))"
"(define-values"
"(readtable-dispatch-handler)"
"(lambda(config_0 c_0)"
"(begin"
"(let-values((()(begin(force-parameters! config_0)(values))))"
"(let-values(((rt_0)(read-config-readtable config_0)))"
"(if rt_0(hash-ref(readtable-dispatch-ht rt_0) c_0 #f) #f))))))"
"(define-values"
"(readtable-apply)"
"(lambda(handler_0 c_0 in_0 config_0 line_0 col_0 pos_0)"
"(begin"
"(let-values(((for-syntax?_0)(read-config-for-syntax? config_0)))"
"(let-values(((v_0)"
"(if(not for-syntax?_0)"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()"
"(if(procedure-arity-includes? handler_0 2)"
"(handler_0 c_0 in_0)"
"(handler_0 c_0 in_0 #f line_0 col_0 pos_0)))))"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()(handler_0 c_0 in_0(read-config-source config_0) line_0 col_0 pos_0)))))))"
"(if(1/special-comment? v_0) v_0(coerce v_0 in_0 config_0)))))))"
"(define-values"
"(1/readtable-mapping)"
"(lambda(rt_0 c_0)"
"(begin"
" 'readtable-mapping"
"(let-values((()"
"(begin"
"(if(1/readtable? rt_0)"
"(void)"
"                        (let-values () (raise-argument-error 'readtable-mapping \"readtable?\" rt_0)))"
"(values))))"
"(let-values((()"
"(begin"
"                        (if (char? c_0) (void) (let-values () (raise-argument-error 'readtable-mapping \"char?\" c_0)))"
"(values))))"
"(let-values(((handler_0)(hash-ref(readtable-char-ht rt_0) c_0 #f)))"
"(values"
"(let-values(((or-part_0)"
"(if handler_0"
"(if(char? handler_0)"
"(let-values() handler_0)"
"(if(eq? 'delimit(hash-ref(readtable-delimiter-ht rt_0) c_0 #f))"
"(let-values() 'terminating-macro)"
"(let-values() 'non-terminating-macro)))"
" #f)))"
"(if or-part_0 or-part_0 c_0))"
"(if(char? handler_0) #f handler_0)"
"(hash-ref(readtable-dispatch-ht rt_0) c_0 #f))))))))"
"(define-values"
"(readtable-equivalent-chars)"
"(lambda(rt_0 c_0)"
"(begin"
"(let-values(((ht_0)(readtable-char-ht rt_0)))"
"(append"
"(if(hash-ref ht_0 c_0 #f) null(list c_0))"
"(reverse$1"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)(hash-iterate-key+value ht_1 i_0)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(if(eqv? v_0 c_0)"
"(let-values(((fold-var_2) fold-var_1))"
"(let-values(((fold-var_3)"
"(let-values()"
"(cons(let-values() k_0) fold-var_2))))"
"(values fold-var_3)))"
" fold-var_1))))"
"(if(not #f)"
"(for-loop_0 fold-var_1(hash-iterate-next ht_1 i_0))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
"(hash-iterate-first ht_1))))))))))"
"(define-values"
"(struct:special special1.1 special? special-value)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()(make-struct-type 'special #f 1 0 #f null(current-inspector) #f '(0) #f 'special)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'value))))"
"(define-values"
"(wrap)"
"(lambda(s-exp_0 in_0 config_0 rep_0)"
"(begin"
"(let-values(((wrap_0)(read-config-wrap config_0)))"
"(if wrap_0"
"(wrap_0"
" s-exp_0"
"(let-values(((in1_0) in_0)((config2_0) config_0))(port+config->srcloc51.1 #f in1_0 config2_0))"
" rep_0)"
" s-exp_0)))))"
"(define-values(consume-char)(lambda(in_0 c_0)(begin(begin(read-char in_0)(void)))))"
"(define-values"
"(consume-char/special)"
"(lambda(in_0 config_0 c_0)"
"(begin(begin(read-char-or-special in_0 special1.1(read-config-source config_0))(void)))))"
"(define-values"
"(reader-error12.1)"
"(lambda(continuation-marks1_0 due-to2_0 end-pos4_0 who3_0 in9_0 config10_0 str11_0 new-rest_0)"
"(begin"
" 'reader-error12"
"(let-values(((in_0) in9_0))"
"(let-values(((config_0) config10_0))"
"(let-values(((continuation-marks_0)"
"(if(eq? continuation-marks1_0 unsafe-undefined)"
"(current-continuation-marks)"
" continuation-marks1_0)))"
"(let-values(((due-to_0) due-to2_0))"
"(let-values(((who_0)"
"(if(eq? who3_0 unsafe-undefined)"
"(if(read-config-for-syntax? config_0) 'read-syntax 'read)"
" who3_0)))"
"(let-values(((end-pos_0) end-pos4_0))"
"(let-values(((str_0) str11_0))"
"(let-values(((args_0) new-rest_0))"
"                      (let-values (((msg_0) (format \"~a: ~a\" who_0 (apply format str_0 args_0))))"
"(let-values(((srcloc_0)"
"(if in_0"
"(let-values(((in23_0) in_0)((config24_0) config_0)((end-pos25_0) end-pos_0))"
"(port+config->srcloc51.1 end-pos25_0 in23_0 config24_0))"
" #f)))"
"(raise"
"((if(eof-object? due-to_0)"
"(let-values() exn:fail:read:eof)"
"(if(not(char? due-to_0))"
"(let-values() exn:fail:read:non-char)"
"(let-values() exn:fail:read)))"
"(let-values(((s_0)"
"(if(error-print-source-location)"
"(if srcloc_0(srcloc->string srcloc_0) #f)"
" #f)))"
"                              (if s_0 (string-append s_0 \": \" msg_0) msg_0))"
" continuation-marks_0"
"(if srcloc_0(list srcloc_0) null))))))))))))))))"
"(define-values"
"(bad-syntax-error20.1)"
"(lambda(due-to15_0 in17_0 config18_0 str19_0)"
"(begin"
" 'bad-syntax-error20"
"(let-values(((in_0) in17_0))"
"(let-values(((config_0) config18_0))"
"(let-values(((str_0) str19_0))"
"(let-values(((due-to_0) due-to15_0))"
"(let-values()"
"(let-values(((in26_0) in_0)"
"((config27_0) config_0)"
"((due-to28_0) due-to_0)"
"                             ((temp29_0) \"bad syntax `~a`\")"
"((str30_0) str_0))"
"(reader-error12.1"
" unsafe-undefined"
" due-to28_0"
" #f"
" unsafe-undefined"
" in26_0"
" config27_0"
" temp29_0"
"(list str30_0)))))))))))"
"(define-values"
"(catch-and-reraise-as-reader/proc)"
"(lambda(in_0 config_0 thunk_0)"
"(begin"
"(let-values(((with-handlers-predicate31_0) exn:fail?)"
"((with-handlers-handler32_0)"
"(lambda(exn_0)"
"(begin"
" 'with-handlers-handler32"
"(let-values(((in33_0) in_0)"
"((config34_0) config_0)"
"                                     ((temp35_0) \"~a\")"
"((temp36_0)"
"                                      (let-values (((s_0) (exn-message exn_0))) (regexp-replace \"^[a-z-]*: \" s_0 \"\")))"
"((temp37_0)(exn-continuation-marks exn_0)))"
"(reader-error12.1"
" temp37_0"
" '#\\x"
" #f"
" unsafe-undefined"
" in33_0"
" config34_0"
" temp35_0"
"(list temp36_0)))))))"
"(let-values(((bpz_0)(continuation-mark-set-first #f break-enabled-key)))"
"(call-handled-body"
" bpz_0"
"(lambda(e_0)"
"(select-handler/no-breaks e_0 bpz_0(list(cons with-handlers-predicate31_0 with-handlers-handler32_0))))"
"(lambda()(thunk_0))))))))"
"(define-values"
"(port-next-location*)"
"(lambda(in_0 init-c_0)"
"(begin"
"(if(not init-c_0)"
"(let-values()(port-next-location in_0))"
"(let-values()"
"(let-values(((line_0 col_0 pos_0)(port-next-location in_0)))"
"(values line_0(if col_0(max 0(sub1 col_0)) #f)(if pos_0(max 1(sub1 pos_0)) #f))))))))"
"(define-values"
"(read-char/skip-whitespace-and-comments)"
"(lambda(init-c_0 read-one_0 in_0 config_0)"
"(begin"
"(let-values(((rt_0)(read-config-readtable config_0)))"
"(let-values(((source_0)(read-config-source config_0)))"
"((letrec-values(((skip-loop_0)"
"(lambda(init-c_1)"
"(begin"
" 'skip-loop"
"(let-values(((c_0)"
"(let-values(((or-part_0) init-c_1))"
"(if or-part_0"
" or-part_0"
"(let-values(((in_1) in_0)((source_1) source_0))"
"(read-char-or-special in_1 special1.1 source_1))))))"
"(let-values(((ec_0)"
"(let-values(((rt_1) rt_0)((c_1) c_0))"
"(if(let-values(((or-part_0)(not rt_1)))"
"(if or-part_0 or-part_0(not(char? c_1))))"
"(let-values() c_1)"
"(let-values()(*readtable-effective-char rt_1 c_1))))))"
"(if(eof-object? ec_0)"
"(let-values() c_0)"
"(if(not(char? ec_0))"
"(let-values()"
"(let-values(((v_0)(special-value c_0)))"
"(if(if(1/special-comment? v_0)"
"(not(read-config-keep-comment? config_0))"
" #f)"
"(let-values()(skip-loop_0 #f))"
"(let-values() c_0))))"
"(if(char-whitespace? ec_0)"
"(let-values()(skip-loop_0 #f))"
"(if(char=? '#\\; ec_0)"
"(let-values()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((c_1)"
"(let-values(((in_1) in_0)"
"((source_1) source_0))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_1))))"
"(if(let-values(((or-part_0)"
"(eof-object? c_1)))"
"(if or-part_0"
" or-part_0"
"(eqv?"
" '#\\newline"
"(effective-char c_1 config_0))))"
"(void)"
"(let-values()(loop_0))))))))"
" loop_0))"
"(if(read-config-keep-comment? config_0)"
"(result-special-comment)"
"(skip-loop_0 #f))))"
"(if(if(char=? '#\\# ec_0)"
"(eqv?"
" '#\\|"
"(let-values(((in_1) in_0)((skip-count_0) 0)((source_1) source_0))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1))))"
" #f)"
"(let-values()"
"(begin"
"(skip-pipe-comment! c_0 in_0 config_0)"
"(if(read-config-keep-comment? config_0)"
"(result-special-comment)"
"(skip-loop_0 #f))))"
"(if(if(char=? '#\\# ec_0)"
"(if(eqv?"
" '#\\!"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_1) source_0))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1))))"
"(let-values(((c3_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 1)"
"((source_1) source_0))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq? c_1 'special)"
"(special1.1 'special)"
" c_1)))))"
"(let-values(((or-part_0)(eqv? '#\\space c3_0)))"
"(if or-part_0 or-part_0(eqv? '#\\/ c3_0))))"
" #f)"
" #f)"
"(let-values()"
"(begin"
"(skip-unix-line-comment! in_0 config_0)"
"(if(read-config-keep-comment? config_0)"
"(result-special-comment)"
"(skip-loop_0 #f))))"
"(if(if(char=? '#\\# ec_0)"
"(eqv?"
" '#\\;"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_1) source_0))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1))))"
" #f)"
"(let-values()"
"(let-values((()(begin(consume-char in_0 '#\\;)(values))))"
"(let-values(((v_0)(read-one_0 #f in_0 config_0)))"
"(begin"
"(if(eof-object? v_0)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((v3_0) v_0)"
"((temp4_0)"
"                                                                            \"expected a commented-out element for `~a;`, but found end-of-file\")"
"((ec5_0) ec_0))"
"(reader-error12.1"
" unsafe-undefined"
" v3_0"
" #f"
" unsafe-undefined"
" in1_0"
" config2_0"
" temp4_0"
"(list ec5_0))))"
"(void))"
"(if(read-config-keep-comment? config_0)"
"(result-special-comment)"
"(skip-loop_0 #f))))))"
"(let-values() c_0))))))))))))))"
" skip-loop_0)"
" init-c_0))))))"
"(define-values(result-special-comment)(lambda()(begin(special1.1(1/make-special-comment #f)))))"
"(define-values"
"(skip-pipe-comment!)"
"(lambda(init-c_0 in_0 config_0)"
"(begin"
"(let-values(((source_0)(read-config-source config_0)))"
"(let-values(((line_0 col_0 pos_0)(port-next-location in_0)))"
"(begin"
"(consume-char in_0 '#\\|)"
"((letrec-values(((loop_0)"
"(lambda(prev-c_0 depth_0)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_1) source_0))"
"(read-char-or-special in_1 special1.1 source_1))))"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in6_0) in_0)"
"((temp7_0)(reading-at config_0 line_0 col_0 pos_0))"
"((c8_0) c_0)"
"                                                     ((temp9_0) \"end of file in `#|` comment\"))"
"(reader-error12.1"
" unsafe-undefined"
" c8_0"
" #f"
" unsafe-undefined"
" in6_0"
" temp7_0"
" temp9_0"
"(list))))"
"(if(not(char? c_0))"
"(let-values()(loop_0 #f depth_0))"
"(if(if(char=? '#\\| c_0)(eqv? prev-c_0 '#\\#) #f)"
"(let-values()(loop_0 #f(add1 depth_0)))"
"(if(if(char=? '#\\# c_0)(eqv? prev-c_0 '#\\|) #f)"
"(let-values()"
"(if(positive? depth_0)"
"(let-values()(loop_0 #f(sub1 depth_0)))"
"(void)))"
"(let-values()(loop_0 c_0 depth_0)))))))))))"
" loop_0)"
" #f"
" 0)))))))"
"(define-values"
"(skip-unix-line-comment!)"
"(lambda(in_0 config_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(backslash?_0)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(if(eof-object? c_0)"
"(let-values()(void))"
"(if(not(char? c_0))"
"(let-values()(loop_0 #f))"
"(if(char=? c_0 '#\\newline)"
"(let-values()(if backslash?_0(let-values()(loop_0 #f))(void)))"
"(if(char=? c_0 '#\\\\)"
"(let-values()(loop_0 #t))"
"(let-values()(loop_0 #f)))))))))))"
" loop_0)"
" #f))))"
"(define-values"
"(readtable-char-delimiter?)"
"(lambda(rt_0 c_0 config_0)"
"(begin"
"(let-values(((dc_0)"
"(let-values(((or-part_0)(if rt_0(hash-ref(readtable-delimiter-ht rt_0) c_0 #f) #f)))"
"(if or-part_0 or-part_0 c_0))))"
"(if(eq? dc_0 'no-delimit)"
"(let-values() #f)"
"(if(not(char? dc_0))"
"(let-values() #t)"
"(let-values()"
"(let-values(((or-part_0)(char-whitespace? dc_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(char=? dc_0 '#\\()))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(char=? dc_0 '#\\))))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(char=? dc_0 '#\\[)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(char=? dc_0 '#\\])))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)(char=? dc_0 '#\\{)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)(char=? dc_0 '#\\})))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)(char=? dc_0 '#\\')))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)(char=? dc_0 '#\\`)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)(char=? dc_0 '#\\,)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)(char=? dc_0 '#\\;)))"
"(if or-part_10"
" or-part_10"
"                                                          (let-values (((or-part_11) (char=? dc_0 '#\\\")))"
"(if or-part_11"
" or-part_11"
"(if(char=? dc_0 '#\\.)"
"(check-parameter 1/read-cdot config_0)"
" #f))))))))))))))))))))))))))))))))"
"(define-values"
"(char-delimiter?)"
"(lambda(c_0 config_0)(begin(readtable-char-delimiter?(read-config-readtable config_0) c_0 config_0))))"
"(define-values"
"(char-closer?)"
"(lambda(ec_0 config_0)"
"(begin"
"(if(not(eof-object? ec_0))"
"(let-values(((or-part_0)(char=? ec_0 '#\\))))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(char=? ec_0 '#\\])))(if or-part_1 or-part_1(char=? ec_0 '#\\})))))"
" #f))))"
" (define-values (closer-name) (lambda (c_0 config_0) (begin (effective-char-names c_0 config_0 \"closer\"))))"
" (define-values (opener-name) (lambda (c_0 config_0) (begin (effective-char-names c_0 config_0 \"opener\"))))"
"(define-values"
"(effective-char-names)"
"(lambda(c_0 config_0 fallback-str_0)"
"(begin"
"(let-values(((rt_0)(read-config-readtable config_0)))"
"(if(not rt_0)"
"          (let-values () (format \"`~a`\" c_0))"
"(let-values()"
"(let-values(((cs_0)(readtable-equivalent-chars rt_0 c_0)))"
"(if(null? cs_0)"
"(let-values() fallback-str_0)"
"(if(null?(cdr cs_0))"
"                  (let-values () (format \"`~a`\" (car cs_0)))"
"(if(null?(cddr cs_0))"
"                    (let-values () (format \"`~a` or `~a`\" (car cs_0) (cadr cs_0)))"
"(let-values()"
"(apply"
" string-append"
"((letrec-values(((loop_0)"
"(lambda(cs_1)"
"(begin"
" 'loop"
"(if(null?(cdr cs_1))"
"                                               (let-values () (list (format \"or `~a`\" (car cs_1))))"
"(let-values()"
"                                                 (cons (format \"`~a`, \" (car cs_1)) (loop_0 (cdr cs_1)))))))))"
" loop_0)"
" cs_0)))))))))))))"
"(define-values"
"(closer->opener)"
"(lambda(c_0)"
"(begin"
"(let-values(((tmp_0) c_0))"
"(if(equal? tmp_0 '#\\))"
"(let-values() '#\\()"
"(if(equal? tmp_0 '#\\])"
"(let-values() '#\\[)"
"(if(equal? tmp_0 '#\\})(let-values() '#\\{)(let-values() c_0))))))))"
" (define-values (dot-name) (lambda (config_0) (begin \"`.`\")))"
"(define-values"
"(all-openers-str)"
"(lambda(config_0)"
"(begin"
"(let-values(((p_0)(opener-name '#\\( config_0)))"
"(let-values(((s_0)"
"(if(check-parameter 1/read-square-bracket-as-paren config_0)(opener-name '#\\[ config_0) #f)))"
"(let-values(((c_0)"
"(if(check-parameter 1/read-curly-brace-as-paren config_0)(opener-name '#\\{ config_0) #f)))"
"(if(if s_0 c_0 #f)"
"              (let-values () (format \"~a, ~a, or ~a\" p_0 s_0 c_0))"
"(if(let-values(((or-part_0) s_0))(if or-part_0 or-part_0 c_0))"
"                (let-values () (format \"~a or ~a\" p_0 (let-values (((or-part_0) s_0)) (if or-part_0 or-part_0 c_0))))"
"(let-values() p_0)))))))))"
"(define-values"
"(struct:accum-string"
" accum-string1.1"
" accum-string?"
" accum-string-pos"
" accum-string-str"
" set-accum-string-pos!"
" set-accum-string-str!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'accum-string #f 2 0 #f null(current-inspector) #f '() #f 'accum-string)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'pos)"
"(make-struct-field-accessor -ref_0 1 'str)"
"(make-struct-field-mutator -set!_0 0 'pos)"
"(make-struct-field-mutator -set!_0 1 'str))))"
"(define-values"
"(accum-string-init!)"
"(lambda(config_0)"
"(begin"
"(let-values(((st_0)(read-config-st config_0)))"
"(let-values(((a_0)(read-config-state-accum-str st_0)))"
"(if a_0"
"(let-values()(begin(set-read-config-state-accum-str! st_0 #f)(set-accum-string-pos! a_0 0) a_0))"
"(let-values()(accum-string1.1 0(make-string 32)))))))))"
"(define-values"
"(accum-string-add!)"
"(lambda(a_0 c_0)"
"(begin"
"(let-values(((pos_0)(accum-string-pos a_0)))"
"(let-values(((str_0)(accum-string-str a_0)))"
"(let-values(((str2_0)"
"(if(fx< pos_0(string-length str_0))"
"(let-values() str_0)"
"(let-values()"
"(let-values(((str2_0)(make-string(fx*(string-length str_0) 2))))"
"(begin(string-copy! str2_0 0 str_0)(set-accum-string-str! a_0 str2_0) str2_0))))))"
"(begin(string-set! str2_0 pos_0 c_0)(set-accum-string-pos! a_0(fx+ 1 pos_0)))))))))"
"(define-values(accum-string-count)(lambda(a_0)(begin(accum-string-pos a_0))))"
"(define-values(set-accum-string-count!)(lambda(a_0 pos_0)(begin(set-accum-string-pos! a_0 pos_0))))"
"(define-values"
"(accum-string-convert!)"
"(lambda(a_0 convert_0 start-pos_0)"
"(begin"
"(let-values(((str_0)(accum-string-str a_0)))"
"(let-values(((s_0)(convert_0(substring str_0 start-pos_0(accum-string-pos a_0)))))"
"(let-values(((len_0)(string-length s_0)))"
"(begin"
"(if(fx<(fx+ len_0 start-pos_0)(string-length str_0))"
"(void)"
"(let-values()"
"(let-values(((str2_0)(make-string(fx+ start-pos_0 len_0))))"
"(begin(string-copy! str2_0 0 str_0 0 start-pos_0)(set-accum-string-str! a_0 str2_0)))))"
"(string-copy!(accum-string-str a_0) start-pos_0 s_0)"
"(set-accum-string-pos! a_0(fx+ start-pos_0 len_0)))))))))"
"(define-values"
"(accum-string-get!6.1)"
"(lambda(start-pos2_0 a4_0 config5_0)"
"(begin"
" 'accum-string-get!6"
"(let-values(((a_0) a4_0))"
"(let-values(((config_0) config5_0))"
"(let-values(((start-pos_0) start-pos2_0))"
"(let-values()"
"(let-values(((s_0)(substring(accum-string-str a_0) start-pos_0(accum-string-pos a_0))))"
"(begin(accum-string-abandon! a_0 config_0) s_0)))))))))"
"(define-values"
"(accum-string-get-bytes!13.1)"
"(lambda(start-pos9_0 a11_0 config12_0)"
"(begin"
" 'accum-string-get-bytes!13"
"(let-values(((a_0) a11_0))"
"(let-values(((config_0) config12_0))"
"(let-values(((start-pos_0) start-pos9_0))"
"(let-values()"
"(let-values(((bstr_0)"
"(string->bytes/latin-1(accum-string-str a_0) #f start-pos_0(accum-string-pos a_0))))"
"(begin(accum-string-abandon! a_0 config_0) bstr_0)))))))))"
"(define-values"
"(accum-string-abandon!)"
"(lambda(a_0 config_0)(begin(set-read-config-state-accum-str!(read-config-st config_0) a_0))))"
"(define-values"
"(struct:indentation"
" indentation1.1"
" indentation?"
" indentation-closer"
" indentation-suspicious-closer"
" indentation-multiline?"
" indentation-start-line"
" indentation-last-line"
" indentation-suspicious-line"
" indentation-max-indent"
" indentation-suspicious-quote"
" set-indentation-suspicious-closer!"
" set-indentation-multiline?!"
" set-indentation-last-line!"
" set-indentation-suspicious-line!"
" set-indentation-max-indent!"
" set-indentation-suspicious-quote!)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type 'indentation #f 8 0 #f null(current-inspector) #f '(0 3) #f 'indentation)))))"
"(values"
" struct:_0"
" make-_0"
" ?_0"
"(make-struct-field-accessor -ref_0 0 'closer)"
"(make-struct-field-accessor -ref_0 1 'suspicious-closer)"
"(make-struct-field-accessor -ref_0 2 'multiline?)"
"(make-struct-field-accessor -ref_0 3 'start-line)"
"(make-struct-field-accessor -ref_0 4 'last-line)"
"(make-struct-field-accessor -ref_0 5 'suspicious-line)"
"(make-struct-field-accessor -ref_0 6 'max-indent)"
"(make-struct-field-accessor -ref_0 7 'suspicious-quote)"
"(make-struct-field-mutator -set!_0 1 'suspicious-closer)"
"(make-struct-field-mutator -set!_0 2 'multiline?)"
"(make-struct-field-mutator -set!_0 4 'last-line)"
"(make-struct-field-mutator -set!_0 5 'suspicious-line)"
"(make-struct-field-mutator -set!_0 6 'max-indent)"
"(make-struct-field-mutator -set!_0 7 'suspicious-quote))))"
"(define-values"
"(make-indentation)"
"(lambda(closer_0 in_0 config_0)"
"(begin"
"(let-values(((line_0 col_0 pos_0)(port-next-location in_0)))"
"(indentation1.1 closer_0 #f #f line_0 line_0 #f(if col_0(add1 col_0) #f) #f)))))"
"(define-values"
"(track-indentation!)"
"(lambda(config_0 line_0 col_0)"
"(begin"
"(let-values(((indts_0)(read-config-indentations config_0)))"
"(let-values(((indt_0)(if(pair? indts_0)(car indts_0) #f)))"
"(if(if indt_0"
"(if line_0(if(indentation-last-line indt_0)(> line_0(indentation-last-line indt_0)) #f) #f)"
" #f)"
"(let-values()"
"(begin"
"(set-indentation-last-line! indt_0 line_0)"
"(set-indentation-multiline?! indt_0 #t)"
"(if(>= col_0(indentation-max-indent indt_0))"
"(let-values()(set-indentation-max-indent! indt_0 col_0))"
"(let-values()"
"(if(indentation-suspicious-line indt_0)"
"(void)"
"(let-values()"
"(begin"
"(set-indentation-suspicious-closer! indt_0(indentation-closer indt_0))"
"(set-indentation-suspicious-line! indt_0 line_0))))))))"
"(void)))))))"
"(define-values"
"(indentation-possible-cause)"
"(lambda(config_0)"
"(begin"
"(let-values(((indt_0)(car(read-config-indentations config_0))))"
"(if(indentation-suspicious-line indt_0)"
"(let-values()"
"(format"
"             \"\\n  possible cause: indentation suggests a missing ~a before line ~a\""
"(closer-name(indentation-suspicious-closer indt_0) config_0)"
"(indentation-suspicious-line indt_0)))"
"          (let-values () \"\"))))))"
"(define-values"
"(indentation-unexpected-closer-message)"
"(lambda(ec_0 c_0 config_0)"
"(begin"
"(let-values(((indts_0)(read-config-indentations config_0)))"
"(if(null? indts_0)"
"          (let-values () (format \"unexpected `~a`\" c_0))"
"(let-values()"
"(let-values(((indt_0)(car indts_0)))"
"(string-append"
"(if(char=? ec_0(indentation-closer indt_0))"
"                 (let-values () (format \"unexpected `~a`\" c_0))"
"(let-values()"
"(let-values(((missing_0)"
"(let-values(((or-part_0)"
"(let-values(((lst_0)(cdr indts_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((indt_1)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(if(char=?"
" ec_0"
"(indentation-closer"
" indt_1))"
"                                                                                                                 \"missing\""
" #f)))))"
"(values result_1)))))"
"(if(if(not"
"((lambda x_0 result_1) indt_1))"
"(not #f)"
" #f)"
"(for-loop_0 result_1 rest_0)"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" lst_0)))))"
"                                   (if or-part_0 or-part_0 \"expected\"))))"
"(let-values(((opener-str_0)(opener-name(closer->opener(indentation-closer indt_0)) config_0)))"
"(format"
"                        \"~a ~a to close ~a, found instead `~a`\""
" missing_0"
"(closer-name(indentation-closer indt_0) config_0)"
"(if(indentation-multiline? indt_0)"
"                          (let-values () (format \"~a on line ~a\" opener-str_0 (indentation-start-line indt_0)))"
"                          (let-values () (format \"preceding ~a\" opener-str_0)))"
" c_0)))))"
"(indentation-possible-cause config_0)))))))))"
"(define-values"
"(read-unwrapped-sequence17.1)"
"(lambda(dot-mode2_0"
" elem-config1_0"
" first-read-one5_0"
" shape-tag?3_0"
" whitespace-read-one4_0"
" read-one11_0"
" opener-c12_0"
" opener13_0"
" closer14_0"
" in15_0"
" seq-config16_0)"
"(begin"
" 'read-unwrapped-sequence17"
"(let-values(((read-one_0) read-one11_0))"
"(let-values(((opener-c_0) opener-c12_0))"
"(let-values(((opener_0) opener13_0))"
"(let-values(((closer_0) closer14_0))"
"(let-values(((in_0) in15_0))"
"(let-values(((seq-config_0) seq-config16_0))"
"(let-values(((elem-config_0)"
"(if(eq? elem-config1_0 unsafe-undefined)"
"(next-readtable seq-config_0)"
" elem-config1_0)))"
"(let-values(((dot-mode_0) dot-mode2_0))"
"(let-values(((shape-tag?_0) shape-tag?3_0))"
"(let-values(((whitespace-read-one_0)"
"(if(eq? whitespace-read-one4_0 unsafe-undefined)"
" read-one_0"
" whitespace-read-one4_0)))"
"(let-values(((first-read-one_0)"
"(if(eq? first-read-one5_0 unsafe-undefined) read-one_0 first-read-one5_0)))"
"(let-values()"
"(let-values(((head_0) #f))"
"(let-values(((indentation_0)(make-indentation closer_0 in_0 seq-config_0)))"
"(let-values(((config_0)"
"(let-values(((v_0) elem-config_0))"
"(let-values(((the-struct_0) v_0))"
"(if(read-config/outer? the-struct_0)"
"(let-values(((indentations20_0)"
"(cons"
" indentation_0"
"(read-config-indentations seq-config_0)))"
"((inner21_0)(read-config/outer-inner v_0)))"
"(read-config/outer1.1"
" inner21_0"
"(read-config/outer-wrap the-struct_0)"
"(read-config/outer-line the-struct_0)"
"(read-config/outer-col the-struct_0)"
"(read-config/outer-pos the-struct_0)"
" indentations20_0"
"(read-config/outer-keep-comment? the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                       \"read-config/outer?\""
" the-struct_0))))))"
"(let-values(((open-end-line_0 open-end-col_0 open-end-pos_0)"
"(port-next-location in_0)))"
"(let-values(((config/keep-comment_0)(keep-comment config_0)))"
"(let-values(((read-one/not-eof_0)"
"(lambda(init-c_0 read-one_1 config_1)"
"(begin"
" 'read-one/not-eof"
"(let-values(((e_0)(read-one_1 init-c_0 in_0 config_1)))"
"(begin"
"(if(eof-object? e_0)"
"(let-values()"
"(let-values(((in22_0) in_0)"
"((seq-config23_0) seq-config_0)"
"((e24_0) e_0)"
"((open-end-pos25_0) open-end-pos_0)"
"((temp26_0)"
"                                                                                \"expected a ~a to close `~a`~a\")"
"((temp27_0)"
"(closer-name closer_0 config_1))"
"((opener-c28_0) opener-c_0)"
"((temp29_0)"
"(indentation-possible-cause config_1)))"
"(reader-error12.1"
" unsafe-undefined"
" e24_0"
" open-end-pos25_0"
" unsafe-undefined"
" in22_0"
" seq-config23_0"
" temp26_0"
"(list temp27_0 opener-c28_0 temp29_0))))"
"(void))"
" e_0))))))"
"(let-values(((seq_0)"
"((letrec-values(((loop_0)"
"(lambda(depth_0"
" accum_0"
" init-c_0"
" first?_0"
" first-read-one_1)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(read-char/skip-whitespace-and-comments"
" init-c_0"
" whitespace-read-one_0"
" in_0"
" seq-config_0)))"
"(let-values(((ec_0)"
"(effective-char"
" c_0"
" seq-config_0)))"
"(if(eqv? ec_0 closer_0)"
"(let-values()"
"(if(null? accum_0)"
" null"
"(reverse$1 accum_0)))"
"(if(if(not first?_0)"
"(if(eqv? ec_0 '#\\.)"
"(if(check-parameter"
" 1/read-accept-dot"
" config_0)"
"(char-delimiter?"
"(let-values(((in_1)"
" in_0)"
"((skip-count_0)"
" 0)"
"((source_0)"
"(read-config-source"
" config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq?"
" c_1"
" 'special)"
"(special1.1"
" 'special)"
" c_1)))"
" seq-config_0)"
" #f)"
" #f)"
" #f)"
"(let-values()"
"(let-values(((dot-line_0"
" dot-col_0"
" dot-pos_0)"
"(port-next-location*"
" in_0"
" c_0)))"
"(let-values((()"
"(begin"
"(track-indentation!"
" config_0"
" dot-line_0"
" dot-col_0)"
"(values))))"
"(let-values((()"
"(begin"
"(if(if dot-mode_0"
"(not"
" head_0)"
" #f)"
"(void)"
"(let-values()"
"(let-values(((in30_0)"
" in_0)"
"((temp31_0)"
"(reading-at"
" config_0"
" dot-line_0"
" dot-col_0"
" dot-pos_0))"
"((temp32_0)"
"                                                                                                                              \"illegal use of `.`\"))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in30_0"
" temp31_0"
" temp32_0"
"(list)))))"
"(values))))"
"(let-values(((v_0)"
"(read-one/not-eof_0"
" #f"
" first-read-one_1"
" config_0)))"
"(let-values(((rest-c_0)"
"(read-char/skip-whitespace-and-comments"
" #f"
" whitespace-read-one_0"
" in_0"
" seq-config_0)))"
"(let-values(((rest-ec_0)"
"(effective-char"
" rest-c_0"
" seq-config_0)))"
"(if(eqv?"
" rest-ec_0"
" closer_0)"
"(let-values()"
"(if(null?"
" accum_0)"
" v_0"
"(append"
"(reverse$1"
" accum_0)"
" v_0)))"
"(if(if(eqv?"
" rest-ec_0"
" '#\\.)"
"(if(check-parameter"
" 1/read-accept-dot"
" config_0)"
"(if(check-parameter"
" 1/read-accept-infix-dot"
" config_0)"
"(char-delimiter?"
"(let-values(((in_1)"
" in_0)"
"((skip-count_0)"
" 0)"
"((source_0)"
"(read-config-source"
" config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq?"
" c_1"
" 'special)"
"(special1.1"
" 'special)"
" c_1)))"
" seq-config_0)"
" #f)"
" #f)"
" #f)"
"(let-values()"
"(let-values((()"
"(begin"
"(set! head_0"
"(box"
" v_0))"
"(values))))"
"(let-values(((dot2-line_0"
" dot2-col_0"
" dot2-pos_0)"
"(port-next-location"
" in_0)))"
"(let-values((()"
"(begin"
"(track-indentation!"
" config_0"
" dot2-line_0"
" dot2-col_0)"
"(values))))"
"(let-values(((post-c_0)"
"(read-char/skip-whitespace-and-comments"
" #f"
" whitespace-read-one_0"
" in_0"
" seq-config_0)))"
"(let-values(((post-ec_0)"
"(effective-char"
" post-c_0"
" seq-config_0)))"
"(begin"
"(if(let-values(((or-part_0)"
"(eof-object?"
" post-ec_0)))"
"(if or-part_0"
" or-part_0"
"(eqv?"
" post-ec_0"
" closer_0)))"
"(let-values()"
"(let-values(((in33_0)"
" in_0)"
"((temp34_0)"
"(reading-at"
" config_0"
" dot-line_0"
" dot-col_0"
" dot-pos_0))"
"((post-ec35_0)"
" post-ec_0)"
"((temp36_0)"
"                                                                                                                                        \"illegal use of `.`\"))"
"(reader-error12.1"
" unsafe-undefined"
" post-ec35_0"
" #f"
" unsafe-undefined"
" in33_0"
" temp34_0"
" temp36_0"
"(list))))"
"(void))"
"(loop_0"
" depth_0"
" accum_0"
" post-c_0"
" #f"
" read-one_0))))))))"
"(let-values()"
"(let-values(((in37_0)"
" in_0)"
"((temp38_0)"
"(reading-at"
" config_0"
" dot-line_0"
" dot-col_0"
" dot-pos_0))"
"((rest-c39_0)"
" rest-c_0)"
"((temp40_0)"
"                                                                                                                        \"illegal use of `.`\"))"
"(reader-error12.1"
" unsafe-undefined"
" rest-c39_0"
" #f"
" unsafe-undefined"
" in37_0"
" temp38_0"
" temp40_0"
"(list)))))))))))))"
"(let-values()"
"(let-values(((v_0)"
"(read-one/not-eof_0"
" c_0"
" first-read-one_1"
" config/keep-comment_0)))"
"(if(1/special-comment? v_0)"
"(let-values()"
"(loop_0"
" depth_0"
" accum_0"
" #f"
" #f"
" read-one_0))"
"(if(> depth_0 1024)"
"(let-values()"
"(loop_0"
" depth_0"
"(cons v_0 accum_0)"
" #f"
" #f"
" read-one_0))"
"(let-values()"
"(cons"
" v_0"
"(loop_0"
"(add1 depth_0)"
" null"
" #f"
" #f"
" read-one_0)))))))))))))))"
" loop_0)"
" 0"
" null"
" #f"
" #t"
" first-read-one_0)))"
"(let-values(((full-seq_0)(if head_0(cons(unbox head_0) seq_0) seq_0)))"
"(if shape-tag?_0"
"(add-shape-tag opener_0 in_0 config_0 full-seq_0)"
" full-seq_0))))))))))))))))))))))))"
"(define-values"
"(add-shape-tag)"
"(lambda(opener_0 in_0 config_0 seq_0)"
"(begin"
"(let-values(((tag_0)"
"(let-values(((tmp_0) opener_0))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()(if(check-parameter 1/read-square-bracket-with-tag config_0) '#%brackets #f))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()(if(check-parameter 1/read-curly-brace-with-tag config_0) '#%braces #f))"
"(let-values() #f))))))"
"(if tag_0(cons(wrap tag_0 in_0 config_0 #f) seq_0) seq_0)))))"
" (define-values (not-an-fX.1$1) (lambda (who_0 v_0) (begin 'not-an-fX (raise-argument-error who_0 \"flonum?\" v_0))))"
"(define-values"
"(read-digits12.1)"
"(lambda(base1_0 init3_0 max-count2_0 zero-digits-result4_0 in10_0 config11_0 accum-str9_0)"
"(begin"
" 'read-digits12"
"(let-values(((in_0) in10_0))"
"(let-values(((config_0) config11_0))"
"(let-values(((accum-str_0) accum-str9_0))"
"(let-values(((base_0) base1_0))"
"(let-values(((max-count_0) max-count2_0))"
"(let-values(((init-v_0) init3_0))"
"(let-values(((zero-digits-result_0) zero-digits-result4_0))"
"(let-values()"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_0)(peek-char-or-special in_1 skip-count_0 'special source_0)))"
"(if(eq? c_0 'special)(special1.1 'special) c_0)))))"
"(if(digit?$1 c_0 base_0)"
"(let-values()"
"(begin"
"(consume-char in_0 c_0)"
"(if accum-str_0(let-values()(accum-string-add! accum-str_0 c_0))(void))"
"((letrec-values(((loop_0)"
"(lambda(v_0 max-count_1)"
"(begin"
" 'loop"
"(if(zero? max-count_1)"
"(let-values() v_0)"
"(let-values()"
"(let-values(((c_1)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)"
"(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)"
"(special1.1 'special)"
" c_1)))))"
"(if(digit?$1 c_1 base_0)"
"(let-values()"
"(begin"
"(consume-char in_0 c_1)"
"(if accum-str_0"
"(let-values()(accum-string-add! accum-str_0 c_1))"
"(void))"
"(loop_0"
"(+(digit->number c_1)(* v_0 base_0))"
"(sub1 max-count_1))))"
"(let-values() v_0)))))))))"
" loop_0)"
"(+(digit->number c_0)(* init-v_0 base_0))"
"(sub1 max-count_0))))"
"(if zero-digits-result_0"
"(let-values() zero-digits-result_0)"
"(let-values() c_0)))))))))))))))"
"(define-values"
"(digit?$1)"
"(lambda(c_0 base_0)"
"(begin"
" 'digit?"
"(if(not(char? c_0))"
"(let-values() #f)"
"(if(= base_0 8)"
"(let-values()(octal-digit? c_0))"
"(if(= base_0 16)(let-values()(hex-digit? c_0))(let-values()(decimal-digit? c_0))))))))"
"(define-values(decimal-digit?)(lambda(c_0)(begin(if(char>=? c_0 '#\\0)(char<=? c_0 '#\\9) #f))))"
"(define-values(octal-digit?)(lambda(c_0)(begin(if(char>=? c_0 '#\\0)(char<=? c_0 '#\\7) #f))))"
"(define-values"
"(hex-digit?)"
"(lambda(c_0)"
"(begin"
"(let-values(((or-part_0)(if(char>=? c_0 '#\\0)(char<=? c_0 '#\\9) #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(if(char>=? c_0 '#\\A)(char<=? c_0 '#\\F) #f)))"
"(if or-part_1 or-part_1(if(char>=? c_0 '#\\a)(char<=? c_0 '#\\f) #f))))))))"
"(define-values"
"(digit->number)"
"(lambda(c_0)"
"(begin"
"(if(if(char>=? c_0 '#\\0)(char<=? c_0 '#\\9) #f)"
"(let-values()(-(char->integer c_0)(char->integer '#\\0)))"
"(if(if(char>=? c_0 '#\\A)(char<=? c_0 '#\\F) #f)"
"(let-values()(-(char->integer c_0)(-(char->integer '#\\A) 10)))"
"(let-values()(-(char->integer c_0)(-(char->integer '#\\a) 10))))))))"
"(define-values(string->number$1) string->number)"
"(define-values"
"(1/string->number)"
"(let-values(((string->number5_0)"
"(lambda(s4_0 radix1_0 convert-mode2_0 decimal-mode3_0)"
"(begin"
" 'string->number5"
"(let-values(((s_0) s4_0))"
"(let-values(((radix_0) radix1_0))"
"(let-values(((convert-mode_0) convert-mode2_0))"
"(let-values(((decimal-mode_0)"
"(if(eq? decimal-mode3_0 unsafe-undefined)"
"(if(1/read-decimal-as-inexact) 'decimal-as-inexact 'decimal-as-exact)"
" decimal-mode3_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(string? s_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'string->number \"string?\" s_0)))"
"(if((lambda(p_0)(if(exact-integer? radix_0)(<= 2 radix_0 16) #f)) radix_0)"
"(void)"
"(let-values()"
"                                        (raise-argument-error 'string->number \"(integer-in 2 16)\" radix_0)))"
"(if((lambda(p_0)"
"(let-values(((or-part_0)(eq? p_0 'number-or-false)))"
"(if or-part_0 or-part_0(eq? p_0 'read))))"
" convert-mode_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'string->number"
"                                         \"(or/c 'number-or-false 'read)\""
" convert-mode_0)))"
"(if((lambda(p_0)"
"(let-values(((or-part_0)(eq? p_0 'decimal-as-inexact)))"
"(if or-part_0 or-part_0(eq? p_0 'decimal-as-exact))))"
" decimal-mode_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'string->number"
"                                         \"(or/c 'decimal-as-inexact decimal-as-exact)\""
" decimal-mode_0)))"
"(unchecked-string->number s_0 radix_0 convert-mode_0 decimal-mode_0)))))))))))))"
"(case-lambda"
"((s_0)(begin 'string->number(string->number5_0 s_0 10 'number-or-false unsafe-undefined)))"
"((s_0 radix_0 convert-mode_0 decimal-mode3_0)(string->number5_0 s_0 radix_0 convert-mode_0 decimal-mode3_0))"
"((s_0 radix_0 convert-mode2_0)(string->number5_0 s_0 radix_0 convert-mode2_0 unsafe-undefined))"
"((s_0 radix1_0)(string->number5_0 s_0 radix1_0 'number-or-false unsafe-undefined)))))"
"(define-values"
"(unchecked-string->number)"
"(lambda(s_0 radix_0 convert-mode_0 decimal-mode_0)"
"(begin"
"(let-values(((s66_0) s_0)"
"((temp67_0) 0)"
"((temp68_0)(string-length s_0))"
"((radix69_0) radix_0)"
"((temp70_0) #f)"
"((decimal-mode71_0) decimal-mode_0)"
"((convert-mode72_0) convert-mode_0))"
"(do-string->number17.1 #f temp70_0 s66_0 temp67_0 temp68_0 radix69_0 decimal-mode71_0 convert-mode72_0)))))"
"(define-values"
"(do-string->number17.1)"
"(lambda(in-complex8_0 radix-set?7_0 s11_0 start12_0 end13_0 radix14_0 exactness15_0 convert-mode16_0)"
"(begin"
" 'do-string->number17"
"(let-values(((s_0) s11_0))"
"(let-values(((start_0) start12_0))"
"(let-values(((end_0) end13_0))"
"(let-values(((radix_0) radix14_0))"
"(let-values(((radix-set?_0) radix-set?7_0))"
"(let-values(((exactness_0) exactness15_0))"
"(let-values(((in-complex_0) in-complex8_0))"
"(let-values(((convert-mode_0) convert-mode16_0))"
"(let-values()"
"(if(fx= start_0 end_0)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"                              (let-values () (format \"no digits\"))"
"(let-values() #f)))"
"(let-values()"
"(let-values(((c_0)(string-ref s_0 start_0)))"
"(if(char=? '#\\# c_0)"
"(let-values()"
"(let-values(((next_0)(fx+ 1 start_0)))"
"(if(fx= next_0 end_0)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"                                          (let-values () (format \"no character after `#` indicator in `~.a`\" s_0))"
"(let-values() #f)))"
"(let-values()"
"(let-values(((i_0)(string-ref s_0 next_0)))"
"(let-values(((tmp_0) i_0))"
"(let-values(((index_0)"
"(if(char? tmp_0)"
"(let-values(((codepoint_0)(char->integer tmp_0)))"
"(if(if(unsafe-fx>= codepoint_0 66)"
"(unsafe-fx< codepoint_0 121)"
" #f)"
"(let-values(((tbl_0)"
" '#(2"
" 0"
" 2"
" 1"
" 0"
" 0"
" 0"
" 1"
" 0"
" 0"
" 0"
" 0"
" 0"
" 2"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 2"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 2"
" 0"
" 2"
" 1"
" 0"
" 0"
" 0"
" 1"
" 0"
" 0"
" 0"
" 0"
" 0"
" 2"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 2)))"
"(unsafe-vector*-ref"
" tbl_0"
"(unsafe-fx- codepoint_0 66)))"
" 0))"
" 0)))"
"(if(unsafe-fx< index_0 1)"
"(let-values()"
"(if(eq?(read-complains convert-mode_0) 'must-read)"
"(let-values()"
"(format"
"                                                       \"bad `#` indicator `~a` at `~.a`\""
" i_0"
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if(unsafe-fx< index_0 2)"
"(let-values()"
"(if(let-values(((or-part_0)(exactness-set? exactness_0)))"
"(if or-part_0 or-part_0 in-complex_0))"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                             \"misplaced exactness specification at `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(let-values(((s73_0) s_0)"
"((temp74_0)(fx+ 1 next_0))"
"((end75_0) end_0)"
"((radix76_0) radix_0)"
"((radix-set?77_0) radix-set?_0)"
"((temp78_0)"
"(if(let-values(((or-part_0)(char=? i_0 '#\\e)))"
"(if or-part_0 or-part_0(char=? i_0 '#\\E)))"
" 'exact"
" 'inexact))"
"((temp79_0)"
"(if(eq? convert-mode_0 'read)"
" 'must-read"
" convert-mode_0)))"
"(do-string->number17.1"
" #f"
" radix-set?77_0"
" s73_0"
" temp74_0"
" end75_0"
" radix76_0"
" temp78_0"
" temp79_0)))))"
"(let-values()"
"(if(let-values(((or-part_0) radix-set?_0))"
"(if or-part_0 or-part_0 in-complex_0))"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                             \"misplaced radix specification at `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(let-values(((radix_1)"
"(let-values(((tmp_1) i_0))"
"(if(if(equal? tmp_1 '#\\b)"
" #t"
"(equal? tmp_1 '#\\B))"
"(let-values() 2)"
"(if(if(equal? tmp_1 '#\\o)"
" #t"
"(equal? tmp_1 '#\\O))"
"(let-values() 8)"
"(if(if(equal? tmp_1 '#\\d)"
" #t"
"(equal? tmp_1 '#\\D))"
"(let-values() 10)"
"(let-values() 16)))))))"
"(let-values(((s80_0) s_0)"
"((temp81_0)(fx+ 1 next_0))"
"((end82_0) end_0)"
"((radix83_0) radix_1)"
"((temp84_0) #t)"
"((exactness85_0) exactness_0)"
"((temp86_0)"
"(if(eq? convert-mode_0 'read)"
" 'must-read"
" convert-mode_0)))"
"(do-string->number17.1"
" #f"
" temp84_0"
" s80_0"
" temp81_0"
" end82_0"
" radix83_0"
" exactness85_0"
" temp86_0)))))))))))))))"
"(let-values(((c5_0)"
"(if(char-sign? c_0)"
"(read-special-number s_0 start_0 end_0 convert-mode_0)"
" #f)))"
"(if c5_0"
"((lambda(v_0)"
"(if(eq? exactness_0 'exact)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"                                             (let-values () (format \"no exact representation for `~a`\" v_0))"
"(let-values() #f)))"
"(let-values() v_0)))"
" c5_0)"
"(let-values(((c4_0)"
"(if(char-sign? c_0)"
"(if(not in-complex_0)"
"(if(fx>(fx- end_0 start_0) 7)"
"(if(char=? '#\\i(string-ref s_0(fx- end_0 1)))"
"(if(char-sign?(string-ref s_0 6))"
"(read-special-number"
" s_0"
" start_0"
"(fx+ start_0 6)"
" convert-mode_0)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)))"
"(if c4_0"
"((lambda(v_0)"
"(let-values(((s87_0) s_0)"
"((temp88_0)(fx+ start_0 6))"
"((temp89_0)(fx- end_0 1))"
"((radix90_0) radix_0)"
"((exactness91_0) exactness_0)"
"((convert-mode92_0) convert-mode_0)"
"((temp93_0) 'i)"
"((v94_0) v_0)"
"((temp95_0)"
"(lambda(v_1 v2_0)"
"(begin 'temp95(make-rectangular v_1 v2_0)))))"
"(read-for-special-compound62.1"
" temp93_0"
" #f"
" s87_0"
" temp88_0"
" temp89_0"
" radix90_0"
" exactness91_0"
" convert-mode92_0"
" v94_0"
" temp95_0)))"
" c4_0)"
"(let-values(((c3_0)"
"(if(not in-complex_0)"
"(if(fx>=(fx- end_0 start_0) 7)"
"(if(char=? '#\\i(string-ref s_0(fx- end_0 1)))"
"(if(char-sign?(string-ref s_0(fx- end_0 7)))"
"(read-special-number"
" s_0"
"(fx- end_0 7)"
"(fx- end_0 1)"
" convert-mode_0)"
" #f)"
" #f)"
" #f)"
" #f)))"
"(if c3_0"
"((lambda(v2_0)"
"(if(if(fx= start_0(fx- end_0 7))(not(extflonum? v2_0)) #f)"
"(let-values()(make-rectangular 0 v2_0))"
"(let-values()"
"(let-values(((s96_0) s_0)"
"((start97_0) start_0)"
"((temp98_0)(fx- end_0 7))"
"((radix99_0) radix_0)"
"((exactness100_0) exactness_0)"
"((convert-mode101_0) convert-mode_0)"
"((temp102_0) 'i)"
"((temp103_0) #t)"
"((v2104_0) v2_0)"
"((temp105_0)"
"(lambda(v2_1 v_0)"
"(begin 'temp105(make-rectangular v_0 v2_1)))))"
"(read-for-special-compound62.1"
" temp102_0"
" temp103_0"
" s96_0"
" start97_0"
" temp98_0"
" radix99_0"
" exactness100_0"
" convert-mode101_0"
" v2104_0"
" temp105_0)))))"
" c3_0)"
"(let-values(((c2_0)"
"(if(char-sign? c_0)"
"(if(not in-complex_0)"
"(if(fx>(fx- end_0 start_0) 7)"
"(if(char=? '#\\@(string-ref s_0(fx+ start_0 6)))"
"(read-special-number"
" s_0"
" start_0"
"(fx+ start_0 6)"
" convert-mode_0)"
" #f)"
" #f)"
" #f)"
" #f)))"
"(if c2_0"
"((lambda(v_0)"
"(let-values(((s106_0) s_0)"
"((temp107_0)(fx+ start_0 7))"
"((end108_0) end_0)"
"((radix109_0) radix_0)"
"((exactness110_0) exactness_0)"
"((convert-mode111_0) convert-mode_0)"
"((temp112_0) '@)"
"((v113_0) v_0)"
"((temp114_0)"
"(lambda(v_1 v2_0)"
"(begin 'temp114(make-polar v_1 v2_0)))))"
"(read-for-special-compound62.1"
" temp112_0"
" #f"
" s106_0"
" temp107_0"
" end108_0"
" radix109_0"
" exactness110_0"
" convert-mode111_0"
" v113_0"
" temp114_0)))"
" c2_0)"
"(let-values(((c1_0)"
"(if(not in-complex_0)"
"(if(fx>(fx- end_0 start_0) 7)"
"(if(char=? '#\\@(string-ref s_0(fx- end_0 7)))"
"(read-special-number"
" s_0"
"(fx- end_0 6)"
" end_0"
" convert-mode_0)"
" #f)"
" #f)"
" #f)))"
"(if c1_0"
"((lambda(v2_0)"
"(let-values(((s115_0) s_0)"
"((start116_0) start_0)"
"((temp117_0)(fx- end_0 7))"
"((radix118_0) radix_0)"
"((exactness119_0) exactness_0)"
"((convert-mode120_0) convert-mode_0)"
"((temp121_0) '@)"
"((temp122_0) #t)"
"((v2123_0) v2_0)"
"((temp124_0)"
"(lambda(v2_1 v_0)"
"(begin 'temp124(make-polar v_0 v2_1)))))"
"(read-for-special-compound62.1"
" temp121_0"
" temp122_0"
" s115_0"
" start116_0"
" temp117_0"
" radix118_0"
" exactness119_0"
" convert-mode120_0"
" v2123_0"
" temp124_0)))"
" c1_0)"
"(let-values()"
"(let-values(((s125_0) s_0)"
"((start126_0) start_0)"
"((end127_0) end_0)"
"((radix128_0) radix_0)"
"((radix-set?129_0) radix-set?_0)"
"((exactness130_0) exactness_0)"
"((in-complex131_0) in-complex_0)"
"((convert-mode132_0) convert-mode_0))"
"(do-string->non-special-number30.1"
" in-complex131_0"
" radix-set?129_0"
" s125_0"
" start126_0"
" end127_0"
" radix128_0"
" exactness130_0"
" convert-mode132_0)))))))))))))))))))))))))))))"
"(define-values"
"(do-string->non-special-number30.1)"
"(lambda(in-complex21_0 radix-set?20_0 s24_0 start25_0 end26_0 radix27_0 exactness28_0 convert-mode29_0)"
"(begin"
" 'do-string->non-special-number30"
"(let-values(((s_0) s24_0))"
"(let-values(((start_0) start25_0))"
"(let-values(((end_0) end26_0))"
"(let-values(((radix_0) radix27_0))"
"(let-values(((radix-set?_0) radix-set?20_0))"
"(let-values(((exactness_0) exactness28_0))"
"(let-values(((in-complex_0) in-complex21_0))"
"(let-values(((convert-mode_0) convert-mode29_0))"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(i_0"
" any-digits?_0"
" any-hashes?_0"
" i-pos_0"
" @-pos_0"
" sign-pos_0"
" dot-pos_0"
" slash-pos_0"
" exp-pos_0"
" must-i?_0)"
"(begin"
" 'loop"
"(if(fx= i_0 end_0)"
"(let-values()"
"(if(if(not any-digits?_0)(not i-pos_0) #f)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"                                                          (format \"no digits in `~.a`\" (substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if(if must-i?_0(not i-pos_0) #f)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                             \"too many signs in `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if(if sign-pos_0"
"(let-values(((or-part_0)"
"(if dot-pos_0(fx< dot-pos_0 sign-pos_0) #f)))"
"(if or-part_0"
" or-part_0"
"(if slash-pos_0(fx< slash-pos_0 sign-pos_0) #f)))"
" #f)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                               \"misplaced sign in `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if i-pos_0"
"(let-values()"
"(let-values(((s133_0) s_0)"
"((start134_0) start_0)"
"((sign-pos135_0) sign-pos_0)"
"((sign-pos136_0) sign-pos_0)"
"((temp137_0)(fx- end_0 1))"
"((i-pos138_0) i-pos_0)"
"((sign-pos139_0) sign-pos_0)"
"((radix140_0) radix_0)"
"((radix-set?141_0) radix-set?_0)"
"((exactness142_0) exactness_0)"
"((temp143_0) 'i)"
"((convert-mode144_0) convert-mode_0))"
"(string->complex-number47.1"
" temp143_0"
" radix-set?141_0"
" s133_0"
" start134_0"
" sign-pos135_0"
" sign-pos136_0"
" temp137_0"
" i-pos138_0"
" sign-pos139_0"
" radix140_0"
" exactness142_0"
" convert-mode144_0)))"
"(if @-pos_0"
"(let-values()"
"(let-values(((s145_0) s_0)"
"((start146_0) start_0)"
"((@-pos147_0) @-pos_0)"
"((temp148_0)(fx+ 1 @-pos_0))"
"((end149_0) end_0)"
"((i-pos150_0) i-pos_0)"
"((sign-pos151_0) sign-pos_0)"
"((radix152_0) radix_0)"
"((radix-set?153_0) radix-set?_0)"
"((exactness154_0) exactness_0)"
"((temp155_0) '@)"
"((convert-mode156_0) convert-mode_0))"
"(string->complex-number47.1"
" temp155_0"
" radix-set?153_0"
" s145_0"
" start146_0"
" @-pos147_0"
" temp148_0"
" end149_0"
" i-pos150_0"
" sign-pos151_0"
" radix152_0"
" exactness154_0"
" convert-mode156_0)))"
"(let-values()"
"(string->real-number"
" s_0"
" start_0"
" end_0"
" dot-pos_0"
" slash-pos_0"
" exp-pos_0"
" any-hashes?_0"
" radix_0"
" exactness_0"
" convert-mode_0))))))))"
"(let-values()"
"(let-values(((c_0)(string-ref s_0 i_0)))"
"(if(digit? c_0 radix_0)"
"(let-values()"
"(loop_0"
"(fx+ 1 i_0)"
" #t"
" any-hashes?_0"
" i-pos_0"
" @-pos_0"
" sign-pos_0"
" dot-pos_0"
" slash-pos_0"
" exp-pos_0"
" must-i?_0))"
"(if(char=? c_0 '#\\#)"
"(let-values()"
"(loop_0"
"(fx+ 1 i_0)"
" #t"
" #t"
" i-pos_0"
" @-pos_0"
" sign-pos_0"
" dot-pos_0"
" slash-pos_0"
" exp-pos_0"
" must-i?_0))"
"(if(char-sign? c_0)"
"(let-values()"
"(if(if sign-pos_0 must-i?_0 #f)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                     \"too many signs in `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(loop_0"
"(fx+ 1 i_0)"
" any-digits?_0"
" any-hashes?_0"
" i-pos_0"
" @-pos_0"
" i_0"
" dot-pos_0"
" slash-pos_0"
" #f"
"(if(fx> i_0 start_0)"
"(let-values(((or-part_0)(not @-pos_0)))"
"(if or-part_0 or-part_0(fx> i_0(fx+ 1 @-pos_0))))"
" #f)))))"
"(if(char=? c_0 '#\\.)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if exp-pos_0"
"(let-values(((or-part_0)"
"(not sign-pos_0)))"
"(if or-part_0"
" or-part_0"
"(fx> exp-pos_0 sign-pos_0)))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(if dot-pos_0"
"(let-values(((or-part_1)(not sign-pos_0)))"
"(if or-part_1"
" or-part_1"
"(fx> dot-pos_0 sign-pos_0)))"
" #f)))"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                       \"misplaced `.` in `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if(if slash-pos_0"
"(let-values(((or-part_0)(not sign-pos_0)))"
"(if or-part_0"
" or-part_0"
"(fx> slash-pos_0 sign-pos_0)))"
" #f)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                         \"decimal points and fractions annot be mixed `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(loop_0"
"(fx+ 1 i_0)"
" any-digits?_0"
" any-hashes?_0"
" i-pos_0"
" @-pos_0"
" sign-pos_0"
" i_0"
" #f"
" #f"
" must-i?_0)))))"
"(if(char=? c_0 '#\\/)"
"(let-values()"
"(if(if dot-pos_0"
"(let-values(((or-part_0)(not sign-pos_0)))"
"(if or-part_0"
" or-part_0"
"(fx> dot-pos_0 sign-pos_0)))"
" #f)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                         \"decimal points and fractions annot be mixed `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if(let-values(((or-part_0)"
"(if exp-pos_0"
"(let-values(((or-part_0)"
"(not sign-pos_0)))"
"(if or-part_0"
" or-part_0"
"(fx> exp-pos_0 sign-pos_0)))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(if slash-pos_0"
"(let-values(((or-part_1)(not sign-pos_0)))"
"(if or-part_1"
" or-part_1"
"(fx> slash-pos_0 sign-pos_0)))"
" #f)))"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                           \"misplaced `/` in `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(loop_0"
"(fx+ 1 i_0)"
" any-digits?_0"
" any-hashes?_0"
" i-pos_0"
" @-pos_0"
" sign-pos_0"
" #f"
" i_0"
" #f"
" must-i?_0)))))"
"(if(let-values(((or-part_0)(char=? c_0 '#\\e)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(char=? c_0 '#\\E)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(char=? c_0 '#\\f)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)"
"(char=? c_0 '#\\F)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)"
"(char=? c_0 '#\\d)))"
"(if or-part_4"
" or-part_4"
"(let-values(((or-part_5)"
"(char=? c_0 '#\\D)))"
"(if or-part_5"
" or-part_5"
"(let-values(((or-part_6)"
"(char=?"
" c_0"
" '#\\s)))"
"(if or-part_6"
" or-part_6"
"(let-values(((or-part_7)"
"(char=?"
" c_0"
" '#\\S)))"
"(if or-part_7"
" or-part_7"
"(let-values(((or-part_8)"
"(char=?"
" c_0"
" '#\\l)))"
"(if or-part_8"
" or-part_8"
"(let-values(((or-part_9)"
"(char=?"
" c_0"
" '#\\L)))"
"(if or-part_9"
" or-part_9"
"(let-values(((or-part_10)"
"(char=?"
" c_0"
" '#\\t)))"
"(if or-part_10"
" or-part_10"
"(char=?"
" c_0"
" '#\\T)))))))))))))))))))))))"
"(let-values()"
"(if exp-pos_0"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                           \"misplaced `~a` in `~.a`\""
" c_0"
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if(if(fx<(fx+ 1 i_0) end_0)"
"(char-sign?(string-ref s_0(fx+ 1 i_0)))"
" #f)"
"(let-values()"
"(loop_0"
"(fx+ i_0 2)"
" any-digits?_0"
" any-hashes?_0"
" i-pos_0"
" @-pos_0"
" sign-pos_0"
" dot-pos_0"
" slash-pos_0"
"(let-values(((or-part_0) exp-pos_0))"
"(if or-part_0 or-part_0 i_0))"
" must-i?_0))"
"(let-values()"
"(loop_0"
"(fx+ i_0 1)"
" any-digits?_0"
" any-hashes?_0"
" i-pos_0"
" @-pos_0"
" sign-pos_0"
" dot-pos_0"
" slash-pos_0"
"(let-values(((or-part_0) exp-pos_0))"
"(if or-part_0 or-part_0 i_0))"
" must-i?_0)))))"
"(if(char=? c_0 '#\\@)"
"(let-values()"
"(if(eq? in-complex_0 'i)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                             \"cannot mix `@` and `i` in `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if(let-values(((or-part_0) @-pos_0))"
"(if or-part_0"
" or-part_0"
"(eq? in-complex_0 '@)))"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                               \"too many `@`s in `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if(fx= i_0 start_0)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                                 \"`@` cannot be at start in `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if must-i?_0"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                                   \"too many signs in `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(loop_0"
"(fx+ 1 i_0)"
" any-digits?_0"
" any-hashes?_0"
" i-pos_0"
" i_0"
" #f"
" #f"
" #f"
" #f"
" must-i?_0)))))))"
"(if(if(let-values(((or-part_0)(char=? c_0 '#\\i)))"
"(if or-part_0 or-part_0(char=? c_0 '#\\I)))"
" sign-pos_0"
" #f)"
"(let-values()"
"(if(let-values(((or-part_0) @-pos_0))"
"(if or-part_0"
" or-part_0"
"(eq? in-complex_0 '@)))"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                               \"cannot mix `@` and `i` in `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if(let-values(((or-part_0)"
"(fx<(fx+ 1 i_0) end_0)))"
"(if or-part_0"
" or-part_0"
"(eq? in-complex_0 'i)))"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                                                                 \"`i` must be at the end in `~.a`\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(loop_0"
"(fx+ 1 i_0)"
" any-digits?_0"
" any-hashes?_0"
" i_0"
" @-pos_0"
" sign-pos_0"
" #f"
" #f"
" #f"
" #f)))))"
"(let-values()"
"(if(char=? c_0 '#\\nul)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"                                                                              (format \"nul character in `~.a`\" s_0))"
"(let-values() #f)))"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"                                                                              (format \"bad digit `~a`\" c_0))"
"(let-values() #f))))))))))))))))))))"
" loop_0)"
" start_0"
" #f"
" #f"
" #f"
" #f"
" #f"
" #f"
" #f"
" #f"
" #f)))))))))))))"
"(define-values"
"(string->complex-number47.1)"
"(lambda(in-complex34_0"
" radix-set?33_0"
" s37_0"
" start138_0"
" end139_0"
" start240_0"
" end241_0"
" i-pos42_0"
" sign-pos43_0"
" radix44_0"
" exactness45_0"
" convert-mode46_0)"
"(begin"
" 'string->complex-number47"
"(let-values(((s_0) s37_0))"
"(let-values(((start1_0) start138_0))"
"(let-values(((end1_0) end139_0))"
"(let-values(((start2_0) start240_0))"
"(let-values(((end2_0) end241_0))"
"(let-values()"
"(let-values()"
"(let-values(((radix_0) radix44_0))"
"(let-values(((radix-set?_0) radix-set?33_0))"
"(let-values(((exactness_0) exactness45_0))"
"(let-values(((in-complex_0) in-complex34_0))"
"(let-values(((convert-mode_0) convert-mode46_0))"
"(let-values()"
"(let-values(((v1_0)"
"(if(fx= start1_0 end1_0)"
"(let-values()(if(eq? exactness_0 'inexact) 0.0 0))"
"(let-values()"
"(let-values(((s157_0) s_0)"
"((start1158_0) start1_0)"
"((end1159_0) end1_0)"
"((radix160_0) radix_0)"
"((radix-set?161_0) radix-set?_0)"
"((exactness162_0) exactness_0)"
"((in-complex163_0) in-complex_0)"
"((convert-mode164_0) convert-mode_0))"
"(do-string->number17.1"
" in-complex163_0"
" radix-set?161_0"
" s157_0"
" start1158_0"
" end1159_0"
" radix160_0"
" exactness162_0"
" convert-mode164_0))))))"
"(let-values(((v2_0)"
"(if(if(eq? in-complex_0 'i)(fx=(fx- end2_0 start2_0) 1) #f)"
"(let-values()"
"(let-values(((neg?_0)(char=?(string-ref s_0 start2_0) '#\\-)))"
"(if(eq? exactness_0 'inexact)"
"(let-values()(if neg?_0 -1.0 1.0))"
"(let-values()(if neg?_0 -1 1)))))"
"(let-values()"
"(let-values(((s165_0) s_0)"
"((start2166_0) start2_0)"
"((end2167_0) end2_0)"
"((radix168_0) radix_0)"
"((radix-set?169_0) radix-set?_0)"
"((exactness170_0) exactness_0)"
"((in-complex171_0) in-complex_0)"
"((convert-mode172_0) convert-mode_0))"
"(do-string->number17.1"
" in-complex171_0"
" radix-set?169_0"
" s165_0"
" start2166_0"
" end2167_0"
" radix168_0"
" exactness170_0"
" convert-mode172_0))))))"
"(if(let-values(((or-part_0)(not v1_0)))(if or-part_0 or-part_0(not v2_0)))"
"(let-values() #f)"
"(if(if(let-values(((or-part_0)(extflonum? v1_0)))"
"(if or-part_0 or-part_0(extflonum? v2_0)))"
"(not(eq? convert-mode_0 'must-read))"
" #f)"
"(let-values()(fail-extflonum convert-mode_0 v1_0))"
"(if(string? v1_0)"
"(let-values() v1_0)"
"(if(extflonum? v1_0)"
"(let-values()(fail-extflonum convert-mode_0 v1_0))"
"(if(string? v2_0)"
"(let-values() v2_0)"
"(if(extflonum? v2_0)"
"(let-values()(fail-extflonum convert-mode_0 v2_0))"
"(if(eq? in-complex_0 'i)"
"(let-values()(make-rectangular v1_0 v2_0))"
"(let-values()"
"(let-values(((p_0)(make-polar v1_0 v2_0)))"
"(if(eq? exactness_0 'exact)"
"(inexact->exact p_0)"
" p_0))))))))))))))))))))))))))))"
"(define-values"
"(string->real-number)"
"(lambda(s_0 start_0 end_0 dot-pos_0 slash-pos_0 exp-pos_0 any-hashes?_0 radix_0 exactness_0 convert-mode_0)"
"(begin"
"(let-values(((extfl-mark?_0)"
"(lambda()(begin 'extfl-mark?(char=?(char-downcase(string-ref s_0 exp-pos_0)) '#\\t)))))"
"(let-values(((simple?_0)"
"(if(not slash-pos_0)"
"(if(let-values(((or-part_0)(eq? exactness_0 'inexact)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(eq? exactness_0 'decimal-as-inexact)))"
"(if or-part_1 or-part_1(if(not dot-pos_0)(not exp-pos_0) #f)))))"
"(if(let-values(((or-part_0)(not exp-pos_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(not(eq? convert-mode_0 'number-or-false))))"
"(if or-part_1 or-part_1(not(extfl-mark?_0))))))"
"(not(if any-hashes?_0(hashes? s_0 start_0 end_0) #f))"
" #f)"
" #f)"
" #f)))"
"(let-values(((has-sign?_0)(if(fx> end_0 start_0)(char-sign?(string-ref s_0 start_0)) #f)))"
"(if(fx=(fx- end_0 start_0)(fx+(if dot-pos_0 1 0)(if exp-pos_0 1 0)(if has-sign?_0 1 0)))"
"(let-values()"
"(if(fx= end_0 start_0)"
"                  (if (eq? convert-mode_0 'must-read) (let-values () (format \"missing digits\")) (let-values () #f))"
"(if(eq? convert-mode_0 'must-read)"
"                    (let-values () (format \"missing digits in `~.a`\" (substring s_0 start_0 end_0)))"
"(let-values() #f))))"
"(if simple?_0"
"(let-values()"
"(if(if exp-pos_0"
"(fx="
"(fx- exp-pos_0 start_0)"
"(fx+(if(if dot-pos_0(fx< dot-pos_0 exp-pos_0) #f) 1 0)(if has-sign?_0 1 0)))"
" #f)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"                          (format \"missing digits before exponent marker in `~.a`\" (substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if(if exp-pos_0"
"(let-values(((or-part_0)(fx= exp-pos_0(fx- end_0 1))))"
"(if or-part_0"
" or-part_0"
"(if(fx= exp-pos_0(fx- end_0 2))(char-sign?(string-ref s_0(fx- end_0 1))) #f)))"
" #f)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"                            (format \"missing digits after exponent marker in `~.a`\" (substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(let-values(((n_0)"
"(string->number$1"
"(maybe-substring s_0 start_0 end_0)"
" radix_0"
"(if(let-values(((or-part_0)(eq? convert-mode_0 'number-or-false)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(not exp-pos_0)))"
"(if or-part_1 or-part_1(not(extfl-mark?_0))))))"
" 'number-or-false"
" 'read))))"
"(if(let-values(((or-part_0)(not n_0)))(if or-part_0 or-part_0(string? n_0)))"
"(let-values()"
"(error"
" 'string->number"
"                               \"host `string->number` failed on ~s with radix ~s\""
"(substring s_0 start_0 end_0)"
" radix_0))"
"(if(eq? exactness_0 'inexact)"
"(let-values()"
"(if(extflonum? n_0)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                         \"cannot convert extflonum `~.a` to inexact\""
"(substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(if(if(eqv? n_0 0)(char=?(string-ref s_0 start_0) '#\\-) #f)"
"(let-values() -0.0)"
"(let-values()(exact->inexact n_0)))))"
"(let-values() n_0))))))))"
"(if exp-pos_0"
"(let-values()"
"(let-values(((m-v_0)"
"(string->real-number"
" s_0"
" start_0"
" exp-pos_0"
" dot-pos_0"
" slash-pos_0"
" #f"
" any-hashes?_0"
" radix_0"
" 'exact"
" convert-mode_0)))"
"(let-values(((e-v_0)"
"(string->exact-integer-number s_0(fx+ exp-pos_0 1) end_0 radix_0 convert-mode_0)))"
"(let-values(((real->precision-inexact_0)"
"(lambda(r_0)"
"(begin"
" 'real->precision-inexact"
"(let-values(((tmp_0)(string-ref s_0 exp-pos_0)))"
"(if(if(equal? tmp_0 '#\\s)"
" #t"
"(if(equal? tmp_0 '#\\S)"
" #t"
"(if(equal? tmp_0 '#\\f) #t(equal? tmp_0 '#\\F))))"
"(let-values()(real->single-flonum r_0))"
"(if(if(equal? tmp_0 '#\\t) #t(equal? tmp_0 '#\\T))"
"(let-values()"
"(if(extflonum-available?)"
"(real->extfl r_0)"
"(string->number$1"
"(replace-hashes s_0 start_0 end_0)"
" radix_0"
" 'read)))"
"(let-values()(real->double-flonum r_0)))))))))"
"(let-values(((get-extfl?_0)(extfl-mark?_0)))"
"(if(let-values(((or-part_0)(not m-v_0)))(if or-part_0 or-part_0(not e-v_0)))"
"(let-values() #f)"
"(if(string? m-v_0)"
"(let-values() m-v_0)"
"(if(string? e-v_0)"
"(let-values() e-v_0)"
"(if(if(eq? convert-mode_0 'number-or-false) get-extfl?_0 #f)"
"(let-values() #f)"
"(if(if(let-values(((or-part_0)(eq? exactness_0 'inexact)))"
"(if or-part_0 or-part_0(eq? exactness_0 'decimal-as-inexact)))"
"(>(abs e-v_0)(if get-extfl?_0 6000 400))"
" #f)"
"(let-values()"
"(real->precision-inexact_0"
"(if(eqv? m-v_0 0)"
"(let-values()(if(char=?(string-ref s_0 start_0) '#\\-) -0.0 0.0))"
"(if(positive? m-v_0)"
"(let-values()(if(positive? e-v_0) +inf.0 0.0))"
"(let-values()(if(positive? e-v_0) -inf.0 -0.0))))))"
"(if(if(exactness-set? exactness_0) get-extfl?_0 #f)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"(format"
"                                               \"cannot convert extflonum `~.a` to ~a\""
"(substring s_0 start_0 end_0)"
" exactness_0))"
"(let-values() #f)))"
"(let-values()"
"(let-values(((n_0)(* m-v_0(expt radix_0 e-v_0))))"
"(if(if(not get-extfl?_0)"
"(let-values(((or-part_0)(eq? exactness_0 'exact)))"
"(if or-part_0 or-part_0(eq? exactness_0 'decimal-as-exact)))"
" #f)"
"(let-values() n_0)"
"(if(if(eqv? n_0 0)(char=?(string-ref s_0 start_0) '#\\-) #f)"
"(let-values()(real->precision-inexact_0 -0.0))"
"(let-values()(real->precision-inexact_0 n_0)))))))))))))))))"
"(if slash-pos_0"
"(let-values()"
"(let-values(((n-v_0)"
"(string->real-number"
" s_0"
" start_0"
" slash-pos_0"
" #f"
" #f"
" #f"
" any-hashes?_0"
" radix_0"
" 'exact"
" convert-mode_0)))"
"(let-values(((d-v_0)"
"(string->real-number"
" s_0"
"(fx+ 1 slash-pos_0)"
" end_0"
" #f"
" #f"
" #f"
" any-hashes?_0"
" radix_0"
" 'exact"
" convert-mode_0)))"
"(let-values(((get-inexact?_0)"
"(lambda(from-pos_0)"
"(begin"
" 'get-inexact?"
"(let-values(((or-part_0)(eq? exactness_0 'inexact)))"
"(if or-part_0"
" or-part_0"
"(if(not(eq? exactness_0 'exact))"
"(hashes? s_0 from-pos_0 end_0)"
" #f)))))))"
"(if(let-values(((or-part_0)(not n-v_0)))(if or-part_0 or-part_0(not d-v_0)))"
"(let-values() #f)"
"(if(string? n-v_0)"
"(let-values() n-v_0)"
"(if(string? d-v_0)"
"(let-values() d-v_0)"
"(if(eqv? d-v_0 0)"
"(let-values()"
"(if(get-inexact?_0(fx+ 1 slash-pos_0))"
"(let-values()(if(negative? n-v_0) -inf.0 +inf.0))"
"(let-values()"
"(if(eq?(read-complains convert-mode_0) 'must-read)"
"(let-values()"
"                                              (format \"division by zero in `~.a`\" (substring s_0 start_0 end_0)))"
"(let-values() #f)))))"
"(let-values()"
"(let-values(((n_0)(/ n-v_0 d-v_0)))"
"(if(get-inexact?_0 start_0)(exact->inexact n_0) n_0)))))))))))"
"(let-values()"
"(string->decimal-number s_0 start_0 end_0 dot-pos_0 radix_0 exactness_0 convert-mode_0))))))))))))"
"(define-values"
"(string->decimal-number)"
"(lambda(s_0 start_0 end_0 dot-pos_0 radix_0 exactness_0 convert-mode_0)"
"(begin"
"(let-values(((get-exact?_0)"
"(let-values(((or-part_0)(eq? exactness_0 'exact)))"
"(if or-part_0 or-part_0(eq? exactness_0 'decimal-as-exact)))))"
"(let-values(((new-str_0)(make-string(fx- end_0 start_0(if(if dot-pos_0 get-exact?_0 #f) 1 0)))))"
"((letrec-values(((loop_0)"
"(lambda(i_0 j_0 hashes-pos_0)"
"(begin"
" 'loop"
"(if(fx< i_0 start_0)"
"(let-values()"
"(if(fx= hashes-pos_0 start_0)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"                                            (format \"misplaced `#` in `~.a`\" (substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(let-values(((n_0)(string->number$1 new-str_0 radix_0)))"
"(if(not n_0)"
"(let-values()(fail-bad-number convert-mode_0 s_0 start_0 end_0))"
"(if(not get-exact?_0)"
"(let-values()"
"(if(if(eqv? n_0 0)(char=?(string-ref s_0 start_0) '#\\-) #f)"
" -0.0"
"(exact->inexact n_0)))"
"(if(if dot-pos_0 get-exact?_0 #f)"
"(let-values()(/ n_0(expt 10(fx- end_0 dot-pos_0 1))))"
"(let-values() n_0))))))))"
"(let-values()"
"(let-values(((c_0)(string-ref s_0 i_0)))"
"(if(char=? c_0 '#\\.)"
"(let-values()"
"(if get-exact?_0"
"(let-values()"
"(loop_0"
"(fx- i_0 1)"
" j_0"
"(if(fx= hashes-pos_0(fx+ 1 i_0)) i_0 hashes-pos_0)))"
"(let-values()"
"(begin"
"(string-set! new-str_0 j_0 c_0)"
"(loop_0"
"(fx- i_0 1)"
"(fx- j_0 1)"
"(if(fx= hashes-pos_0(fx+ 1 i_0)) i_0 hashes-pos_0))))))"
"(if(let-values(((or-part_0)(char=? c_0 '#\\-)))"
"(if or-part_0 or-part_0(char=? c_0 '#\\+)))"
"(let-values()"
"(begin"
"(string-set! new-str_0 j_0 c_0)"
"(loop_0"
"(fx- i_0 1)"
"(fx- j_0 1)"
"(if(fx= hashes-pos_0(fx+ 1 i_0)) i_0 hashes-pos_0))))"
"(if(char=? c_0 '#\\#)"
"(let-values()"
"(if(fx= hashes-pos_0(fx+ 1 i_0))"
"(let-values()"
"(begin"
"(string-set! new-str_0 j_0 '#\\0)"
"(loop_0(fx- i_0 1)(fx- j_0 1) i_0)))"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"(let-values()"
"                                                      (format \"misplaced `#` in `~.a`\" (substring s_0 start_0 end_0)))"
"(let-values() #f)))))"
"(let-values()"
"(begin"
"(string-set! new-str_0 j_0 c_0)"
"(loop_0(fx- i_0 1)(fx- j_0 1) hashes-pos_0)))))))))))))"
" loop_0)"
"(fx- end_0 1)"
"(fx-(string-length new-str_0) 1)"
" end_0))))))"
"(define-values"
"(string->exact-integer-number)"
"(lambda(s_0 start_0 end_0 radix_0 convert-mode_0)"
"(begin"
"(if(hashes? s_0 start_0 end_0)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"            (let-values () (format \"misplaced `#` in `~.a`\" (substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values()"
"(let-values(((n_0)(string->number$1(maybe-substring s_0 start_0 end_0) radix_0)))"
"(if(not n_0)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"                  (let-values () (format \"bad exponent `~.a`\" (substring s_0 start_0 end_0)))"
"(let-values() #f)))"
"(let-values() n_0))))))))"
"(define-values"
"(read-special-number)"
"(lambda(s_0 start_0 end_0 convert-mode_0)"
"(begin"
"(if(fx=(fx- end_0 start_0) 6)"
"(if(let-values(((or-part_0)(char=?(string-ref s_0 start_0) '#\\+)))"
"(if or-part_0 or-part_0(char=?(string-ref s_0 start_0) '#\\-)))"
"(let-values(((or-part_0)"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 1))) '#\\i)"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 2))) '#\\n)"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 3))) '#\\f)"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 4))) '#\\.)"
"(let-values(((or-part_0)"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 5))) '#\\0)"
"(if(char=?(string-ref s_0 start_0) '#\\+) +inf.0 -inf.0)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 5))) '#\\f)"
"(if(char=?(string-ref s_0 start_0) '#\\+) +inf.f -inf.f)"
" #f)))"
"(if or-part_1"
" or-part_1"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 5))) '#\\t)"
"(if(not(eq? convert-mode_0 'number-or-false))"
"(if(char=?(string-ref s_0 start_0) '#\\+) '+inf.t '-inf.t)"
" #f)"
" #f)))))"
" #f)"
" #f)"
" #f)"
" #f)))"
"(if or-part_0"
" or-part_0"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 1))) '#\\n)"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 2))) '#\\a)"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 3))) '#\\n)"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 4))) '#\\.)"
"(let-values(((or-part_1)"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 5))) '#\\0) +nan.0 #f)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 5))) '#\\f) +nan.f #f)))"
"(if or-part_2"
" or-part_2"
"(if(char=?(char-downcase(string-ref s_0(fx+ start_0 5))) '#\\t)"
"(if(not(eq? convert-mode_0 'number-or-false)) '+nan.t #f)"
" #f)))))"
" #f)"
" #f)"
" #f)"
" #f)))"
" #f)"
" #f))))"
"(define-values"
"(fail-extflonum)"
"(lambda(convert-mode_0 v_0)"
"(begin"
"(if(eq? convert-mode_0 'must-read)"
"        (let-values () (format \"cannot combine extflonum `~a` into complex number\" v_0))"
"(let-values() #f)))))"
"(define-values"
"(read-for-special-compound62.1)"
"(lambda(in-complex50_0"
" reading-first?51_0"
" s54_0"
" start55_0"
" end56_0"
" radix57_0"
" exactness58_0"
" convert-mode59_0"
" v60_0"
" combine61_0)"
"(begin"
" 'read-for-special-compound62"
"(let-values(((s_0) s54_0))"
"(let-values(((start_0) start55_0))"
"(let-values(((end_0) end56_0))"
"(let-values(((radix_0) radix57_0))"
"(let-values(((exactness_0) exactness58_0))"
"(let-values(((convert-mode_0) convert-mode59_0))"
"(let-values(((in-complex_0) in-complex50_0))"
"(let-values(((reading-first?_0) reading-first?51_0))"
"(let-values(((v_0) v60_0))"
"(let-values(((combine_0) combine61_0))"
"(let-values()"
"(if(eq? exactness_0 'exact)"
"(let-values()"
"(if(eq? convert-mode_0 'must-read)"
"                                  (let-values () (format \"no exact representation for `~a`\" v_0))"
"(let-values() #f)))"
"(if(if(extflonum? v_0)"
"(let-values(((or-part_0)(not reading-first?_0)))"
"(if or-part_0 or-part_0(not(eq? convert-mode_0 'must-read))))"
" #f)"
"(let-values()(fail-extflonum convert-mode_0 v_0))"
"(let-values()"
"(let-values(((v2_0)"
"(let-values(((s173_0) s_0)"
"((start174_0) start_0)"
"((end175_0) end_0)"
"((radix176_0) radix_0)"
"((temp177_0) #t)"
"((exactness178_0) exactness_0)"
"((in-complex179_0) in-complex_0)"
"((convert-mode180_0) convert-mode_0))"
"(do-string->number17.1"
" in-complex179_0"
" temp177_0"
" s173_0"
" start174_0"
" end175_0"
" radix176_0"
" exactness178_0"
" convert-mode180_0))))"
"(if(string? v2_0)"
"(let-values() v2_0)"
"(if(not v2_0)"
"(let-values() v2_0)"
"(if(extflonum? v_0)"
"(let-values()(fail-extflonum convert-mode_0 v_0))"
"(let-values()(combine_0 v_0 v2_0)))))))))))))))))))))))"
"(define-values"
"(hashes?)"
"(lambda(s_0 start_0 end_0)"
"(begin"
"(let-values(((v*_0 start*_0 stop*_0 step*_0)"
"(normalise-inputs"
" 'in-string"
"                     \"string\""
"(lambda(x_0)(string? x_0))"
"(lambda(x_0)(unsafe-string-length x_0))"
" s_0"
" start_0"
" end_0"
" 1)))"
"(begin"
" #t"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 idx_0)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< idx_0 stop*_0)"
"(let-values(((c_0)(string-ref v*_0 idx_0)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()(let-values()(char=? c_0 '#\\#)))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) c_0))(not #f) #f)"
"(for-loop_0 result_1(unsafe-fx+ idx_0 1))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" start*_0))))))"
"(define-values"
"(replace-hashes)"
"(lambda(s_0 start_0 end_0)"
"(begin"
"(let-values(((new-s_0)(make-string(fx- end_0 start_0))))"
"(begin"
"(let-values(((v*_0 start*_0 stop*_0 step*_0)"
"(normalise-inputs"
" 'in-string"
"                         \"string\""
"(lambda(x_0)(string? x_0))"
"(lambda(x_0)(unsafe-string-length x_0))"
" s_0"
" start_0"
" end_0"
" 1))"
"((start_1) 0))"
"(begin"
" #t"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(idx_0 pos_0)"
"(begin"
" 'for-loop"
"(if(if(unsafe-fx< idx_0 stop*_0) #t #f)"
"(let-values(((c_0)(string-ref v*_0 idx_0))((i_0) pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(char=? c_0 '#\\#)"
"(string-set! new-s_0 i_0 '#\\0)"
"(string-set! new-s_0 i_0 c_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0(unsafe-fx+ idx_0 1)(+ pos_0 1))(values))))"
"(values))))))"
" for-loop_0)"
" start*_0"
" start_1)))"
"(void)"
" new-s_0)))))"
"(define-values"
"(maybe-substring)"
"(lambda(s_0 start_0 end_0)"
"(begin(if(if(fx= 0 start_0)(fx= end_0(string-length s_0)) #f) s_0(substring s_0 start_0 end_0)))))"
"(define-values"
"(exactness-set?)"
"(lambda(exactness_0)"
"(begin(let-values(((or-part_0)(eq? exactness_0 'exact)))(if or-part_0 or-part_0(eq? exactness_0 'inexact))))))"
"(define-values"
"(char-sign?)"
"(lambda(c_0)(begin(let-values(((or-part_0)(char=? c_0 '#\\-)))(if or-part_0 or-part_0(char=? c_0 '#\\+))))))"
"(define-values"
"(digit?)"
"(lambda(c_0 radix_0)"
"(begin"
"(let-values(((v_0)(char->integer c_0)))"
"(let-values(((or-part_0)(if(fx>= v_0(char->integer '#\\0))(fx<(fx- v_0(char->integer '#\\0)) radix_0) #f)))"
"(if or-part_0"
" or-part_0"
"(if(fx> radix_0 10)"
"(let-values(((or-part_1)"
"(if(fx>= v_0(char->integer '#\\a))"
"(fx<(fx- v_0(fx-(char->integer '#\\a) 10)) radix_0)"
" #f)))"
"(if or-part_1"
" or-part_1"
"(if(fx>= v_0(char->integer '#\\A))(fx<(fx- v_0(fx-(char->integer '#\\A) 10)) radix_0) #f)))"
" #f)))))))"
"(define-values"
"(fail-bad-number)"
"(lambda(convert-mode_0 s_0 start_0 end_0)"
"(begin"
"(if(eq? convert-mode_0 'must-read)"
"        (let-values () (format \"bad number `~.a`\" (substring s_0 start_0 end_0)))"
"(let-values() #f)))))"
"(define-values"
"(read-complains)"
"(lambda(convert-mode_0)(begin(if(eq? convert-mode_0 'read) 'must-read convert-mode_0))))"
"(define-values"
"(read-symbol-or-number8.1)"
"(lambda(extra-prefix2_0 mode1_0 init-c5_0 in6_0 orig-config7_0)"
"(begin"
" 'read-symbol-or-number8"
"(let-values(((init-c_0) init-c5_0))"
"(let-values(((in_0) in6_0))"
"(let-values(((orig-config_0) orig-config7_0))"
"(let-values(((mode_0) mode1_0))"
"(let-values(((extra-prefix_0) extra-prefix2_0))"
"(let-values()"
"(let-values(((config_0)"
"(if(string? mode_0)(override-parameter 1/read-cdot orig-config_0 #f) orig-config_0)))"
"(let-values(((rt_0)(read-config-readtable config_0)))"
"(let-values(((c1_0)"
"(if rt_0"
"(if(let-values(((or-part_0)(eq? mode_0 'symbol-or-number)))"
"(if or-part_0 or-part_0(eq? mode_0 'symbol/indirect)))"
"(readtable-symbol-parser rt_0)"
" #f)"
" #f)))"
"(if c1_0"
"((lambda(handler_0)"
"(readtable-apply"
" handler_0"
" init-c_0"
" in_0"
" config_0"
"(read-config-line config_0)"
"(read-config-col config_0)"
"(read-config-pos config_0)))"
" c1_0)"
"(let-values()"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values(((quoted-ever?_0) #f))"
"(let-values(((case-sens?_0)(check-parameter read-case-sensitive config_0)))"
"(let-values((()"
"(begin"
"(if extra-prefix_0"
"(let-values()(accum-string-add! accum-str_0 extra-prefix_0))"
"(void))"
"(values))))"
"(let-values(((source_0)(read-config-source config_0)))"
"(let-values(((unexpected-quoted_0)"
"(lambda(c_0 after-c_0)"
"(begin"
" 'unexpected-quoted"
"(let-values(((in11_0) in_0)"
"((config12_0) config_0)"
"((c13_0) c_0)"
"                                                                     ((temp14_0) \"~a following `~a` in ~a\")"
"((temp15_0)"
"(if(eof-object? c_0)"
"                                                                        \"end-of-file\""
"                                                                        \"non-character\"))"
"((after-c16_0) after-c_0)"
"((temp17_0)"
"(if(eq? mode_0 'keyword)"
"                                                                        (let-values () \"keyword\")"
"(if(string? mode_0)"
"                                                                          (let-values () \"number\")"
"                                                                          (let-values () \"symbol\")))))"
"(reader-error12.1"
" unsafe-undefined"
" c13_0"
" #f"
" unsafe-undefined"
" in11_0"
" config12_0"
" temp14_0"
"(list temp15_0 after-c16_0 temp17_0)))))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(init-c_1"
" pipe-quote-c_0"
" foldcase-from_0)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((or-part_0)"
" init-c_1))"
"(if or-part_0"
" or-part_0"
"(let-values(((in_1)"
" in_0)"
"((skip-count_0)"
" 0)"
"((source_1)"
" source_0))"
"(let-values(((c_0)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq?"
" c_0"
" 'special)"
"(special1.1"
" 'special)"
" c_0)))))))"
"(let-values(((ec_0)"
"(let-values(((rt_1) rt_0)"
"((c_1) c_0))"
"(if(let-values(((or-part_0)"
"(not"
" rt_1)))"
"(if or-part_0"
" or-part_0"
"(not"
"(char? c_1))))"
"(let-values() c_1)"
"(let-values()"
"(*readtable-effective-char"
" rt_1"
" c_1))))))"
"(if(if pipe-quote-c_0"
"(not(char? ec_0))"
" #f)"
"(let-values()"
"(begin"
"(if init-c_1"
"(void)"
"(let-values()"
"(consume-char/special"
" in_0"
" config_0"
" c_0)))"
"(unexpected-quoted_0"
" c_0"
" pipe-quote-c_0)))"
"(if(if(not pipe-quote-c_0)"
"(readtable-char-delimiter?"
" rt_0"
" c_0"
" config_0)"
" #f)"
"(let-values()"
"(if case-sens?_0"
"(void)"
"(let-values()"
"(accum-string-convert!"
" accum-str_0"
" string-foldcase"
" foldcase-from_0))))"
"(if(if pipe-quote-c_0"
"(char=? c_0 pipe-quote-c_0)"
" #f)"
"(let-values()"
"(begin"
"(if init-c_1"
"(void)"
"(let-values()"
"(consume-char"
" in_0"
" c_0)))"
"(loop_0"
" #f"
" #f"
"(accum-string-count"
" accum-str_0))))"
"(if(if(char=? ec_0 '#\\|)"
"(check-parameter"
" read-accept-bar-quote"
" config_0)"
" #f)"
"(let-values()"
"(begin"
"(if init-c_1"
"(void)"
"(let-values()"
"(consume-char"
" in_0"
" c_0)))"
"(set! quoted-ever?_0 #t)"
"(if case-sens?_0"
"(void)"
"(let-values()"
"(accum-string-convert!"
" accum-str_0"
" string-foldcase"
" foldcase-from_0)))"
"(loop_0"
" #f"
" c_0"
"(accum-string-count"
" accum-str_0))))"
"(if(if(char=? ec_0 '#\\\\)"
"(not pipe-quote-c_0)"
" #f)"
"(let-values()"
"(let-values((()"
"(begin"
"(if init-c_1"
"(void)"
"(let-values()"
"(consume-char"
" in_0"
" c_0)))"
"(values))))"
"(let-values(((next-c_0)"
"(let-values(((in_1)"
" in_0)"
"((source_1)"
" source_0))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_1))))"
"(begin"
"(if(char? next-c_0)"
"(void)"
"(let-values()"
"(unexpected-quoted_0"
" next-c_0"
" c_0)))"
"(if(let-values(((or-part_0)"
" pipe-quote-c_0))"
"(if or-part_0"
" or-part_0"
" case-sens?_0))"
"(void)"
"(let-values()"
"(accum-string-convert!"
" accum-str_0"
" string-foldcase"
" foldcase-from_0)))"
"(accum-string-add!"
" accum-str_0"
" next-c_0)"
"(set! quoted-ever?_0"
" #t)"
"(loop_0"
" #f"
" #f"
"(accum-string-count"
" accum-str_0))))))"
"(let-values()"
"(begin"
"(if init-c_1"
"(void)"
"(let-values()"
"(consume-char"
" in_0"
" c_0)))"
"(accum-string-add!"
" accum-str_0"
" c_0)"
"(loop_0"
" #f"
" pipe-quote-c_0"
" foldcase-from_0))))))))))))))"
" loop_0)"
" init-c_0"
" #f"
" 0)"
"(values))))"
"(let-values(((str_0)"
"(let-values(((accum-str18_0) accum-str_0)"
"((config19_0) config_0))"
"(accum-string-get!6.1 0 accum-str18_0 config19_0))))"
"(let-values((()"
"(begin"
"(if(if(= 1(string-length str_0))"
"(if(not quoted-ever?_0)"
"(char=?"
" '#\\."
"(effective-char(string-ref str_0 0) config_0))"
" #f)"
" #f)"
"(let-values()"
"(let-values(((in20_0) in_0)"
"((config21_0) config_0)"
"                                                                             ((temp22_0) \"illegal use of `.`\"))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in20_0"
" config21_0"
" temp22_0"
"(list))))"
"(void))"
"(values))))"
"(let-values(((num_0)"
"(if(let-values(((or-part_0)"
"(eq? mode_0 'symbol-or-number)))"
"(if or-part_0 or-part_0(string? mode_0)))"
"(if(not quoted-ever?_0)"
"(unchecked-string->number"
"(if(string? mode_0)"
"(string-append mode_0 str_0)"
" str_0)"
" 10"
" 'read"
"(if(check-parameter"
" 1/read-decimal-as-inexact"
" config_0)"
" 'decimal-as-inexact"
" 'decimal-as-exact))"
" #f)"
" #f)))"
"(begin"
"(if(string? num_0)"
"(let-values()"
"(let-values(((in23_0) in_0)"
"((config24_0) config_0)"
"                                                                   ((temp25_0) \"~a\")"
"((num26_0) num_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in23_0"
" config24_0"
" temp25_0"
"(list num26_0))))"
"(void))"
"(if(if(not num_0)(string? mode_0) #f)"
"(let-values()"
"(let-values(((in27_0) in_0)"
"((config28_0) config_0)"
"                                                                   ((temp29_0) \"bad number: `~a`\")"
"((temp30_0)(string-append mode_0 str_0)))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in27_0"
" config28_0"
" temp29_0"
"(list temp30_0))))"
"(void))"
"(wrap"
"(let-values(((or-part_0) num_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(if(eq? mode_0 'keyword)"
"(string->keyword str_0)"
" #f)))"
"(if or-part_1 or-part_1(string->symbol str_0)))))"
" in_0"
" config_0"
" str_0))))))))))))))))))))))))))"
"(define-values"
"(read-fixnum)"
"(lambda(read-one_0 init-c_0 in_0 config_0)"
"(begin"
"(let-values(((c_0)(read-char/skip-whitespace-and-comments init-c_0 read-one_0 in_0 config_0)))"
"(let-values(((line_0 col_0 pos_0)(port-next-location* in_0 c_0)))"
"          (let-values (((v_0) (read-number-literal c_0 in_0 config_0 \"#e\")))"
"(if(fixnum? v_0)"
"(let-values() v_0)"
"(if(eof-object? v_0)"
"(let-values() v_0)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((temp2_0)(reading-at config_0 line_0 col_0 pos_0))"
"                               ((temp3_0) \"expected a fixnum, found ~a\")"
"((v4_0) v_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in1_0"
" temp2_0"
" temp3_0"
"(list v4_0))))))))))))"
"(define-values"
"(read-flonum)"
"(lambda(read-one_0 init-c_0 in_0 config_0)"
"(begin"
"(let-values(((c_0)(read-char/skip-whitespace-and-comments init-c_0 read-one_0 in_0 config_0)))"
"(let-values(((line_0 col_0 pos_0)(port-next-location* in_0 c_0)))"
"          (let-values (((v_0) (read-number-literal c_0 in_0 config_0 \"#i\")))"
"(if(flonum? v_0)"
"(let-values() v_0)"
"(if(eof-object? v_0)"
"(let-values() v_0)"
"(let-values()"
"(let-values(((in5_0) in_0)"
"((temp6_0)(reading-at config_0 line_0 col_0 pos_0))"
"                               ((temp7_0) \"expected a flonum, found ~a\")"
"((v8_0) v_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in5_0"
" temp6_0"
" temp7_0"
"(list v8_0))))))))))))"
"(define-values"
"(read-number-literal)"
"(lambda(c_0 in_0 config_0 mode_0)"
"(begin"
"(if(not(char? c_0))"
"(let-values() c_0)"
"(let-values()"
"(let-values(((c9_0) c_0)((in10_0) in_0)((config11_0) config_0)((mode12_0) mode_0))"
"(read-symbol-or-number8.1 #f mode12_0 c9_0 in10_0 config11_0)))))))"
"(define-values"
"(read-vector11.1)"
"(lambda(length2_0 mode1_0 read-one5_0 opener-c6_0 opener7_0 closer8_0 in9_0 config10_0)"
"(begin"
" 'read-vector11"
"(let-values(((read-one_0) read-one5_0))"
"(let-values(((opener-c_0) opener-c6_0))"
"(let-values(((opener_0) opener7_0))"
"(let-values(((closer_0) closer8_0))"
"(let-values(((in_0) in9_0))"
"(let-values(((config_0) config10_0))"
"(let-values(((vector-mode_0) mode1_0))"
"(let-values(((expected-len_0) length2_0))"
"(let-values()"
"(let-values(((read-one-element_0)"
"(let-values(((tmp_0) vector-mode_0))"
"(if(equal? tmp_0 'any)"
"(let-values() read-one_0)"
"(if(equal? tmp_0 'fixnum)"
"(let-values()"
"(lambda(init-c_0 in_1 config_1)"
"(begin"
" 'read-one-element"
"(read-fixnum read-one_0 init-c_0 in_1 config_1))))"
"(if(equal? tmp_0 'flonum)"
"(let-values()"
"(lambda(init-c_0 in_1 config_1)"
"(begin"
" 'read-one-element"
"(read-flonum read-one_0 init-c_0 in_1 config_1))))"
"(let-values()(void))))))))"
"(let-values(((seq_0)"
"(let-values(((read-one-element14_0) read-one-element_0)"
"((opener-c15_0) opener-c_0)"
"((opener16_0) opener_0)"
"((closer17_0) closer_0)"
"((in18_0) in_0)"
"((config19_0) config_0)"
"((read-one20_0) read-one_0)"
"((temp21_0) #f))"
"(read-unwrapped-sequence17.1"
" temp21_0"
" unsafe-undefined"
" unsafe-undefined"
" #f"
" read-one20_0"
" read-one-element14_0"
" opener-c15_0"
" opener16_0"
" closer17_0"
" in18_0"
" config19_0))))"
"(let-values(((vec_0)"
"(if(not expected-len_0)"
"(let-values()"
"(let-values(((tmp_0) vector-mode_0))"
"(if(equal? tmp_0 'any)"
"(let-values()(list->vector seq_0))"
"(if(equal? tmp_0 'fixnum)"
"(let-values()"
"(let-values(((len_0)(length seq_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'for/fxvector"
"                                                               \"exact-nonnegative-integer?\""
" len_0)))"
"(let-values(((fill_0) 0))"
"(let-values(((v_0)(make-fxvector len_0 fill_0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((lst_0) seq_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((i_1)"
"(let-values(((i_1)"
" i_0))"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(let-values(((elem_0)"
"(let-values()"
" e_0)))"
"(if(fixnum?"
" elem_0)"
"(unsafe-fxvector-set!"
" v_0"
" i_1"
" elem_0)"
"(not-an-fX.1"
" 'for*/vector"
" elem_0)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values"
" i_2)))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_1"
" len_0))"
" e_0))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_1"
" rest_0)"
" i_1)))"
" i_0)))))"
" for-loop_0)"
" 0"
" lst_0)))))"
" v_0))))))"
"(if(equal? tmp_0 'flonum)"
"(let-values()"
"(let-values(((len_0)(length seq_0)))"
"(begin"
"(if(exact-nonnegative-integer? len_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'for/flvector"
"                                                                 \"exact-nonnegative-integer?\""
" len_0)))"
"(let-values(((fill_0) 0.0))"
"(let-values(((v_0)(make-flvector len_0 fill_0)))"
"(begin"
"(if(zero? len_0)"
"(void)"
"(let-values()"
"(let-values(((lst_0) seq_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((i_1)"
"(let-values(((i_1)"
" i_0))"
"(let-values(((i_2)"
"(let-values()"
"(begin"
"(let-values(((elem_0)"
"(let-values()"
" e_0)))"
"(if(flonum?"
" elem_0)"
"(unsafe-flvector-set!"
" v_0"
" i_1"
" elem_0)"
"(not-an-fX.1$1"
" 'for*/vector"
" elem_0)))"
"(unsafe-fx+"
" 1"
" i_1)))))"
"(values"
" i_2)))))"
"(if(if(not"
"((lambda x_0"
"(unsafe-fx="
" i_1"
" len_0))"
" e_0))"
"(not #f)"
" #f)"
"(for-loop_0"
" i_1"
" rest_0)"
" i_1)))"
" i_0)))))"
" for-loop_0)"
" 0"
" lst_0)))))"
" v_0))))))"
"(let-values()(void)))))))"
"(let-values()"
"(let-values(((len_0)(length seq_0)))"
"(if(= expected-len_0 len_0)"
"(let-values()(list->vector seq_0))"
"(if(< expected-len_0 len_0)"
"(let-values()"
"(let-values(((in22_0) in_0)"
"((config23_0) config_0)"
"((temp24_0)"
"                                                                    \"~avector length ~a is too small, ~a values provided\")"
"((temp25_0)"
"(let-values(((tmp_0) vector-mode_0))"
"(if(equal? tmp_0 'any)"
"                                                                        (let-values () \"\")"
"(if(equal? tmp_0 'fixnum)"
"                                                                          (let-values () \"fx\")"
"(if(equal? tmp_0 'flonum)"
"                                                                            (let-values () \"fl\")"
"(let-values()(void)))))))"
"((expected-len26_0) expected-len_0)"
"((len27_0) len_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in22_0"
" config23_0"
" temp24_0"
"(list temp25_0 expected-len26_0 len27_0))))"
"(let-values()"
"(let-values(((last-or_0)"
"(lambda(v_0)"
"(begin"
" 'last-or"
"(if(null? seq_0)"
"(wrap v_0 in_0 config_0 #f)"
"((letrec-values(((loop_0)"
"(lambda(seq_1)"
"(begin"
" 'loop"
"(if(null?(cdr seq_1))"
"(car seq_1)"
"(loop_0"
"(cdr seq_1)))))))"
" loop_0)"
" seq_0))))))"
"(let-values((()"
"(begin"
"(if(>=(integer-length expected-len_0) 48)"
"(let-values()"
"(raise"
"(exn:fail:out-of-memory"
"                                                                              \"out of memory\""
"(current-continuation-marks))))"
"(void))"
"(values))))"
"(let-values(((vec_0)"
"(let-values(((tmp_0) vector-mode_0))"
"(if(equal? tmp_0 'any)"
"(let-values()"
"(make-vector"
" expected-len_0"
"(last-or_0 0)))"
"(if(equal? tmp_0 'fixnum)"
"(let-values()"
"(make-fxvector"
" expected-len_0"
"(last-or_0 0)))"
"(if(equal? tmp_0 'flonum)"
"(let-values()"
"(make-flvector"
" expected-len_0"
"(last-or_0 0.0)))"
"(let-values()(void))))))))"
"(begin"
"(let-values(((tmp_0) vector-mode_0))"
"(if(equal? tmp_0 'any)"
"(let-values()"
"(begin"
"(let-values(((lst_0) seq_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1)"
" #t"
" #f)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1))"
"((i_0)"
" pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(vector-set!"
" vec_0"
" i_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
" rest_0"
"(+ pos_0 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" start_0)))"
"(void)))"
"(if(equal? tmp_0 'fixnum)"
"(let-values()"
"(begin"
"(let-values(((lst_0) seq_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_1)"
" #t"
" #f)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1))"
"((i_0)"
" pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(fxvector-set!"
" vec_0"
" i_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
" rest_0"
"(+ pos_0 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" start_0)))"
"(void)))"
"(if(equal? tmp_0 'flonum)"
"(let-values()"
"(begin"
"(let-values(((lst_0) seq_0)((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1 pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_1)"
" #t"
" #f)"
"(let-values(((e_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1))"
"((i_0)"
" pos_0))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(flvector-set!"
" vec_0"
" i_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
" rest_0"
"(+"
" pos_0"
" 1))"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" start_0)))"
"(void)))"
"(let-values()(void))))))"
" vec_0))))))))))))"
"(wrap"
"(if(read-config-for-syntax? config_0)(vector->immutable-vector vec_0) vec_0)"
" in_0"
" config_0"
" opener_0))))))))))))))))"
"(define-values"
"(read-fixnum-or-flonum-vector)"
"(lambda(read-one_0 dispatch-c_0 c_0 c2_0 in_0 config_0)"
"(begin"
"(let-values(((vector-mode_0)(if(char=? c2_0 '#\\x) 'fixnum 'flonum)))"
"(let-values((()(begin(consume-char in_0 c2_0)(values))))"
"(let-values((()"
"(begin"
"(if(read-config-for-syntax? config_0)"
"(let-values()"
"(let-values(((in28_0) in_0)"
"((config29_0) config_0)"
"                                           ((temp30_0) \"literal f~avectors not allowed\")"
"((c231_0) c2_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in28_0"
" config29_0"
" temp30_0"
"(list c231_0))))"
"(void))"
"(values))))"
"(let-values(((c3_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((vector-len_0 len-str_0 c4_0)"
"(if(decimal-digit? c3_0)"
"(let-values()(read-simple-number in_0 config_0 c3_0))"
"                              (let-values () (values #f \"\" c3_0)))))"
"(let-values(((tmp_0) c4_0))"
"(if(equal? tmp_0 '#\\()"
"(let-values()"
"(let-values(((read-one32_0) read-one_0)"
"((temp33_0) '#\\()"
"((temp34_0) '#\\()"
"((temp35_0) '#\\))"
"((in36_0) in_0)"
"((config37_0) config_0)"
"((vector-mode38_0) vector-mode_0)"
"((vector-len39_0) vector-len_0))"
"(read-vector11.1"
" vector-len39_0"
" vector-mode38_0"
" read-one32_0"
" temp33_0"
" temp34_0"
" temp35_0"
" in36_0"
" config37_0)))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()"
"(if(check-parameter 1/read-square-bracket-as-paren config_0)"
"(let-values()"
"(let-values(((read-one40_0) read-one_0)"
"((temp41_0) '#\\[)"
"((temp42_0) '#\\[)"
"((temp43_0) '#\\])"
"((in44_0) in_0)"
"((config45_0) config_0)"
"((vector-mode46_0) vector-mode_0)"
"((vector-len47_0) vector-len_0))"
"(read-vector11.1"
" vector-len47_0"
" vector-mode46_0"
" read-one40_0"
" temp41_0"
" temp42_0"
" temp43_0"
" in44_0"
" config45_0)))"
"(let-values()"
"(let-values(((in48_0) in_0)"
"((config49_0) config_0)"
"                                         ((temp50_0) (format \"~a~a\" dispatch-c_0 (format \"~a~a\" c_0 c2_0))))"
"(bad-syntax-error20.1 '#\\x in48_0 config49_0 temp50_0)))))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()"
"(if(check-parameter 1/read-curly-brace-as-paren config_0)"
"(let-values()"
"(let-values(((read-one51_0) read-one_0)"
"((temp52_0) '#\\{)"
"((temp53_0) '#\\{)"
"((temp54_0) '#\\})"
"((in55_0) in_0)"
"((config56_0) config_0)"
"((vector-mode57_0) vector-mode_0)"
"((vector-len58_0) vector-len_0))"
"(read-vector11.1"
" vector-len58_0"
" vector-mode57_0"
" read-one51_0"
" temp52_0"
" temp53_0"
" temp54_0"
" in55_0"
" config56_0)))"
"(let-values()"
"(let-values(((in59_0) in_0)"
"((config60_0) config_0)"
"                                           ((temp61_0) (format \"~a~a\" dispatch-c_0 (format \"~a~a\" c_0 c2_0))))"
"(bad-syntax-error20.1 '#\\x in59_0 config60_0 temp61_0)))))"
"(let-values()"
"(let-values(((in62_0) in_0)"
"((config63_0) config_0)"
"((c464_0) c4_0)"
"                                       ((temp65_0) \"expected `(`, `[`, or `{` after `#~a~a~a`\")"
"((c66_0) c_0)"
"((c267_0) c2_0)"
"((len-str68_0) len-str_0))"
"(reader-error12.1"
" unsafe-undefined"
" c464_0"
" #f"
" unsafe-undefined"
" in62_0"
" config63_0"
" temp65_0"
"(list c66_0 c267_0 len-str68_0))))))))))))))))"
"(define-values"
"(read-simple-number)"
"(lambda(in_0 config_0 init-c_0)"
"(begin"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 init-c_0)(values))))"
"(let-values(((init-v_0)(digit->number init-c_0)))"
"(let-values(((v_0)"
"(let-values(((in69_0) in_0)"
"((config70_0) config_0)"
"((accum-str71_0) accum-str_0)"
"((temp72_0) 10)"
"((temp73_0) +inf.0)"
"((init-v74_0) init-v_0)"
"((init-v75_0) init-v_0))"
"(read-digits12.1 temp72_0 init-v74_0 temp73_0 init-v75_0 in69_0 config70_0 accum-str71_0))))"
"(values"
" v_0"
"(let-values(((accum-str76_0) accum-str_0)((config77_0) config_0))"
"(accum-string-get!6.1 0 accum-str76_0 config77_0))"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))))))))"
"(define-values"
"(read-struct)"
"(lambda(read-one_0 dispatch-c_0 in_0 config_0)"
"(begin"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(let-values(((seq_0)"
"(let-values(((tmp_0) ec_0))"
"(if(equal? tmp_0 '#\\()"
"(let-values()(read-struct-sequence read-one_0 c_0 '#\\( '#\\) in_0 config_0))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()"
"(if(check-parameter 1/read-square-bracket-as-paren config_0)"
"(let-values()(read-struct-sequence read-one_0 c_0 '#\\[ '#\\] in_0 config_0))"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"                                                 ((temp3_0) (format \"~as~a\" dispatch-c_0 c_0)))"
"(bad-syntax-error20.1 '#\\x in1_0 config2_0 temp3_0)))))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()"
"(if(check-parameter 1/read-curly-brace-as-paren config_0)"
"(let-values()(read-struct-sequence read-one_0 c_0 '#\\{ '#\\} in_0 config_0))"
"(let-values()"
"(let-values(((in4_0) in_0)"
"((config5_0) config_0)"
"                                                   ((temp6_0) (format \"~as~a\" dispatch-c_0 c_0)))"
"(bad-syntax-error20.1 '#\\x in4_0 config5_0 temp6_0)))))"
"(let-values()"
"(let-values(((in7_0) in_0)"
"((config8_0) config_0)"
"                                               ((temp9_0) \"expected ~a after `~as`\")"
"((temp10_0)(all-openers-str config_0))"
"((dispatch-c11_0) dispatch-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in7_0"
" config8_0"
" temp9_0"
"(list temp10_0 dispatch-c11_0))))))))))"
"(let-values((()"
"(begin"
"(if(null? seq_0)"
"(let-values()"
"(let-values(((in12_0) in_0)"
"((config13_0) config_0)"
"                                             ((temp14_0) \"missing structure description in `~as` form\")"
"((dispatch-c15_0) dispatch-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in12_0"
" config13_0"
" temp14_0"
"(list dispatch-c15_0))))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if(prefab-key?(car seq_0))"
"(void)"
"(let-values()"
"(let-values(((in16_0) in_0)"
"((config17_0) config_0)"
"                                               ((temp18_0) \"invalid structure description in `~as` form\")"
"((dispatch-c19_0) dispatch-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in16_0"
" config17_0"
" temp18_0"
"(list dispatch-c19_0)))))"
"(values))))"
"(let-values(((st_0)"
"(let-values(((with-handlers-predicate20_0) exn:fail?)"
"((with-handlers-handler21_0)"
"(lambda(exn_0)(begin 'with-handlers-handler21 #f))))"
"(let-values(((bpz_0)(continuation-mark-set-first #f break-enabled-key)))"
"(call-handled-body"
" bpz_0"
"(lambda(e_0)"
"(select-handler/no-breaks"
" e_0"
" bpz_0"
"(list(cons with-handlers-predicate20_0 with-handlers-handler21_0))))"
"(lambda()(prefab-key->struct-type(car seq_0)(length(cdr seq_0)))))))))"
"(begin"
"(if st_0"
"(void)"
"(let-values()"
"(let-values(((in22_0) in_0)"
"((config23_0) config_0)"
"((temp24_0)"
"(string-append"
"                                       \"mismatch between structure description\""
"                                       \" and number of provided field values in `~as` form\"))"
"((dispatch-c25_0) dispatch-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in22_0"
" config23_0"
" temp24_0"
"(list dispatch-c25_0)))))"
"(if(read-config-for-syntax? config_0)"
"(let-values()"
"(if(all-fields-immutable?(car seq_0))"
"(void)"
"(let-values()"
"(let-values(((in26_0) in_0)"
"((config27_0) config_0)"
"                                         ((temp28_0) \"cannot read mutable `~as` form as syntax\")"
"((dispatch-c29_0) dispatch-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in26_0"
" config27_0"
" temp28_0"
"(list dispatch-c29_0))))))"
"(void))"
"(wrap(apply make-prefab-struct seq_0) in_0 config_0 ec_0)))))))))))"
"(define-values"
"(read-struct-sequence)"
"(lambda(read-one_0 opener-c_0 opener_0 closer_0 in_0 config_0)"
"(begin"
"(let-values(((read-one30_0) read-one_0)"
"((opener-c31_0) opener-c_0)"
"((opener32_0) opener_0)"
"((closer33_0) closer_0)"
"((in34_0) in_0)"
"((config35_0) config_0)"
"((temp36_0)"
"(lambda(init-c_0 in_1 config_1)(read-one_0 init-c_0 in_1(disable-wrapping config_1)))))"
"(read-unwrapped-sequence17.1"
" 'all"
" unsafe-undefined"
" temp36_0"
" #f"
" unsafe-undefined"
" read-one30_0"
" opener-c31_0"
" opener32_0"
" closer33_0"
" in34_0"
" config35_0)))))"
"(define-values"
"(read-vector-or-graph)"
"(lambda(read-one_0 dispatch-c_0 init-c_0 in_0 config_0)"
"(begin"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 init-c_0)(values))))"
"(let-values(((init-v_0)(digit->number init-c_0)))"
"(let-values(((v_0)"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((accum-str3_0) accum-str_0)"
"((temp4_0) 10)"
"((temp5_0) +inf.0)"
"((init-v6_0) init-v_0)"
"((init-v7_0) init-v_0))"
"(read-digits12.1 temp4_0 init-v6_0 temp5_0 init-v7_0 in1_0 config2_0 accum-str3_0))))"
"(let-values(((post-line_0 post-col_0 post-pos_0)(port-next-location in_0)))"
"(let-values(((get-accum_0)"
"(lambda(c_0)"
"(begin"
" 'get-accum"
"(format"
"                                   \"~a~a~a\""
" dispatch-c_0"
"(let-values(((accum-str8_0) accum-str_0)((config9_0) config_0))"
"(accum-string-get!6.1 0 accum-str8_0 config9_0))"
" c_0)))))"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(let-values(((tmp_0) ec_0))"
"(if(equal? tmp_0 '#\\()"
"(let-values()"
"(begin"
"(accum-string-abandon! accum-str_0 config_0)"
"(let-values(((read-one10_0) read-one_0)"
"((c11_0) c_0)"
"((temp12_0) '#\\()"
"((temp13_0) '#\\))"
"((in14_0) in_0)"
"((config15_0) config_0)"
"((v16_0) v_0))"
"(read-vector11.1 v16_0 'any read-one10_0 c11_0 temp12_0 temp13_0 in14_0 config15_0))))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()"
"(begin"
"(accum-string-abandon! accum-str_0 config_0)"
"(if(check-parameter 1/read-square-bracket-as-paren config_0)"
"(let-values()"
"(let-values(((read-one17_0) read-one_0)"
"((c18_0) c_0)"
"((temp19_0) '#\\[)"
"((temp20_0) '#\\])"
"((in21_0) in_0)"
"((config22_0) config_0)"
"((v23_0) v_0))"
"(read-vector11.1"
" v23_0"
" 'any"
" read-one17_0"
" c18_0"
" temp19_0"
" temp20_0"
" in21_0"
" config22_0)))"
"(let-values()"
"(let-values(((in24_0) in_0)"
"((config25_0) config_0)"
"((temp26_0)(get-accum_0(get-accum_0 c_0))))"
"(bad-syntax-error20.1 '#\\x in24_0 config25_0 temp26_0))))))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()"
"(begin"
"(accum-string-abandon! accum-str_0 config_0)"
"(if(check-parameter 1/read-curly-brace-as-paren config_0)"
"(let-values()"
"(let-values(((read-one27_0) read-one_0)"
"((c28_0) c_0)"
"((temp29_0) '#\\{)"
"((temp30_0) '#\\})"
"((in31_0) in_0)"
"((config32_0) config_0)"
"((v33_0) v_0))"
"(read-vector11.1"
" v33_0"
" 'any"
" read-one27_0"
" c28_0"
" temp29_0"
" temp30_0"
" in31_0"
" config32_0)))"
"(let-values()"
"(let-values(((in34_0) in_0)"
"((config35_0) config_0)"
"((temp36_0)(get-accum_0(get-accum_0 c_0))))"
"(bad-syntax-error20.1 '#\\x in34_0 config35_0 temp36_0))))))"
"(let-values()"
"(let-values(((tmp_1) c_0))"
"(if(if(equal? tmp_1 '#\\=) #t(equal? tmp_1 '#\\#))"
"(let-values()"
"(begin"
"(if(let-values(((or-part_0)(read-config-for-syntax? config_0)))"
"(if or-part_0"
" or-part_0"
"(not(check-parameter 1/read-accept-graph config_0))))"
"(let-values()"
"(let-values(((in37_0) in_0)"
"((config38_0) config_0)"
"                                                         ((temp39_0) \"`#...~a` forms not ~a\")"
"((c40_0) c_0)"
"((temp41_0)"
"(if(read-config-for-syntax? config_0)"
"                                                            \"allowed in `read-syntax` mode\""
"                                                            \"enabled\")))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in37_0"
" config38_0"
" temp39_0"
"(list c40_0 temp41_0))))"
"(void))"
"(if(<=(accum-string-count accum-str_0) 8)"
"(void)"
"(let-values()"
"(let-values(((in42_0) in_0)"
"((config43_0) config_0)"
"                                                         ((temp44_0) \"graph ID too long in `~a~a~a`\")"
"((dispatch-c45_0) dispatch-c_0)"
"((temp46_0)"
"(let-values(((accum-str48_0) accum-str_0)"
"((config49_0) config_0))"
"(accum-string-get!6.1 0 accum-str48_0 config49_0)))"
"((c47_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in42_0"
" config43_0"
" temp44_0"
"(list dispatch-c45_0 temp46_0 c47_0)))))"
"(let-values(((tmp_2) c_0))"
"(if(equal? tmp_2 '#\\=)"
"(let-values()"
"(let-values(((ph_0)(make-placeholder 'placeholder)))"
"(let-values(((ht_0)(get-graph-hash config_0)))"
"(let-values((()"
"(begin"
"(if(hash-ref ht_0 v_0 #f)"
"(let-values()"
"(let-values(((in50_0) in_0)"
"((config51_0) config_0)"
"                                                                                   ((temp52_0) \"multiple `~a~a~a` tags\")"
"((dispatch-c53_0) dispatch-c_0)"
"((temp54_0)"
"(let-values(((accum-str56_0)"
" accum-str_0)"
"((config57_0)"
" config_0))"
"(accum-string-get!6.1"
" 0"
" accum-str56_0"
" config57_0)))"
"((c55_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in50_0"
" config51_0"
" temp52_0"
"(list dispatch-c53_0 temp54_0 c55_0))))"
"(void))"
"(values))))"
"(let-values((()(begin(hash-set! ht_0 v_0 ph_0)(values))))"
"(let-values(((result-v_0)"
"(read-one_0 #f in_0(next-readtable config_0))))"
"(begin"
"(if(eof-object? result-v_0)"
"(let-values()"
"(let-values(((in58_0) in_0)"
"((config59_0) config_0)"
"((result-v60_0) result-v_0)"
"((temp61_0)"
"                                                                            \"expected an element for graph after `~a~a~a`, found end-of-file\")"
"((dispatch-c62_0) dispatch-c_0)"
"((temp63_0)"
"(let-values(((accum-str65_0) accum-str_0)"
"((config66_0) config_0))"
"(accum-string-get!6.1"
" 0"
" accum-str65_0"
" config66_0)))"
"((c64_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" result-v60_0"
" #f"
" unsafe-undefined"
" in58_0"
" config59_0"
" temp61_0"
"(list dispatch-c62_0 temp63_0 c64_0))))"
"(void))"
"(accum-string-abandon! accum-str_0 config_0)"
"(placeholder-set! ph_0 result-v_0)"
" ph_0)))))))"
"(if(equal? tmp_2 '#\\#)"
"(let-values()"
"(begin0"
"(hash-ref"
"(let-values(((or-part_0)"
"(read-config-state-graph(read-config-st config_0))))"
"(if or-part_0 or-part_0 '#hash()))"
" v_0"
"(lambda()"
"(let-values(((in67_0) in_0)"
"((config68_0) config_0)"
"                                                                  ((temp69_0) \"no preceding `~a~a=` for `~a~a~a`\")"
"((dispatch-c70_0) dispatch-c_0)"
"((v71_0) v_0)"
"((dispatch-c72_0) dispatch-c_0)"
"((temp73_0)"
"(let-values(((accum-str75_0) accum-str_0)"
"((config76_0) config_0))"
"(accum-string-get!6.1 0 accum-str75_0 config76_0)))"
"((c74_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in67_0"
" config68_0"
" temp69_0"
"(list dispatch-c70_0 v71_0 dispatch-c72_0 temp73_0 c74_0)))))"
"(accum-string-abandon! accum-str_0 config_0)))"
"(let-values()(void)))))))"
"(let-values()"
"(let-values(((in77_0) in_0)"
"((config78_0) config_0)"
"((c79_0) c_0)"
"                                                   ((temp80_0) \"bad syntax `~a`\")"
"((temp81_0)(get-accum_0 c_0)))"
"(reader-error12.1"
" unsafe-undefined"
" c79_0"
" #f"
" unsafe-undefined"
" in77_0"
" config78_0"
" temp80_0"
"(list temp81_0))))))))))))))))))))))"
"(define-values"
"(get-graph-hash)"
"(lambda(config_0)"
"(begin"
"(let-values(((st_0)(read-config-st config_0)))"
"(let-values(((or-part_0)(read-config-state-graph st_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((ht_0)(make-hasheqv)))(begin(set-read-config-state-graph! st_0 ht_0) ht_0))))))))"
"(define-values"
"(coerce-key)"
"(lambda(key_0 config_0)"
"(begin"
"(let-values(((for-syntax?_0)(read-config-for-syntax? config_0)))"
"((read-config-coerce-key config_0) for-syntax?_0 key_0)))))"
"(define-values"
"(read-hash)"
"(lambda(read-one_0 dispatch-c_0 init-c_0 in_0 config_0)"
"(begin"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 dispatch-c_0)(values))))"
"(let-values((()(begin(accum-string-add! accum-str_0 init-c_0)(values))))"
"(let-values(((get-next!_0)"
"(lambda(expect-c_0 expect-alt-c_0)"
"(begin"
" 'get-next!"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(let-values(((or-part_0)(eqv? c_0 expect-c_0)))"
"(if or-part_0 or-part_0(eqv? c_0 expect-alt-c_0)))"
"(void)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((c3_0) c_0)"
"                                                   ((temp4_0) \"expected `~a` after `~a`\")"
"((expect-c5_0) expect-c_0)"
"((temp6_0)"
"(let-values(((accum-str7_0) accum-str_0)((config8_0) config_0))"
"(accum-string-get!6.1 0 accum-str7_0 config8_0))))"
"(reader-error12.1"
" unsafe-undefined"
" c3_0"
" #f"
" unsafe-undefined"
" in1_0"
" config2_0"
" temp4_0"
"(list expect-c5_0 temp6_0)))))"
"(accum-string-add! accum-str_0 c_0)))))))"
"(let-values((()(begin(get-next!_0 '#\\a '#\\A)(values))))"
"(let-values((()(begin(get-next!_0 '#\\s '#\\S)(values))))"
"(let-values((()(begin(get-next!_0 '#\\h '#\\H)(values))))"
"(let-values(((content_0 opener_0 mode_0)"
"((letrec-values(((loop_0)"
"(lambda(mode_0)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((source_0)"
"(read-config-source config_0)))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_0))))"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(let-values(((tmp_0) ec_0))"
"(if(equal? tmp_0 '#\\()"
"(let-values()"
"(let-values(((open-end-line_0"
" open-end-col_0"
" open-end-pos_0)"
"(port-next-location in_0)))"
"(let-values(((read-one-key+value_0)"
"(make-read-one-key+value"
" read-one_0"
" c_0"
" '#\\)"
" open-end-pos_0)))"
"(values"
"(let-values(((read-one-key+value9_0)"
" read-one-key+value_0)"
"((c10_0) c_0)"
"((temp11_0) '#\\()"
"((temp12_0) '#\\))"
"((in13_0) in_0)"
"((config14_0) config_0)"
"((config15_0) config_0)"
"((temp16_0) #f))"
"(read-unwrapped-sequence17.1"
" temp16_0"
" config15_0"
" unsafe-undefined"
" #f"
" unsafe-undefined"
" read-one-key+value9_0"
" c10_0"
" temp11_0"
" temp12_0"
" in13_0"
" config14_0))"
" ec_0"
" mode_0))))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()"
"(if(check-parameter"
" 1/read-square-bracket-as-paren"
" config_0)"
"(let-values()"
"(let-values(((open-end-line_0"
" open-end-col_0"
" open-end-pos_0)"
"(port-next-location in_0)))"
"(let-values(((read-one-key+value_0)"
"(make-read-one-key+value"
" read-one_0"
" c_0"
" '#\\]"
" open-end-pos_0)))"
"(values"
"(let-values(((read-one-key+value17_0)"
" read-one-key+value_0)"
"((c18_0) c_0)"
"((temp19_0) '#\\[)"
"((temp20_0) '#\\])"
"((in21_0) in_0)"
"((config22_0) config_0)"
"((config23_0) config_0)"
"((temp24_0) #f))"
"(read-unwrapped-sequence17.1"
" temp24_0"
" config23_0"
" unsafe-undefined"
" #f"
" unsafe-undefined"
" read-one-key+value17_0"
" c18_0"
" temp19_0"
" temp20_0"
" in21_0"
" config22_0))"
" ec_0"
" mode_0))))"
"(let-values()"
"(let-values(((in25_0) in_0)"
"((config26_0) config_0)"
"                                                                                     ((temp27_0) \"illegal use of `~a`\")"
"((c28_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in25_0"
" config26_0"
" temp27_0"
"(list c28_0))))))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()"
"(if(check-parameter"
" 1/read-curly-brace-as-paren"
" config_0)"
"(let-values()"
"(let-values(((open-end-line_0"
" open-end-col_0"
" open-end-pos_0)"
"(port-next-location in_0)))"
"(let-values(((read-one-key+value_0)"
"(make-read-one-key+value"
" read-one_0"
" c_0"
" '#\\}"
" open-end-pos_0)))"
"(values"
"(let-values(((read-one-key+value29_0)"
" read-one-key+value_0)"
"((c30_0) c_0)"
"((temp31_0) '#\\{)"
"((temp32_0) '#\\})"
"((in33_0) in_0)"
"((config34_0) config_0)"
"((config35_0) config_0)"
"((temp36_0) #f))"
"(read-unwrapped-sequence17.1"
" temp36_0"
" config35_0"
" unsafe-undefined"
" #f"
" unsafe-undefined"
" read-one-key+value29_0"
" c30_0"
" temp31_0"
" temp32_0"
" in33_0"
" config34_0))"
" ec_0"
" mode_0))))"
"(let-values()"
"(let-values(((in37_0) in_0)"
"((config38_0) config_0)"
"((temp39_0)"
"                                                                                        \"illegal use of `~a`\")"
"((c40_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in37_0"
" config38_0"
" temp39_0"
"(list c40_0))))))"
"(if(if(equal? tmp_0 '#\\e) #t(equal? tmp_0 '#\\E))"
"(let-values()"
"(begin"
"(accum-string-add! accum-str_0 c_0)"
"(get-next!_0 '#\\q '#\\Q)"
"(loop_0 'eq)))"
"(if(if(equal? tmp_0 '#\\v)"
" #t"
"(equal? tmp_0 '#\\V))"
"(let-values()"
"(begin"
"(accum-string-add! accum-str_0 c_0)"
"(if(eq? mode_0 'eq)"
"(loop_0 'eqv)"
"(let-values(((in41_0) in_0)"
"((config42_0) config_0)"
"((temp43_0)"
"                                                                                            \"bad syntax `~a`\")"
"((temp44_0)"
"(let-values(((accum-str45_0)"
" accum-str_0)"
"((config46_0)"
" config_0))"
"(accum-string-get!6.1"
" 0"
" accum-str45_0"
" config46_0))))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in41_0"
" config42_0"
" temp43_0"
"(list temp44_0))))))"
"(let-values()"
"(begin"
"(if(char? c_0)"
"(let-values()"
"(accum-string-add! accum-str_0 c_0))"
"(void))"
"(let-values(((in47_0) in_0)"
"((config48_0) config_0)"
"((c49_0) c_0)"
"                                                                                         ((temp50_0) \"bad syntax `~a`\")"
"((temp51_0)"
"(let-values(((accum-str52_0)"
" accum-str_0)"
"((config53_0)"
" config_0))"
"(accum-string-get!6.1"
" 0"
" accum-str52_0"
" config53_0))))"
"(reader-error12.1"
" unsafe-undefined"
" c49_0"
" #f"
" unsafe-undefined"
" in47_0"
" config48_0"
" temp50_0"
"(list temp51_0)))))))))))))))))"
" loop_0)"
" 'equal)))"
"(let-values(((graph?_0)(if(read-config-state-graph(read-config-st config_0)) #t #f)))"
"(wrap"
"(let-values(((tmp_0) mode_0))"
"(if(equal? tmp_0 'equal)"
"(let-values()"
"(if graph?_0(make-hash-placeholder content_0)(make-immutable-hash content_0)))"
"(if(equal? tmp_0 'eq)"
"(let-values()"
"(if graph?_0(make-hasheq-placeholder content_0)(make-immutable-hasheq content_0)))"
"(if(equal? tmp_0 'eqv)"
"(let-values()"
"(if graph?_0"
"(make-hasheqv-placeholder content_0)"
"(make-immutable-hasheqv content_0)))"
"(let-values()(void))))))"
" in_0"
" config_0"
" opener_0)))))))))))))"
"(define-values"
"(make-read-one-key+value)"
"(lambda(read-one_0 overall-opener-c_0 overall-closer-ec_0 prefix-end-pos_0)"
"(begin"
"(lambda(init-c_0 in_0 config_0)"
"(let-values(((c_0)(read-char/skip-whitespace-and-comments init-c_0 read-one_0 in_0 config_0)))"
"(let-values(((open-line_0 open-col_0 open-pos_0)(port-next-location* in_0 c_0)))"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(let-values(((elem-config_0)(next-readtable config_0)))"
"(let-values(((closer_0)"
"(let-values(((tmp_0) ec_0))"
"(if(equal? tmp_0 '#\\()"
"(let-values() '#\\))"
"(if(equal? tmp_0 '#\\[)"
"(let-values()"
"(if(check-parameter 1/read-square-bracket-as-paren config_0) '#\\] #f))"
"(if(equal? tmp_0 '#\\{)"
"(let-values()"
"(if(check-parameter 1/read-curly-brace-as-paren config_0) '#\\} #f))"
"(let-values() #f)))))))"
"(if(not closer_0)"
"(let-values()"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in54_0) in_0)"
"((config55_0) config_0)"
"((c56_0) c_0)"
"((prefix-end-pos57_0) prefix-end-pos_0)"
"                                       ((temp58_0) \"expected ~a to close `~a`\")"
"((temp59_0)(closer-name overall-closer-ec_0 config_0))"
"((overall-opener-c60_0) overall-opener-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" c56_0"
" prefix-end-pos57_0"
" unsafe-undefined"
" in54_0"
" config55_0"
" temp58_0"
"(list temp59_0 overall-opener-c60_0))))"
"(if(char-closer? ec_0 config_0)"
"(let-values()"
"(let-values(((in61_0) in_0)"
"((temp62_0)(reading-at config_0 open-line_0 open-col_0 open-pos_0))"
"                                         ((temp63_0) \"~a\")"
"((temp64_0)(indentation-unexpected-closer-message ec_0 c_0 config_0)))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in61_0"
" temp62_0"
" temp63_0"
"(list temp64_0))))"
"(let-values()"
"(let-values(((v_0)(read-one_0 c_0 in_0(keep-comment elem-config_0))))"
"(if(1/special-comment? v_0)"
"(let-values()"
"((make-read-one-key+value"
" read-one_0"
" overall-opener-c_0"
" overall-closer-ec_0"
" prefix-end-pos_0)"
" #f"
" in_0"
" config_0))"
"(let-values()"
"(let-values(((in65_0) in_0)"
"((temp66_0)(reading-at config_0 open-line_0 open-col_0 open-pos_0))"
"                                               ((temp67_0) \"expected ~a to start a hash pair\")"
"((temp68_0)(all-openers-str config_0)))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in65_0"
" temp66_0"
" temp67_0"
"(list temp68_0))))))))))"
"(let-values()"
"(let-values(((k_0)(read-one_0 #f in_0(disable-wrapping elem-config_0))))"
"(let-values(((dot-c_0)(read-char/skip-whitespace-and-comments #f read-one_0 in_0 config_0)))"
"(let-values(((dot-line_0 dot-col_0 dot-pos_0)(port-next-location* in_0 dot-c_0)))"
"(let-values(((dot-ec_0)(effective-char dot-c_0 config_0)))"
"(let-values((()"
"(begin"
"(if(if(eqv? dot-ec_0 '#\\.)"
"(char-delimiter?"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))"
" config_0)"
" #f)"
"(void)"
"(let-values()"
"(let-values(((in69_0) in_0)"
"((temp70_0)"
"(reading-at config_0 dot-line_0 dot-col_0 dot-pos_0))"
"((dot-c71_0) dot-c_0)"
"                                                               ((temp72_0) \"expected ~a and value for hash\")"
"((temp73_0)(dot-name config_0)))"
"(reader-error12.1"
" unsafe-undefined"
" dot-c71_0"
" #f"
" unsafe-undefined"
" in69_0"
" temp70_0"
" temp72_0"
"(list temp73_0)))))"
"(values))))"
"(let-values(((v_0)(read-one_0 #f in_0 elem-config_0)))"
"(let-values(((closer-c_0)"
"(read-char/skip-whitespace-and-comments #f read-one_0 in_0 config_0)))"
"(let-values(((closer-line_0 closer-col_0 closer-pos_0)"
"(port-next-location* in_0 closer-c_0)))"
"(let-values(((closer-ec_0)(effective-char closer-c_0 config_0)))"
"(begin"
"(if(eqv? closer-ec_0 closer_0)"
"(void)"
"(let-values()"
"(let-values(((in74_0) in_0)"
"((temp75_0)"
"(reading-at"
" config_0"
" closer-line_0"
" closer-col_0"
" closer-pos_0))"
"((closer-c76_0) closer-c_0)"
"                                                           ((temp77_0) \"expected ~a after value within a hash\")"
"((temp78_0)(closer-name closer_0 config_0)))"
"(reader-error12.1"
" unsafe-undefined"
" closer-c76_0"
" #f"
" unsafe-undefined"
" in74_0"
" temp75_0"
" temp77_0"
"(list temp78_0)))))"
"(cons(coerce-key k_0 elem-config_0) v_0))))))))))))))))))))))"
"(define-values"
"(read-string5.1)"
"(lambda(mode1_0 in3_0 config4_0)"
"(begin"
" 'read-string5"
"(let-values(((in_0) in3_0))"
"(let-values(((config_0) config4_0))"
"(let-values(((mode_0) mode1_0))"
"(let-values()"
"(let-values(((source_0)(read-config-source config_0)))"
"(let-values(((open-end-line_0 open-end-col_0 open-end-pos_0)(port-next-location in_0)))"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values(((bad-end_0)"
"(lambda(c_0)"
"(begin"
" 'bad-end"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in8_0) in_0)"
"((config9_0) config_0)"
"((c10_0) c_0)"
"((open-end-pos11_0) open-end-pos_0)"
"                                                       ((temp12_0) \"expected a closing `\\\"`\"))"
"(reader-error12.1"
" unsafe-undefined"
" c10_0"
" open-end-pos11_0"
" unsafe-undefined"
" in8_0"
" config9_0"
" temp12_0"
"(list))))"
"(let-values()"
"(let-values(((in13_0) in_0)"
"((config14_0) config_0)"
"((c15_0) c_0)"
"                                                       ((temp16_0) \"found non-character while reading a ~a\")"
"((mode17_0) mode_0))"
"(reader-error12.1"
" unsafe-undefined"
" c15_0"
" #f"
" unsafe-undefined"
" in13_0"
" config14_0"
" temp16_0"
"(list mode17_0)))))))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((source_1) source_0))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_1))))"
"(if(not(char? c_0))"
"(let-values()(bad-end_0 c_0))"
"(if(char=? '#\\\\ c_0)"
"(let-values()"
"(let-values(((escaping-c_0) c_0))"
"(let-values(((escaped-c_0)"
"(let-values(((in_1) in_0)"
"((source_1) source_0))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_1))))"
"(let-values((()"
"(begin"
"(if(not(char? escaped-c_0))"
"(let-values()"
"(bad-end_0 escaped-c_0))"
"(void))"
"(values))))"
"(let-values(((unknown-error_0)"
"(lambda()"
"(begin"
" 'unknown-error"
"(let-values(((in18_0) in_0)"
"((config19_0)"
" config_0)"
"((temp20_0)"
"                                                                                                          \"unknown escape sequence `~a~a` in ~a\")"
"((escaping-c21_0)"
" escaping-c_0)"
"((escaped-c22_0)"
" escaped-c_0)"
"((mode23_0)"
" mode_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in18_0"
" config19_0"
" temp20_0"
"(list"
" escaping-c21_0"
" escaped-c22_0"
" mode23_0)))))))"
"(begin"
"(let-values(((tmp_0) escaped-c_0))"
"(let-values(((index_0)"
"(if(char? tmp_0)"
"(let-values(((codepoint_0)"
"(char->integer"
" tmp_0)))"
"(if(if(unsafe-fx>="
" codepoint_0"
" 10)"
"(unsafe-fx<"
" codepoint_0"
" 121)"
" #f)"
"(let-values(((tbl_0)"
" '#(10"
" 0"
" 0"
" 11"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 1"
" 0"
" 0"
" 0"
" 0"
" 1"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 12"
" 12"
" 12"
" 12"
" 12"
" 12"
" 12"
" 12"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 15"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 1"
" 0"
" 0"
" 0"
" 0"
" 2"
" 3"
" 0"
" 0"
" 9"
" 7"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 5"
" 0"
" 0"
" 0"
" 8"
" 0"
" 4"
" 14"
" 6"
" 0"
" 13)))"
"(unsafe-vector*-ref"
" tbl_0"
"(unsafe-fx-"
" codepoint_0"
" 10)))"
" 0))"
" 0)))"
"(if(unsafe-fx< index_0 7)"
"(if(unsafe-fx< index_0 3)"
"(if(unsafe-fx< index_0 1)"
"(let-values()"
"(unknown-error_0))"
"(if(unsafe-fx< index_0 2)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" escaped-c_0))"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\u0007))))"
"(if(unsafe-fx< index_0 4)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\backspace))"
"(if(unsafe-fx< index_0 5)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\tab))"
"(if(unsafe-fx< index_0 6)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\newline))"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\vtab))))))"
"(if(unsafe-fx< index_0 11)"
"(if(unsafe-fx< index_0 8)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\page))"
"(if(unsafe-fx< index_0 9)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\return))"
"(if(unsafe-fx< index_0 10)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" '#\\u001B))"
"(let-values()(void)))))"
"(if(unsafe-fx< index_0 13)"
"(if(unsafe-fx< index_0 12)"
"(let-values()"
"(let-values(((maybe-newline-c_0)"
"(let-values(((in_1)"
" in_0)"
"((skip-count_0)"
" 0)"
"((source_1)"
" source_0))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_1)))"
"(if(eq?"
" c_1"
" 'special)"
"(special1.1"
" 'special)"
" c_1)))))"
"(begin"
"(if(eqv?"
" maybe-newline-c_0"
" '#\\newline)"
"(let-values()"
"(consume-char"
" in_0"
" maybe-newline-c_0))"
"(void))"
"(void))))"
"(let-values()"
"(let-values(((pos_0)"
"(accum-string-count"
" accum-str_0)))"
"(let-values((()"
"(begin"
"(accum-string-add!"
" accum-str_0"
" escaped-c_0)"
"(values))))"
"(let-values(((init-v_0)"
"(digit->number"
" escaped-c_0)))"
"(let-values(((v_0)"
"(let-values(((in24_0)"
" in_0)"
"((config25_0)"
" config_0)"
"((accum-str26_0)"
" accum-str_0)"
"((temp27_0)"
" 8)"
"((temp28_0)"
" 2)"
"((init-v29_0)"
" init-v_0)"
"((init-v30_0)"
" init-v_0))"
"(read-digits12.1"
" temp27_0"
" init-v29_0"
" temp28_0"
" init-v30_0"
" in24_0"
" config25_0"
" accum-str26_0))))"
"(begin"
"(if(<= v_0 255)"
"(void)"
"(let-values()"
"(let-values(((in31_0)"
" in_0)"
"((config32_0)"
" config_0)"
"((temp33_0)"
"                                                                                                                        \"escape sequence `~a~a` is out of range in ~a\")"
"((escaping-c34_0)"
" escaping-c_0)"
"((temp35_0)"
"(let-values(((accum-str37_0)"
" accum-str_0)"
"((config38_0)"
" config_0)"
"((pos39_0)"
" pos_0))"
"(accum-string-get!6.1"
" pos39_0"
" accum-str37_0"
" config38_0)))"
"((mode36_0)"
" mode_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in31_0"
" config32_0"
" temp33_0"
"(list"
" escaping-c34_0"
" temp35_0"
" mode36_0)))))"
"(set-accum-string-count!"
" accum-str_0"
" pos_0)"
"(accum-string-add!"
" accum-str_0"
"(integer->char"
" v_0)))))))))"
"(if(unsafe-fx< index_0 14)"
"(let-values()"
"(let-values(((pos_0)"
"(accum-string-count"
" accum-str_0)))"
"(let-values(((v_0)"
"(let-values(((in40_0)"
" in_0)"
"((config41_0)"
" config_0)"
"((accum-str42_0)"
" accum-str_0)"
"((temp43_0)"
" 16)"
"((temp44_0)"
" 2))"
"(read-digits12.1"
" temp43_0"
" 0"
" temp44_0"
" #f"
" in40_0"
" config41_0"
" accum-str42_0))))"
"(begin"
"(if(integer? v_0)"
"(void)"
"(let-values()"
"(no-hex-digits"
" in_0"
" config_0"
" v_0"
" escaping-c_0"
" escaped-c_0)))"
"(set-accum-string-count!"
" accum-str_0"
" pos_0)"
"(accum-string-add!"
" accum-str_0"
"(integer->char"
" v_0))))))"
"(if(unsafe-fx< index_0 15)"
"(let-values()"
"(let-values((()"
"(begin"
"(if(eq?"
" mode_0"
" 'string)"
"(void)"
"(let-values()"
"(unknown-error_0)))"
"(values))))"
"(let-values(((pos_0)"
"(accum-string-count"
" accum-str_0)))"
"(let-values(((v_0)"
"(let-values(((in45_0)"
" in_0)"
"((config46_0)"
" config_0)"
"((accum-str47_0)"
" accum-str_0)"
"((temp48_0)"
" 16)"
"((temp49_0)"
" 4))"
"(read-digits12.1"
" temp48_0"
" 0"
" temp49_0"
" #f"
" in45_0"
" config46_0"
" accum-str47_0))))"
"(begin"
"(if(integer? v_0)"
"(void)"
"(let-values()"
"(no-hex-digits"
" in_0"
" config_0"
" v_0"
" escaping-c_0"
" escaped-c_0)))"
"(if(let-values(((or-part_0)"
"(<"
" v_0"
" 55296)))"
"(if or-part_0"
" or-part_0"
"(>"
" v_0"
" 57343)))"
"(let-values()"
"(begin"
"(set-accum-string-count!"
" accum-str_0"
" pos_0)"
"(accum-string-add!"
" accum-str_0"
"(integer->char"
" v_0))))"
"(let-values()"
"(let-values(((next!_0)"
"(lambda()"
"(begin"
" 'next!"
"(let-values(((next-c_0)"
"(let-values(((in_1)"
" in_0)"
"((source_1)"
" source_0))"
"(read-char-or-special"
" in_1"
" special1.1"
" source_1))))"
"(begin"
"(if(char?"
" next-c_0)"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" next-c_0))"
"(void))"
" next-c_0))))))"
"(let-values(((v2_0)"
"(let-values(((next-c_0)"
"(next!_0)))"
"(if(char=?"
" next-c_0"
" '#\\\\)"
"(let-values()"
"(let-values(((next-c_1)"
"(next!_0)))"
"(if(char=?"
" next-c_1"
" '#\\u)"
"(let-values()"
"(let-values(((v2_0)"
"(let-values(((in50_0)"
" in_0)"
"((config51_0)"
" config_0)"
"((accum-str52_0)"
" accum-str_0)"
"((temp53_0)"
" 16)"
"((temp54_0)"
" 4))"
"(read-digits12.1"
" temp53_0"
" 0"
" temp54_0"
" #f"
" in50_0"
" config51_0"
" accum-str52_0))))"
"(if(integer?"
" v2_0)"
"(let-values()"
"(if(>="
" v2_0"
" 56320)"
"(if(<="
" v2_0"
" 57343)"
" v2_0"
" #f)"
" #f))"
"(let-values()"
" v2_0))))"
"(let-values()"
" next-c_1))))"
"(let-values()"
" next-c_0)))))"
"(if(integer?"
" v2_0)"
"(let-values()"
"(let-values(((combined-v_0)"
"(+"
"(arithmetic-shift"
"(-"
" v_0"
" 55296)"
" 10)"
"(-"
" v2_0"
" 56320)"
" 65536)))"
"(if(>"
" combined-v_0"
" 1114111)"
"(let-values()"
"(let-values(((in55_0)"
" in_0)"
"((config56_0)"
" config_0)"
"((temp57_0)"
"                                                                                                                                      \"escape sequence `~au~a` is out of range in string\")"
"((escaping-c58_0)"
" escaping-c_0)"
"((temp59_0)"
"(let-values(((accum-str60_0)"
" accum-str_0)"
"((config61_0)"
" config_0)"
"((pos62_0)"
" pos_0))"
"(accum-string-get!6.1"
" pos62_0"
" accum-str60_0"
" config61_0))))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in55_0"
" config56_0"
" temp57_0"
"(list"
" escaping-c58_0"
" temp59_0))))"
"(let-values()"
"(begin"
"(set-accum-string-count!"
" accum-str_0"
" pos_0)"
"(accum-string-add!"
" accum-str_0"
"(integer->char"
" combined-v_0)))))))"
"(let-values()"
"(let-values(((in63_0)"
" in_0)"
"((config64_0)"
" config_0)"
"((v265_0)"
" v2_0)"
"((temp66_0)"
"                                                                                                                                \"bad or incomplete surrogate-style encoding at `~au~a`\")"
"((escaping-c67_0)"
" escaping-c_0)"
"((temp68_0)"
"(let-values(((accum-str69_0)"
" accum-str_0)"
"((config70_0)"
" config_0)"
"((pos71_0)"
" pos_0))"
"(accum-string-get!6.1"
" pos71_0"
" accum-str69_0"
" config70_0))))"
"(reader-error12.1"
" unsafe-undefined"
" v265_0"
" #f"
" unsafe-undefined"
" in63_0"
" config64_0"
" temp66_0"
"(list"
" escaping-c67_0"
" temp68_0))))))))))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(eq?"
" mode_0"
" 'string)"
"(void)"
"(let-values()"
"(unknown-error_0)))"
"(values))))"
"(let-values(((pos_0)"
"(accum-string-count"
" accum-str_0)))"
"(let-values(((v_0)"
"(let-values(((in72_0)"
" in_0)"
"((config73_0)"
" config_0)"
"((accum-str74_0)"
" accum-str_0)"
"((temp75_0)"
" 16)"
"((temp76_0)"
" 8))"
"(read-digits12.1"
" temp75_0"
" 0"
" temp76_0"
" #f"
" in72_0"
" config73_0"
" accum-str74_0))))"
"(begin"
"(if(integer? v_0)"
"(void)"
"(let-values()"
"(no-hex-digits"
" in_0"
" config_0"
" v_0"
" escaping-c_0"
" escaped-c_0)))"
"(if(if(let-values(((or-part_0)"
"(<"
" v_0"
" 55296)))"
"(if or-part_0"
" or-part_0"
"(>"
" v_0"
" 57343)))"
"(<="
" v_0"
" 1114111)"
" #f)"
"(let-values()"
"(begin"
"(set-accum-string-count!"
" accum-str_0"
" pos_0)"
"(accum-string-add!"
" accum-str_0"
"(integer->char"
" v_0))))"
"(let-values()"
"(let-values(((in77_0)"
" in_0)"
"((config78_0)"
" config_0)"
"((temp79_0)"
"                                                                                                                        \"escape sequence `~aU~a` is out of range in string\")"
"((escaping-c80_0)"
" escaping-c_0)"
"((temp81_0)"
"(let-values(((accum-str82_0)"
" accum-str_0)"
"((config83_0)"
" config_0)"
"((pos84_0)"
" pos_0))"
"(accum-string-get!6.1"
" pos84_0"
" accum-str82_0"
" config83_0))))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in77_0"
" config78_0"
" temp79_0"
"(list"
" escaping-c80_0"
" temp81_0)))))))))))))))))"
"(loop_0)))))))"
"                                                                  (if (char=? '#\\\" c_0)"
"(let-values() null)"
"(let-values()"
"(begin"
"(if(eq? mode_0 '|byte string|)"
"(let-values()"
"(if(byte?(char->integer c_0))"
"(void)"
"(let-values()"
"(let-values(((in85_0) in_0)"
"((config86_0) config_0)"
"((temp87_0)"
"                                                                                              \"character `~a` is out of range in byte string\")"
"((c88_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in85_0"
" config86_0"
" temp87_0"
"(list c88_0))))))"
"(void))"
"(accum-string-add! accum-str_0 c_0)"
"(loop_0)))))))))))"
" loop_0))"
"(values))))"
"(let-values(((str_0)"
"(if(eq? mode_0 '|byte string|)"
"(let-values(((accum-str89_0) accum-str_0)((config90_0) config_0))"
"(accum-string-get-bytes!13.1 0 accum-str89_0 config90_0))"
"(let-values(((accum-str91_0) accum-str_0)((config92_0) config_0))"
"(accum-string-get!6.1 0 accum-str91_0 config92_0)))))"
"(wrap str_0 in_0 config_0 str_0))))))))))))))"
"(define-values"
"(read-here-string)"
"(lambda(in_0 config_0)"
"(begin"
"(let-values(((source_0)(read-config-source config_0)))"
"(let-values(((open-end-line_0 open-end-col_0 open-end-pos_0)(port-next-location in_0)))"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values(((full-terminator_0)"
"(cons"
" '#\\newline"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_1) source_0))"
"(read-char-or-special in_1 special1.1 source_1))))"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in93_0) in_0)"
"((config94_0) config_0)"
"((c95_0) c_0)"
"((temp96_0)"
"                                                                     \"found end-of-file after `#<<` and before a newline\"))"
"(reader-error12.1"
" unsafe-undefined"
" c95_0"
" #f"
" unsafe-undefined"
" in93_0"
" config94_0"
" temp96_0"
"(list))))"
"(if(not(char? c_0))"
"(let-values()"
"(let-values(((in97_0) in_0)"
"((config98_0) config_0)"
"((c99_0) c_0)"
"((temp100_0)"
"                                                                       \"found non-character while reading `#<<`\"))"
"(reader-error12.1"
" unsafe-undefined"
" c99_0"
" #f"
" unsafe-undefined"
" in97_0"
" config98_0"
" temp100_0"
"(list))))"
"(if(char=? c_0 '#\\newline)"
"(let-values() null)"
"(let-values()(cons c_0(loop_0)))))))))))"
" loop_0)))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(terminator_0 terminator-accum_0)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_1) source_0))"
"(read-char-or-special in_1 special1.1 source_1))))"
"(if(eof-object? c_0)"
"(let-values()"
"(if(null? terminator_0)"
"(void)"
"(let-values()"
"(let-values(((in101_0) in_0)"
"((config102_0) config_0)"
"((c103_0) c_0)"
"((open-end-pos104_0) open-end-pos_0)"
"((temp105_0)"
"                                                                            \"found end-of-file before terminating `~a`\")"
"((temp106_0)"
"(list->string(cdr full-terminator_0))))"
"(reader-error12.1"
" unsafe-undefined"
" c103_0"
" open-end-pos104_0"
" unsafe-undefined"
" in101_0"
" config102_0"
" temp105_0"
"(list temp106_0))))))"
"(if(not(char? c_0))"
"(let-values()"
"(let-values(((in107_0) in_0)"
"((config108_0) config_0)"
"((c109_0) c_0)"
"((temp110_0)"
"                                                                          \"found non-character while reading `#<<`\"))"
"(reader-error12.1"
" unsafe-undefined"
" c109_0"
" #f"
" unsafe-undefined"
" in107_0"
" config108_0"
" temp110_0"
"(list))))"
"(if(if(pair? terminator_0)"
"(char=? c_0(car terminator_0))"
" #f)"
"(let-values()"
"(loop_0"
"(cdr terminator_0)"
"(cons(car terminator_0) terminator-accum_0)))"
"(if(if(null? terminator_0)(char=? c_0 '#\\newline) #f)"
"(let-values()(void))"
"(let-values()"
"(begin"
"(if(null? terminator-accum_0)"
"(void)"
"(let-values()"
"(begin"
"(let-values(((lst_0)"
"(reverse$1 terminator-accum_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((c_1)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(accum-string-add!"
" accum-str_0"
" c_1))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void))))"
"(if(char=? c_0 '#\\newline)"
"(let-values()"
"(loop_0"
"(cdr full-terminator_0)"
"(list '#\\newline)))"
"(let-values()"
"(begin"
"(accum-string-add! accum-str_0 c_0)"
"(loop_0 full-terminator_0 null)))))))))))))))"
" loop_0)"
"(cdr full-terminator_0)"
" null)"
"(values))))"
"(let-values(((str_0)"
"(let-values(((accum-str111_0) accum-str_0)((config112_0) config_0))"
"(accum-string-get!6.1 0 accum-str111_0 config112_0))))"
"(wrap str_0 in_0 config_0 str_0))))))))))"
"(define-values"
"(no-hex-digits)"
"(lambda(in_0 config_0 c_0 escaping-c_0 escaped-c_0)"
"(begin"
"(let-values(((in113_0) in_0)"
"((config114_0) config_0)"
"((c115_0) c_0)"
"                   ((temp116_0) \"no hex digit following `~a~a`\")"
"((escaping-c117_0) escaping-c_0)"
"((escaped-c118_0) escaped-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" c115_0"
" #f"
" unsafe-undefined"
" in113_0"
" config114_0"
" temp116_0"
"(list escaping-c117_0 escaped-c118_0))))))"
"(define-values"
"(read-character)"
"(lambda(in_0 config_0)"
"(begin"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((char_0)"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((c3_0) c_0)"
"                                       ((temp4_0) \"expected a character after `#\\\\`\"))"
"(reader-error12.1"
" unsafe-undefined"
" c3_0"
" #f"
" unsafe-undefined"
" in1_0"
" config2_0"
" temp4_0"
"(list))))"
"(if(not(char? c_0))"
"(let-values()"
"(let-values(((in5_0) in_0)"
"((config6_0) config_0)"
"((c7_0) c_0)"
"                                         ((temp8_0) \"found non-character after `#\\\\`\"))"
"(reader-error12.1"
" unsafe-undefined"
" c7_0"
" #f"
" unsafe-undefined"
" in5_0"
" config6_0"
" temp8_0"
"(list))))"
"(if(octal-digit? c_0)"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special in_1 skip-count_0 'special source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(if(char? c2_0)(octal-digit? c2_0) #f)"
"(let-values()"
"(let-values((()(begin(consume-char in_0 c2_0)(values))))"
"(let-values(((c3_0)"
"(let-values(((in_1) in_0)"
"((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((v_0)"
"(if(if(char? c3_0)(octal-digit? c3_0) #f)"
"(let-values()"
"(+"
"(arithmetic-shift(digit->number c_0) 6)"
"(arithmetic-shift(digit->number c2_0) 3)"
"(digit->number c3_0)))"
"(let-values() #f))))"
"(begin"
"(if(if v_0(<= v_0 255) #f)"
"(void)"
"(let-values()"
"(let-values(((in9_0) in_0)"
"((config10_0) config_0)"
"((c311_0) c3_0)"
"                                                             ((temp12_0) \"bad character constant `#\\\\~a~a~a`\")"
"((c13_0) c_0)"
"((c214_0) c2_0)"
"                                                             ((temp15_0) (if (char? c3_0) c3_0 \"\")))"
"(reader-error12.1"
" unsafe-undefined"
" c311_0"
" #f"
" unsafe-undefined"
" in9_0"
" config10_0"
" temp12_0"
"(list c13_0 c214_0 temp15_0)))))"
"(integer->char v_0))))))"
"(let-values() c_0))))"
"(if(let-values(((or-part_0)(char=? c_0 '#\\u)))"
"(if or-part_0 or-part_0(char=? c_0 '#\\U)))"
"(let-values()"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values(((v_0)"
"(let-values(((in16_0) in_0)"
"((config17_0) config_0)"
"((accum-str18_0) accum-str_0)"
"((temp19_0) 16)"
"((temp20_0)(if(char=? c_0 '#\\u) 4 8)))"
"(read-digits12.1"
" temp19_0"
" 0"
" temp20_0"
" #f"
" in16_0"
" config17_0"
" accum-str18_0))))"
"(if(integer? v_0)"
"(let-values()"
"(if(if(let-values(((or-part_0)(< v_0 55296)))"
"(if or-part_0 or-part_0(> v_0 57343)))"
"(<= v_0 1114111)"
" #f)"
"(let-values()"
"(begin(accum-string-abandon! accum-str_0 config_0)(integer->char v_0)))"
"(let-values()"
"(let-values(((in21_0) in_0)"
"((config22_0) config_0)"
"                                                         ((temp23_0) \"bad character constant `#\\\\u~a`\")"
"((temp24_0)"
"(let-values(((accum-str25_0) accum-str_0)"
"((config26_0) config_0))"
"(accum-string-get!6.1 0 accum-str25_0 config26_0))))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in21_0"
" config22_0"
" temp23_0"
"(list temp24_0))))))"
"(let-values()(begin(accum-string-abandon! accum-str_0 config_0) c_0))))))"
"(if(char-alphabetic? c_0)"
"(let-values()"
"(let-values(((next-c_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(if(char? next-c_0)(char-alphabetic? next-c_0) #f)"
"(let-values()"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 c_0)(values))))"
"(let-values((()(begin(accum-string-add! accum-str_0 next-c_0)(values))))"
"(let-values((()(begin(consume-char in_0 next-c_0)(values))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((next-c_1)"
"(let-values(((in_1)"
" in_0)"
"((skip-count_0)"
" 0)"
"((source_0)"
"(read-config-source"
" config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq?"
" c_1"
" 'special)"
"(special1.1"
" 'special)"
" c_1)))))"
"(if(if(char? next-c_1)"
"(char-alphabetic?"
" next-c_1)"
" #f)"
"(let-values()"
"(begin"
"(accum-string-add!"
" accum-str_0"
" next-c_1)"
"(consume-char"
" in_0"
" next-c_1)"
"(loop_0)))"
"(void)))))))"
" loop_0))"
"(values))))"
"(let-values(((name_0)"
"(string-foldcase"
"(let-values(((accum-str27_0) accum-str_0)"
"((config28_0) config_0))"
"(accum-string-get!6.1 0 accum-str27_0 config28_0)))))"
"(let-values(((tmp_0) name_0))"
"                                                      (if (if (equal? tmp_0 \"nul\") #t (equal? tmp_0 \"null\"))"
"(let-values() '#\\nul)"
"                                                        (if (equal? tmp_0 \"backspace\")"
"(let-values() '#\\backspace)"
"                                                          (if (equal? tmp_0 \"tab\")"
"(let-values() '#\\tab)"
"                                                            (if (if (equal? tmp_0 \"newline\")"
" #t"
"                                                                  (equal? tmp_0 \"linefeed\"))"
"(let-values() '#\\newline)"
"                                                              (if (equal? tmp_0 \"vtab\")"
"(let-values() '#\\vtab)"
"                                                                (if (equal? tmp_0 \"page\")"
"(let-values() '#\\page)"
"                                                                  (if (equal? tmp_0 \"return\")"
"(let-values() '#\\return)"
"                                                                    (if (equal? tmp_0 \"space\")"
"(let-values() '#\\space)"
"                                                                      (if (equal? tmp_0 \"rubout\")"
"(let-values() '#\\rubout)"
"(let-values()"
"(let-values(((in29_0) in_0)"
"((config30_0) config_0)"
"((temp31_0)"
"                                                                                        \"bad character constant `#\\\\~a`\")"
"((name32_0) name_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in29_0"
" config30_0"
" temp31_0"
"(list name32_0)))))))))))))))))))))"
"(let-values() c_0))))"
"(let-values() c_0))))))))"
"(wrap char_0 in_0 config_0 char_0))))))"
"(define-values"
"(read-quote)"
"(lambda(read-one_0 sym_0 desc_0 c_0 in_0 config_0)"
"(begin"
"(let-values(((wrapped-sym_0)(wrap sym_0 in_0 config_0 c_0)))"
"(let-values(((end-line_0 end-col_0 end-pos_0)(port-next-location in_0)))"
"(let-values(((e_0)(read-one_0 #f in_0 config_0)))"
"(begin"
"(if(eof-object? e_0)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((e3_0) e_0)"
"((end-pos4_0) end-pos_0)"
"                               ((temp5_0) \"expected an element for ~a, found end-of-file\")"
"((desc6_0) desc_0))"
"(reader-error12.1"
" unsafe-undefined"
" e3_0"
" end-pos4_0"
" unsafe-undefined"
" in1_0"
" config2_0"
" temp5_0"
"(list desc6_0))))"
"(void))"
"(wrap(list wrapped-sym_0 e_0) in_0 config_0 #f))))))))"
"(define-values"
"(read-delimited-constant)"
"(lambda(init-c_0 can-match?_0 chars_0 val_0 in_0 config_0)"
"(begin"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(begin"
"(accum-string-add! accum-str_0 init-c_0)"
"((letrec-values(((loop_0)"
"(lambda(chars_1)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_0)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_0 'special)(special1.1 'special) c_0)))))"
"(if(char-delimiter? c_0 config_0)"
"(let-values()"
"(if(null? chars_1)"
"(void)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"((c3_0) c_0)"
"                                                       ((temp4_0) \"bad syntax `#~a`\")"
"((temp5_0)"
"(let-values(((accum-str6_0) accum-str_0)"
"((config7_0) config_0))"
"(accum-string-get!6.1 0 accum-str6_0 config7_0))))"
"(reader-error12.1"
" unsafe-undefined"
" c3_0"
" #f"
" unsafe-undefined"
" in1_0"
" config2_0"
" temp4_0"
"(list temp5_0))))))"
"(if(null? chars_1)"
"(let-values()"
"(begin"
"(accum-string-add! accum-str_0 c_0)"
"(let-values(((in8_0) in_0)"
"((config9_0) config_0)"
"                                                       ((temp10_0) \"bad syntax `#~a`\")"
"((temp11_0)"
"(let-values(((accum-str12_0) accum-str_0)"
"((config13_0) config_0))"
"(accum-string-get!6.1 0 accum-str12_0 config13_0))))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in8_0"
" config9_0"
" temp10_0"
"(list temp11_0)))))"
"(if(if can-match?_0(char=? c_0(car chars_1)) #f)"
"(let-values()"
"(begin"
"(consume-char in_0 c_0)"
"(accum-string-add! accum-str_0 c_0)"
"(loop_0(cdr chars_1))))"
"(let-values()"
"(begin"
"(consume-char/special in_0 config_0 c_0)"
"(accum-string-add! accum-str_0 c_0)"
"(let-values(((in14_0) in_0)"
"((config15_0) config_0)"
"                                                         ((temp16_0) \"bad syntax `#~a`\")"
"((temp17_0)"
"(let-values(((accum-str18_0) accum-str_0)"
"((config19_0) config_0))"
"(accum-string-get!6.1 0 accum-str18_0 config19_0))))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in14_0"
" config15_0"
" temp16_0"
"(list temp17_0)))))))))))))"
" loop_0)"
" chars_0)"
"(wrap"
" val_0"
" in_0"
" config_0"
"(let-values(((accum-str20_0) accum-str_0)((config21_0) config_0))"
"(accum-string-get!6.1 0 accum-str20_0 config21_0))))))))"
"(define-values"
"(read-box)"
"(lambda(read-one_0 dispatch-c_0 in_0 config_0)"
"(begin"
"(let-values((()"
"(begin"
"(if(check-parameter 1/read-accept-box config_0)"
"(void)"
"(let-values()"
"(let-values(((in1_0) in_0)"
"((config2_0) config_0)"
"                                       ((temp3_0) \"`~a&` forms not enabled\")"
"((dispatch-c4_0) dispatch-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in1_0"
" config2_0"
" temp3_0"
"(list dispatch-c4_0)))))"
"(values))))"
"(let-values(((open-end-line_0 open-end-col_0 open-end-pos_0)(port-next-location in_0)))"
"(let-values(((e_0)(read-one_0 #f in_0(next-readtable config_0))))"
"(begin"
"(if(eof-object? e_0)"
"(let-values()"
"(let-values(((in5_0) in_0)"
"((config6_0) config_0)"
"((e7_0) e_0)"
"((open-end-pos8_0) open-end-pos_0)"
"                               ((temp9_0) \"expected an element for `~a&` box, found end-of-file\")"
"((dispatch-c10_0) dispatch-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" e7_0"
" open-end-pos8_0"
" unsafe-undefined"
" in5_0"
" config6_0"
" temp9_0"
"(list dispatch-c10_0))))"
"(void))"
"(wrap(if(read-config-for-syntax? config_0)(box-immutable e_0)(box e_0)) in_0 config_0 #f))))))))"
"(define-values"
"(read-regexp)"
"(lambda(mode-c_0 accum-str_0 in_0 config_0)"
"(begin"
"(let-values(((c3_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((no-wrap-config_0)(disable-wrapping config_0)))"
"(let-values(((rx_0)"
"(let-values(((tmp_0) c3_0))"
"                          (if (equal? tmp_0 '#\\\")"
"(let-values()"
"(let-values((()(begin(accum-string-abandon! accum-str_0 config_0)(values))))"
"(let-values(((str_0)"
"(let-values(((in1_0) in_0)((no-wrap-config2_0) no-wrap-config_0))"
"(read-string5.1 'string in1_0 no-wrap-config2_0))))"
"(catch-and-reraise-as-reader/proc"
" in_0"
" config_0"
"(lambda()((if(char=? mode-c_0 '#\\r) regexp pregexp) str_0))))))"
"(if(equal? tmp_0 '#\\#)"
"(let-values()"
"(let-values((()(begin(accum-string-add! accum-str_0 c3_0)(values))))"
"(let-values(((c4_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((tmp_1) c4_0))"
"                                      (if (equal? tmp_1 '#\\\")"
"(let-values()"
"(let-values((()"
"(begin(accum-string-abandon! accum-str_0 config_0)(values))))"
"(let-values(((bstr_0)"
"(let-values(((in3_0) in_0)"
"((no-wrap-config4_0) no-wrap-config_0)"
"((temp5_0) '|byte string|))"
"(read-string5.1 temp5_0 in3_0 no-wrap-config4_0))))"
"(catch-and-reraise-as-reader/proc"
" in_0"
" config_0"
"(lambda()"
"((if(char=? mode-c_0 '#\\r) byte-regexp byte-pregexp) bstr_0))))))"
"(let-values()"
"(let-values(((in6_0) in_0)"
"((config7_0) config_0)"
"((c48_0) c4_0)"
"                                                       ((temp9_0) \"expected `\\\"` after `~a`\")"
"((temp10_0)"
"(let-values(((accum-str11_0) accum-str_0)"
"((config12_0) config_0))"
"(accum-string-get!6.1 0 accum-str11_0 config12_0))))"
"(reader-error12.1"
" unsafe-undefined"
" c48_0"
" #f"
" unsafe-undefined"
" in6_0"
" config7_0"
" temp9_0"
"(list temp10_0)))))))))"
"(let-values()"
"(let-values(((in13_0) in_0)"
"((config14_0) config_0)"
"((c315_0) c3_0)"
"                                             ((temp16_0) \"expected `\\\"` or `#` after `~a`\")"
"((temp17_0)"
"(let-values(((accum-str18_0) accum-str_0)((config19_0) config_0))"
"(accum-string-get!6.1 0 accum-str18_0 config19_0))))"
"(reader-error12.1"
" unsafe-undefined"
" c315_0"
" #f"
" unsafe-undefined"
" in13_0"
" config14_0"
" temp16_0"
"(list temp17_0)))))))))"
"(wrap rx_0 in_0 config_0 #f)))))))"
"(define-values"
"(read-extension-reader)"
"(lambda(read-one_0 read-recur_0 dispatch-c_0 in_0 config_0)"
"(begin"
"(let-values(((extend-str_0)"
"(read-extension-prefix(cons dispatch-c_0 '(#\\r #\\e)) '(#\\a #\\d #\\e #\\r) in_0 config_0)))"
"(let-values((()"
"(begin"
"(if(check-parameter 1/read-accept-reader config_0)"
"(void)"
"(let-values()"
"(let-values(((in52_0) in_0)"
"((config53_0) config_0)"
"                                         ((temp54_0) \"`~a` not enabled\")"
"((extend-str55_0) extend-str_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in52_0"
" config53_0"
" temp54_0"
"(list extend-str55_0)))))"
"(values))))"
"(let-values(((mod-path-wrapped_0)(read-one_0 #f in_0(next-readtable config_0))))"
"(begin"
"(if(eof-object? mod-path-wrapped_0)"
"(let-values()"
"(let-values(((in56_0) in_0)"
"((config57_0) config_0)"
"((mod-path-wrapped58_0) mod-path-wrapped_0)"
"                               ((temp59_0) \"expected a datum after `~a`, found end-of-file\")"
"((extend-str60_0) extend-str_0))"
"(reader-error12.1"
" unsafe-undefined"
" mod-path-wrapped58_0"
" #f"
" unsafe-undefined"
" in56_0"
" config57_0"
" temp59_0"
"(list extend-str60_0))))"
"(void))"
"(let-values(((temp47_0)((read-config-coerce config_0) #f mod-path-wrapped_0 #f))"
"((read-recur48_0) read-recur_0)"
"((in49_0) in_0)"
"((config50_0) config_0)"
"((mod-path-wrapped51_0) mod-path-wrapped_0))"
"(read-extension44.1"
" #f"
" mod-path-wrapped51_0"
" #f"
" '|#reader|"
" temp47_0"
" read-recur48_0"
" in49_0"
" config50_0)))))))))"
"(define-values"
"(read-extension-lang7.1)"
"(lambda(get-info?1_0 read-recur3_0 dispatch-c4_0 in5_0 config6_0)"
"(begin"
" 'read-extension-lang7"
"(let-values(((read-recur_0) read-recur3_0))"
"(let-values(((dispatch-c_0) dispatch-c4_0))"
"(let-values(((in_0) in5_0))"
"(let-values(((config_0) config6_0))"
"(let-values(((get-info?_0) get-info?1_0))"
"(let-values()"
"(let-values(((extend-str_0)"
"(read-extension-prefix(cons dispatch-c_0 '(#\\l)) '(#\\a #\\n #\\g) in_0 config_0)))"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(char=? c_0 '#\\space)"
"(void)"
"(let-values()"
"(let-values(((in67_0) in_0)"
"((config68_0) config_0)"
"                                         ((temp69_0) \"expected a single space after `~a`\")"
"((extend-str70_0) extend-str_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in67_0"
" config68_0"
" temp69_0"
"(list extend-str70_0)))))"
"(let-values(((extend-str61_0) extend-str_0)"
"((read-recur62_0) read-recur_0)"
"((in63_0) in_0)"
"((config64_0) config_0)"
"((temp65_0) '|#lang|)"
"((get-info?66_0) get-info?_0))"
"(read-lang29.1"
" get-info?66_0"
" #f"
" temp65_0"
" extend-str61_0"
" read-recur62_0"
" in63_0"
" config64_0))))))))))))))"
"(define-values"
"(read-extension-#!16.1)"
"(lambda(get-info?10_0 read-recur12_0 dispatch-c13_0 in14_0 config15_0)"
"(begin"
" 'read-extension-#!16"
"(let-values(((read-recur_0) read-recur12_0))"
"(let-values(((dispatch-c_0) dispatch-c13_0))"
"(let-values(((in_0) in14_0))"
"(let-values(((config_0) config15_0))"
"(let-values(((get-info?_0) get-info?10_0))"
"(let-values()"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(char-lang-nonsep? c_0)"
"(void)"
"(let-values()"
"(let-values(((in78_0) in_0)"
"((config79_0) config_0)"
"((temp80_0)"
"(if(char? c_0)(string dispatch-c_0 '#\\! c_0)(string dispatch-c_0 '#\\!))))"
"(bad-syntax-error20.1 '#\\x in78_0 config79_0 temp80_0))))"
"(let-values(((temp71_0)(string dispatch-c_0 '#\\!))"
"((read-recur72_0) read-recur_0)"
"((in73_0) in_0)"
"((config74_0) config_0)"
"((c75_0) c_0)"
"((temp76_0) '|#!|)"
"((get-info?77_0) get-info?_0))"
"(read-lang29.1"
" get-info?77_0"
" c75_0"
" temp76_0"
" temp71_0"
" read-recur72_0"
" in73_0"
" config74_0)))))))))))))"
"(define-values"
"(read-lang29.1)"
"(lambda(get-info?20_0 init-c19_0 who21_0 extend-str25_0 read-recur26_0 in27_0 config28_0)"
"(begin"
" 'read-lang29"
"(let-values(((extend-str_0) extend-str25_0))"
"(let-values(((read-recur_0) read-recur26_0))"
"(let-values(((in_0) in27_0))"
"(let-values(((config_0) config28_0))"
"(let-values(((init-c_0) init-c19_0))"
"(let-values(((get-info?_0) get-info?20_0))"
"(let-values(((who_0) who21_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(if(check-parameter 1/read-accept-reader config_0)"
"(check-parameter 1/read-accept-lang config_0)"
" #f)"
"(void)"
"(let-values()"
"(let-values(((in88_0) in_0)"
"((config89_0) config_0)"
"                                                       ((temp90_0) \"`~a` not enabled\")"
"((extend-str91_0) extend-str_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in88_0"
" config89_0"
" temp90_0"
"(list extend-str91_0)))))"
"(values))))"
"(let-values(((line_0 col_0 pos_0)(port-next-location in_0)))"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()"
"(begin"
"(if init-c_0"
"(let-values()(accum-string-add! accum-str_0 init-c_0))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"((letrec-values(((loop_0)"
"(lambda()"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)"
"(read-config-source"
" config_0)))"
"(let-values(((c_0)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_0 'special)"
"(special1.1 'special)"
" c_0)))))"
"(if(eof-object? c_0)"
"(let-values()(void))"
"(if(not(char? c_0))"
"(let-values()"
"(begin"
"(consume-char/special in_0 config_0 c_0)"
"(let-values(((in92_0) in_0)"
"((config93_0) config_0)"
"((c94_0) c_0)"
"((temp95_0)"
"                                                                                            \"found non-character while reading `#~a`\")"
"((extend-str96_0)"
" extend-str_0))"
"(reader-error12.1"
" unsafe-undefined"
" c94_0"
" #f"
" unsafe-undefined"
" in92_0"
" config93_0"
" temp95_0"
"(list extend-str96_0)))))"
"(if(char-whitespace? c_0)"
"(let-values()(void))"
"(if(let-values(((or-part_0)"
"(char-lang-nonsep? c_0)))"
"(if or-part_0"
" or-part_0"
"(char=? '#\\/ c_0)))"
"(let-values()"
"(begin"
"(consume-char in_0 c_0)"
"(accum-string-add! accum-str_0 c_0)"
"(loop_0)))"
"(let-values()"
"(begin"
"(consume-char in_0 c_0)"
"(let-values(((in97_0) in_0)"
"((config98_0) config_0)"
"((temp99_0)"
"(string-append"
"                                                                                                 \"expected only alphanumeric, `-`, `+`, `_`, or `/`\""
"                                                                                                 \" characters for `~a`, found `~a`\"))"
"((extend-str100_0)"
" extend-str_0)"
"((c101_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in97_0"
" config98_0"
" temp99_0"
"(list"
" extend-str100_0"
" c101_0))))))))))))))"
" loop_0))"
"(values))))"
"(let-values(((lang-str_0)"
"(let-values(((accum-str102_0) accum-str_0)((config103_0) config_0))"
"(accum-string-get!6.1 0 accum-str102_0 config103_0))))"
"(let-values((()"
"(begin"
"                                                  (if (equal? lang-str_0 \"\")"
"(let-values()"
"(let-values(((in104_0) in_0)"
"((config105_0) config_0)"
"((temp106_0)"
"                                                                    \"expected a non-empty sequence of alphanumeric, `-`, `+`, `_`, or `/` after `~a`\")"
"((extend-str107_0) extend-str_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in104_0"
" config105_0"
" temp106_0"
"(list extend-str107_0))))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if(char=? '#\\/(string-ref lang-str_0 0))"
"(let-values()"
"(let-values(((in108_0) in_0)"
"((config109_0) config_0)"
"((temp110_0)"
"                                                                      \"expected a name that does not start `/` after `~a`\")"
"((extend-str111_0) extend-str_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in108_0"
" config109_0"
" temp110_0"
"(list extend-str111_0))))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if(char=?"
" '#\\/"
"(string-ref lang-str_0(sub1(string-length lang-str_0))))"
"(let-values()"
"(let-values(((in112_0) in_0)"
"((config113_0) config_0)"
"((temp114_0)"
"                                                                        \"expected a name that does not end `/` after `~a`\")"
"((extend-str115_0) extend-str_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in112_0"
" config113_0"
" temp114_0"
"(list extend-str115_0))))"
"(void))"
"(values))))"
"(let-values(((submod-path_0)"
"(list* 'submod(string->symbol lang-str_0) '(reader))))"
"(let-values(((reader-path_0)"
"                                                        (string->symbol (string-append lang-str_0 \"/lang/reader\"))))"
"(let-values(((submod-path81_0) submod-path_0)"
"((reader-path82_0) reader-path_0)"
"((read-recur83_0) read-recur_0)"
"((in84_0) in_0)"
"((temp85_0)(reading-at config_0 line_0 col_0 pos_0))"
"((get-info?86_0) get-info?_0)"
"((who87_0) who_0))"
"(read-extension44.1"
" get-info?86_0"
" unsafe-undefined"
" submod-path81_0"
" who87_0"
" reader-path82_0"
" read-recur83_0"
" in84_0"
" temp85_0))))))))))))))))))))))))"
"(define-values"
"(char-lang-nonsep?)"
"(lambda(c_0)"
"(begin"
"(if(<(char->integer c_0) 128)"
"(let-values(((or-part_0)(char-alphabetic? c_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(char-numeric? c_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(char=? '#\\- c_0)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(char=? '#\\+ c_0)))(if or-part_3 or-part_3(char=? '#\\_ c_0)))))))))"
" #f))))"
"(define-values"
"(read-extension-prefix)"
"(lambda(already_0 wanted_0 in_0 config_0)"
"(begin"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(begin"
"(let-values(((lst_0) already_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((c_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(accum-string-add! accum-str_0 c_0))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"((letrec-values(((loop_0)"
"(lambda(wanted_1)"
"(begin"
" 'loop"
"(if(null? wanted_1)"
"(void)"
"(let-values()"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(char? c_0)(let-values()(accum-string-add! accum-str_0 c_0))(void))"
"(if(eqv? c_0(car wanted_1))"
"(void)"
"(let-values()"
"(let-values(((in118_0) in_0)"
"((config119_0) config_0)"
"((temp120_0)"
"(let-values(((accum-str122_0) accum-str_0)"
"((config123_0) config_0))"
"(accum-string-get!6.1 0 accum-str122_0 config123_0)))"
"((c121_0) c_0))"
"(bad-syntax-error20.1 c121_0 in118_0 config119_0 temp120_0))))"
"(loop_0(cdr wanted_1))))))))))"
" loop_0)"
" wanted_0)"
"(let-values(((accum-str116_0) accum-str_0)((config117_0) config_0))"
"(accum-string-get!6.1 0 accum-str116_0 config117_0)))))))"
"(define-values"
"(read-extension44.1)"
"(lambda(get-info?34_0"
" mod-path-wrapped33_0"
" try-first-mod-path32_0"
" who35_0"
" mod-path-datum40_0"
" read-recur41_0"
" in42_0"
" config43_0)"
"(begin"
" 'read-extension44"
"(let-values(((try-first-mod-path_0) try-first-mod-path32_0))"
"(let-values(((mod-path-datum_0) mod-path-datum40_0))"
"(let-values(((read-recur_0) read-recur41_0))"
"(let-values(((in_0) in42_0))"
"(let-values(((config_0) config43_0))"
"(let-values(((mod-path-wrapped_0)"
"(if(eq? mod-path-wrapped33_0 unsafe-undefined)"
"((read-config-coerce config_0)"
" #t"
" mod-path-datum_0"
"(let-values(((in124_0) in_0)((config125_0) config_0))"
"(port+config->srcloc51.1 #f in124_0 config125_0)))"
" mod-path-wrapped33_0)))"
"(let-values(((get-info?_0) get-info?34_0))"
"(let-values(((who_0) who35_0))"
"(let-values()"
"(let-values((()(begin(force-parameters! config_0)(values))))"
"(let-values(((guard_0)(1/current-reader-guard)))"
"(let-values(((mod-path_0)"
"(let-values(((or-part_0)"
"(if try-first-mod-path_0"
"(let-values(((mod-path_0)(guard_0 try-first-mod-path_0)))"
"(if((read-config-module-declared? config_0)"
" try-first-mod-path_0)"
" mod-path_0"
" #f))"
" #f)))"
"(if or-part_0 or-part_0(guard_0 mod-path-datum_0)))))"
"((read-config-call-with-root-namespace config_0)"
"(lambda()"
"(let-values(((for-syntax?_0)(read-config-for-syntax? config_0)))"
"(let-values(((dynamic-require_0)(read-config-dynamic-require config_0)))"
"(let-values(((no-value_0)(gensym)))"
"(let-values(((extension_0)"
"(if get-info?_0"
"(let-values()"
"(dynamic-require_0"
" mod-path_0"
" 'get-info"
"(lambda() no-value_0)))"
"(let-values()"
"(dynamic-require_0"
" mod-path_0"
"(if for-syntax?_0 'read-syntax 'read))))))"
"(if(eq? extension_0 no-value_0)"
"(let-values() #f)"
"(let-values()"
"(let-values(((result-v_0)"
"(if(if for-syntax?_0(not get-info?_0) #f)"
"(let-values()"
"(if(procedure-arity-includes? extension_0 6)"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()"
"(extension_0"
"(read-config-source config_0)"
" in_0"
" mod-path-wrapped_0"
"(read-config-line config_0)"
"(read-config-col config_0)"
"(read-config-pos config_0)))))"
"(if(procedure-arity-includes? extension_0 2)"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()"
"(extension_0"
"(read-config-source config_0)"
" in_0))))"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                                      \"(or/c (procedure-arity-includes?/c 2) (procedure-arity-includes?/c 6))\""
" extension_0)))))"
"(let-values()"
"(if(procedure-arity-includes? extension_0 5)"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()"
"(extension_0"
" in_0"
" mod-path-wrapped_0"
"(read-config-line config_0)"
"(read-config-col config_0)"
"(read-config-pos config_0)))))"
"(if get-info?_0"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                                      \"(procedure-arity-includes?/c 5)\""
" extension_0))"
"(if(procedure-arity-includes? extension_0 1)"
"(let-values()"
"(with-continuation-mark"
" current-read-config"
" config_0"
"(let-values()(extension_0 in_0))))"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                                        \"(or/c (procedure-arity-includes?/c 1) (procedure-arity-includes?/c 5))\""
" extension_0)))))))))"
"(if get-info?_0"
"(let-values()"
"(begin"
"(if(if(procedure? result-v_0)"
"(procedure-arity-includes? result-v_0 2)"
" #f)"
"(void)"
"(let-values()"
"(raise-result-error"
" 'read-language"
"                                                          \"(procedure-arity-includes?/c 2)\""
" result-v_0)))"
" result-v_0))"
"(if(1/special-comment? result-v_0)"
"(let-values()(read-recur_0 #f in_0 config_0))"
"(let-values()"
"(coerce result-v_0 in_0 config_0))))))))))))))))))))))))))))"
"(define-values"
"(read-language/get-info)"
"(lambda(read-one_0 in_0 config_0 fail-k_0)"
"(begin"
"(let-values(((c_0)(read-char/skip-whitespace-and-comments #f read-one_0 in_0 config_0)))"
"(let-values(((line_0 col_0 pos_0)(port-next-location* in_0 c_0)))"
"(let-values(((l-config_0)"
"(override-parameter 1/read-accept-reader(reading-at config_0 line_0 col_0 pos_0) #t)))"
"(if(not(eqv? c_0 '#\\#))"
"              (let-values () (if fail-k_0 (fail-k_0) (lang-error in_0 l-config_0 \"\" c_0)))"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source l-config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(if(eqv? c2_0 '#\\l)"
"(let-values()"
"(let-values(((read-one1_0) read-one_0)"
"((c2_1) c_0)"
"((in3_0) in_0)"
"((l-config4_0) l-config_0)"
"((temp5_0) #t))"
"(read-extension-lang7.1 temp5_0 read-one1_0 c2_1 in3_0 l-config4_0)))"
"(if(eqv? c2_0 '#\\!)"
"(let-values()"
"(let-values(((read-one6_0) read-one_0)"
"((c7_0) c_0)"
"((in8_0) in_0)"
"((l-config9_0) l-config_0)"
"((temp10_0) #t))"
"(read-extension-#!16.1 temp10_0 read-one6_0 c7_0 in8_0 l-config9_0)))"
"(let-values()(if fail-k_0(fail-k_0)(lang-error in_0 l-config_0(string c_0) c2_0))))))))))))))"
"(define-values"
"(lang-error)"
"(lambda(in_0 config_0 prefix_0 c_0)"
"(begin"
"(let-values(((add-prefix_0)"
"(lambda(s_0)"
"                      (begin 'add-prefix (if (string=? prefix_0 \"\") (format \"`~a` followed by ~a\" prefix_0 s_0) s_0)))))"
"(let-values(((in11_0) in_0)"
"((config12_0) config_0)"
"((c13_0) c_0)"
"((temp14_0) 'read-language)"
"((temp15_0)"
"(string-append"
"                       \"expected (after whitespace and comments) `#lang ` or `#!` followed\""
"                       \" immediately by a language name, found ~a\"))"
"((temp16_0)"
"(if(eof-object? c_0)"
"                        (let-values () (add-prefix_0 \"end-of-file\"))"
"(if(not(char? c_0))"
"                          (let-values () (add-prefix_0 \"non-character\"))"
"                          (let-values () (format \"`~a~a`\" prefix_0 c_0))))))"
"(reader-error12.1 unsafe-undefined c13_0 #f temp14_0 in11_0 config12_0 temp15_0(list temp16_0)))))))"
"(define-values"
"(read32.1)"
"(lambda(call-with-root-namespace10_0"
" coerce13_0"
" coerce-key14_0"
" dynamic-require11_0"
" for-syntax?8_0"
" init-c2_0"
" keep-comment?15_0"
" local-graph?6_0"
" module-declared?12_0"
" next-readtable3_0"
" read-compiled9_0"
" readtable4_0"
" recursive?5_0"
" source7_0"
" wrap1_0"
" in31_0)"
"(begin"
" 'read32"
"(let-values(((in_0) in31_0))"
"(let-values(((wrap_0) wrap1_0))"
"(let-values(((init-c_0) init-c2_0))"
"(let-values(((next-readtable_0)"
"(if(eq? next-readtable3_0 unsafe-undefined)(1/current-readtable) next-readtable3_0)))"
"(let-values(((readtable_0)(if(eq? readtable4_0 unsafe-undefined) next-readtable_0 readtable4_0)))"
"(let-values(((recursive?_0) recursive?5_0))"
"(let-values(((local-graph?_0) local-graph?6_0))"
"(let-values(((source_0) source7_0))"
"(let-values(((for-syntax?_0) for-syntax?8_0))"
"(let-values(((read-compiled_0) read-compiled9_0))"
"(let-values(((call-with-root-namespace_0) call-with-root-namespace10_0))"
"(let-values(((dynamic-require_0) dynamic-require11_0))"
"(let-values(((module-declared?_0) module-declared?12_0))"
"(let-values(((coerce_0) coerce13_0))"
"(let-values(((coerce-key_0) coerce-key14_0))"
"(let-values(((keep-comment?_0)"
"(if(eq? keep-comment?15_0 unsafe-undefined)"
" recursive?_0"
" keep-comment?15_0)))"
"(let-values()"
"(let-values(((config_0)"
"(let-values(((c1_0)(if recursive?_0(current-read-config) #f)))"
"(if c1_0"
"((lambda(config_0)"
"(let-values(((config56_0) config_0)"
"((for-syntax?57_0) for-syntax?_0)"
"((wrap58_0) wrap_0)"
"((readtable59_0) readtable_0)"
"((next-readtable60_0) next-readtable_0)"
"((local-graph?61_0) local-graph?_0)"
"((keep-comment?62_0) keep-comment?_0))"
"(read-config-update44.1"
" for-syntax?57_0"
" keep-comment?62_0"
" next-readtable60_0"
" readtable59_0"
" local-graph?61_0"
" wrap58_0"
" config56_0)))"
" c1_0)"
"(let-values()"
"(let-values(((readtable63_0) readtable_0)"
"((next-readtable64_0) next-readtable_0)"
"((source65_0) source_0)"
"((for-syntax?66_0) for-syntax?_0)"
"((wrap67_0) wrap_0)"
"((read-compiled68_0) read-compiled_0)"
"((call-with-root-namespace69_0)"
" call-with-root-namespace_0)"
"((dynamic-require70_0) dynamic-require_0)"
"((module-declared?71_0) module-declared?_0)"
"((coerce72_0) coerce_0)"
"((coerce-key73_0) coerce-key_0)"
"((keep-comment?74_0) keep-comment?_0))"
"(make-read-config28.1"
" call-with-root-namespace69_0"
" coerce72_0"
" coerce-key73_0"
" dynamic-require70_0"
" for-syntax?66_0"
" keep-comment?74_0"
" module-declared?71_0"
" next-readtable64_0"
" read-compiled68_0"
" readtable63_0"
" source65_0"
" wrap67_0)))))))"
"(let-values(((v_0)(read-one init-c_0 in_0 config_0)))"
"(if(if(let-values(((or-part_0)(not recursive?_0)))"
"(if or-part_0 or-part_0 local-graph?_0))"
"(read-config-state-graph(read-config-st config_0))"
" #f)"
"(let-values()"
"(catch-and-reraise-as-reader/proc"
" #f"
" config_0"
"(lambda()(make-reader-graph v_0))))"
"(if(if recursive?_0"
"(if(not local-graph?_0)"
"(if(not for-syntax?_0)"
"(if(not(eof-object? v_0))(not(1/special-comment? v_0)) #f)"
" #f)"
" #f)"
" #f)"
"(let-values()(begin(get-graph-hash config_0) v_0))"
"(let-values() v_0)))))))))))))))))))))))))"
"(define-values"
"(read-language53.1)"
"(lambda(call-with-root-namespace39_0"
" coerce41_0"
" coerce-key42_0"
" dynamic-require38_0"
" for-syntax?35_0"
" module-declared?40_0"
" read-compiled37_0"
" wrap36_0"
" in51_0"
" fail-k52_0)"
"(begin"
" 'read-language53"
"(let-values(((in_0) in51_0))"
"(let-values(((fail-k_0) fail-k52_0))"
"(let-values(((for-syntax?_0) for-syntax?35_0))"
"(let-values(((wrap_0) wrap36_0))"
"(let-values(((read-compiled_0) read-compiled37_0))"
"(let-values(((dynamic-require_0) dynamic-require38_0))"
"(let-values(((call-with-root-namespace_0) call-with-root-namespace39_0))"
"(let-values(((module-declared?_0) module-declared?40_0))"
"(let-values(((coerce_0) coerce41_0))"
"(let-values(((coerce-key_0) coerce-key42_0))"
"(let-values()"
"(let-values(((config_0)"
"(let-values(((temp75_0) #f)"
"((temp76_0) #f)"
"((for-syntax?77_0) for-syntax?_0)"
"((wrap78_0) wrap_0)"
"((read-compiled79_0) read-compiled_0)"
"((call-with-root-namespace80_0) call-with-root-namespace_0)"
"((dynamic-require81_0) dynamic-require_0)"
"((module-declared?82_0) module-declared?_0)"
"((coerce83_0) coerce_0)"
"((coerce-key84_0) coerce-key_0))"
"(make-read-config28.1"
" call-with-root-namespace80_0"
" coerce83_0"
" coerce-key84_0"
" dynamic-require81_0"
" for-syntax?77_0"
" #f"
" module-declared?82_0"
" temp76_0"
" read-compiled79_0"
" temp75_0"
" #f"
" wrap78_0))))"
"(let-values(((l-config_0)(override-parameter 1/read-accept-reader config_0 #f)))"
"(read-language/get-info read-undotted in_0 config_0 fail-k_0)))))))))))))))))"
"(define-values"
"(read-one)"
"(lambda(init-c_0 in_0 config_0)"
"(begin"
"(if(not(check-parameter 1/read-cdot config_0))"
"(let-values()(read-undotted init-c_0 in_0 config_0))"
"(if(check-parameter 1/read-cdot config_0)"
"(let-values()"
"(let-values(((line_0 col_0 pos_0)(port-next-location in_0)))"
"(let-values(((v_0)(read-undotted init-c_0 in_0 config_0)))"
"(if(1/special-comment? v_0)"
"(let-values() v_0)"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(v_1)"
"(begin"
" 'loop"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_0)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_0 'special)(special1.1 'special) c_0)))))"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(if(not(char? ec_0))"
"(let-values() v_1)"
"(if(char-whitespace? ec_0)"
"(let-values()(begin(consume-char in_0 c_0)(loop_0 v_1)))"
"(if(char=? ec_0 '#\\.)"
"(let-values()"
"(let-values(((dot-line_0 dot-col_0 dot-pos_0)"
"(port-next-location in_0)))"
"(let-values((()(begin(consume-char in_0 c_0)(values))))"
"(let-values(((pos-config_0)"
"(reading-at"
" config_0"
" dot-line_0"
" dot-col_0"
" dot-pos_0)))"
"(let-values(((cdot_0)"
"(wrap '#%dot in_0 pos-config_0 '#\\.)))"
"(let-values(((post-v_0)"
"(read-undotted #f in_0 config_0)))"
"(begin"
"(if(eof-object? post-v_0)"
"(let-values()"
"(let-values(((in85_0) in_0)"
"((pos-config86_0) pos-config_0)"
"((eof87_0) eof)"
"((temp88_0)"
"                                                                                    \"expected a datum after cdot, found end-of-file\"))"
"(reader-error12.1"
" unsafe-undefined"
" eof87_0"
" #f"
" unsafe-undefined"
" in85_0"
" pos-config86_0"
" temp88_0"
"(list))))"
"(void))"
"(loop_0"
"(wrap"
"(list cdot_0 v_1 post-v_0)"
" in_0"
"(reading-at config_0 line_0 col_0 pos_0)"
" '#\\.)))))))))"
"(let-values() v_1))))))))))"
" loop_0)"
" v_0))))))"
"(void))))))"
"(define-values"
"(read-undotted)"
"(lambda(init-c_0 in_0 config_0)"
"(begin"
"(let-values(((c_0)(read-char/skip-whitespace-and-comments init-c_0 read-one in_0 config_0)))"
"(let-values(((line_0 col_0 pos_0)(port-next-location* in_0 c_0)))"
"(if(eof-object? c_0)"
"(let-values() eof)"
"(if(not(char? c_0))"
"(let-values()"
"(let-values(((v_0)(special-value c_0)))"
"(if(1/special-comment? v_0)"
"(let-values()(if(read-config-keep-comment? config_0) v_0(read-undotted #f in_0 config_0)))"
"(let-values()(coerce v_0 in_0(reading-at config_0 line_0 col_0 pos_0))))))"
"(let-values(((c2_0)(readtable-handler config_0 c_0)))"
"(if c2_0"
"((lambda(handler_0)"
"(let-values(((v_0)(readtable-apply handler_0 c_0 in_0 config_0 line_0 col_0 pos_0)))"
"(retry-special-comment v_0 in_0 config_0)))"
" c2_0)"
"(let-values()"
"(let-values(((ec_0)(effective-char c_0 config_0)))"
"(let-values((()"
"(begin"
"(if(not(char-closer? ec_0 config_0))"
"(let-values()(track-indentation! config_0 line_0 col_0))"
"(void))"
"(values))))"
"(let-values(((r-config_0)(reading-at(discard-comment config_0) line_0 col_0 pos_0)))"
"(let-values(((tmp_0) ec_0))"
"(let-values(((index_0)"
"(if(char? tmp_0)"
"(let-values(((codepoint_0)(char->integer tmp_0)))"
"(if(if(unsafe-fx>= codepoint_0 34)(unsafe-fx< codepoint_0 126) #f)"
"(if(unsafe-fx< codepoint_0 91)"
"(if(unsafe-fx< codepoint_0 40)"
"(let-values(((tbl_0) '#(11 1 0 0 0 2)))"
"(unsafe-vector*-ref tbl_0(unsafe-fx- codepoint_0 34)))"
"(if(unsafe-fx< codepoint_0 42)"
"(let-values(((tbl_0) '#(5 6)))"
"(unsafe-vector*-ref tbl_0(unsafe-fx- codepoint_0 40)))"
"(if(unsafe-fx< codepoint_0 44)"
" 0"
"(if(unsafe-fx< codepoint_0 45) 4 0))))"
"(let-values(((tbl_0)"
" '#(7"
" 0"
" 8"
" 0"
" 0"
" 3"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 0"
" 9"
" 12"
" 10)))"
"(unsafe-vector*-ref tbl_0(unsafe-fx- codepoint_0 91))))"
" 0))"
" 0)))"
"(if(unsafe-fx< index_0 6)"
"(if(unsafe-fx< index_0 2)"
"(if(unsafe-fx< index_0 1)"
"(let-values()"
"(let-values(((v_0)"
"(let-values(((c89_0) c_0)"
"((in90_0) in_0)"
"((r-config91_0) r-config_0)"
"((temp92_0)"
"(if(let-values(((or-part_0)(eq? c_0 ec_0)))"
"(if or-part_0"
" or-part_0"
"(if(<(char->integer ec_0) 128)"
"(char-numeric? ec_0)"
" #f)))"
" 'symbol-or-number"
" 'symbol/indirect)))"
"(read-symbol-or-number8.1"
" #f"
" temp92_0"
" c89_0"
" in90_0"
" r-config91_0))))"
"(retry-special-comment v_0 in_0 config_0)))"
"(let-values()(read-dispatch c_0 in_0 r-config_0 config_0)))"
"(if(unsafe-fx< index_0 3)"
"                                    (let-values () (read-quote read-one 'quote \"quoting \\\"'\\\"\" c_0 in_0 r-config_0))"
"(if(unsafe-fx< index_0 4)"
"(let-values()"
"(if(check-parameter 1/read-accept-quasiquote config_0)"
"(let-values()"
"                                            (read-quote read-one 'quasiquote \"quasiquoting \\\"`\\\"\" c_0 in_0 r-config_0))"
"(let-values()"
"(let-values(((in93_0) in_0)"
"((r-config94_0) r-config_0)"
"                                                         ((temp95_0) \"illegal use of `~a`\")"
"((c96_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in93_0"
" r-config94_0"
" temp95_0"
"(list c96_0))))))"
"(if(unsafe-fx< index_0 5)"
"(let-values()"
"(if(check-parameter 1/read-accept-quasiquote config_0)"
"(let-values()"
"(let-values(((c2_1)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(eqv? c2_1 '#\\@)"
"(begin"
"(consume-char in_0 c2_1)"
"(read-quote"
" read-one"
" 'unquote-splicing"
"                                                     \"unquoting `,@`\""
" c_0"
" in_0"
" r-config_0))"
"                                                  (read-quote read-one 'unquote \"unquoting `,`\" c_0 in_0 r-config_0))))"
"(let-values()"
"(let-values(((in97_0) in_0)"
"((r-config98_0) r-config_0)"
"                                                           ((temp99_0) \"illegal use of `~a`\")"
"((c100_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in97_0"
" r-config98_0"
" temp99_0"
"(list c100_0))))))"
"(let-values()"
"(wrap"
"(let-values(((read-one101_0) read-one)"
"((ec102_0) ec_0)"
"((temp103_0) '#\\()"
"((temp104_0) '#\\))"
"((in105_0) in_0)"
"((r-config106_0) r-config_0)"
"((temp107_0) #t))"
"(read-unwrapped-sequence17.1"
" 'all"
" unsafe-undefined"
" unsafe-undefined"
" temp107_0"
" unsafe-undefined"
" read-one101_0"
" ec102_0"
" temp103_0"
" temp104_0"
" in105_0"
" r-config106_0))"
" in_0"
" r-config_0"
" ec_0))))))"
"(if(unsafe-fx< index_0 9)"
"(if(unsafe-fx< index_0 7)"
"(let-values()"
"(let-values(((in108_0) in_0)"
"((r-config109_0) r-config_0)"
"                                                   ((temp110_0) \"~a\")"
"((temp111_0)"
"(indentation-unexpected-closer-message ec_0 c_0 r-config_0)))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in108_0"
" r-config109_0"
" temp110_0"
"(list temp111_0))))"
"(if(unsafe-fx< index_0 8)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(check-parameter 1/read-square-bracket-as-paren config_0)))"
"(if or-part_0"
" or-part_0"
"(check-parameter 1/read-square-bracket-with-tag config_0)))"
"(let-values()"
"(wrap"
"(let-values(((read-one112_0) read-one)"
"((ec113_0) ec_0)"
"((temp114_0) '#\\[)"
"((temp115_0) '#\\])"
"((in116_0) in_0)"
"((r-config117_0) r-config_0)"
"((temp118_0) #t))"
"(read-unwrapped-sequence17.1"
" 'all"
" unsafe-undefined"
" unsafe-undefined"
" temp118_0"
" unsafe-undefined"
" read-one112_0"
" ec113_0"
" temp114_0"
" temp115_0"
" in116_0"
" r-config117_0))"
" in_0"
" r-config_0"
" ec_0))"
"(let-values()"
"(let-values(((in119_0) in_0)"
"((r-config120_0) r-config_0)"
"                                                         ((temp121_0) \"illegal use of `~a`\")"
"((c122_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in119_0"
" r-config120_0"
" temp121_0"
"(list c122_0))))))"
"(let-values()"
"(if(let-values(((or-part_0)"
"(check-parameter 1/read-square-bracket-as-paren config_0)))"
"(if or-part_0"
" or-part_0"
"(check-parameter 1/read-square-bracket-with-tag config_0)))"
"(let-values()"
"(let-values(((in123_0) in_0)"
"((r-config124_0) r-config_0)"
"                                                         ((temp125_0) \"~a\")"
"((temp126_0)"
"(indentation-unexpected-closer-message ec_0 c_0 r-config_0)))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in123_0"
" r-config124_0"
" temp125_0"
"(list temp126_0))))"
"(let-values()"
"(let-values(((in127_0) in_0)"
"((r-config128_0) r-config_0)"
"                                                         ((temp129_0) \"illegal use of `~a`\")"
"((c130_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in127_0"
" r-config128_0"
" temp129_0"
"(list c130_0))))))))"
"(if(unsafe-fx< index_0 10)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(check-parameter 1/read-curly-brace-as-paren config_0)))"
"(if or-part_0"
" or-part_0"
"(check-parameter 1/read-curly-brace-with-tag config_0)))"
"(let-values()"
"(wrap"
"(let-values(((read-one131_0) read-one)"
"((ec132_0) ec_0)"
"((temp133_0) '#\\{)"
"((temp134_0) '#\\})"
"((in135_0) in_0)"
"((r-config136_0) r-config_0)"
"((temp137_0) #t))"
"(read-unwrapped-sequence17.1"
" 'all"
" unsafe-undefined"
" unsafe-undefined"
" temp137_0"
" unsafe-undefined"
" read-one131_0"
" ec132_0"
" temp133_0"
" temp134_0"
" in135_0"
" r-config136_0))"
" in_0"
" r-config_0"
" ec_0))"
"(let-values()"
"(let-values(((in138_0) in_0)"
"((r-config139_0) r-config_0)"
"                                                       ((temp140_0) \"illegal use of `~a`\")"
"((c141_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in138_0"
" r-config139_0"
" temp140_0"
"(list c141_0))))))"
"(if(unsafe-fx< index_0 11)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(check-parameter 1/read-curly-brace-as-paren config_0)))"
"(if or-part_0"
" or-part_0"
"(check-parameter 1/read-curly-brace-with-tag config_0)))"
"(let-values()"
"(let-values(((in142_0) in_0)"
"((r-config143_0) r-config_0)"
"                                                         ((temp144_0) \"~a\")"
"((temp145_0)"
"(indentation-unexpected-closer-message ec_0 c_0 r-config_0)))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in142_0"
" r-config143_0"
" temp144_0"
"(list temp145_0))))"
"(let-values()"
"(let-values(((in146_0) in_0)"
"((r-config147_0) r-config_0)"
"                                                         ((temp148_0) \"illegal use of `~a`\")"
"((c149_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in146_0"
" r-config147_0"
" temp148_0"
"(list c149_0))))))"
"(if(unsafe-fx< index_0 12)"
"(let-values()"
"(let-values(((in150_0) in_0)((r-config151_0) r-config_0))"
"(read-string5.1 'string in150_0 r-config151_0)))"
"(let-values()"
"(let-values(((c152_0) c_0)"
"((in153_0) in_0)"
"((r-config154_0) r-config_0)"
"((temp155_0) 'symbol))"
"(read-symbol-or-number8.1"
" #f"
" temp155_0"
" c152_0"
" in153_0"
" r-config154_0)))))))))))))))))))))))"
"(define-values"
"(read-dispatch)"
"(lambda(dispatch-c_0 in_0 config_0 orig-config_0)"
"(begin"
"(let-values(((c_0)"
"(let-values(((in_1) in_0)((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(if(eof-object? c_0)"
"(let-values()"
"(let-values(((in156_0) in_0)"
"((config157_0) config_0)"
"((c158_0) c_0)"
"                         ((temp159_0) \"bad syntax `~a`\")"
"((dispatch-c160_0) dispatch-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" c158_0"
" #f"
" unsafe-undefined"
" in156_0"
" config157_0"
" temp159_0"
"(list dispatch-c160_0))))"
"(if(not(char? c_0))"
"(let-values()"
"(let-values(((in161_0) in_0)"
"((config162_0) config_0)"
"((c163_0) c_0)"
"                           ((temp164_0) \"bad syntax `~a`\")"
"((dispatch-c165_0) dispatch-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" c163_0"
" #f"
" unsafe-undefined"
" in161_0"
" config162_0"
" temp164_0"
"(list dispatch-c165_0))))"
"(let-values(((c3_0)(readtable-dispatch-handler orig-config_0 c_0)))"
"(if c3_0"
"((lambda(handler_0)"
"(let-values(((line_0)(read-config-line config_0)))"
"(let-values(((col_0)(read-config-col config_0)))"
"(let-values(((pos_0)(read-config-pos config_0)))"
"(let-values(((v_0)(readtable-apply handler_0 c_0 in_0 config_0 line_0 col_0 pos_0)))"
"(retry-special-comment v_0 in_0 orig-config_0))))))"
" c3_0)"
"(let-values()"
"(let-values()"
"(let-values(((tmp_0) c_0))"
"(let-values(((index_0)"
"(if(char? tmp_0)"
"(let-values(((codepoint_0)(char->integer tmp_0)))"
"(if(if(unsafe-fx>= codepoint_0 33)(unsafe-fx< codepoint_0 127) #f)"
"(let-values(((tbl_0)"
" '#(34"
" 11"
" 0"
" 0"
" 13"
" 6"
" 7"
" 2"
" 0"
" 0"
" 0"
" 9"
" 0"
" 0"
" 0"
" 1"
" 1"
" 1"
" 1"
" 1"
" 1"
" 1"
" 1"
" 1"
" 1"
" 14"
" 0"
" 12"
" 0"
" 0"
" 0"
" 0"
" 0"
" 22"
" 29"
" 25"
" 18"
" 16"
" 0"
" 30"
" 20"
" 0"
" 0"
" 0"
" 0"
" 0"
" 24"
" 0"
" 0"
" 0"
" 0"
" 15"
" 0"
" 0"
" 0"
" 28"
" 0"
" 0"
" 3"
" 10"
" 0"
" 0"
" 0"
" 8"
" 0"
" 26"
" 29"
" 21"
" 17"
" 16"
" 0"
" 30"
" 19"
" 0"
" 0"
" 33"
" 0"
" 0"
" 23"
" 32"
" 0"
" 31"
" 5"
" 15"
" 0"
" 0"
" 0"
" 27"
" 0"
" 0"
" 4"
" 0"
" 0"
" 35)))"
"(unsafe-vector*-ref tbl_0(unsafe-fx- codepoint_0 33)))"
" 0))"
" 0)))"
"(if(unsafe-fx< index_0 17)"
"(if(unsafe-fx< index_0 8)"
"(if(unsafe-fx< index_0 3)"
"(if(unsafe-fx< index_0 1)"
"(let-values()"
"(let-values(((in166_0) in_0)"
"((config167_0) config_0)"
"                                               ((temp168_0) \"bad syntax `~a~a`\")"
"((dispatch-c169_0) dispatch-c_0)"
"((c170_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in166_0"
" config167_0"
" temp168_0"
"(list dispatch-c169_0 c170_0))))"
"(if(unsafe-fx< index_0 2)"
"(let-values()(read-vector-or-graph read-one dispatch-c_0 c_0 in_0 config_0))"
"(let-values()"
"(let-values(((read-one171_0) read-one)"
"((temp172_0) '#\\()"
"((temp173_0) '#\\()"
"((temp174_0) '#\\))"
"((in175_0) in_0)"
"((config176_0) config_0))"
"(read-vector11.1"
" #f"
" 'any"
" read-one171_0"
" temp172_0"
" temp173_0"
" temp174_0"
" in175_0"
" config176_0)))))"
"(if(unsafe-fx< index_0 5)"
"(if(unsafe-fx< index_0 4)"
"(let-values()"
"(if(check-parameter 1/read-square-bracket-as-paren config_0)"
"(let-values()"
"(let-values(((read-one177_0) read-one)"
"((temp178_0) '#\\[)"
"((temp179_0) '#\\[)"
"((temp180_0) '#\\])"
"((in181_0) in_0)"
"((config182_0) config_0))"
"(read-vector11.1"
" #f"
" 'any"
" read-one177_0"
" temp178_0"
" temp179_0"
" temp180_0"
" in181_0"
" config182_0)))"
"(let-values()"
"(let-values(((in183_0) in_0)"
"((config184_0) config_0)"
"                                                     ((temp185_0) (format \"~a~a\" dispatch-c_0 c_0)))"
"(bad-syntax-error20.1 '#\\x in183_0 config184_0 temp185_0)))))"
"(let-values()"
"(if(check-parameter 1/read-curly-brace-as-paren config_0)"
"(let-values()"
"(let-values(((read-one186_0) read-one)"
"((temp187_0) '#\\{)"
"((temp188_0) '#\\{)"
"((temp189_0) '#\\})"
"((in190_0) in_0)"
"((config191_0) config_0))"
"(read-vector11.1"
" #f"
" 'any"
" read-one186_0"
" temp187_0"
" temp188_0"
" temp189_0"
" in190_0"
" config191_0)))"
"(let-values()"
"(let-values(((in192_0) in_0)"
"((config193_0) config_0)"
"                                                     ((temp194_0) (format \"~a~a\" dispatch-c_0 c_0)))"
"(bad-syntax-error20.1 '#\\x in192_0 config193_0 temp194_0))))))"
"(if(unsafe-fx< index_0 6)"
"(let-values()(read-struct read-one dispatch-c_0 in_0 config_0))"
"(if(unsafe-fx< index_0 7)"
"(let-values()(read-box read-one dispatch-c_0 in_0 config_0))"
"                                    (let-values () (read-quote read-one 'syntax \"quoting #'\" c_0 in_0 config_0))))))"
"(if(unsafe-fx< index_0 12)"
"(if(unsafe-fx< index_0 9)"
"                                (let-values () (read-quote read-one 'quasisyntax \"quasiquoting #`\" c_0 in_0 config_0))"
"(if(unsafe-fx< index_0 10)"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(eqv? c2_0 '#\\@)"
"(begin"
"(consume-char in_0 c2_0)"
"                                          (read-quote read-one 'unsyntax-splicing \"unquoting #,@\" c_0 in_0 config_0))"
"                                        (read-quote read-one 'unsyntax \"unquoting #,\" c_0 in_0 config_0))))"
"(if(unsafe-fx< index_0 11)"
"(let-values()(read-character in_0 config_0))"
"(let-values()"
"(let-values(((in195_0) in_0)"
"((config196_0) config_0)"
"((temp197_0) '|byte string|))"
"(read-string5.1 temp197_0 in195_0 config196_0))))))"
"(if(unsafe-fx< index_0 14)"
"(if(unsafe-fx< index_0 13)"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(eqv? '#\\< c2_0)"
"(let-values()"
"(begin(consume-char in_0 '#\\<)(read-here-string in_0 config_0)))"
"(let-values()"
"(let-values(((in198_0) in_0)"
"((config199_0) config_0)"
"((c2200_0) c2_0)"
"                                                       ((temp201_0) \"bad syntax `~a<`\")"
"((dispatch-c202_0) dispatch-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" c2200_0"
" #f"
" unsafe-undefined"
" in198_0"
" config199_0"
" temp201_0"
"(list dispatch-c202_0)))))))"
"(let-values()"
"(let-values(((c203_0) c_0)"
"((in204_0) in_0)"
"((config205_0) config_0)"
"((dispatch-c206_0) dispatch-c_0)"
"((temp207_0) 'symbol))"
"(read-symbol-or-number8.1 dispatch-c206_0 temp207_0 c203_0 in204_0 config205_0))))"
"(if(unsafe-fx< index_0 15)"
"(let-values()"
"(let-values(((temp208_0) #f)"
"((in209_0) in_0)"
"((config210_0) config_0)"
"((temp211_0) 'keyword))"
"(read-symbol-or-number8.1 #f temp211_0 temp208_0 in209_0 config210_0)))"
"(if(unsafe-fx< index_0 16)"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(char-delimiter? c2_0 config_0)"
"(let-values()(wrap #t in_0 config_0 c_0))"
"(let-values()"
"(read-delimited-constant"
" c_0"
"(char=? c_0 '#\\t)"
" '(#\\r #\\u #\\e)"
" #t"
" in_0"
" config_0)))))"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((skip-count_0) 0)"
"((source_0)(read-config-source config_0)))"
"(let-values(((c_1)"
"(peek-char-or-special"
" in_1"
" skip-count_0"
" 'special"
" source_0)))"
"(if(eq? c_1 'special)(special1.1 'special) c_1)))))"
"(if(char-delimiter? c2_0 config_0)"
"(let-values()(wrap #f in_0 config_0 c_0))"
"(if(let-values(((or-part_0)(char=? c2_0 '#\\x)))"
"(if or-part_0 or-part_0(char=? c2_0 '#\\l)))"
"(let-values()"
"(read-fixnum-or-flonum-vector"
" read-one"
" dispatch-c_0"
" c_0"
" c2_0"
" in_0"
" config_0))"
"(let-values()"
"(read-delimited-constant"
" c_0"
"(char=? c_0 '#\\f)"
" '(#\\a #\\l #\\s #\\e)"
" #f"
" in_0"
" config_0)))))))))))"
"(if(unsafe-fx< index_0 26)"
"(if(unsafe-fx< index_0 21)"
"(if(unsafe-fx< index_0 18)"
"(let-values()"
"(let-values(((temp212_0) #f)"
"((in213_0) in_0)"
"((config214_0) config_0)"
"                                               ((temp215_0) \"#e\"))"
"(read-symbol-or-number8.1 #f temp215_0 temp212_0 in213_0 config214_0)))"
"(if(unsafe-fx< index_0 19)"
"(let-values()"
"(let-values(((temp216_0) #f)"
"((in217_0) in_0)"
"((config218_0) config_0)"
"                                                 ((temp219_0) \"#E\"))"
"(read-symbol-or-number8.1 #f temp219_0 temp216_0 in217_0 config218_0)))"
"(if(unsafe-fx< index_0 20)"
"(let-values()"
"(let-values(((temp220_0) #f)"
"((in221_0) in_0)"
"((config222_0) config_0)"
"                                                   ((temp223_0) \"#i\"))"
"(read-symbol-or-number8.1 #f temp223_0 temp220_0 in221_0 config222_0)))"
"(let-values()"
"(let-values(((temp224_0) #f)"
"((in225_0) in_0)"
"((config226_0) config_0)"
"                                                   ((temp227_0) \"#I\"))"
"(read-symbol-or-number8.1 #f temp227_0 temp224_0 in225_0 config226_0))))))"
"(if(unsafe-fx< index_0 23)"
"(if(unsafe-fx< index_0 22)"
"(let-values()"
"(let-values(((temp228_0) #f)"
"((in229_0) in_0)"
"((config230_0) config_0)"
"                                                 ((temp231_0) \"#d\"))"
"(read-symbol-or-number8.1 #f temp231_0 temp228_0 in229_0 config230_0)))"
"(let-values()"
"(let-values(((temp232_0) #f)"
"((in233_0) in_0)"
"((config234_0) config_0)"
"                                                 ((temp235_0) \"#B\"))"
"(read-symbol-or-number8.1 #f temp235_0 temp232_0 in233_0 config234_0))))"
"(if(unsafe-fx< index_0 24)"
"(let-values()"
"(let-values(((temp236_0) #f)"
"((in237_0) in_0)"
"((config238_0) config_0)"
"                                                 ((temp239_0) \"#o\"))"
"(read-symbol-or-number8.1 #f temp239_0 temp236_0 in237_0 config238_0)))"
"(if(unsafe-fx< index_0 25)"
"(let-values()"
"(let-values(((temp240_0) #f)"
"((in241_0) in_0)"
"((config242_0) config_0)"
"                                                   ((temp243_0) \"#O\"))"
"(read-symbol-or-number8.1 #f temp243_0 temp240_0 in241_0 config242_0)))"
"(let-values()"
"(let-values(((temp244_0) #f)"
"((in245_0) in_0)"
"((config246_0) config_0)"
"                                                   ((temp247_0) \"#D\"))"
"(read-symbol-or-number8.1 #f temp247_0 temp244_0 in245_0 config246_0)))))))"
"(if(unsafe-fx< index_0 30)"
"(if(unsafe-fx< index_0 27)"
"(let-values()"
"(let-values(((temp248_0) #f)"
"((in249_0) in_0)"
"((config250_0) config_0)"
"                                               ((temp251_0) \"#b\"))"
"(read-symbol-or-number8.1 #f temp251_0 temp248_0 in249_0 config250_0)))"
"(if(unsafe-fx< index_0 28)"
"(let-values()"
"(let-values(((temp252_0) #f)"
"((in253_0) in_0)"
"((config254_0) config_0)"
"                                                 ((temp255_0) \"#x\"))"
"(read-symbol-or-number8.1 #f temp255_0 temp252_0 in253_0 config254_0)))"
"(if(unsafe-fx< index_0 29)"
"(let-values()"
"(let-values(((temp256_0) #f)"
"((in257_0) in_0)"
"((config258_0) config_0)"
"                                                   ((temp259_0) \"#X\"))"
"(read-symbol-or-number8.1 #f temp259_0 temp256_0 in257_0 config258_0)))"
"(let-values()"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(let-values(((tmp_1) c2_0))"
"(if(if(equal? tmp_1 '#\\s) #t(equal? tmp_1 '#\\S))"
"(let-values()"
"(read-one #f in_0(override-parameter read-case-sensitive config_0 #t)))"
"(if(if(equal? tmp_1 '#\\i) #t(equal? tmp_1 '#\\I))"
"(let-values()"
"(read-one #f in_0(override-parameter read-case-sensitive config_0 #f)))"
"(let-values()"
"(let-values(((in260_0) in_0)"
"((config261_0) config_0)"
"((c2262_0) c2_0)"
"                                                             ((temp263_0) \"expected `s', `S`, `i`, or `I` after `~a~a`\")"
"((dispatch-c264_0) dispatch-c_0)"
"((c265_0) c_0))"
"(reader-error12.1"
" unsafe-undefined"
" c2262_0"
" #f"
" unsafe-undefined"
" in260_0"
" config261_0"
" temp263_0"
"(list dispatch-c264_0 c265_0))))))))))))"
"(if(unsafe-fx< index_0 32)"
"(if(unsafe-fx< index_0 31)"
"(let-values()(read-hash read-one dispatch-c_0 c_0 in_0 config_0))"
"(let-values()"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 dispatch-c_0)(values))))"
"(let-values((()(begin(accum-string-add! accum-str_0 c_0)(values))))"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(char? c2_0)"
"(let-values()(accum-string-add! accum-str_0 c2_0))"
"(void))"
"(let-values(((tmp_1) c2_0))"
"(if(equal? tmp_1 '#\\x)"
"(let-values()(read-regexp c_0 accum-str_0 in_0 config_0))"
"(if(equal? tmp_1 '#\\e)"
"(let-values()"
"(read-extension-reader"
" read-one"
" read-undotted"
" dispatch-c_0"
" in_0"
" config_0))"
"(let-values()"
"(let-values(((in266_0) in_0)"
"((config267_0) config_0)"
"((c2268_0) c2_0)"
"((temp269_0)"
"(let-values(((accum-str270_0) accum-str_0)"
"((config271_0) config_0))"
"(accum-string-get!6.1"
" 0"
" accum-str270_0"
" config271_0))))"
"(bad-syntax-error20.1"
" c2268_0"
" in266_0"
" config267_0"
" temp269_0)))))))))))))"
"(if(unsafe-fx< index_0 33)"
"(let-values()"
"(let-values(((accum-str_0)(accum-string-init! config_0)))"
"(let-values((()(begin(accum-string-add! accum-str_0 dispatch-c_0)(values))))"
"(let-values((()(begin(accum-string-add! accum-str_0 c_0)(values))))"
"(let-values(((c2_0)"
"(let-values(((in_1) in_0)"
"((source_0)(read-config-source config_0)))"
"(read-char-or-special in_1 special1.1 source_0))))"
"(begin"
"(if(char? c2_0)"
"(let-values()(accum-string-add! accum-str_0 c2_0))"
"(void))"
"(let-values(((tmp_1) c2_0))"
"(if(equal? tmp_1 '#\\x)"
"(let-values()(read-regexp c_0 accum-str_0 in_0 config_0))"
"(let-values()"
"(let-values(((in272_0) in_0)"
"((config273_0) config_0)"
"((c2274_0) c2_0)"
"((temp275_0)"
"(let-values(((accum-str276_0) accum-str_0)"
"((config277_0) config_0))"
"(accum-string-get!6.1"
" 0"
" accum-str276_0"
" config277_0))))"
"(bad-syntax-error20.1"
" c2274_0"
" in272_0"
" config273_0"
" temp275_0)))))))))))"
"(if(unsafe-fx< index_0 34)"
"(let-values()"
"(let-values(((read-undotted278_0) read-undotted)"
"((dispatch-c279_0) dispatch-c_0)"
"((in280_0) in_0)"
"((config281_0) config_0))"
"(read-extension-lang7.1"
" #f"
" read-undotted278_0"
" dispatch-c279_0"
" in280_0"
" config281_0)))"
"(if(unsafe-fx< index_0 35)"
"(let-values()"
"(let-values(((read-undotted282_0) read-undotted)"
"((dispatch-c283_0) dispatch-c_0)"
"((in284_0) in_0)"
"((config285_0) config_0))"
"(read-extension-#!16.1"
" #f"
" read-undotted282_0"
" dispatch-c283_0"
" in284_0"
" config285_0)))"
"(let-values()"
"(if(check-parameter 1/read-accept-compiled config_0)"
"(let-values()"
"(wrap((read-config-read-compiled config_0) in_0) in_0 config_0 c_0))"
"(let-values()"
"(let-values(((in286_0) in_0)"
"((config287_0) config_0)"
"                                                         ((temp288_0) \"`~a~~` compiled expressions not enabled\")"
"((dispatch-c289_0) dispatch-c_0))"
"(reader-error12.1"
" unsafe-undefined"
" '#\\x"
" #f"
" unsafe-undefined"
" in286_0"
" config287_0"
" temp288_0"
"(list dispatch-c289_0)))))))))))))))))))))))))"
"(define-values"
"(retry-special-comment)"
"(lambda(v_0 in_0 config_0)"
"(begin"
"(if(1/special-comment? v_0)"
"(let-values()(if(read-config-keep-comment? config_0) v_0(read-undotted #f in_0 config_0)))"
"(let-values() v_0)))))"
"(define-values"
"(1/module-declared?)"
"(let-values(((module-declared?3_0)"
"(lambda(mod2_0 load?1_0)"
"(begin"
" 'module-declared?3"
"(let-values(((mod_0) mod2_0))"
"(let-values(((load?_0) load?1_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(module-reference? mod_0)"
"(void)"
"(let-values()"
"(raise-argument-error 'module-declared? module-reference-str mod_0)))"
"(values))))"
"(let-values(((ns_0)(1/current-namespace)))"
"(let-values(((name_0)"
"(let-values(((mod31_0) mod_0)((load?32_0) load?_0))"
"(reference->resolved-module-path27.1 load?32_0 mod31_0))))"
"(if(namespace->module ns_0 name_0) #t #f)))))))))))))"
"(case-lambda"
"((mod_0)(begin 'module-declared?(module-declared?3_0 mod_0 #f)))"
"((mod_0 load?1_0)(module-declared?3_0 mod_0 load?1_0)))))"
"(define-values"
"(1/module-predefined?)"
"(lambda(mod_0)"
"(begin"
" 'module-predefined?"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(module-reference? mod_0)"
"(void)"
"(let-values()(raise-argument-error 'module-predefined? module-reference-str mod_0)))"
"(values))))"
"(let-values(((ns_0)(1/current-namespace)))"
"(let-values(((name_0)"
"(let-values(((mod34_0) mod_0)((temp35_0) #f))"
"(reference->resolved-module-path27.1 temp35_0 mod34_0))))"
"(let-values(((m_0)(namespace->module ns_0 name_0)))(if m_0(module-is-predefined? m_0) #f))))))))))"
"(define-values"
"(module->)"
"(let-values(((module->9_0)"
"(lambda(extract6_0 who7_0 mod8_0 load?5_0)"
"(begin"
" 'module->9"
"(let-values(((extract_0) extract6_0))"
"(let-values(((who_0) who7_0))"
"(let-values(((mod_0) mod8_0))"
"(let-values(((load?_0) load?5_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(module-reference? mod_0)"
"(void)"
"(let-values()(raise-argument-error who_0 module-reference-str mod_0)))"
"(values))))"
"(let-values(((m_0)"
"(namespace->module/complain"
" who_0"
"(1/current-namespace)"
"(let-values(((mod36_0) mod_0)((load?37_0) load?_0))"
"(reference->resolved-module-path27.1 load?37_0 mod36_0)))))"
"(extract_0 m_0))))))))))))"
"(case-lambda"
"((extract_0 who_0 mod_0)(begin(module->9_0 extract_0 who_0 mod_0 #f)))"
"((extract_0 who_0 mod_0 load?5_0)(module->9_0 extract_0 who_0 mod_0 load?5_0)))))"
"(define-values"
"(1/module->language-info)"
"(let-values(((module->language-info13_0)"
"(lambda(mod12_0 load?11_0)"
"(begin"
" 'module->language-info13"
"(let-values(((mod_0) mod12_0))"
"(let-values(((load?_0) load?11_0))"
"(let-values()"
"(let-values()"
"(let-values()(module-> module-language-info 'module->language-info mod_0 load?_0))))))))))"
"(case-lambda"
"((mod_0)(begin 'module->language-info(module->language-info13_0 mod_0 #f)))"
"((mod_0 load?11_0)(module->language-info13_0 mod_0 load?11_0)))))"
"(define-values"
"(1/module->imports)"
"(lambda(mod_0)"
"(begin 'module->imports(let-values()(let-values()(module-> module-requires 'module->imports mod_0))))))"
"(define-values"
"(1/module->exports)"
"(lambda(mod_0)"
"(begin"
" 'module->exports"
"(let-values(((provides_0 self_0)"
"(module->(lambda(m_0)(values(module-provides m_0)(module-self m_0))) 'module->exports mod_0)))"
"(provides->api-provides provides_0 self_0)))))"
"(define-values"
"(1/module->indirect-exports)"
"(lambda(mod_0)"
"(begin"
" 'module->indirect-exports"
"(module->"
"(lambda(m_0)(variables->api-nonprovides(module-provides m_0)((module-get-all-variables m_0))))"
" 'module->indirect-exports"
" mod_0))))"
"(define-values"
"(1/module-provide-protected?)"
"(lambda(mod_0 sym_0)"
"(begin"
" 'module-provide-protected?"
"(module->"
"(lambda(m_0)"
"(let-values(((b/p_0)(hash-ref(module-provides m_0) sym_0 #f)))"
"(let-values(((or-part_0)(not b/p_0)))(if or-part_0 or-part_0(provided-as-protected? b/p_0)))))"
" 'module-provide-protected?"
" mod_0))))"
"(define-values"
"(1/module->namespace)"
"(let-values(((module->namespace17_0)"
"(lambda(mod16_0 ns15_0)"
"(begin"
" 'module->namespace17"
"(let-values(((mod_0) mod16_0))"
"(let-values(((ns_0)(if(eq? ns15_0 unsafe-undefined)(1/current-namespace) ns15_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(module-reference? mod_0)"
"(void)"
"(let-values()"
"(raise-argument-error 'module->namespace module-reference-str mod_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"                                                    (raise-argument-error 'module->namespace \"namespace?\" ns_0)))"
"(values))))"
"(let-values(((name_0)"
"(let-values(((mod44_0) mod_0)((temp45_0) #t))"
"(reference->resolved-module-path27.1 temp45_0 mod44_0))))"
"(let-values(((phase_0)(namespace-phase ns_0)))"
"(let-values(((m-ns_0)"
"(let-values(((ns46_0) ns_0)"
"((name47_0) name_0)"
"((phase48_0) phase_0))"
"(namespace->module-namespace82.1"
" #f"
" #f"
" unsafe-undefined"
" ns46_0"
" name47_0"
" phase48_0))))"
"(begin"
"(if m-ns_0"
"(void)"
"(let-values()"
"(begin"
"(namespace->module/complain 'module->namespace ns_0 name_0)"
"(raise-arguments-error"
" 'module->namespace"
"                                                 \"module not instantiated in the current namespace\""
"                                                 \"name\""
" name_0))))"
"(if(inspector-superior?"
"(current-code-inspector)"
"(namespace-inspector m-ns_0))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'module->namespace"
"                                               \"current code inspector cannot access namespace of module\""
"                                               \"module name\""
" name_0)))"
"(if(namespace-get-root-expand-ctx m-ns_0)"
"(void)"
"(let-values()"
"(namespace-set-root-expand-ctx!"
" m-ns_0"
"(let-values(((temp49_0)(namespace-mpi m-ns_0)))"
"(make-root-expand-context13.1"
" #f"
" null"
" unsafe-undefined"
" unsafe-undefined"
" temp49_0)))))"
"(let-values(((ns41_0) ns_0)"
"((temp42_0)(namespace-mpi m-ns_0))"
"((phase43_0) phase_0))"
"(namespace-module-make-available!112.1"
" unsafe-undefined"
" ns41_0"
" temp42_0"
" phase43_0))"
" m-ns_0)))))))))))))))"
"(case-lambda"
"((mod_0)(begin 'module->namespace(module->namespace17_0 mod_0 unsafe-undefined)))"
"((mod_0 ns15_0)(module->namespace17_0 mod_0 ns15_0)))))"
"(define-values"
"(1/namespace-unprotect-module)"
"(let-values(((namespace-unprotect-module22_0)"
"(lambda(insp20_0 mod21_0 ns19_0)"
"(begin"
" 'namespace-unprotect-module22"
"(let-values(((insp_0) insp20_0))"
"(let-values(((mod_0) mod21_0))"
"(let-values(((ns_0)(if(eq? ns19_0 unsafe-undefined)(1/current-namespace) ns19_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(inspector? insp_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-unprotect-module"
"                                                     \"inspector?\""
" insp_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/module-path? mod_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-unprotect-module"
"                                                       \"module-path?\""
" mod_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(1/namespace? ns_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'namespace-unprotect-module"
"                                                         \"namespace?\""
" ns_0)))"
"(values))))"
"(let-values(((name_0)"
"(let-values(((mod51_0) mod_0)((temp52_0) #f))"
"(reference->resolved-module-path27.1 temp52_0 mod51_0))))"
"(let-values(((phase_0)(namespace-phase ns_0)))"
"(let-values(((m-ns_0)"
"(let-values(((ns53_0) ns_0)"
"((name54_0) name_0)"
"((phase55_0) phase_0))"
"(namespace->module-namespace82.1"
" #f"
" #f"
" unsafe-undefined"
" ns53_0"
" name54_0"
" phase55_0))))"
"(begin"
"(if m-ns_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'namespace-unprotect-module"
"                                                   \"module not instantiated\""
"                                                   \"module name\""
" name_0)))"
"(if(inspector-superior? insp_0(namespace-inspector m-ns_0))"
"(let-values()"
"(set-namespace-inspector!"
" m-ns_0"
"(make-inspector(current-code-inspector))))"
"(void)))))))))))))))))))"
"(case-lambda"
"((insp_0 mod_0)(begin 'namespace-unprotect-module(namespace-unprotect-module22_0 insp_0 mod_0 unsafe-undefined)))"
"((insp_0 mod_0 ns19_0)(namespace-unprotect-module22_0 insp_0 mod_0 ns19_0)))))"
"(define-values"
"(namespace->module/complain)"
"(lambda(who_0 ns_0 name_0)"
"(begin"
"(let-values(((or-part_0)(namespace->module ns_0 name_0)))"
"(if or-part_0"
" or-part_0"
"          (raise-arguments-error who_0 \"unknown module in the current namespace\" \"name\" name_0))))))"
"(define-values"
"(module-reference?)"
"(lambda(mod_0)"
"(begin"
"(let-values(((or-part_0)(1/module-path? mod_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(1/module-path-index? mod_0)))"
"(if or-part_1 or-part_1(1/resolved-module-path? mod_0))))))))"
" (define-values (module-reference-str) \"(or/c module-path? module-path-index? resolved-module-path?)\")"
"(define-values"
"(reference->resolved-module-path27.1)"
"(lambda(load?24_0 mod26_0)"
"(begin"
" 'reference->resolved-module-path27"
"(let-values(((mod_0) mod26_0))"
"(let-values(((load?_0) load?24_0))"
"(let-values()"
"(if(1/resolved-module-path? mod_0)"
"(let-values() mod_0)"
"(let-values()"
"(let-values(((mpi_0)(if(1/module-path-index? mod_0) mod_0(1/module-path-index-join mod_0 #f))))"
"(1/module-path-index-resolve mpi_0 load?_0))))))))))"
"(define-values"
"(read-linklet-bundle-or-directory)"
"(lambda(in_0)"
"(begin"
"(letrec-values(((read-linklet-or-directory_0)"
"(lambda(initial?_0)"
"(begin"
" 'read-linklet-or-directory"
"(let-values(((start-pos_0)(-(file-position in_0) 2)))"
"(let-values(((vers-len_0)(min 63(read-byte in_0))))"
"(let-values(((vers_0)(read-bytes vers-len_0 in_0)))"
"(let-values((()"
"(begin"
"(if(equal? vers_0 version-bytes$1)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'read-compiled-linklet"
"                                                      \"version mismatch\""
"                                                      \"expected\""
"(version)"
"                                                      \"found\""
"(bytes->string/utf-8 vers_0 '#\\?)"
"                                                      \"in\""
"(let-values(((n_0)(object-name in_0)))"
"(if(path? n_0)"
"(unquoted-printing-string(path->string n_0))"
" in_0)))))"
"(values))))"
"(let-values(((vm-len_0)(min 63(read-byte in_0))))"
"(let-values(((vm_0)(read-bytes vm-len_0 in_0)))"
"(let-values(((as-correlated-linklet?_0)"
"(equal? vm_0 correlated-linklet-vm-bytes)))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0) as-correlated-linklet?_0))"
"(if or-part_0 or-part_0(equal? vm_0 vm-bytes$1)))"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'read-compiled-linklet"
"                                                              \"virtual-machine mismatch\""
"                                                              \"expected\""
"(bytes->string/utf-8 vm-bytes$1)"
"                                                              \"found\""
"(bytes->string/utf-8 vm_0 '#\\?)"
"                                                              \"in\""
"(let-values(((n_0)(object-name in_0)))"
"(if(path? n_0)"
"(unquoted-printing-string(path->string n_0))"
" in_0)))))"
"(values))))"
"(let-values(((tag_0)(read-byte in_0)))"
"(if(eqv? tag_0(char->integer '#\\B))"
"(let-values()"
"(let-values(((sha-1_0)(read-bytes 20 in_0)))"
"(let-values(((b-ht_0)"
"(if as-correlated-linklet?_0"
"(read-correlated-linklet-bundle-hash in_0)"
"(1/read-linklet-bundle-hash in_0))))"
"(begin"
"(if(hash? b-ht_0)"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'read-linklet-bundle-hash"
"                                                            \"bad read result\""
"                                                            \"expected\""
"                                                            \"hash/c\""
"                                                            \"found\""
"                                                            (format \"~s\" b-ht_0)"
"                                                            \"in\""
"(let-values(((n_0)(object-name in_0)))"
"(if(path? n_0)(path->string n_0) in_0)))))"
"(hash->linklet-bundle"
"(add-hash-code"
"(if initial?_0(strip-submodule-references b-ht_0) b-ht_0)"
" sha-1_0))))))"
"(if(eqv? tag_0(char->integer '#\\D))"
"(let-values()"
"(begin"
"(if initial?_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'read-compiled-linklet"
"                                                          \"expected a linklet bundle\")))"
"(read-bundle-directory_0 start-pos_0)))"
"(let-values()"
"(raise-arguments-error"
" 'read-compiled-linklet"
"                                                    \"expected a `B` or `D`\"))))))))))))))))"
"((read-bundle-directory_0)"
"(lambda(pos_0)"
"(begin"
" 'read-bundle-directory"
"(let-values(((count_0)(read-int in_0)))"
"(let-values(((position-to-name_0)"
"((letrec-values(((loop_0)"
"(lambda(count_1 accum_0)"
"(begin"
" 'loop"
"(if(zero? count_1)"
"(let-values() accum_0)"
"(let-values()"
"(let-values(((bstr_0)"
"(read-bytes(read-int in_0) in_0)))"
"(let-values(((offset_0)(read-int in_0)))"
"(let-values(((len_0)(read-int in_0)))"
"(begin"
"(read-int in_0)"
"(read-int in_0)"
"(loop_0"
"(sub1 count_1)"
"(hash-set"
" accum_0"
" offset_0"
" bstr_0))))))))))))"
" loop_0)"
" count_0"
"(hasheqv))))"
"((letrec-values(((loop_0)"
"(lambda(count_1 accum_0)"
"(begin"
" 'loop"
"(if(zero? count_1)"
"(let-values()"
"(list->bundle-directory accum_0 hash->linklet-directory))"
"(let-values()"
"(let-values(((name_0)"
"(hash-ref"
" position-to-name_0"
"(-(file-position in_0) pos_0)"
" #f)))"
"(let-values((()"
"(begin"
"(if name_0"
"(void)"
"(let-values()"
"(raise-arguments-error"
" 'read-compiled-linklet"
"                                                                                \"bundle not at an expected file position\")))"
"(values))))"
"(let-values(((bstr_0)(read-bytes 2 in_0)))"
"(let-values(((bundle_0)"
"                                                                             (if (equal? #\"#~\" bstr_0)"
"(let-values()"
"(read-linklet-or-directory_0 #f))"
"                                                                               (if (equal? #\"#f\" bstr_0)"
"(let-values() #f)"
"(let-values()"
"(raise-arguments-error"
" 'read-compiled-linklet"
"                                                                                    \"expected a `#~` or `#f` for a bundle\"))))))"
"(loop_0"
"(sub1 count_1)"
"(cons"
"(cons(decode-name name_0 0) bundle_0)"
" accum_0))))))))))))"
" loop_0)"
" count_0"
" '())))))))"
"(read-linklet-or-directory_0 #t)))))"
"(define-values(read-int)(lambda(in_0)(begin(integer-bytes->integer(read-bytes 4 in_0) #f #f))))"
"(define-values"
"(decode-name)"
"(lambda(bstr_0 pos_0)"
"(begin"
"(let-values(((blen_0)(bytes-length bstr_0)))"
"(let-values(((bad-bundle_0)"
"(lambda()"
"                        (begin 'bad-bundle (raise-arguments-error 'read-compiled-linklet \"malformed bundle\")))))"
"(if(= pos_0 blen_0)"
"(let-values() '())"
"(if(> pos_0 blen_0)"
"(let-values()(bad-bundle_0))"
"(let-values()"
"(let-values(((len_0)(bytes-ref bstr_0 pos_0)))"
"(begin"
"(if(>(+ pos_0 len_0 1) blen_0)(let-values()(bad-bundle_0))(void))"
"(if(= len_0 255)"
"(let-values()"
"(let-values(((len_1)(integer-bytes->integer bstr_0 #f #f(add1 pos_0)(+ pos_0 5))))"
"(begin"
"(if(>(+ pos_0 len_1 1) blen_0)(let-values()(bad-bundle_0))(void))"
"(cons"
"(string->symbol(bytes->string/utf-8(subbytes bstr_0(+ pos_0 5)(+ pos_0 5 len_1)) '#\\?))"
"(decode-name bstr_0(+ pos_0 5 len_1))))))"
"(let-values()"
"(cons"
"(string->symbol(bytes->string/utf-8(subbytes bstr_0(add1 pos_0)(+ pos_0 1 len_0)) '#\\?))"
"(decode-name bstr_0(+ pos_0 1 len_0)))))))))))))))"
"(define-values"
"(list->bundle-directory)"
"(lambda(l_0 hash->linklet-directory_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(l_1 prev-len_0 stack_0 accum_0)"
"(begin"
" 'loop"
"(begin"
"(if(null? l_1)"
"                                (let-values () (raise-arguments-error 'read-compiled-linklet \"invalid bundle sequence\"))"
"(void))"
"(let-values(((p_0)(car l_1)))"
"(let-values(((path_0)(car p_0)))"
"(let-values(((v_0)(cdr p_0)))"
"(let-values(((len_0)(length path_0)))"
"(begin"
"(if(< len_0 prev-len_0)"
"(let-values()"
"                                            (raise-arguments-error 'read-compiled-linklet \"invalid bundle sequence\"))"
"(void))"
"((letrec-values(((sloop_0)"
"(lambda(prev-len_1 stack_1 accum_1)"
"(begin"
" 'sloop"
"(if(> len_0(add1 prev-len_1))"
"(let-values()"
"(sloop_0"
"(add1 prev-len_1)"
"(cons accum_1 stack_1)"
"(hasheq)))"
"(let-values()"
"(let-values(((path_1)"
"(list-tail"
" path_0"
"(max 0(sub1 prev-len_1)))))"
"(if(= len_0 prev-len_1)"
"(let-values()"
"(let-values(((accum_2)"
"(if v_0"
"(hash-set accum_1 #f v_0)"
" accum_1)))"
"(if(zero? len_0)"
"(hash->linklet-directory_0 accum_2)"
"(loop_0"
"(cdr l_1)"
"(sub1 prev-len_1)"
"(cdr stack_1)"
"(hash-set"
"(car stack_1)"
"(car path_1)"
"(hash->linklet-directory_0 accum_2))))))"
"(let-values()"
"(let-values(((path_2)"
"(if(positive? prev-len_1)"
"(cdr path_1)"
" path_1)))"
"(loop_0"
"(cdr l_1)"
" prev-len_1"
" stack_1"
"(hash-set"
" accum_1"
"(car path_2)"
"(hash->linklet-directory_0"
"(if v_0"
"(hasheq #f v_0)"
"(hasheq)))))))))))))))"
" sloop_0)"
" prev-len_0"
" stack_0"
" accum_0)))))))))))"
" loop_0)"
" l_0"
" 0"
" '()"
"(hasheq)))))"
"(define-values(strip-submodule-references)(lambda(b-ht_0)(begin(hash-remove(hash-remove b-ht_0 'pre) 'post))))"
"(define-values"
"(add-hash-code)"
"(lambda(b-ht_0 sha-1_0)"
"(begin"
"      (if (bytes=? sha-1_0 #\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\") b-ht_0 (hash-set b-ht_0 'hash-code sha-1_0)))))"
"(define-values"
"(read-syntax$1)"
"(lambda(src_0 in_0)"
"(begin"
" 'read-syntax"
"(if(default-read-handler? in_0)"
"(let-values()"
"(begin"
"(maybe-flush-stdout in_0)"
"(let-values(((in17_0) in_0)((temp18_0) #t)((src19_0) src_0))"
"(read*14.1 temp18_0 #f #f unsafe-undefined #f src19_0 in17_0))))"
"(let-values()(values((port-read-handler in_0) in_0 src_0)))))))"
"(define-values"
"(read-syntax/recursive$1)"
"(lambda(src_0 in_0 start_0 readtable_0 graph?_0)"
"(begin"
" 'read-syntax/recursive"
"(let-values(((in20_0) in_0)"
"((temp21_0) #t)"
"((temp22_0) #t)"
"((src23_0) src_0)"
"((start24_0) start_0)"
"((readtable25_0) readtable_0)"
"((temp26_0)(not graph?_0)))"
"(read*14.1 temp21_0 start24_0 temp26_0 readtable25_0 temp22_0 src23_0 in20_0)))))"
"(define-values"
"(read$1)"
"(lambda(in_0)"
"(begin"
" 'read"
"(if(default-read-handler? in_0)"
"(let-values()"
"(begin"
"(maybe-flush-stdout in_0)"
"(let-values(((in27_0) in_0)((temp28_0) #f))(read*14.1 temp28_0 #f #f unsafe-undefined #f #f in27_0))))"
"(let-values()(values((port-read-handler in_0) in_0)))))))"
"(define-values"
"(read/recursive$1)"
"(lambda(in_0 start_0 readtable_0 graph?_0)"
"(begin"
" 'read/recursive"
"(let-values(((in29_0) in_0)"
"((temp30_0) #f)"
"((temp31_0) #t)"
"((start32_0) start_0)"
"((readtable33_0) readtable_0)"
"((temp34_0)(not graph?_0)))"
"(read*14.1 temp30_0 start32_0 temp34_0 readtable33_0 temp31_0 #f in29_0)))))"
"(define-values"
"(read*14.1)"
"(lambda(for-syntax?1_0 init-c4_0 local-graph?6_0 readtable5_0 recursive?2_0 source3_0 in13_0)"
"(begin"
" 'read*14"
"(let-values(((in_0) in13_0))"
"(let-values(((for-syntax?_0) for-syntax?1_0))"
"(let-values(((recursive?_0) recursive?2_0))"
"(let-values(((source_0) source3_0))"
"(let-values(((init-c_0) init-c4_0))"
"(let-values(((readtable_0)"
"(if(eq? readtable5_0 unsafe-undefined)(1/current-readtable) readtable5_0)))"
"(let-values(((local-graph?_0) local-graph?6_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'read))(void))"
"(begin0"
"(let-values()"
"(let-values(((in35_0) in_0)"
"((for-syntax?36_0) for-syntax?_0)"
"((recursive?37_0) recursive?_0)"
"((source38_0) source_0)"
"((temp39_0)(if for-syntax?_0 read-to-syntax #f))"
"((init-c40_0) init-c_0)"
"((readtable41_0) readtable_0)"
"((local-graph?42_0) local-graph?_0)"
"((read-linklet-bundle-or-directory43_0) read-linklet-bundle-or-directory)"
"((call-with-root-namespace44_0) call-with-root-namespace)"
"((dynamic-require45_0) 1/dynamic-require)"
"((read-module-declared?46_0) read-module-declared?)"
"((read-coerce47_0) read-coerce)"
"((read-coerce-key48_0) read-coerce-key))"
"(read32.1"
" call-with-root-namespace44_0"
" read-coerce47_0"
" read-coerce-key48_0"
" dynamic-require45_0"
" for-syntax?36_0"
" init-c40_0"
" unsafe-undefined"
" local-graph?42_0"
" read-module-declared?46_0"
" unsafe-undefined"
" read-linklet-bundle-or-directory43_0"
" readtable41_0"
" recursive?37_0"
" source38_0"
" temp39_0"
" in35_0)))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))))))))))"
"(define-values"
"(read-language$1)"
"(lambda(in_0 fail-thunk_0)"
"(begin"
" 'read-language"
"(let-values(((in49_0) in_0)"
"((fail-thunk50_0) fail-thunk_0)"
"((temp51_0) #t)"
"((read-to-syntax52_0) read-to-syntax)"
"((read-linklet-bundle-or-directory53_0) read-linklet-bundle-or-directory)"
"((call-with-root-namespace54_0) call-with-root-namespace)"
"((dynamic-require55_0) 1/dynamic-require)"
"((read-module-declared?56_0) read-module-declared?)"
"((read-coerce57_0) read-coerce)"
"((read-coerce-key58_0) read-coerce-key))"
"(read-language53.1"
" call-with-root-namespace54_0"
" read-coerce57_0"
" read-coerce-key58_0"
" dynamic-require55_0"
" temp51_0"
" read-module-declared?56_0"
" read-linklet-bundle-or-directory53_0"
" read-to-syntax52_0"
" in49_0"
" fail-thunk50_0)))))"
"(define-values"
"(read-to-syntax)"
"(lambda(s-exp_0 srcloc_0 rep_0)"
"(begin"
"(let-values(((the-struct_0) empty-syntax))"
"(if(syntax?$1 the-struct_0)"
"(let-values(((content59_0)(datum-intern-literal s-exp_0))"
"((srcloc60_0) srcloc_0)"
"((props61_0)"
"(let-values(((tmp_0) rep_0))"
"(if(equal? tmp_0 '#\\[)"
"(let-values() original-square-props)"
"(if(equal? tmp_0 '#\\{)"
"(let-values() original-curly-props)"
"(let-values() original-props))))))"
"(syntax1.1"
" content59_0"
"(syntax-scopes the-struct_0)"
"(syntax-shifted-multi-scopes the-struct_0)"
"(syntax-scope-propagations+tamper the-struct_0)"
"(syntax-mpi-shifts the-struct_0)"
" srcloc60_0"
" props61_0"
"(syntax-inspector the-struct_0)))"
"          (raise-argument-error 'struct-copy \"syntax?\" the-struct_0))))))"
"(define-values(original-props)(syntax-props(syntax-property$1 empty-syntax original-property-sym #t)))"
"(define-values"
"(original-square-props)"
"(syntax-props(syntax-property$1(syntax-property$1 empty-syntax original-property-sym #t) 'paren-shape '#\\[)))"
"(define-values"
"(original-curly-props)"
"(syntax-props(syntax-property$1(syntax-property$1 empty-syntax original-property-sym #t) 'paren-shape '#\\{)))"
"(define-values(read-module-declared?)(lambda(mod-path_0)(begin(1/module-declared? mod-path_0 #t))))"
"(define-values"
"(read-coerce)"
"(lambda(for-syntax?_0 v_0 srcloc_0)"
"(begin"
"(if(not for-syntax?_0)"
"(let-values()(if(syntax?$1 v_0)(let-values()(syntax->datum$1 v_0))(let-values() v_0)))"
"(if(syntax?$1 v_0)"
"(let-values() v_0)"
"(if(list? v_0)"
"(let-values()"
"(read-to-syntax"
"(reverse$1"
"(let-values(((lst_0) v_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(read-coerce #t e_0 srcloc_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
" srcloc_0"
" #f))"
"(if(pair? v_0)"
"(let-values()"
"(read-to-syntax"
"(cons(read-coerce #t(car v_0) srcloc_0)(read-coerce #t(cdr v_0) srcloc_0))"
" srcloc_0"
" #f))"
"(let-values()(read-to-syntax v_0 srcloc_0 #f)))))))))"
"(define-values"
"(read-coerce-key)"
"(lambda(for-syntax?_0 k_0)"
"(begin(if for-syntax?_0(let-values()(datum-intern-literal k_0))(let-values() k_0)))))"
"(define-values(default-read-handler) #f)"
"(define-values"
"(default-read-handler?)"
"(lambda(in_0)"
"(begin"
"(if(not default-read-handler)"
"(let-values()(begin(set! default-read-handler(port-read-handler in_0)) #t))"
"(let-values()(eq? default-read-handler(port-read-handler in_0)))))))"
"(define-values(orig-input-port)(current-input-port))"
"(define-values(orig-output-port)(current-output-port))"
"(define-values(orig-error-port)(current-error-port))"
"(define-values"
"(maybe-flush-stdout)"
"(lambda(in_0)"
"(begin"
"(if(eq? in_0 orig-input-port)"
"(let-values()(begin(flush-output orig-output-port)(flush-output orig-error-port)))"
"(void)))))"
"(define-values"
"(call-with-root-namespace)"
"(lambda(thunk_0)"
"(begin"
"(let-values(((root-ns_0)(namespace-root-namespace(1/current-namespace))))"
"(if root-ns_0"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization(continuation-mark-set-first #f parameterization-key) 1/current-namespace root-ns_0)"
"(let-values()(thunk_0)))"
"(thunk_0))))))"
"(define-values"
"(1/read-syntax)"
"(let-values(((read-syntax3_0)"
"(lambda(src1_0 in2_0)"
"(begin"
" 'read-syntax3"
"(let-values(((src_0)(if(eq? src1_0 unsafe-undefined)(object-name(current-input-port)) src1_0)))"
"(let-values(((in_0)(if(eq? in2_0 unsafe-undefined)(current-input-port) in2_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(input-port? in_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'read-syntax \"input-port?\" in_0)))"
"(read-syntax$1 src_0 in_0)))))))))))"
"(case-lambda"
"(()(begin 'read-syntax(read-syntax3_0 unsafe-undefined unsafe-undefined)))"
"((src_0 in2_0)(read-syntax3_0 src_0 in2_0))"
"((src1_0)(read-syntax3_0 src1_0 unsafe-undefined)))))"
"(define-values"
"(1/read-syntax/recursive)"
"(let-values(((read-syntax/recursive10_0)"
"(lambda(src5_0 in6_0 start7_0 readtable8_0 graph?9_0)"
"(begin"
" 'read-syntax/recursive10"
"(let-values(((src_0)(if(eq? src5_0 unsafe-undefined)(object-name(current-input-port)) src5_0)))"
"(let-values(((in_0)(if(eq? in6_0 unsafe-undefined)(current-input-port) in6_0)))"
"(let-values(((start_0) start7_0))"
"(let-values(((readtable_0)"
"(if(eq? readtable8_0 unsafe-undefined)(1/current-readtable) readtable8_0)))"
"(let-values(((graph?_0) graph?9_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(input-port? in_0)"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'read-syntax/recursive \"input-port?\" in_0)))"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(char? x_0))))"
" start_0)"
"(void)"
"(let-values()"
"                                          (raise-argument-error 'read-syntax/recursive \"(or/c char? #f)\" start_0)))"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(1/readtable? x_0))))"
" readtable_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'read-syntax/recursive"
"                                           \"(or/c readtable? #f)\""
" readtable_0)))"
"(read-syntax/recursive$1 src_0 in_0 start_0 readtable_0 graph?_0))))))))))))))"
"(case-lambda"
"(()"
"(begin"
" 'read-syntax/recursive"
"(read-syntax/recursive10_0 unsafe-undefined unsafe-undefined #f unsafe-undefined #t)))"
"((src_0 in_0 start_0 readtable_0 graph?9_0)(read-syntax/recursive10_0 src_0 in_0 start_0 readtable_0 graph?9_0))"
"((src_0 in_0 start_0 readtable8_0)(read-syntax/recursive10_0 src_0 in_0 start_0 readtable8_0 #t))"
"((src_0 in_0 start7_0)(read-syntax/recursive10_0 src_0 in_0 start7_0 unsafe-undefined #t))"
"((src_0 in6_0)(read-syntax/recursive10_0 src_0 in6_0 #f unsafe-undefined #t))"
"((src5_0)(read-syntax/recursive10_0 src5_0 unsafe-undefined #f unsafe-undefined #t)))))"
"(define-values"
"(1/read)"
"(let-values(((read13_0)"
"(lambda(in12_0)"
"(begin"
" 'read13"
"(let-values(((in_0)(if(eq? in12_0 unsafe-undefined)(current-input-port) in12_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(input-port? in_0)"
"(void)"
"                                (let-values () (raise-argument-error 'read \"input-port?\" in_0)))"
"(read$1 in_0))))))))))"
"(case-lambda(()(begin 'read(read13_0 unsafe-undefined)))((in12_0)(read13_0 in12_0)))))"
"(define-values"
"(1/read/recursive)"
"(let-values(((read/recursive19_0)"
"(lambda(in15_0 start16_0 readtable17_0 graph?18_0)"
"(begin"
" 'read/recursive19"
"(let-values(((in_0)(if(eq? in15_0 unsafe-undefined)(current-input-port) in15_0)))"
"(let-values(((start_0) start16_0))"
"(let-values(((readtable_0)"
"(if(eq? readtable17_0 unsafe-undefined)(1/current-readtable) readtable17_0)))"
"(let-values(((graph?_0) graph?18_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(input-port? in_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'read/recursive \"input-port?\" in_0)))"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))(if or-part_0 or-part_0(char? x_0))))"
" start_0)"
"(void)"
"                                      (let-values () (raise-argument-error 'read/recursive \"(or/c char? #f)\" start_0)))"
"(if((lambda(x_0)"
"(let-values(((or-part_0)(not x_0)))"
"(if or-part_0 or-part_0(1/readtable? x_0))))"
" readtable_0)"
"(void)"
"(let-values()"
"                                        (raise-argument-error 'read/recursive \"(or/c readtable? #f)\" readtable_0)))"
"(read/recursive$1 in_0 start_0 readtable_0 graph?_0)))))))))))))"
"(case-lambda"
"(()(begin 'read/recursive(read/recursive19_0 unsafe-undefined #f unsafe-undefined #t)))"
"((in_0 start_0 readtable_0 graph?18_0)(read/recursive19_0 in_0 start_0 readtable_0 graph?18_0))"
"((in_0 start_0 readtable17_0)(read/recursive19_0 in_0 start_0 readtable17_0 #t))"
"((in_0 start16_0)(read/recursive19_0 in_0 start16_0 unsafe-undefined #t))"
"((in15_0)(read/recursive19_0 in15_0 #f unsafe-undefined #t)))))"
"(define-values"
"(1/read-language)"
"(let-values(((read-language23_0)"
"(lambda(in21_0 fail-thunk22_0)"
"(begin"
" 'read-language23"
"(let-values(((in_0)(if(eq? in21_0 unsafe-undefined)(current-input-port) in21_0)))"
"(let-values(((fail-thunk_0)"
"(if(eq? fail-thunk22_0 unsafe-undefined) read-language-fail-thunk fail-thunk22_0)))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(input-port? in_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'read-language \"input-port?\" in_0)))"
"(if((lambda(p_0)(if(procedure? p_0)(procedure-arity-includes? p_0 0) #f))"
" fail-thunk_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'read-language"
"                                     \"(procedure-arity-includes/c 0)\""
" fail-thunk_0)))"
"(read-language$1"
" in_0"
"(if(eq? fail-thunk_0 read-language-fail-thunk) #f fail-thunk_0))))))))))))"
"(case-lambda"
"(()(begin 'read-language(read-language23_0 unsafe-undefined unsafe-undefined)))"
"((in_0 fail-thunk22_0)(read-language23_0 in_0 fail-thunk22_0))"
"((in21_0)(read-language23_0 in21_0 unsafe-undefined)))))"
" (define-values (read-language-fail-thunk) (lambda () (begin (error \"fail\"))))"
"(define-values"
"(declare-primitive-module!)"
"(lambda(name_0 inst_0 in-ns_0 protected_0 cross-phase-persistent?_0)"
"(begin"
"(let-values(((mpi_0)(1/module-path-index-join(list 'quote name_0) #f)))"
"(let-values(((in-ns1_0) in-ns_0)"
"((temp2_0)"
"(let-values(((temp4_0)(1/current-module-declare-source))"
"((cross-phase-persistent?5_0) cross-phase-persistent?_0)"
"((temp6_0)(zero?(hash-count protected_0)))"
"((mpi7_0) mpi_0)"
"((temp8_0)"
"(hasheqv"
" 0"
"(let-values(((lst_0)(1/instance-variable-names inst_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((sym_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values(((binding_0)"
"(let-values(((mpi10_0)"
" mpi_0)"
"((temp11_0)"
" 0)"
"((sym12_0)"
" sym_0))"
"(make-module-binding20.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" mpi10_0"
" temp11_0"
" sym12_0))))"
"(values"
" sym_0"
"(if(hash-ref"
" protected_0"
" sym_0"
" #f)"
"(provided1.1"
" binding_0"
" #t"
" #f)"
" binding_0))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)(for-loop_0 table_1 rest_0) table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
" lst_0)))))"
"((temp9_0)"
"(lambda(data-box_0"
" ns_0"
" phase-shift_0"
" phase-level_0"
" self_0"
" bulk-binding-registry_0"
" insp_0)"
"(if(= 0 phase-level_0)"
"(let-values()"
"(begin"
"(let-values(((lst_0)(1/instance-variable-names inst_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((sym_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((val_0)"
"(1/instance-variable-value"
" inst_0"
" sym_0)))"
"(namespace-set-variable!"
" ns_0"
" 0"
" sym_0"
" val_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))"
"(void)))))"
"(make-module39.1"
" cross-phase-persistent?5_0"
" unsafe-undefined"
" unsafe-undefined"
" temp9_0"
" #f"
" 0"
" 0"
" temp6_0"
" unsafe-undefined"
" #f"
" unsafe-undefined"
" #f"
" temp8_0"
" null"
" mpi7_0"
" temp4_0"
" null"
" #f)))"
"((temp3_0)(substitute-module-declare-name name_0)))"
"(declare-module!58.1 #t in-ns1_0 temp2_0 temp3_0))))))"
"(define-values"
"(1/prop:exn:missing-module 1/exn:missing-module? 1/exn:missing-module-accessor)"
"(make-struct-type-property"
" 'missing-module"
"(lambda(v_0 info_0)"
"(begin"
"(if(if(procedure? v_0)(procedure-arity-includes? v_0 1) #f)"
"(void)"
"         (let-values () (raise-argument-error 'guard-for-prop:exn:missing-module \"(procedure-arity-includes/c 1)\" v_0)))"
" v_0))))"
"(define-values"
"(1/struct:exn:fail:filesystem:missing-module"
" 1/make-exn:fail:filesystem:missing-module"
" 1/exn:fail:filesystem:missing-module?"
" 1/exn:fail:filesystem:missing-module-path)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'exn:fail:filesystem:missing-module"
" struct:exn:fail:filesystem"
" 1"
" 0"
" #f"
"(list"
"(cons 1/prop:exn:missing-module(lambda(e_0)(1/exn:fail:filesystem:missing-module-path e_0))))"
" #f"
" #f"
" '(0)"
" #f"
" 'exn:fail:filesystem:missing-module)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'path))))"
"(define-values"
"(1/struct:exn:fail:syntax:missing-module"
" 1/make-exn:fail:syntax:missing-module"
" 1/exn:fail:syntax:missing-module?"
" 1/exn:fail:syntax:missing-module-path)"
"(let-values(((struct:_0 make-_0 ?_0 -ref_0 -set!_0)"
"(let-values()"
"(let-values()"
"(make-struct-type"
" 'exn:fail:syntax:missing-module"
" 1/struct:exn:fail:syntax"
" 1"
" 0"
" #f"
"(list(cons 1/prop:exn:missing-module(lambda(e_0)(1/exn:fail:syntax:missing-module-path e_0))))"
" #f"
" #f"
" '(0)"
" #f"
" 'exn:fail:syntax:missing-module)))))"
"(values struct:_0 make-_0 ?_0(make-struct-field-accessor -ref_0 0 'path))))"
"(define-values"
"(1/current-module-path-for-load)"
"(make-parameter"
" #f"
"(lambda(v_0)"
"(begin"
"(if(let-values(((or-part_0)(not v_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(1/module-path? v_0)))"
"(if or-part_1 or-part_1(if(syntax?$1 v_0)(1/module-path?(syntax->datum$1 v_0)) #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'current-module-path-for-load"
"(string-append"
"             \"(or/c module-path?\""
"             \" (and/c syntax? (lambda (stx) (module-path? (syntax->datum stx))))\""
"             \" #f)\")"
" v_0)))"
" v_0))))"
"(define-values"
"(maybe-raise-missing-module)"
"(lambda(name_0 filename_0 pre_0 rel_0 post_0 errstr_0)"
"(begin"
"(let-values(((path_0)(1/current-module-path-for-load)))"
"(if path_0"
"(let-values()"
"(begin"
"(if(syntax?$1 path_0)"
"(let-values()"
"(raise"
"(1/make-exn:fail:syntax:missing-module"
"(format"
"(string-append"
"                      \"~a: cannot open module file\\n\""
"                      \"  module path: ~a\\n\""
"                      \"  path: ~a~a~a~a\\n\""
"                      \"  system error: ~a\")"
"(if(syntax-srcloc path_0)(srcloc->string(syntax-srcloc path_0)) name_0)"
"(syntax->datum$1 path_0)"
" filename_0"
" pre_0"
" rel_0"
" post_0"
" errstr_0)"
"(current-continuation-marks)"
"(list path_0)"
"(syntax->datum$1 path_0))))"
"(void))"
"(raise"
"(1/make-exn:fail:filesystem:missing-module"
"(format"
"(string-append"
"                  \"~a: cannot open module file\\n\""
"                  \"  module path: ~a\\n\""
"                  \"  path: ~a~a~a~a\\n\""
"                  \"  system error: ~a\")"
" name_0"
" path_0"
" filename_0"
" pre_0"
" rel_0"
" post_0"
" errstr_0)"
"(current-continuation-marks)"
" path_0))))"
"(void))))))"
"(define-values"
"(1/local-expand)"
"(let-values(((local-expand5_0)"
"(lambda(s2_0 context3_0 stop-ids4_0 intdefs1_0)"
"(begin"
" 'local-expand5"
"(let-values(((s_0) s2_0))"
"(let-values(((context_0) context3_0))"
"(let-values(((stop-ids_0) stop-ids4_0))"
"(let-values(((intdefs_0) intdefs1_0))"
"(let-values()"
"(let-values(((temp53_0) 'local-expand)"
"((s54_0) s_0)"
"((context55_0) context_0)"
"((stop-ids56_0) stop-ids_0)"
"((intdefs57_0) intdefs_0))"
"(do-local-expand50.1"
" #f"
" #f"
" #t"
" unsafe-undefined"
" #f"
" #f"
" #f"
" temp53_0"
" s54_0"
" context55_0"
" stop-ids56_0"
" intdefs57_0)))))))))))"
"(case-lambda"
"((s_0 context_0 stop-ids_0)(begin 'local-expand(local-expand5_0 s_0 context_0 stop-ids_0 '())))"
"((s_0 context_0 stop-ids_0 intdefs1_0)(local-expand5_0 s_0 context_0 stop-ids_0 intdefs1_0)))))"
"(define-values"
"(1/local-expand/capture-lifts)"
"(let-values(((local-expand/capture-lifts12_0)"
"(lambda(s9_0 context10_0 stop-ids11_0 intdefs7_0 lift-key8_0)"
"(begin"
" 'local-expand/capture-lifts12"
"(let-values(((s_0) s9_0))"
"(let-values(((context_0) context10_0))"
"(let-values(((stop-ids_0) stop-ids11_0))"
"(let-values(((intdefs_0) intdefs7_0))"
"(let-values(((lift-key_0)"
"(if(eq? lift-key8_0 unsafe-undefined)(generate-lift-key) lift-key8_0)))"
"(let-values()"
"(let-values(((temp58_0) 'local-expand)"
"((s59_0) s_0)"
"((context60_0) context_0)"
"((stop-ids61_0) stop-ids_0)"
"((intdefs62_0) intdefs_0)"
"((temp63_0) #t)"
"((lift-key64_0) lift-key_0))"
"(do-local-expand50.1"
" #f"
" temp63_0"
" #t"
" lift-key64_0"
" #f"
" #f"
" #f"
" temp58_0"
" s59_0"
" context60_0"
" stop-ids61_0"
" intdefs62_0))))))))))))"
"(case-lambda"
"((s_0 context_0 stop-ids_0)"
"(begin"
" 'local-expand/capture-lifts"
"(local-expand/capture-lifts12_0 s_0 context_0 stop-ids_0 '() unsafe-undefined)))"
"((s_0 context_0 stop-ids_0 intdefs_0 lift-key8_0)"
"(local-expand/capture-lifts12_0 s_0 context_0 stop-ids_0 intdefs_0 lift-key8_0))"
"((s_0 context_0 stop-ids_0 intdefs7_0)"
"(local-expand/capture-lifts12_0 s_0 context_0 stop-ids_0 intdefs7_0 unsafe-undefined)))))"
"(define-values"
"(1/local-transformer-expand)"
"(let-values(((local-transformer-expand18_0)"
"(lambda(s15_0 context16_0 stop-ids17_0 intdefs14_0)"
"(begin"
" 'local-transformer-expand18"
"(let-values(((s_0) s15_0))"
"(let-values(((context_0) context16_0))"
"(let-values(((stop-ids_0) stop-ids17_0))"
"(let-values(((intdefs_0) intdefs14_0))"
"(let-values()"
"(let-values(((temp65_0) 'local-expand)"
"((s66_0) s_0)"
"((context67_0) context_0)"
"((stop-ids68_0) stop-ids_0)"
"((intdefs69_0) intdefs_0)"
"((temp70_0) #t))"
"(do-local-expand50.1"
" temp70_0"
" #f"
" #t"
" unsafe-undefined"
" #f"
" #f"
" #f"
" temp65_0"
" s66_0"
" context67_0"
" stop-ids68_0"
" intdefs69_0)))))))))))"
"(case-lambda"
"((s_0 context_0 stop-ids_0)"
"(begin 'local-transformer-expand(local-transformer-expand18_0 s_0 context_0 stop-ids_0 '())))"
"((s_0 context_0 stop-ids_0 intdefs14_0)(local-transformer-expand18_0 s_0 context_0 stop-ids_0 intdefs14_0)))))"
"(define-values"
"(1/local-transformer-expand/capture-lifts)"
"(let-values(((local-transformer-expand/capture-lifts25_0)"
"(lambda(s22_0 context23_0 stop-ids24_0 intdefs20_0 lift-key21_0)"
"(begin"
" 'local-transformer-expand/capture-lifts25"
"(let-values(((s_0) s22_0))"
"(let-values(((context_0) context23_0))"
"(let-values(((stop-ids_0) stop-ids24_0))"
"(let-values(((intdefs_0) intdefs20_0))"
"(let-values(((lift-key_0)"
"(if(eq? lift-key21_0 unsafe-undefined)(generate-lift-key) lift-key21_0)))"
"(let-values()"
"(let-values(((temp71_0) 'local-expand)"
"((s72_0) s_0)"
"((context73_0) context_0)"
"((stop-ids74_0) stop-ids_0)"
"((intdefs75_0) intdefs_0)"
"((temp76_0) #t)"
"((temp77_0) #t)"
"((lift-key78_0) lift-key_0))"
"(do-local-expand50.1"
" temp76_0"
" temp77_0"
" #t"
" lift-key78_0"
" #f"
" #f"
" #f"
" temp71_0"
" s72_0"
" context73_0"
" stop-ids74_0"
" intdefs75_0))))))))))))"
"(case-lambda"
"((s_0 context_0 stop-ids_0)"
"(begin"
" 'local-transformer-expand/capture-lifts"
"(local-transformer-expand/capture-lifts25_0 s_0 context_0 stop-ids_0 '() unsafe-undefined)))"
"((s_0 context_0 stop-ids_0 intdefs_0 lift-key21_0)"
"(local-transformer-expand/capture-lifts25_0 s_0 context_0 stop-ids_0 intdefs_0 lift-key21_0))"
"((s_0 context_0 stop-ids_0 intdefs20_0)"
"(local-transformer-expand/capture-lifts25_0 s_0 context_0 stop-ids_0 intdefs20_0 unsafe-undefined)))))"
"(define-values"
"(1/syntax-local-expand-expression)"
"(let-values(((syntax-local-expand-expression29_0)"
"(lambda(s28_0 opaque-only?27_0)"
"(begin"
" 'syntax-local-expand-expression29"
"(let-values(((s_0) s28_0))"
"(let-values(((opaque-only?_0) opaque-only?27_0))"
"(let-values()"
"(let-values(((exp-s_0)"
"(let-values(((temp79_0) 'syntax-local-expand-expression)"
"((s80_0) s_0)"
"((temp81_0) 'expression)"
"((null82_0) null)"
"((temp83_0) #f)"
"((opaque-only?84_0) opaque-only?_0)"
"((temp85_0) #t)"
"((temp86_0) #t)"
"((temp87_0) #f))"
"(do-local-expand50.1"
" #f"
" #f"
" temp87_0"
" unsafe-undefined"
" temp85_0"
" opaque-only?84_0"
" temp86_0"
" temp79_0"
" s80_0"
" temp81_0"
" null82_0"
" temp83_0))))"
"(let-values(((ctx_0)(let-values()(get-current-expand-context18.1 #f 'unexpected))))"
"(let-values(((ae_0)"
"(flip-introduction-scopes"
"(datum->syntax$1"
" #f"
"(already-expanded1.1"
"(if(parsed? exp-s_0) exp-s_0(flip-introduction-scopes exp-s_0 ctx_0))"
"(expand-context-binding-layer ctx_0)))"
" ctx_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'opaque-expr ae_0)))"
"(void)))"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'exit-local exp-s_0)))"
"(void)))"
"(values(if(not opaque-only?_0) exp-s_0 #f) ae_0))))))))))))"
"(case-lambda"
"((s_0)(begin 'syntax-local-expand-expression(syntax-local-expand-expression29_0 s_0 #f)))"
"((s_0 opaque-only?27_0)(syntax-local-expand-expression29_0 s_0 opaque-only?27_0)))))"
"(define-values"
"(do-local-expand50.1)"
"(lambda(as-transformer?32_0"
" capture-lifts?31_0"
" keep-#%expression?34_0"
" lift-key35_0"
" skip-log-exit?37_0"
" to-parsed-ok?33_0"
" track-to-be-defined?36_0"
" who46_0"
" s-or-s-exp47_0"
" context48_0"
" stop-ids49_0"
" intdefs45_0)"
"(begin"
" 'do-local-expand50"
"(let-values(((who_0) who46_0))"
"(let-values(((s-or-s-exp_0) s-or-s-exp47_0))"
"(let-values(((context_0) context48_0))"
"(let-values(((stop-ids_0) stop-ids49_0))"
"(let-values(((intdefs_0) intdefs45_0))"
"(let-values(((capture-lifts?_0) capture-lifts?31_0))"
"(let-values(((as-transformer?_0) as-transformer?32_0))"
"(let-values(((to-parsed-ok?_0) to-parsed-ok?33_0))"
"(let-values(((keep-#%expression?_0) keep-#%expression?34_0))"
"(let-values(((lift-key_0)"
"(if(eq? lift-key35_0 unsafe-undefined)"
"(if(let-values(((or-part_0) capture-lifts?_0))"
"(if or-part_0 or-part_0 as-transformer?_0))"
"(generate-lift-key)"
" #f)"
" lift-key35_0)))"
"(let-values(((track-to-be-defined?_0) track-to-be-defined?36_0))"
"(let-values(((skip-log-exit?_0) skip-log-exit?37_0))"
"(let-values()"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'expand 'local-expand))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((s_0)(datum->syntax$1 #f s-or-s-exp_0)))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(list? context_0)))"
"(if or-part_0"
" or-part_0"
"(memq"
" context_0"
"(if as-transformer?_0"
" '(expression top-level)"
" '(expression top-level module module-begin)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"(if as-transformer?_0"
"                                                               \"(or/c 'expression 'top-level list?)\""
"                                                               \"(or/c 'expression 'top-level 'module 'module-begin list?)\")"
" context_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not stop-ids_0)))"
"(if or-part_0"
" or-part_0"
"(if(list? stop-ids_0)"
"(andmap2 identifier? stop-ids_0)"
" #f)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
"                                                               \"(or/c (listof identifier?) #f)\""
" stop-ids_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(intdefs-or-false? intdefs_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" who_0"
" intdefs-or-false?-string"
" intdefs_0)))"
"(values))))"
"(let-values(((ctx_0)"
"(let-values(((who88_0) who_0))"
"(get-current-expand-context18.1 #f who88_0))))"
"(let-values(((phase_0)"
"(if as-transformer?_0"
"(add1(expand-context-phase ctx_0))"
"(expand-context-phase ctx_0))))"
"(let-values(((local-ctx_0)"
"(let-values(((ctx89_0) ctx_0)"
"((context90_0) context_0)"
"((phase91_0) phase_0)"
"((intdefs92_0) intdefs_0)"
"((stop-ids93_0) stop-ids_0)"
"((to-parsed-ok?94_0) to-parsed-ok?_0)"
"((temp95_0)"
"(let-values(((or-part_0)"
" keep-#%expression?_0))"
"(if or-part_0"
" or-part_0"
"(if(expand-context-in-local-expand?"
" ctx_0)"
"(expand-context-keep-#%expression?"
" ctx_0)"
" #f))))"
"((track-to-be-defined?96_0)"
" track-to-be-defined?_0))"
"(make-local-expand-context42.1"
" context90_0"
" intdefs92_0"
" temp95_0"
" phase91_0"
" stop-ids93_0"
" to-parsed-ok?94_0"
" track-to-be-defined?96_0"
" ctx89_0))))"
"(let-values((()"
"(begin"
"(namespace-visit-available-modules!"
"(expand-context-namespace ctx_0)"
" phase_0)"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-local"
" s_0)))"
"(void)))"
"(values))))"
"(let-values(((input-s_0)"
"(let-values(((temp97_0)"
"(flip-introduction-scopes"
" s_0"
" ctx_0))"
"((intdefs98_0) intdefs_0))"
"(add-intdef-scopes24.1"
" unsafe-undefined"
" #f"
" temp97_0"
" intdefs98_0))))"
"(let-values((()"
"(begin"
"(if as-transformer?_0"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'phase-up)))"
"(void))))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'local-pre"
" input-s_0)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if stop-ids_0"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'start)))"
"(void))))"
"(void))"
"(values))))"
"(let-values(((output-s_0)"
"(if(if as-transformer?_0"
" capture-lifts?_0"
" #f)"
"(let-values()"
"(let-values(((input-s99_0) input-s_0)"
"((local-ctx100_0)"
" local-ctx_0)"
"((context101_0)"
" context_0)"
"((temp102_0) #f)"
"((temp103_0) #t)"
"((lift-key104_0)"
" lift-key_0)"
"((temp105_0) #t)"
"((temp106_0) #t))"
"(expand-transformer92.1"
" temp105_0"
" temp103_0"
" context101_0"
" temp102_0"
" temp106_0"
" lift-key104_0"
" input-s99_0"
" local-ctx100_0)))"
"(if as-transformer?_0"
"(let-values()"
"(let-values(((input-s107_0)"
" input-s_0)"
"((local-ctx108_0)"
" local-ctx_0)"
"((context109_0)"
" context_0)"
"((temp110_0) #f)"
"((temp111_0)"
"(eq?"
" 'top-level"
" context_0))"
"((lift-key112_0)"
" lift-key_0)"
"((temp113_0) #t))"
"(expand-transformer92.1"
" #f"
" temp111_0"
" context109_0"
" temp110_0"
" temp113_0"
" lift-key112_0"
" input-s107_0"
" local-ctx108_0)))"
"(if capture-lifts?_0"
"(let-values()"
"(let-values(((input-s114_0)"
" input-s_0)"
"((local-ctx115_0)"
" local-ctx_0)"
"((temp116_0) #t)"
"((lift-key117_0)"
" lift-key_0)"
"((temp118_0) #t))"
"(expand/capture-lifts75.1"
" temp118_0"
" temp116_0"
" #f"
" lift-key117_0"
" input-s114_0"
" local-ctx115_0)))"
"(let-values()"
"(let-values(((input-s119_0)"
" input-s_0)"
"((local-ctx120_0)"
" local-ctx_0))"
"(expand9.1"
" #f"
" #f"
" #f"
" input-s119_0"
" local-ctx120_0))))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'local-post"
" output-s_0)))"
"(void)))"
"(values))))"
"(let-values(((result-s_0)"
"(if(parsed? output-s_0)"
" output-s_0"
"(flip-introduction-scopes"
" output-s_0"
" ctx_0))))"
"(begin"
"(if skip-log-exit?_0"
"(void)"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" local-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-local"
" result-s_0)))"
"(void)))))"
" result-s_0))))))))))))))))))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void))))))))))))))))))))"
"(define-values"
"(1/syntax-tainted?)"
"(lambda(s_0)"
"(begin"
" 'syntax-tainted?"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-tainted? \"syntax?\" s_0)))"
"(syntax-tainted?$1 s_0)))))))"
"(define-values"
"(1/syntax-arm)"
"(let-values(((syntax-arm4_0)"
"(lambda(s3_0 maybe-insp1_0 use-mode?2_0)"
"(begin"
" 'syntax-arm4"
"(let-values(((s_0) s3_0))"
"(let-values(((maybe-insp_0) maybe-insp1_0))"
"(let-values(((use-mode?_0) use-mode?2_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                                  (let-values () (raise-argument-error 'syntax-arm \"syntax?\" s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not maybe-insp_0)))"
"(if or-part_0 or-part_0(inspector? maybe-insp_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'syntax-arm"
"                                                       \"(or/c inspector? #f)\""
" maybe-insp_0)))"
"(values))))"
"(let-values(((insp_0)(inspector-for-taint maybe-insp_0)))"
"(if use-mode?_0"
"(let-values()"
"(taint-dispatch"
" s_0"
"(lambda(s_1)(syntax-arm$1 s_1 insp_0))"
"(1/syntax-local-phase-level)))"
"(let-values()(syntax-arm$1 s_0 insp_0))))))))))))))))"
"(case-lambda"
"((s_0)(begin 'syntax-arm(syntax-arm4_0 s_0 #f #f)))"
"((s_0 maybe-insp_0 use-mode?2_0)(syntax-arm4_0 s_0 maybe-insp_0 use-mode?2_0))"
"((s_0 maybe-insp1_0)(syntax-arm4_0 s_0 maybe-insp1_0 #f)))))"
"(define-values"
"(1/syntax-disarm)"
"(lambda(s_0 maybe-insp_0)"
"(begin"
" 'syntax-disarm"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                            (let-values () (raise-argument-error 'syntax-disarm \"syntax?\" s_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not maybe-insp_0)))"
"(if or-part_0 or-part_0(inspector? maybe-insp_0)))"
"(void)"
"                              (let-values () (raise-argument-error 'syntax-disarm \"(or/c inspector? #f)\" maybe-insp_0)))"
"(values))))"
"(let-values(((insp_0)(inspector-for-taint maybe-insp_0)))(syntax-disarm$1 s_0 insp_0)))))))))"
"(define-values"
"(1/syntax-rearm)"
"(let-values(((syntax-rearm9_0)"
"(lambda(s7_0 from-s8_0 use-mode?6_0)"
"(begin"
" 'syntax-rearm9"
"(let-values(((s_0) s7_0))"
"(let-values(((from-s_0) from-s8_0))"
"(let-values(((use-mode?_0) use-mode?6_0))"
"(let-values()"
"(let-values()"
"(let-values()"
"(begin"
"(if(syntax?$1 s_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'syntax-rearm \"syntax?\" s_0)))"
"(if(syntax?$1 from-s_0)"
"(void)"
"                                    (let-values () (raise-argument-error 'syntax-rearm \"syntax?\" from-s_0)))"
"(if use-mode?_0"
"(let-values()"
"(taint-dispatch"
" s_0"
"(lambda(s_1)(syntax-rearm$1 s_1 from-s_0))"
"(1/syntax-local-phase-level)))"
"(let-values()(syntax-rearm$1 s_0 from-s_0))))))))))))))"
"(case-lambda"
"((s_0 from-s_0)(begin 'syntax-rearm(syntax-rearm9_0 s_0 from-s_0 #f)))"
"((s_0 from-s_0 use-mode?6_0)(syntax-rearm9_0 s_0 from-s_0 use-mode?6_0)))))"
"(define-values"
"(1/syntax-taint)"
"(lambda(s_0)"
"(begin"
" 'syntax-taint"
"(let-values()"
"(let-values()"
"(begin"
"            (if (syntax?$1 s_0) (void) (let-values () (raise-argument-error 'syntax-taint \"syntax?\" s_0)))"
"(syntax-taint$1 s_0)))))))"
"(define-values"
"(inspector-for-taint)"
"(lambda(maybe-insp_0)"
"(begin"
"(let-values(((or-part_0) maybe-insp_0))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(current-module-code-inspector)))"
"(if or-part_1 or-part_1(current-code-inspector))))))))"
"(define-values"
"(1/variable-reference->empty-namespace)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->empty-namespace"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"              (let-values () (raise-argument-error 'variable-reference->empty-namespace \"variable-reference?\" vr_0)))"
"(let-values(((temp2_0)(1/variable-reference->namespace vr_0)))"
"(new-namespace8.1 #t unsafe-undefined temp2_0))))))))"
"(define-values"
"(1/variable-reference->namespace)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->namespace"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'variable-reference->namespace \"variable-reference?\" vr_0)))"
"(values))))"
"(let-values(((ns_0)(variable-reference->namespace* vr_0)))"
"(let-values(((mpi_0)(namespace-mpi ns_0)))"
"(begin"
"(if(non-self-module-path-index? mpi_0)"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
" ns_0)"
"(let-values()"
"(let-values(((ns4_0) ns_0)((mpi5_0) mpi_0)((temp6_0)(namespace-0-phase ns_0)))"
"(namespace-module-make-available!112.1 unsafe-undefined ns4_0 mpi5_0 temp6_0)))))"
"(void))"
" ns_0)))))))))"
"(define-values"
"(variable-reference->namespace*)"
"(lambda(vr_0)"
"(begin"
"(let-values(((inst_0)(1/variable-reference->instance vr_0)))"
"(if(symbol? inst_0)"
"(let-values()"
"(1/module->namespace(list 'quote inst_0)(1/instance-data(1/variable-reference->instance vr_0 #t))))"
"(if(not inst_0)"
"(let-values()(1/instance-data(1/variable-reference->instance vr_0 #t)))"
"(let-values()(1/instance-data inst_0))))))))"
"(define-values"
"(1/variable-reference->module-path-index)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->module-path-index"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'variable-reference->module-path-index \"variable-reference?\" vr_0)))"
"(values))))"
"(let-values(((mpi_0)(namespace-mpi(variable-reference->namespace* vr_0))))"
"(if(top-level-module-path-index? mpi_0) #f mpi_0))))))))"
"(define-values"
"(1/variable-reference->resolved-module-path)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->resolved-module-path"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'variable-reference->resolved-module-path"
"                               \"variable-reference?\""
" vr_0)))"
"(values))))"
"(let-values(((mpi_0)(1/variable-reference->module-path-index vr_0)))"
"(if mpi_0(1/module-path-index-resolve mpi_0) #f))))))))"
"(define-values"
"(1/variable-reference->module-source)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->module-source"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"(let-values()"
"                              (raise-argument-error 'variable-reference->module-source \"variable-reference?\" vr_0)))"
"(values))))"
"(let-values(((ns_0)(variable-reference->namespace* vr_0)))(namespace-source-name ns_0))))))))"
"(define-values"
"(1/variable-reference->phase)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->phase"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"              (let-values () (raise-argument-error 'variable-reference->phase \"variable-reference?\" vr_0)))"
"(namespace-phase(variable-reference->namespace* vr_0))))))))"
"(define-values"
"(1/variable-reference->module-base-phase)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->module-base-phase"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"              (let-values () (raise-argument-error 'variable-reference->module-base-phase \"variable-reference?\" vr_0)))"
"(namespace-0-phase(variable-reference->namespace* vr_0))))))))"
"(define-values"
"(1/variable-reference->module-declaration-inspector)"
"(lambda(vr_0)"
"(begin"
" 'variable-reference->module-declaration-inspector"
"(let-values()"
"(let-values()"
"(begin"
"(if(1/variable-reference? vr_0)"
"(void)"
"(let-values()"
"                (raise-argument-error 'variable-reference->module-declaration-inspector \"variable-reference?\" vr_0)))"
"(if(1/variable-reference->instance vr_0)"
"(let-values()"
"(raise-arguments-error"
" 'variable-reference->module-declaration-inspector"
"                 \"variable reference does not refer to an anonymous module variable\""
"                 \"variable reference\""
" vr_0))"
"(void))"
"(let-values(((or-part_0)(namespace-declaration-inspector(variable-reference->namespace* vr_0))))"
"(if or-part_0"
" or-part_0"
"(raise-arguments-error"
" 'variable-reference->module-declaration-inspector"
"                 \"given variable reference is not from a module\")))))))))"
"(define-values"
"(primitive-ids)"
"(seteq"
" 'syntax?"
" 'syntax-e"
" 'syntax->datum"
" 'datum->syntax"
" 'bound-identifier=?"
" 'free-identifier=?"
" 'free-transformer-identifier=?"
" 'free-template-identifier=?"
" 'free-label-identifier=?"
" 'identifier-binding"
" 'identifier-transformer-binding"
" 'identifier-template-binding"
" 'identifier-label-binding"
" 'identifier-binding-symbol"
" 'identifier-prune-lexical-context"
" 'syntax-debug-info"
" 'syntax-track-origin"
" 'syntax-shift-phase-level"
" 'syntax-source-module"
" 'identifier-prune-to-source-module"
" 'syntax-source"
" 'syntax-line"
" 'syntax-column"
" 'syntax-position"
" 'syntax-span"
" 'syntax->list"
" 'syntax-property"
" 'syntax-property-remove"
" 'syntax-property-preserved?"
" 'syntax-property-symbol-keys"
" 'syntax-original?"
" 'syntax-tainted?"
" 'syntax-arm"
" 'syntax-disarm"
" 'syntax-rearm"
" 'syntax-taint"
" 'syntax-binding-set"
" 'syntax-binding-set?"
" 'syntax-binding-set-extend"
" 'syntax-binding-set->syntax"
" 'raise-syntax-error"
" 'struct:exn:fail:syntax"
" 'exn:fail:syntax"
" 'make-exn:fail:syntax"
" 'exn:fail:syntax?"
" 'exn:fail:syntax-exprs"
" 'struct:exn:fail:syntax:unbound"
" 'exn:fail:syntax:unbound"
" 'make-exn:fail:syntax:unbound"
" 'exn:fail:syntax:unbound?"
" 'current-module-path-for-load"
" 'prop:exn:missing-module"
" 'exn:missing-module?"
" 'exn:missing-module-accessor"
" 'struct:exn:fail:filesystem:missing-module"
" 'exn:fail:filesystem:missing-module"
" 'make-exn:fail:filesystem:missing-module"
" 'exn:fail:filesystem:missing-module?"
" 'exn:fail:filesystem:missing-module-path"
" 'struct:exn:fail:syntax:missing-module"
" 'exn:fail:syntax:missing-module"
" 'make-exn:fail:syntax:missing-module"
" 'exn:fail:syntax:missing-module?"
" 'exn:fail:syntax:missing-module-path"
" 'syntax-transforming?"
" 'syntax-transforming-with-lifts?"
" 'syntax-transforming-module-expression?"
" 'syntax-local-transforming-module-provides?"
" 'syntax-local-context"
" 'syntax-local-introduce"
" 'syntax-local-identifier-as-binding"
" 'syntax-local-phase-level"
" 'syntax-local-name"
" 'make-syntax-introducer"
" 'make-interned-syntax-introducer"
" 'make-syntax-delta-introducer"
" 'syntax-local-make-delta-introducer"
" 'syntax-local-value"
" 'syntax-local-value/immediate"
" 'syntax-local-lift-expression"
" 'syntax-local-lift-values-expression"
" 'syntax-local-lift-context"
" 'syntax-local-lift-module"
" 'syntax-local-lift-require"
" 'syntax-local-lift-provide"
" 'syntax-local-lift-module-end-declaration"
" 'syntax-local-module-defined-identifiers"
" 'syntax-local-module-required-identifiers"
" 'syntax-local-module-exports"
" 'syntax-local-submodules"
" 'syntax-local-get-shadower"
" 'local-expand"
" 'local-expand/capture-lifts"
" 'local-transformer-expand"
" 'local-transformer-expand/capture-lifts"
" 'syntax-local-expand-expression"
" 'internal-definition-context?"
" 'syntax-local-make-definition-context"
" 'syntax-local-bind-syntaxes"
" 'internal-definition-context-binding-identifiers"
" 'internal-definition-context-introduce"
" 'internal-definition-context-seal"
" 'identifier-remove-from-definition-context"
" 'make-set!-transformer"
" 'prop:set!-transformer"
" 'set!-transformer?"
" 'set!-transformer-procedure"
" 'rename-transformer?"
" 'prop:rename-transformer"
" 'make-rename-transformer"
" 'rename-transformer-target"
" 'prop:liberal-define-context"
" 'liberal-define-context?"
" 'prop:expansion-contexts"
" 'module-path?"
" 'resolved-module-path?"
" 'make-resolved-module-path"
" 'resolved-module-path-name"
" 'module-path-index?"
" 'module-path-index-resolve"
" 'module-path-index-join"
" 'module-path-index-split"
" 'module-path-index-submodule"
" 'current-module-name-resolver"
" 'current-module-declare-name"
" 'current-module-declare-source"
" 'current-namespace"
" 'namespace-module-registry"
" 'namespace?"
" 'variable-reference->empty-namespace"
" 'variable-reference->namespace"
" 'variable-reference->resolved-module-path"
" 'variable-reference->module-path-index"
" 'variable-reference->module-source"
" 'variable-reference->phase"
" 'variable-reference->module-base-phase"
" 'variable-reference->module-declaration-inspector"
" 'read-syntax"
" 'read-syntax/recursive))"
"(void"
"(begin"
"(add-core-primitive! 'syntax? syntax?$1)"
"(add-core-primitive! 'syntax-e 1/syntax-e)"
"(add-core-primitive! 'syntax->datum 1/syntax->datum)"
"(add-core-primitive! 'datum->syntax 1/datum->syntax)"
"(add-core-primitive! 'bound-identifier=? 1/bound-identifier=?)"
"(add-core-primitive! 'free-identifier=? 1/free-identifier=?)"
"(add-core-primitive! 'free-transformer-identifier=? 1/free-transformer-identifier=?)"
"(add-core-primitive! 'free-template-identifier=? 1/free-template-identifier=?)"
"(add-core-primitive! 'free-label-identifier=? 1/free-label-identifier=?)"
"(add-core-primitive! 'identifier-binding 1/identifier-binding)"
"(add-core-primitive! 'identifier-transformer-binding 1/identifier-transformer-binding)"
"(add-core-primitive! 'identifier-template-binding 1/identifier-template-binding)"
"(add-core-primitive! 'identifier-label-binding 1/identifier-label-binding)"
"(add-core-primitive! 'identifier-binding-symbol 1/identifier-binding-symbol)"
"(add-core-primitive! 'identifier-prune-lexical-context 1/identifier-prune-lexical-context)"
"(add-core-primitive! 'syntax-debug-info 1/syntax-debug-info)"
"(add-core-primitive! 'syntax-track-origin 1/syntax-track-origin)"
"(add-core-primitive! 'syntax-shift-phase-level 1/syntax-shift-phase-level)"
"(add-core-primitive! 'syntax-source-module 1/syntax-source-module)"
"(add-core-primitive! 'identifier-prune-to-source-module 1/identifier-prune-to-source-module)"
"(add-core-primitive! 'syntax-source 1/syntax-source)"
"(add-core-primitive! 'syntax-line 1/syntax-line)"
"(add-core-primitive! 'syntax-column 1/syntax-column)"
"(add-core-primitive! 'syntax-position 1/syntax-position)"
"(add-core-primitive! 'syntax-span 1/syntax-span)"
"(add-core-primitive! 'syntax->list 1/syntax->list)"
"(add-core-primitive! 'syntax-property syntax-property$1)"
"(add-core-primitive! 'syntax-property-remove 1/syntax-property-remove)"
"(add-core-primitive! 'syntax-property-preserved? 1/syntax-property-preserved?)"
"(add-core-primitive! 'syntax-property-symbol-keys 1/syntax-property-symbol-keys)"
"(add-core-primitive! 'syntax-original? 1/syntax-original?)"
"(add-core-primitive! 'syntax-tainted? 1/syntax-tainted?)"
"(add-core-primitive! 'syntax-arm 1/syntax-arm)"
"(add-core-primitive! 'syntax-disarm 1/syntax-disarm)"
"(add-core-primitive! 'syntax-rearm 1/syntax-rearm)"
"(add-core-primitive! 'syntax-taint 1/syntax-taint)"
"(add-core-primitive! 'syntax-binding-set 1/syntax-binding-set)"
"(add-core-primitive! 'syntax-binding-set? 1/syntax-binding-set?)"
"(add-core-primitive! 'syntax-binding-set-extend 1/syntax-binding-set-extend)"
"(add-core-primitive! 'syntax-binding-set->syntax 1/syntax-binding-set->syntax)"
"(add-core-primitive! 'raise-syntax-error raise-syntax-error$1)"
"(add-core-primitive! 'struct:exn:fail:syntax 1/struct:exn:fail:syntax)"
"(add-core-primitive! 'exn:fail:syntax make-exn:fail:syntax$1)"
"(add-core-primitive! 'make-exn:fail:syntax make-exn:fail:syntax$1)"
"(add-core-primitive! 'exn:fail:syntax? 1/exn:fail:syntax?)"
"(add-core-primitive! 'exn:fail:syntax-exprs 1/exn:fail:syntax-exprs)"
"(add-core-primitive! 'struct:exn:fail:syntax:unbound 1/struct:exn:fail:syntax:unbound)"
"(add-core-primitive! 'exn:fail:syntax:unbound make-exn:fail:syntax:unbound$1)"
"(add-core-primitive! 'make-exn:fail:syntax:unbound make-exn:fail:syntax:unbound$1)"
"(add-core-primitive! 'exn:fail:syntax:unbound? 1/exn:fail:syntax:unbound?)"
"(add-core-primitive! 'current-module-path-for-load 1/current-module-path-for-load)"
"(add-core-primitive! 'prop:exn:missing-module 1/prop:exn:missing-module)"
"(add-core-primitive! 'exn:missing-module? 1/exn:missing-module?)"
"(add-core-primitive! 'exn:missing-module-accessor 1/exn:missing-module-accessor)"
"(add-core-primitive! 'struct:exn:fail:filesystem:missing-module 1/struct:exn:fail:filesystem:missing-module)"
"(add-core-primitive! 'exn:fail:filesystem:missing-module 1/make-exn:fail:filesystem:missing-module)"
"(add-core-primitive! 'make-exn:fail:filesystem:missing-module 1/make-exn:fail:filesystem:missing-module)"
"(add-core-primitive! 'exn:fail:filesystem:missing-module? 1/exn:fail:filesystem:missing-module?)"
"(add-core-primitive! 'exn:fail:filesystem:missing-module-path 1/exn:fail:filesystem:missing-module-path)"
"(add-core-primitive! 'struct:exn:fail:syntax:missing-module 1/struct:exn:fail:syntax:missing-module)"
"(add-core-primitive! 'exn:fail:syntax:missing-module 1/make-exn:fail:syntax:missing-module)"
"(add-core-primitive! 'make-exn:fail:syntax:missing-module 1/make-exn:fail:syntax:missing-module)"
"(add-core-primitive! 'exn:fail:syntax:missing-module? 1/exn:fail:syntax:missing-module?)"
"(add-core-primitive! 'exn:fail:syntax:missing-module-path 1/exn:fail:syntax:missing-module-path)"
"(add-core-primitive! 'syntax-transforming? 1/syntax-transforming?)"
"(add-core-primitive! 'syntax-transforming-with-lifts? 1/syntax-transforming-with-lifts?)"
"(add-core-primitive! 'syntax-transforming-module-expression? 1/syntax-transforming-module-expression?)"
"(add-core-primitive! 'syntax-local-transforming-module-provides? 1/syntax-local-transforming-module-provides?)"
"(add-core-primitive! 'syntax-local-context 1/syntax-local-context)"
"(add-core-primitive! 'syntax-local-introduce 1/syntax-local-introduce)"
"(add-core-primitive! 'syntax-local-identifier-as-binding 1/syntax-local-identifier-as-binding)"
"(add-core-primitive! 'syntax-local-phase-level 1/syntax-local-phase-level)"
"(add-core-primitive! 'syntax-local-name 1/syntax-local-name)"
"(add-core-primitive! 'make-syntax-introducer 1/make-syntax-introducer)"
"(add-core-primitive! 'make-interned-syntax-introducer 1/make-interned-syntax-introducer)"
"(add-core-primitive! 'make-syntax-delta-introducer 1/make-syntax-delta-introducer)"
"(add-core-primitive! 'syntax-local-make-delta-introducer 1/syntax-local-make-delta-introducer)"
"(add-core-primitive! 'syntax-local-value 1/syntax-local-value)"
"(add-core-primitive! 'syntax-local-value/immediate 1/syntax-local-value/immediate)"
"(add-core-primitive! 'syntax-local-lift-expression 1/syntax-local-lift-expression)"
"(add-core-primitive! 'syntax-local-lift-values-expression 1/syntax-local-lift-values-expression)"
"(add-core-primitive! 'syntax-local-lift-context 1/syntax-local-lift-context)"
"(add-core-primitive! 'syntax-local-lift-module 1/syntax-local-lift-module)"
"(add-core-primitive! 'syntax-local-lift-require 1/syntax-local-lift-require)"
"(add-core-primitive! 'syntax-local-lift-provide 1/syntax-local-lift-provide)"
"(add-core-primitive! 'syntax-local-lift-module-end-declaration 1/syntax-local-lift-module-end-declaration)"
"(add-core-primitive! 'syntax-local-module-defined-identifiers 1/syntax-local-module-defined-identifiers)"
"(add-core-primitive! 'syntax-local-module-required-identifiers 1/syntax-local-module-required-identifiers)"
"(add-core-primitive! 'syntax-local-module-exports 1/syntax-local-module-exports)"
"(add-core-primitive! 'syntax-local-submodules 1/syntax-local-submodules)"
"(add-core-primitive! 'syntax-local-get-shadower 1/syntax-local-get-shadower)"
"(add-core-primitive! 'local-expand 1/local-expand)"
"(add-core-primitive! 'local-expand/capture-lifts 1/local-expand/capture-lifts)"
"(add-core-primitive! 'local-transformer-expand 1/local-transformer-expand)"
"(add-core-primitive! 'local-transformer-expand/capture-lifts 1/local-transformer-expand/capture-lifts)"
"(add-core-primitive! 'syntax-local-expand-expression 1/syntax-local-expand-expression)"
"(add-core-primitive! 'internal-definition-context? 1/internal-definition-context?)"
"(add-core-primitive! 'syntax-local-make-definition-context 1/syntax-local-make-definition-context)"
"(add-core-primitive! 'syntax-local-bind-syntaxes 1/syntax-local-bind-syntaxes)"
"(add-core-primitive!"
" 'internal-definition-context-binding-identifiers"
" 1/internal-definition-context-binding-identifiers)"
"(add-core-primitive! 'internal-definition-context-introduce 1/internal-definition-context-introduce)"
"(add-core-primitive! 'internal-definition-context-seal 1/internal-definition-context-seal)"
"(add-core-primitive! 'identifier-remove-from-definition-context 1/identifier-remove-from-definition-context)"
"(add-core-primitive! 'make-set!-transformer 1/make-set!-transformer)"
"(add-core-primitive! 'prop:set!-transformer 1/prop:set!-transformer)"
"(add-core-primitive! 'set!-transformer? 1/set!-transformer?)"
"(add-core-primitive! 'set!-transformer-procedure 1/set!-transformer-procedure)"
"(add-core-primitive! 'rename-transformer? 1/rename-transformer?)"
"(add-core-primitive! 'prop:rename-transformer 1/prop:rename-transformer)"
"(add-core-primitive! 'make-rename-transformer 1/make-rename-transformer)"
"(add-core-primitive! 'rename-transformer-target 1/rename-transformer-target)"
"(add-core-primitive! 'prop:liberal-define-context 1/prop:liberal-define-context)"
"(add-core-primitive! 'liberal-define-context? has-liberal-define-context-property?)"
"(add-core-primitive! 'prop:expansion-contexts 1/prop:expansion-contexts)"
"(add-core-primitive! 'module-path? 1/module-path?)"
"(add-core-primitive! 'resolved-module-path? 1/resolved-module-path?)"
"(add-core-primitive! 'make-resolved-module-path 1/make-resolved-module-path)"
"(add-core-primitive! 'resolved-module-path-name 1/resolved-module-path-name)"
"(add-core-primitive! 'module-path-index? 1/module-path-index?)"
"(add-core-primitive! 'module-path-index-resolve 1/module-path-index-resolve)"
"(add-core-primitive! 'module-path-index-join 1/module-path-index-join)"
"(add-core-primitive! 'module-path-index-split 1/module-path-index-split)"
"(add-core-primitive! 'module-path-index-submodule 1/module-path-index-submodule)"
"(add-core-primitive! 'current-module-name-resolver 1/current-module-name-resolver)"
"(add-core-primitive! 'current-module-declare-name 1/current-module-declare-name)"
"(add-core-primitive! 'current-module-declare-source 1/current-module-declare-source)"
"(add-core-primitive! 'current-namespace 1/current-namespace)"
"(add-core-primitive! 'namespace-module-registry namespace-module-registry$1)"
"(add-core-primitive! 'namespace? 1/namespace?)"
"(add-core-primitive! 'variable-reference->empty-namespace 1/variable-reference->empty-namespace)"
"(add-core-primitive! 'variable-reference->namespace 1/variable-reference->namespace)"
"(add-core-primitive! 'variable-reference->resolved-module-path 1/variable-reference->resolved-module-path)"
"(add-core-primitive! 'variable-reference->module-path-index 1/variable-reference->module-path-index)"
"(add-core-primitive! 'variable-reference->module-source 1/variable-reference->module-source)"
"(add-core-primitive! 'variable-reference->phase 1/variable-reference->phase)"
"(add-core-primitive! 'variable-reference->module-base-phase 1/variable-reference->module-base-phase)"
"(add-core-primitive!"
" 'variable-reference->module-declaration-inspector"
" 1/variable-reference->module-declaration-inspector)"
"(add-core-primitive! 'read-syntax 1/read-syntax)"
"(add-core-primitive! 'read-syntax/recursive 1/read-syntax/recursive)))"
"(define-values"
"(declare-kernel-module!6.1)"
"(lambda(main-ids1_0 read-ids2_0 ns5_0)"
"(begin"
" 'declare-kernel-module!6"
"(let-values(((ns_0) ns5_0))"
"(let-values(((main-ids_0) main-ids1_0))"
"(let-values(((read-ids_0) read-ids2_0))"
"(let-values()"
"(begin"
"(let-values(((temp51_0) '#%kernel)"
"((temp52_0) '#%runtime)"
"((temp53_0)(set-union primitive-ids(set-union main-ids_0 read-ids_0)))"
"((temp54_0)"
"(hasheq"
" 'variable-reference?"
" 1/variable-reference?"
" 'variable-reference-constant?"
" 1/variable-reference-constant?"
" 'variable-reference-from-unsafe?"
" 1/variable-reference-from-unsafe?))"
"((ns55_0) ns_0))"
"(copy-runtime-module!24.1 unsafe-undefined temp54_0 ns55_0 #t #f temp53_0 temp52_0 temp51_0))"
"(let-values(((temp56_0) '#%kernel)((temp57_0) '(#%core #%runtime #%main #%read))((ns58_0) ns_0))"
"(declare-reexporting-module!48.1 ns58_0 #t temp56_0 temp57_0))))))))))"
"(define-values"
"(copy-runtime-module!24.1)"
"(lambda(alts12_0 extras13_0 namespace10_0 primitive?14_0 protected?15_0 skip11_0 to9_0 name23_0)"
"(begin"
" 'copy-runtime-module!24"
"(let-values(((name_0) name23_0))"
"(let-values(((to-name_0)(if(eq? to9_0 unsafe-undefined) name_0 to9_0)))"
"(let-values(((ns_0) namespace10_0))"
"(let-values(((skip-syms_0)(if(eq? skip11_0 unsafe-undefined)(seteq) skip11_0)))"
"(let-values(((alts_0)(if(eq? alts12_0 unsafe-undefined) '#hasheq() alts12_0)))"
"(let-values(((extras_0)(if(eq? extras13_0 unsafe-undefined) '#hasheq() extras13_0)))"
"(let-values(((primitive?_0) primitive?14_0))"
"(let-values(((protected?_0) protected?15_0))"
"(let-values()"
"(let-values(((prims_0)(1/primitive-table name_0)))"
"(let-values((()"
"(begin"
"(let-values(((ht_0) prims_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0)"
"(hash-iterate-key ht_0 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(register-built-in-symbol!"
" sym_0))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0(hash-iterate-next ht_0 i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(values))))"
"(let-values()"
"(let-values(((ht_0)"
"(let-values(((ht_0) prims_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 val_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(if(set-member?"
" skip-syms_0"
" sym_0)"
" table_1"
"(let-values(((table_2)"
" table_1))"
"(let-values(((table_3)"
"(let-values()"
"(let-values(((key_0"
" val_1)"
"(let-values()"
"(values"
" sym_0"
"(let-values(((or-part_0)"
"(hash-ref"
" alts_0"
" sym_0"
" #f)))"
"(if or-part_0"
" or-part_0"
" val_0))))))"
"(hash-set"
" table_2"
" key_0"
" val_1)))))"
"(values table_3)))))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hasheq()"
"(hash-iterate-first ht_0))))))"
"(let-values(((ht+extras_0)"
"(let-values(((ht_1) extras_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(ht_2 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((k_0 v_0)"
"(hash-iterate-key+value"
" ht_1"
" i_0)))"
"(let-values(((ht_3)"
"(let-values(((ht_3) ht_2))"
"(let-values(((ht_4)"
"(let-values()"
"(hash-set"
" ht_3"
" k_0"
" v_0))))"
"(values ht_4)))))"
"(if(not #f)"
"(for-loop_0"
" ht_3"
"(hash-iterate-next ht_1 i_0))"
" ht_3)))"
" ht_2)))))"
" for-loop_0)"
" ht_0"
"(hash-iterate-first ht_1))))))"
"(let-values(((to-name59_0) to-name_0)"
"((ht+extras60_0) ht+extras_0)"
"((ns61_0) ns_0)"
"((primitive?62_0) primitive?_0)"
"((protected?63_0) protected?_0))"
"(declare-hash-based-module!39.1"
" ns61_0"
" primitive?62_0"
" null"
" protected?63_0"
" #f"
" to-name59_0"
" ht+extras60_0)))))))))))))))))))"
"(define-values"
"(declare-hash-based-module!39.1)"
"(lambda(namespace27_0 primitive?28_0 protected30_0 protected?29_0 register-builtin?31_0 name37_0 ht38_0)"
"(begin"
" 'declare-hash-based-module!39"
"(let-values(((name_0) name37_0))"
"(let-values(((ht_0) ht38_0))"
"(let-values(((ns_0) namespace27_0))"
"(let-values(((primitive?_0) primitive?28_0))"
"(let-values(((protected?_0) protected?29_0))"
"(let-values(((protected-syms_0) protected30_0))"
"(let-values(((register-builtin?_0) register-builtin?31_0))"
"(let-values()"
"(let-values(((mpi_0)(1/module-path-index-join(list 'quote name_0) #f)))"
"(let-values(((ns64_0) ns_0)"
"((temp65_0)"
"(let-values(((temp67_0) #t)"
"((primitive?68_0) primitive?_0)"
"((temp69_0) #t)"
"((temp70_0)(not protected?_0))"
"((mpi71_0) mpi_0)"
"((temp72_0)"
"(hasheqv"
" 0"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0)"
"(hash-iterate-key"
" ht_1"
" i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1)"
" table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(let-values((()"
"(begin"
"(if register-builtin?_0"
"(let-values()"
"(register-built-in-symbol!"
" sym_0))"
"(void))"
"(values))))"
"(let-values(((binding_0)"
"(let-values(((mpi74_0)"
" mpi_0)"
"((temp75_0)"
" 0)"
"((sym76_0)"
" sym_0))"
"(make-module-binding20.1"
" #f"
" null"
" #f"
" #f"
" unsafe-undefined"
" unsafe-undefined"
" 0"
" unsafe-undefined"
" mpi74_0"
" temp75_0"
" sym76_0))))"
"(values"
" sym_0"
"(if(let-values(((or-part_0)"
" protected?_0))"
"(if or-part_0"
" or-part_0"
"(member"
" sym_0"
" protected-syms_0)))"
"(provided1.1"
" binding_0"
" #t"
" #f)"
" binding_0)))))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values"
" table_2)))))"
"(if(not #f)"
"(for-loop_0"
" table_1"
"(hash-iterate-next ht_1 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first ht_1))))))"
"((temp73_0)"
"(lambda(data-box_0"
" ns_1"
" phase-shift_0"
" phase-level_0"
" self_0"
" bulk-binding-registry_0"
" insp_0)"
"(if(= 0 phase-level_0)"
"(let-values()"
"(begin"
"(let-values(((ht_1) ht_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash ht_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0 val_0)"
"(hash-iterate-key+value"
" ht_1"
" i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(namespace-set-variable!"
" ns_1"
" 0"
" sym_0"
" val_0"
" #t))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0"
"(hash-iterate-next"
" ht_1"
" i_0))"
"(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_1))))"
"(void)))"
"(void)))))"
"(make-module39.1"
" temp67_0"
" unsafe-undefined"
" unsafe-undefined"
" temp73_0"
" #f"
" 0"
" 0"
" temp70_0"
" unsafe-undefined"
" temp69_0"
" unsafe-undefined"
" primitive?68_0"
" temp72_0"
" null"
" mpi71_0"
" #f"
" null"
" #f)))"
"((temp66_0)(1/module-path-index-resolve mpi_0)))"
"(declare-module!58.1 #t ns64_0 temp65_0 temp66_0))))))))))))))"
"(define-values"
"(declare-reexporting-module!48.1)"
"(lambda(namespace43_0 reexport?42_0 name46_0 require-names47_0)"
"(begin"
" 'declare-reexporting-module!48"
"(let-values(((name_0) name46_0))"
"(let-values(((require-names_0) require-names47_0))"
"(let-values(((reexport?_0) reexport?42_0))"
"(let-values(((ns_0) namespace43_0))"
"(let-values()"
"(let-values(((mpi_0)(1/module-path-index-join(list 'quote name_0) #f)))"
"(let-values(((require-mpis_0)"
"(reverse$1"
"(let-values(((lst_0) require-names_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((require-name_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(1/module-path-index-join"
"(list"
" 'quote"
" require-name_0)"
" #f))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values(((ns77_0) ns_0)"
"((temp78_0)"
"(let-values(((temp80_0) #t)"
"((temp81_0) #t)"
"((mpi82_0) mpi_0)"
"((temp83_0)(list(cons 0 require-mpis_0)))"
"((temp84_0)"
"(if reexport?_0"
"(hasheqv"
" 0"
"(let-values(((lst_0) require-mpis_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((require-mpi_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((table_1)"
"(let-values(((m_0)"
"(namespace->module"
" ns_0"
"(1/module-path-index-resolve"
" require-mpi_0))))"
"(begin"
" #t"
"((letrec-values(((for-loop_1)"
"(lambda(table_1)"
"(begin"
" 'for-loop"
"(let-values()"
"(let-values(((table_2)"
"(let-values(((ht_0)"
"(hash-ref"
"(shift-provides-module-path-index"
"(module-provides"
" m_0)"
"(module-self"
" m_0)"
" require-mpi_0)"
" 0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-in-hash"
" ht_0)))"
"((letrec-values(((for-loop_2)"
"(lambda(table_2"
" i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((sym_0"
" binding_0)"
"(hash-iterate-key+value"
" ht_0"
" i_0)))"
"(let-values(((table_3)"
"(let-values(((table_3)"
" table_2))"
"(let-values(((table_4)"
"(let-values()"
"(let-values(((key_0"
" val_0)"
"(let-values()"
"(values"
" sym_0"
" binding_0))))"
"(hash-set"
" table_3"
" key_0"
" val_0)))))"
"(values"
" table_4)))))"
"(if(not"
" #f)"
"(for-loop_2"
" table_3"
"(hash-iterate-next"
" ht_0"
" i_0))"
" table_3)))"
" table_2)))))"
" for-loop_2)"
" table_1"
"(hash-iterate-first"
" ht_0))))))"
" table_2))))))"
" for-loop_1)"
" table_0)))))"
"(if(not #f)"
"(for-loop_0 table_1 rest_0)"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
" lst_0))))"
" '#hasheqv()))"
"((void85_0) void))"
"(make-module39.1"
" temp80_0"
" unsafe-undefined"
" unsafe-undefined"
" void85_0"
" #f"
" 0"
" 0"
" #f"
" unsafe-undefined"
" temp81_0"
" unsafe-undefined"
" #f"
" temp84_0"
" temp83_0"
" mpi82_0"
" #f"
" null"
" #f)))"
"((temp79_0)(1/module-path-index-resolve mpi_0)))"
"(declare-module!58.1 #t ns77_0 temp78_0 temp79_0))))))))))))"
"(define-values"
"(read-primitives)"
"(hasheq"
" 'read"
" 1/read"
" 'read/recursive"
" 1/read/recursive"
" 'read-language"
" 1/read-language"
" 'string->number"
" 1/string->number"
" 'current-reader-guard"
" 1/current-reader-guard"
" 'read-square-bracket-as-paren"
" 1/read-square-bracket-as-paren"
" 'read-curly-brace-as-paren"
" 1/read-curly-brace-as-paren"
" 'read-square-bracket-with-tag"
" 1/read-square-bracket-with-tag"
" 'read-curly-brace-with-tag"
" 1/read-curly-brace-with-tag"
" 'read-cdot"
" 1/read-cdot"
" 'read-accept-graph"
" 1/read-accept-graph"
" 'read-accept-compiled"
" 1/read-accept-compiled"
" 'read-accept-box"
" 1/read-accept-box"
" 'read-decimal-as-inexact"
" 1/read-decimal-as-inexact"
" 'read-accept-dot"
" 1/read-accept-dot"
" 'read-accept-infix-dot"
" 1/read-accept-infix-dot"
" 'read-accept-quasiquote"
" 1/read-accept-quasiquote"
" 'read-accept-reader"
" 1/read-accept-reader"
" 'read-accept-lang"
" 1/read-accept-lang"
" 'current-readtable"
" 1/current-readtable"
" 'readtable?"
" 1/readtable?"
" 'make-readtable"
" 1/make-readtable"
" 'readtable-mapping"
" 1/readtable-mapping"
" 'special-comment?"
" 1/special-comment?"
" 'make-special-comment"
" 1/make-special-comment"
" 'special-comment-value"
" 1/special-comment-value))"
"(define-values"
"(main-primitives)"
"(hasheq"
" 'eval"
" eval$1"
" 'eval-syntax"
" 1/eval-syntax"
" 'compile"
" compile$1"
" 'compile-syntax"
" 1/compile-syntax"
" 'expand"
" 1/expand"
" 'expand-syntax"
" 1/expand-syntax"
" 'expand-once"
" 1/expand-once"
" 'expand-syntax-once"
" 1/expand-syntax-once"
" 'expand-to-top-form"
" 1/expand-to-top-form"
" 'expand-syntax-to-top-form"
" 1/expand-syntax-to-top-form"
" 'dynamic-require"
" 1/dynamic-require"
" 'dynamic-require-for-syntax"
" 1/dynamic-require-for-syntax"
" 'load"
" 1/load"
" 'load-extension"
" 1/load-extension"
" 'load/use-compiled"
" 1/load/use-compiled"
" 'current-eval"
" 1/current-eval"
" 'current-compile"
" 1/current-compile"
" 'current-load"
" 1/current-load"
" 'current-load/use-compiled"
" 1/current-load/use-compiled"
" 'collection-path"
" 1/collection-path"
" 'collection-file-path"
" 1/collection-file-path"
" 'find-library-collection-paths"
" 1/find-library-collection-paths"
" 'find-library-collection-links"
" 1/find-library-collection-links"
" 'current-library-collection-paths"
" 1/current-library-collection-paths"
" 'current-library-collection-links"
" 1/current-library-collection-links"
" 'use-compiled-file-paths"
" 1/use-compiled-file-paths"
" 'current-compiled-file-roots"
" 1/current-compiled-file-roots"
" 'use-compiled-file-check"
" 1/use-compiled-file-check"
" 'use-collection-link-paths"
" 1/use-collection-link-paths"
" 'use-user-specific-search-paths"
" 1/use-user-specific-search-paths"
" 'compiled-expression?"
" 1/compiled-expression?"
" 'compiled-module-expression?"
" 1/compiled-module-expression?"
" 'module-compiled-name"
" 1/module-compiled-name"
" 'module-compiled-submodules"
" 1/module-compiled-submodules"
" 'module-compiled-language-info"
" 1/module-compiled-language-info"
" 'module-compiled-imports"
" 1/module-compiled-imports"
" 'module-compiled-exports"
" 1/module-compiled-exports"
" 'module-compiled-indirect-exports"
" 1/module-compiled-indirect-exports"
" 'compiled-expression-recompile"
" 1/compiled-expression-recompile"
" 'make-empty-namespace"
" 1/make-empty-namespace"
" 'namespace-attach-module"
" 1/namespace-attach-module"
" 'namespace-attach-module-declaration"
" 1/namespace-attach-module-declaration"
" 'namespace-symbol->identifier"
" 1/namespace-symbol->identifier"
" 'namespace-module-identifier"
" 1/namespace-module-identifier"
" 'namespace-syntax-introduce"
" 1/namespace-syntax-introduce"
" 'namespace-require"
" 1/namespace-require"
" 'namespace-require/copy"
" 1/namespace-require/copy"
" 'namespace-require/constant"
" 1/namespace-require/constant"
" 'namespace-require/expansion-time"
" 1/namespace-require/expansion-time"
" 'namespace-variable-value"
" 1/namespace-variable-value"
" 'namespace-set-variable-value!"
" 1/namespace-set-variable-value!"
" 'namespace-undefine-variable!"
" 1/namespace-undefine-variable!"
" 'namespace-mapped-symbols"
" 1/namespace-mapped-symbols"
" 'namespace-base-phase"
" 1/namespace-base-phase"
" 'module-declared?"
" 1/module-declared?"
" 'module-predefined?"
" 1/module-predefined?"
" 'module->language-info"
" 1/module->language-info"
" 'module->imports"
" 1/module->imports"
" 'module->exports"
" 1/module->exports"
" 'module->indirect-exports"
" 1/module->indirect-exports"
" 'module-compiled-cross-phase-persistent?"
" 1/module-compiled-cross-phase-persistent?"
" 'module-provide-protected?"
" 1/module-provide-protected?"
" 'module->namespace"
" 1/module->namespace"
" 'namespace-unprotect-module"
" 1/namespace-unprotect-module))"
"(define-values"
"(utils-primitives)"
"(hasheq"
" 'path-string?"
" path-string?"
" 'normal-case-path"
" normal-case-path"
" 'path-replace-extension"
" path-replace-extension"
" 'path-add-extension"
" path-add-extension"
" 'reroot-path"
" reroot-path"
" 'path-list-string->path-list"
" path-list-string->path-list"
" 'find-executable-path"
" find-executable-path"
" 'call-with-default-reading-parameterization"
" call-with-default-reading-parameterization"
" 'collection-path"
" 1/collection-path"
" 'collection-file-path"
" 1/collection-file-path"
" 'find-library-collection-paths"
" 1/find-library-collection-paths"
" 'find-library-collection-links"
" 1/find-library-collection-links"
" 'load/use-compiled"
" 1/load/use-compiled"
" 'find-main-config"
" find-main-config"
" 'find-main-collects"
" find-main-collects))"
"(define-values(expobs-primitives)(hasheq 'current-expand-observe current-expand-observe))"
"(define-values"
"(struct:TH-place-channel TH-place-channel TH-place-channel? TH-place-channel-ref TH-place-channel-set!)"
"(make-struct-type 'TH-place-channel #f 2 0 #f(list(cons prop:evt(lambda(x_0)(TH-place-channel-ref x_0 0))))))"
"(define-values"
"(TH-place-channel-in TH-place-channel-out)"
"(values(lambda(x_0)(TH-place-channel-ref x_0 0))(lambda(x_0)(TH-place-channel-ref x_0 1))))"
"(define-values"
"(place-struct-primitives)"
"(hasheq"
" 'struct:TH-place-channel"
" struct:TH-place-channel"
" 'TH-place-channel"
" TH-place-channel"
" 'TH-place-channel?"
" TH-place-channel?"
" 'TH-place-channel-in"
" TH-place-channel-in"
" 'TH-place-channel-out"
" TH-place-channel-out))"
"(define-values"
"(linklet-primitives)"
"(hasheq"
" 'primitive-table"
" 1/primitive-table"
" 'primitive->compiled-position"
" 1/primitive->compiled-position"
" 'compiled-position->primitive"
" 1/compiled-position->primitive"
" 'primitive-in-category?"
" 1/primitive-in-category?"
" 'linklet?"
" 1/linklet?"
" 'compile-linklet"
" 1/compile-linklet"
" 'recompile-linklet"
" 1/recompile-linklet"
" 'eval-linklet"
" 1/eval-linklet"
" 'instantiate-linklet"
" 1/instantiate-linklet"
" 'linklet-import-variables"
" 1/linklet-import-variables"
" 'linklet-export-variables"
" 1/linklet-export-variables"
" 'instance?"
" 1/instance?"
" 'make-instance"
" 1/make-instance"
" 'instance-name"
" 1/instance-name"
" 'instance-data"
" 1/instance-data"
" 'instance-variable-names"
" 1/instance-variable-names"
" 'instance-variable-value"
" 1/instance-variable-value"
" 'instance-set-variable-value!"
" 1/instance-set-variable-value!"
" 'instance-unset-variable!"
" 1/instance-unset-variable!"
" 'instance-describe-variable!"
" 1/instance-describe-variable!"
" 'linklet-virtual-machine-bytes"
" 1/linklet-virtual-machine-bytes"
" 'write-linklet-bundle-hash"
" 1/write-linklet-bundle-hash"
" 'read-linklet-bundle-hash"
" 1/read-linklet-bundle-hash"
" 'variable-reference?"
" 1/variable-reference?"
" 'variable-reference->instance"
" 1/variable-reference->instance"
" 'variable-reference-constant?"
" 1/variable-reference-constant?"
" 'variable-reference-from-unsafe?"
" 1/variable-reference-from-unsafe?))"
"(define-values"
"(linklet-expander-primitives)"
"(hasheq"
" 'linklet-directory?"
" linklet-directory?"
" 'linklet-directory->hash"
" linklet-directory->hash"
" 'hash->linklet-directory"
" hash->linklet-directory"
" 'linklet-bundle?"
" linklet-bundle?"
" 'linklet-bundle->hash"
" linklet-bundle->hash"
" 'hash->linklet-bundle"
" hash->linklet-bundle))"
"(define-values"
"(with-module-reading-parameterization)"
"(lambda(thunk_0)"
"(begin"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/read-accept-reader"
" #t"
" 1/read-accept-lang"
" #t"
" 1/read-accept-compiled"
" #t"
" read-case-sensitive"
" #t"
" 1/read-square-bracket-as-paren"
" #t"
" 1/read-curly-brace-as-paren"
" #t"
" 1/read-square-bracket-with-tag"
" #f"
" 1/read-curly-brace-with-tag"
" #f"
" 1/read-accept-box"
" #t"
" read-accept-bar-quote"
" #t"
" 1/read-accept-graph"
" #t"
" 1/read-decimal-as-inexact"
" #t"
" 1/read-cdot"
" #f"
" 1/read-accept-dot"
" #t"
" 1/read-accept-infix-dot"
" #t"
" 1/read-accept-quasiquote"
" #t"
" 1/current-readtable"
" #f)"
"(let-values()(thunk_0))))))"
"(define-values"
"(check-module-form)"
"(lambda(exp_0 filename_0)"
"(begin"
"(if(let-values(((or-part_0)(eof-object? exp_0)))(if or-part_0 or-part_0(eof-object?(1/syntax-e exp_0))))"
"(let-values()"
"(if filename_0"
"(error"
" 'load-handler"
"             (string-append \"expected a `module' declaration, but found end-of-file\\n\" \"  file: ~a\")"
" filename_0)"
" #f))"
"(if(1/compiled-module-expression?(1/syntax-e exp_0))"
"(let-values() exp_0)"
"(if(if(syntax?$1 exp_0)"
"(if(pair?(1/syntax-e exp_0))"
"(if(eq? 'module(1/syntax-e(car(1/syntax-e exp_0))))"
"(let-values(((r_0)(cdr(1/syntax-e exp_0))))"
"(let-values(((r_1)(if(syntax?$1 r_0)(1/syntax-e r_0) r_0)))"
"(if(pair? r_1)(identifier?(car r_1)) #f)))"
" #f)"
" #f)"
" #f)"
"(let-values()"
"(1/datum->syntax exp_0(cons(1/namespace-module-identifier)(cdr(1/syntax-e exp_0))) exp_0 exp_0))"
"(let-values()"
"(if filename_0"
"(error"
" 'default-load-handler"
"                 (string-append \"expected a `module' declaration, but found something else\\n\" \"  file: ~a\")"
" filename_0)"
" #f))))))))"
"(define-values"
"(default-load-handler)"
"(lambda(path_0 expected-mod_0)"
"(begin"
"(let-values((()"
"(begin"
"(if(path-string? path_0)"
"(void)"
"                        (let-values () (raise-argument-error 'default-load-handler \"path-string?\" path_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not expected-mod_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(symbol? expected-mod_0)))"
"(if or-part_1"
" or-part_1"
"(if(pair? expected-mod_0)"
"(if(list? expected-mod_0)"
"(if(let-values(((or-part_2)(not(car expected-mod_0))))"
"(if or-part_2 or-part_2(symbol?(car expected-mod_0))))"
"(andmap2 symbol?(cdr expected-mod_0))"
" #f)"
" #f)"
" #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'default-load-handler"
"                             \"(or/c #f symbol? (cons/c (or/c #f symbol?) (non-empty-listof symbol?)))\""
" expected-mod_0)))"
"(values))))"
"(let-values(((maybe-count-lines!_0)"
"(lambda(i_0)"
"(begin"
" 'maybe-count-lines!"
"                            (if (regexp-match? '#rx\"[.]zo$\" path_0) (void) (let-values () (port-count-lines! i_0)))))))"
"(if expected-mod_0"
"(let-values()"
"((call-with-input-module-file"
" path_0"
"(lambda(i_0)"
"(begin"
"(maybe-count-lines!_0 i_0)"
"(with-module-reading-parameterization+delay-source"
" path_0"
"(lambda()"
"(let-values(((c2_0)(linklet-directory-start i_0)))"
"(if c2_0"
"((lambda(pos_0)"
"(let-values(((b-pos_0)(search-directory i_0 pos_0(encode-symbols expected-mod_0))))"
"(if b-pos_0"
"(let-values()"
"(begin"
"(file-position i_0 b-pos_0)"
"(let-values(((or-part_0)(cached-bundle i_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((v_0)(1/read i_0)))"
"(if(1/compiled-module-expression? v_0)"
"(lambda()((1/current-eval) v_0))"
"(error"
" 'default-load-handler"
"(string-append"
"                                                  \"expected a compiled module\\n\""
"                                                  \"  in: ~e\\n\""
"                                                  \"  found: ~e\")"
"(object-name i_0)"
" v_0)))))))"
"(if(pair? expected-mod_0)"
"(let-values() void)"
"(let-values()"
"(error"
" 'default-load-handler"
"                                         (string-append \"could not find main module\\n\" \"  in: ~e\")"
"(object-name i_0)))))))"
" c2_0)"
"(if(if(pair? expected-mod_0)(not(car expected-mod_0)) #f)"
"(let-values() void)"
"(let-values(((c1_0)(cached-bundle i_0)))"
"(if c1_0"
"((lambda(thunk_0) thunk_0) c1_0)"
"(let-values()"
"(let-values(((s_0)(1/read-syntax(object-name i_0) i_0)))"
"(let-values((()"
"(begin"
"(if(eof-object? s_0)"
"(let-values()"
"(error"
" 'default-load-handler"
"(string-append"
"                                                             \"expected a `module' declaration;\\n\""
"                                                             \" found end-of-file\\n\""
"                                                             \"  in: ~e\")"
"(object-name i_0)))"
"(void))"
"(values))))"
"(let-values(((m-s_0)(check-module-form s_0 path_0)))"
"(let-values(((s2_0)(1/read-syntax(object-name i_0) i_0)))"
"(begin"
"(if(eof-object? s2_0)"
"(void)"
"(let-values()"
"(error"
" 'default-load-handler"
"(string-append"
"                                                     \"expected a `module' declaration;\\n\""
"                                                     \" found an extra form\\n\""
"                                                     \"  in: ~e\\n\""
"                                                     \"  found: ~.s\")"
"(object-name i_0)"
" s2_0)))"
"(lambda()((1/current-eval) m-s_0))))))))))))))))))))"
"(let-values()"
"(let-values(((add-top-interaction_0)"
"(lambda(s_0)"
"(begin"
" 'add-top-interaction"
"(1/namespace-syntax-introduce"
"(1/datum->syntax #f(cons '#%top-interaction s_0) s_0))))))"
"(let-values(((path1_0) path_0)"
"((temp2_0)"
"(lambda(i_0)"
"(begin"
" 'temp2"
"(begin"
"(maybe-count-lines!_0 i_0)"
"((letrec-values(((loop_0)"
"(lambda(vals_0)"
"(begin"
" 'loop"
"(let-values(((s_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/read-accept-compiled"
" #t"
" 1/read-accept-reader"
" #t"
" 1/read-accept-lang"
" #t)"
"(let-values()"
"(if(load-on-demand-enabled)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" read-on-demand-source"
"(path->complete-path path_0))"
"(let-values()"
"(1/read-syntax"
"(object-name i_0)"
" i_0)))"
"(1/read-syntax"
"(object-name i_0)"
" i_0))))))"
"(if(eof-object? s_0)"
"(apply values vals_0)"
"(loop_0"
"(call-with-continuation-prompt"
"(lambda()"
"(call-with-values"
"(lambda()"
"((1/current-eval)(add-top-interaction_0 s_0)))"
" list))"
"(default-continuation-prompt-tag)"
"(lambda args_0"
"(apply"
" abort-current-continuation"
"(default-continuation-prompt-tag)"
" args_0))))))))))"
" loop_0)"
"(list(void))))))))"
"(call-with-input-file*61.1 'binary path1_0 temp2_0)))))))))))"
"(define-values(version-bytes)(string->bytes/utf-8(version)))"
"(define-values(version-length)(bytes-length version-bytes))"
"(define-values(vm-bytes)(string->bytes/utf-8(symbol->string(system-type 'vm))))"
"(define-values(vm-length)(bytes-length vm-bytes))"
"(define-values"
"(linklet-bundle-or-directory-start)"
"(lambda(i_0 tag_0)"
"(begin"
"(let-values(((version-length_0)(string-length(version))))"
"(let-values(((vm-length_0)(string-length(symbol->string(system-type 'vm)))))"
"(if(equal?(peek-byte i_0)(char->integer '#\\#))"
"(if(equal?(peek-byte i_0 1)(char->integer '#\\~))"
"(if(equal?(peek-byte i_0 2) version-length_0)"
"(if(equal?(peek-bytes version-length_0 3 i_0) version-bytes)"
"(if(equal?(peek-byte i_0(+ 3 version-length_0)) vm-length_0)"
"(if(equal?(peek-bytes vm-length_0(+ 4 version-length_0) i_0) vm-bytes)"
"(if(equal?(peek-byte i_0(+ 4 version-length_0 vm-length_0))(char->integer tag_0))"
"(+ version-length_0 vm-length_0 5)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f)"
" #f))))))"
"(define-values"
"(linklet-directory-start)"
"(lambda(i_0)"
"(begin(let-values(((pos_0)(linklet-bundle-or-directory-start i_0 '#\\D)))(if pos_0(+ pos_0 4) #f)))))"
"(define-values"
"(linklet-bundle-hash-code)"
"(lambda(i_0)"
"(begin"
"(let-values(((pos_0)(linklet-bundle-or-directory-start i_0 '#\\B)))"
"(let-values(((hash-code_0)(if pos_0(peek-bytes 20 pos_0 i_0) #f)))"
"(if(bytes? hash-code_0)"
"(if(= 20(bytes-length hash-code_0))"
"(if(let-values(((vec_0 len_0)"
"(let-values(((vec_0) hash-code_0))"
"(begin(check-bytes vec_0)(values vec_0(unsafe-bytes-length vec_0))))))"
"(begin"
" #f"
"((letrec-values(((for-loop_0)"
"(lambda(result_0 pos_1)"
"(begin"
" 'for-loop"
"(if(unsafe-fx< pos_1 len_0)"
"(let-values(((c_0)(unsafe-bytes-ref vec_0 pos_1)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()(not(eq? c_0 0))))))"
"(values result_1)))))"
"(if(if(not((lambda x_0 result_1) c_0))(not #f) #f)"
"(for-loop_0 result_1(unsafe-fx+ 1 pos_1))"
" result_1)))"
" result_0)))))"
" for-loop_0)"
" #f"
" 0)))"
" hash-code_0"
" #f)"
" #f)"
" #f))))))"
"(define-values"
"(cached-bundle)"
"(lambda(i_0)"
"(begin"
"(let-values(((c3_0)(module-cache-ref(make-module-cache-key(linklet-bundle-hash-code i_0)))))"
"(if c3_0"
"((lambda(declare-module_0)(lambda()(declare-module_0(1/current-namespace)))) c3_0)"
"(let-values() #f))))))"
"(define-values"
"(read-number)"
"(lambda(i_0)"
"(begin"
"(let-values(((read-byte/not-eof_0)"
"(lambda(i_1)"
"(begin 'read-byte/not-eof(let-values(((v_0)(read-byte i_1)))(if(eof-object? v_0) 0 v_0))))))"
"(bitwise-ior"
"(read-byte/not-eof_0 i_0)"
"(arithmetic-shift(read-byte/not-eof_0 i_0) 8)"
"(arithmetic-shift(read-byte/not-eof_0 i_0) 16)"
"(arithmetic-shift(read-byte/not-eof_0 i_0) 24))))))"
"(define-values"
"(search-directory)"
"(lambda(i_0 pos_0 bstr_0)"
"(begin"
"(if(zero? pos_0)"
"(let-values() #f)"
"(let-values()"
"(let-values((()(begin(file-position i_0 pos_0)(values))))"
"(let-values(((name-len_0)(read-number i_0)))"
"(let-values(((v_0)(read-bytes name-len_0 i_0)))"
"(begin"
"(if(if(bytes? v_0)(=(bytes-length v_0) name-len_0) #f)"
"(void)"
"(let-values()"
"(error"
" 'deafult-load-handler"
"(string-append"
"                        \"failure getting submodule path\\n\""
"                        \"  in: ~e\\n\""
"                        \"  at position: ~a\\n\""
"                        \"  expected bytes: ~a\\n\""
"                        \"  read bytes: ~e\")"
"(object-name i_0)"
" pos_0"
" name-len_0"
" v_0)))"
"(if(bytes=? bstr_0 v_0)"
"(let-values()(read-number i_0))"
"(if(bytes<? bstr_0 v_0)"
"(let-values()"
"(begin(read-number i_0)(read-number i_0)(search-directory i_0(read-number i_0) bstr_0)))"
"(let-values()"
"(begin"
"(read-number i_0)"
"(read-number i_0)"
"(read-number i_0)"
"(search-directory i_0(read-number i_0) bstr_0))))))))))))))"
"(define-values"
"(encode-symbols)"
"(lambda(expected-mod_0)"
"(begin"
"(if(symbol? expected-mod_0)"
"        (let-values () #\"\")"
"(let-values()"
"(apply"
" bytes-append"
"(reverse$1"
"(let-values(((lst_0)(cdr expected-mod_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((bstr_0)"
"(string->bytes/utf-8"
"(symbol->string s_0))))"
"(let-values(((len_0)"
"(bytes-length bstr_0)))"
"(if(< len_0 255)"
"(let-values()"
"(bytes-append"
"(bytes len_0)"
" bstr_0))"
"(let-values()"
"(bytes-append"
" 255"
"(integer->integer-bytes"
" len_0"
" 4"
" #f"
" #f)"
" bstr_0))))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))))"
"(define-values"
"(with-module-reading-parameterization+delay-source)"
"(lambda(path_0 thunk_0)"
"(begin"
"(if(load-on-demand-enabled)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" read-on-demand-source"
"(path->complete-path path_0))"
"(let-values()(with-module-reading-parameterization thunk_0)))"
"(with-module-reading-parameterization thunk_0)))))"
"(define-values"
"(call-with-input-module-file)"
"(lambda(path_0 proc_0)"
"(begin"
"(let-values(((i_0) #f))"
"(dynamic-wind"
"(lambda()"
"(set! i_0(let-values(((path3_0) path_0)((temp4_0) #t))(open-input-file6.1 temp4_0 'binary path3_0))))"
"(lambda()(proc_0 i_0))"
"(lambda()(close-input-port i_0)))))))"
"(define-values(dll-suffix)(system-type 'so-suffix))"
"(define-values"
"(default-load/use-compiled)"
"(let-values(((resolve_0)"
"(lambda(s_0)"
"(begin"
" 'resolve"
"(if(complete-path? s_0)"
" s_0"
"(let-values(((d_0)(current-load-relative-directory)))"
"(if d_0(path->complete-path s_0 d_0) s_0)))))))"
"(let-values(((date-of-1_0)"
"(lambda(a_0)"
"(begin"
" 'date-of-1"
"(let-values(((v_0)(file-or-directory-modify-seconds a_0 #f(lambda() #f))))"
"(if v_0(cons a_0 v_0) #f))))))"
"(let-values(((date-of_0)"
"(lambda(a_0 modes_0 roots_0)"
"(begin"
" 'date-of"
"(ormap2"
"(lambda(root-dir_0)"
"(ormap2"
"(lambda(compiled-dir_0)"
"(let-values(((a_1)(a_0 root-dir_0 compiled-dir_0)))(date-of-1_0 a_1)))"
" modes_0))"
" roots_0)))))"
"(let-values(((date>=?_0)"
"(lambda(modes_0 roots_0 a_0 bm_0)"
"(begin"
" 'date>=?"
"(if a_0"
"(let-values(((am_0)(date-of_0 a_0 modes_0 roots_0)))"
"(let-values(((or-part_0)(if(not bm_0) am_0 #f)))"
"(if or-part_0"
" or-part_0"
"(if am_0(if bm_0(if(>=(cdr am_0)(cdr bm_0)) am_0 #f) #f) #f))))"
" #f)))))"
"(let-values(((with-dir*_0)"
"(lambda(base_0 t_0)"
"(begin"
" 'with-dir*"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" current-load-relative-directory"
"(if(path? base_0) base_0(current-directory)))"
"(let-values()(t_0)))))))"
"(lambda(path_0 expect-module_0)"
"(begin"
"(let-values((()"
"(begin"
"(if(path-string? path_0)"
"(void)"
"                                  (let-values () (raise-argument-error 'load/use-compiled \"path-string?\" path_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not expect-module_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(symbol? expect-module_0)))"
"(if or-part_1"
" or-part_1"
"(if(list? expect-module_0)"
"(if(>(length expect-module_0) 1)"
"(if(let-values(((or-part_2)(symbol?(car expect-module_0))))"
"(if or-part_2 or-part_2(not(car expect-module_0))))"
"(andmap2 symbol?(cdr expect-module_0))"
" #f)"
" #f)"
" #f)))))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'load/use-compiled"
"                                       \"(or/c #f symbol? (cons/c (or/c #f symbol?) (non-empty-listof symbol?)))\""
" path_0)))"
"(values))))"
"(let-values(((name_0)(if expect-module_0(1/current-module-declare-name) #f)))"
"(let-values(((ns-hts_0)"
"(if name_0"
"(registry-table-ref(namespace-module-registry$1(1/current-namespace)))"
" #f)))"
"(let-values(((use-path/src_0)(if ns-hts_0(hash-ref(cdr ns-hts_0) name_0 #f) #f)))"
"(if use-path/src_0"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-module-declare-source"
"(cadr use-path/src_0))"
"(let-values()"
"(with-dir*_0"
"(caddr use-path/src_0)"
"(lambda()((1/current-load)(car use-path/src_0) expect-module_0)))))"
"(let-values(((orig-path_0)(resolve_0 path_0)))"
"(let-values(((base_0 orig-file_0 dir?_0)(split-path path_0)))"
"(let-values(((file_0 alt-file_0)"
"(if expect-module_0"
"(let-values(((b_0)(path->bytes orig-file_0)))"
"(let-values(((len_0)(bytes-length b_0)))"
"(if(if(>= len_0 4)"
"                                                          (bytes=? #\".rkt\" (subbytes b_0 (- len_0 4)))"
" #f)"
"(let-values()"
"(values"
" orig-file_0"
"(bytes->path"
"                                                          (bytes-append (subbytes b_0 0 (- len_0 4)) #\".ss\"))))"
"(let-values()(values orig-file_0 #f)))))"
"(values orig-file_0 #f))))"
"(let-values(((path_1)"
"(if(eq? file_0 orig-file_0) orig-path_0(build-path base_0 file_0))))"
"(let-values(((alt-path_0)"
"(if alt-file_0"
"(if(eq? alt-file_0 orig-file_0)"
" orig-path_0"
"(build-path base_0 alt-file_0))"
" #f)))"
"(let-values(((base_1)(if(eq? base_0 'relative) 'same base_0)))"
"(let-values(((modes_0)(1/use-compiled-file-paths)))"
"(let-values(((roots_0)(1/current-compiled-file-roots)))"
"(let-values(((reroot_0)"
"(lambda(p_0 d_0)"
"(begin"
" 'reroot"
"(if(eq? d_0 'same)"
"(let-values() p_0)"
"(if(relative-path? d_0)"
"(let-values()(build-path p_0 d_0))"
"(let-values()(reroot-path p_0 d_0))))))))"
"(let-values(((main-path-d_0)(date-of-1_0 path_1)))"
"(let-values(((alt-path-d_0)"
"(if alt-path_0"
"(if(not main-path-d_0)(date-of-1_0 alt-path_0) #f)"
" #f)))"
"(let-values(((path-d_0)"
"(let-values(((or-part_0) main-path-d_0))"
"(if or-part_0 or-part_0 alt-path-d_0))))"
"(let-values(((get-so_0)"
"(lambda(file_1 rep-sfx?_0)"
"(begin"
" 'get-so"
"(lambda(root-dir_0 compiled-dir_0)"
"(build-path"
"(reroot_0 base_1 root-dir_0)"
" compiled-dir_0"
"                                                                         \"native\""
"(system-library-subpath)"
"(if rep-sfx?_0"
"(path-add-extension file_1 dll-suffix)"
" file_1)))))))"
"(let-values(((zo_0)"
"(lambda(root-dir_0 compiled-dir_0)"
"(begin"
" 'zo"
"(build-path"
"(reroot_0 base_1 root-dir_0)"
" compiled-dir_0"
"                                                                         (path-add-extension file_0 #\".zo\"))))))"
"(let-values(((alt-zo_0)"
"(lambda(root-dir_0 compiled-dir_0)"
"(begin"
" 'alt-zo"
"(build-path"
"(reroot_0 base_1 root-dir_0)"
" compiled-dir_0"
"                                                                           (path-add-extension alt-file_0 #\".zo\"))))))"
"(let-values(((so_0)(get-so_0 file_0 #t)))"
"(let-values(((alt-so_0)(get-so_0 alt-file_0 #t)))"
"(let-values(((try-main?_0)"
"(let-values(((or-part_0) main-path-d_0))"
"(if or-part_0"
" or-part_0"
"(not alt-path-d_0)))))"
"(let-values(((try-alt?_0)"
"(if alt-file_0"
"(let-values(((or-part_0) alt-path-d_0))"
"(if or-part_0"
" or-part_0"
"(not main-path-d_0)))"
" #f)))"
"(let-values(((with-dir_0)"
"(lambda(t_0)"
"(begin"
" 'with-dir"
"(with-dir*_0 base_1 t_0)))))"
"(let-values(((c4_0)"
"(if try-main?_0"
"(date>=?_0"
" modes_0"
" roots_0"
" so_0"
" path-d_0)"
" #f)))"
"(if c4_0"
"((lambda(so-d_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-module-declare-source"
" #f)"
"(let-values()"
"(with-dir_0"
"(lambda()"
"((current-load-extension)"
"(car so-d_0)"
" expect-module_0))))))"
" c4_0)"
"(let-values(((c3_0)"
"(if try-alt?_0"
"(date>=?_0"
" modes_0"
" roots_0"
" alt-so_0"
" alt-path-d_0)"
" #f)))"
"(if c3_0"
"((lambda(so-d_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-module-declare-source"
" alt-path_0)"
"(let-values()"
"(with-dir_0"
"(lambda()"
"((current-load-extension)"
"(car so-d_0)"
" expect-module_0))))))"
" c3_0)"
"(let-values(((c2_0)"
"(if try-main?_0"
"(date>=?_0"
" modes_0"
" roots_0"
" zo_0"
" path-d_0)"
" #f)))"
"(if c2_0"
"((lambda(zo-d_0)"
"(begin"
"(register-zo-path"
" name_0"
" ns-hts_0"
"(car zo-d_0)"
" #f"
" base_1)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-module-declare-source"
" #f)"
"(let-values()"
"(with-dir_0"
"(lambda()"
"((1/current-load)"
"(car zo-d_0)"
" expect-module_0)))))))"
" c2_0)"
"(let-values(((c1_0)"
"(if try-alt?_0"
"(date>=?_0"
" modes_0"
" roots_0"
" alt-zo_0"
" path-d_0)"
" #f)))"
"(if c1_0"
"((lambda(zo-d_0)"
"(begin"
"(register-zo-path"
" name_0"
" ns-hts_0"
"(car zo-d_0)"
" alt-path_0"
" base_1)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-module-declare-source"
" alt-path_0)"
"(let-values()"
"(with-dir_0"
"(lambda()"
"((1/current-load)"
"(car zo-d_0)"
" expect-module_0)))))))"
" c1_0)"
"(if(let-values(((or-part_0)"
"(not"
"(pair?"
" expect-module_0))))"
"(if or-part_0"
" or-part_0"
"(car expect-module_0)))"
"(let-values()"
"(let-values(((p_0)"
"(if try-main?_0"
" path_1"
" alt-path_0)))"
"(if(if(pair?"
" expect-module_0)"
"(not(file-exists? p_0))"
" #f)"
"(void)"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-module-declare-source"
"(if expect-module_0"
"(if(not try-main?_0)"
" p_0"
" #f)"
" #f))"
"(let-values()"
"(with-dir_0"
"(lambda()"
"((1/current-load)"
" p_0"
" expect-module_0)))))))))"
"(void))))))))))))))))))))))))))))))))))))))))))))"
"(define-values"
"(register-zo-path)"
"(lambda(name_0 ns-hts_0 path_0 src-path_0 base_0)"
"(begin(if ns-hts_0(let-values()(hash-set!(cdr ns-hts_0) name_0(list path_0 src-path_0 base_0)))(void)))))"
"(define-values(default-reader-guard)(lambda(path_0)(begin path_0)))"
"(define-values(cell.1)(unsafe-make-place-local(make-weak-hasheq)))"
"(define-values"
"(registry-table-ref)"
"(lambda(reg_0)"
"(begin"
"(let-values(((e_0)(hash-ref(unsafe-place-local-ref cell.1) reg_0 #f)))(if e_0(ephemeron-value e_0) #f)))))"
"(define-values"
"(registry-table-set!)"
"(lambda(reg_0 v_0)(begin(hash-set!(unsafe-place-local-ref cell.1) reg_0(make-ephemeron reg_0 v_0)))))"
"(define-values(CACHE-N) 512)"
"(define-values(cell.2)(unsafe-make-place-local(make-vector CACHE-N #f)))"
"(define-values"
"(path-cache-get)"
"(lambda(p_0)"
"(begin"
"(let-values(((i_0)(modulo(abs(equal-hash-code p_0)) CACHE-N)))"
"(let-values(((w_0)(vector-ref(unsafe-place-local-ref cell.2) i_0)))"
"(let-values(((l_0)(if w_0(weak-box-value w_0) #f)))"
"(if l_0(let-values(((a_0)(1/assoc p_0 l_0)))(if a_0(cdr a_0) #f)) #f)))))))"
"(define-values"
"(path-cache-set!)"
"(lambda(p_0 v_0)"
"(begin"
"(let-values(((i_0)(modulo(abs(equal-hash-code p_0)) CACHE-N)))"
"(let-values(((w_0)(vector-ref(unsafe-place-local-ref cell.2) i_0)))"
"(let-values(((l_0)(if w_0(weak-box-value w_0) #f)))"
"(vector-set!"
"(unsafe-place-local-ref cell.2)"
" i_0"
"(make-weak-box(cons(cons p_0 v_0)(let-values(((or-part_0) l_0))(if or-part_0 or-part_0 null)))))))))))"
"(define-values(-loading-filename)(gensym))"
"(define-values(-loading-prompt-tag)(make-continuation-prompt-tag 'module-loading))"
"(define-values(cell.3)(unsafe-make-place-local #f))"
"(define-values(cell.4)(unsafe-make-place-local #f))"
"(define-values"
"(split-relative-string)"
"(lambda(s_0 coll-mode?_0)"
"(begin"
"(let-values(((l_0)"
"((letrec-values(((loop_0)"
"(lambda(s_1)"
"(begin"
" 'loop"
"(let-values(((len_0)(string-length s_1)))"
"((letrec-values(((iloop_0)"
"(lambda(i_0)"
"(begin"
" 'iloop"
"(if(= i_0 len_0)"
"(let-values()(list s_1))"
"(if(char=? '#\\/(string-ref s_1 i_0))"
"(let-values()"
"(cons"
"(substring s_1 0 i_0)"
"(loop_0(substring s_1(add1 i_0)))))"
"(let-values()(iloop_0(add1 i_0)))))))))"
" iloop_0)"
" 0))))))"
" loop_0)"
" s_0)))"
"(if coll-mode?_0"
" l_0"
"((letrec-values(((loop_0)"
"(lambda(l_1)"
"(begin"
" 'loop"
"(if(null?(cdr l_1))"
"(values null(car l_1))"
"(let-values(((c_0 f_0)(loop_0(cdr l_1))))(values(cons(car l_1) c_0) f_0)))))))"
" loop_0)"
" l_0))))))"
"(define-values"
"(format-source-location)"
"(lambda(stx_0)"
"(begin"
"(srcloc->string"
"(srcloc"
"(1/syntax-source stx_0)"
"(1/syntax-line stx_0)"
"(1/syntax-column stx_0)"
"(1/syntax-position stx_0)"
"(1/syntax-span stx_0))))))"
"(define-values(cell.5)(unsafe-make-place-local #f))"
"(define-values(cell.6)(unsafe-make-place-local #f))"
"(define-values"
"(prep-planet-resolver!)"
"(lambda()"
"(begin"
"(if(unsafe-place-local-ref cell.6)"
"(void)"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(unsafe-place-local-ref cell.5)"
"(unsafe-place-local-set!"
" cell.6"
"            (1/dynamic-require '(lib \"planet/resolver.rkt\") 'planet-module-name-resolver))))))))"
"(define-values"
"(standard-module-name-resolver)"
"(case-lambda"
"((s_0 from-namespace_0)"
"(begin"
"(begin"
"(if(1/resolved-module-path? s_0)"
"(void)"
"          (let-values () (raise-argument-error 'standard-module-name-resolver \"resolved-module-path?\" s_0)))"
"(if(let-values(((or-part_0)(not from-namespace_0)))(if or-part_0 or-part_0(1/namespace? from-namespace_0)))"
"(void)"
"          (let-values () (raise-argument-error 'standard-module-name-resolver \"(or/c #f namespace?)\" from-namespace_0)))"
"(if(unsafe-place-local-ref cell.6)(let-values()((unsafe-place-local-ref cell.6) s_0))(void))"
"(let-values(((hts_0)"
"(let-values(((or-part_0)"
"(registry-table-ref(namespace-module-registry$1(1/current-namespace)))))"
"(if or-part_0"
" or-part_0"
"(let-values(((hts_0)(cons(make-hasheq)(make-hasheq))))"
"(begin"
"(registry-table-set!(namespace-module-registry$1(1/current-namespace)) hts_0)"
" hts_0))))))"
"(begin"
"(hash-set!(car hts_0) s_0 'declared)"
"(if from-namespace_0"
"(let-values()"
"(let-values(((root-name_0)"
"(if(pair?(1/resolved-module-path-name s_0))"
"(1/make-resolved-module-path(car(1/resolved-module-path-name s_0)))"
" s_0))"
"((from-hts_0)(registry-table-ref(namespace-module-registry$1 from-namespace_0))))"
"(if from-hts_0"
"(let-values()"
"(let-values(((use-path/src_0)(hash-ref(cdr from-hts_0) root-name_0 #f)))"
"(if use-path/src_0(let-values()(hash-set!(cdr hts_0) root-name_0 use-path/src_0))(void))))"
"(void))))"
"(void)))))))"
"((s_0 relto_0 stx_0)"
"(begin"
"      (log-message (current-logger) 'error \"default module name resolver called with three arguments (deprecated)\" #f)"
"(standard-module-name-resolver s_0 relto_0 stx_0 #t)))"
"((s_0 relto_0 stx_0 load?_0)"
"(let-values((()"
"(begin"
"(if(1/module-path? s_0)"
"(void)"
"(let-values()"
"(if(syntax?$1 stx_0)"
"                          (raise-syntax-error$1 #f \"bad module path\" stx_0)"
"                          (raise-argument-error 'standard-module-name-resolver \"module-path?\" s_0))))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not relto_0)))"
"(if or-part_0 or-part_0(1/resolved-module-path? relto_0)))"
"(void)"
"(let-values()"
"(raise-argument-error"
" 'standard-module-name-resolver"
"                           \"(or/c #f resolved-module-path?)\""
" relto_0)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0)(not stx_0)))(if or-part_0 or-part_0(syntax?$1 stx_0)))"
"(void)"
"(let-values()"
"                            (raise-argument-error 'standard-module-name-resolver \"(or/c #f syntax?)\" stx_0)))"
"(values))))"
"(let-values(((flatten-sub-path_0)"
"(lambda(base_0 orig-l_0)"
"(begin"
" 'flatten-sub-path"
"((letrec-values(((loop_0)"
"(lambda(a_0 l_0)"
"(begin"
" 'loop"
"(if(null? l_0)"
"(let-values()"
"(if(null? a_0) base_0(cons base_0(reverse$1 a_0))))"
"                                                    (if (equal? (car l_0) \"..\")"
"(let-values()"
"(if(null? a_0)"
"(error"
" 'standard-module-name-resolver"
"                                                           \"too many \\\"..\\\"s in submodule path: ~.s\""
"(list*"
" 'submod"
"                                                            (if (equal? base_0 \".\")"
" base_0"
"(if(path? base_0)"
" base_0"
"(list(if(symbol? base_0) 'quote 'file) base_0)))"
" orig-l_0))"
"(loop_0(cdr a_0)(cdr l_0))))"
"(let-values()(loop_0(cons(car l_0) a_0)(cdr l_0)))))))))"
" loop_0)"
" null"
" orig-l_0)))))"
"(if(if(pair? s_0)(eq?(car s_0) 'quote) #f)"
"(let-values()(1/make-resolved-module-path(cadr s_0)))"
"(if(if(pair? s_0)"
"(if(eq?(car s_0) 'submod)(if(pair?(cadr s_0))(eq?(caadr s_0) 'quote) #f) #f)"
" #f)"
"(let-values()(1/make-resolved-module-path(flatten-sub-path_0(cadadr s_0)(cddr s_0))))"
"(if(if(pair? s_0)"
"(if(eq?(car s_0) 'submod)"
"                        (if (let-values (((or-part_0) (equal? (cadr s_0) \".\")))"
"                              (if or-part_0 or-part_0 (equal? (cadr s_0) \"..\")))"
"(if relto_0"
"(let-values(((p_0)(1/resolved-module-path-name relto_0)))"
"(let-values(((or-part_0)(symbol? p_0)))"
"(if or-part_0 or-part_0(if(pair? p_0)(symbol?(car p_0)) #f))))"
" #f)"
" #f)"
" #f)"
" #f)"
"(let-values()"
"(let-values(((rp_0)(1/resolved-module-path-name relto_0)))"
"(1/make-resolved-module-path"
"(flatten-sub-path_0"
"(if(pair? rp_0)(car rp_0) rp_0)"
"                        (let-values (((r_0) (if (equal? (cadr s_0) \"..\") (cdr s_0) (cddr s_0))))"
"(if(pair? rp_0)(append(cdr rp_0) r_0) r_0))))))"
"(if(if(pair? s_0)(eq?(car s_0) 'planet) #f)"
"(let-values()"
"(begin"
"(prep-planet-resolver!)"
"((unsafe-place-local-ref cell.6) s_0 relto_0 stx_0 load?_0 #f(unsafe-place-local-ref cell.5))))"
"(if(if(pair? s_0)"
"(if(eq?(car s_0) 'submod)(if(pair?(cadr s_0))(eq?(caadr s_0) 'planet) #f) #f)"
" #f)"
"(let-values()"
"(begin"
"(prep-planet-resolver!)"
"((unsafe-place-local-ref cell.6)"
"(cadr s_0)"
" relto_0"
" stx_0"
" load?_0"
"(cddr s_0)"
"(unsafe-place-local-ref cell.5))))"
"(let-values()"
"(let-values(((get-dir_0)"
"(lambda()"
"(begin"
" 'get-dir"
"(let-values(((or-part_0)"
"(if relto_0"
"(if(eq? relto_0(unsafe-place-local-ref cell.3))"
"(unsafe-place-local-ref cell.4)"
"(let-values(((p_0)(1/resolved-module-path-name relto_0)))"
"(let-values(((p_1)(if(pair? p_0)(car p_0) p_0)))"
"(if(path? p_1)"
"(let-values(((base_0 n_0 d?_0)(split-path p_1)))"
"(begin"
"(unsafe-place-local-set! cell.3 relto_0)"
"(unsafe-place-local-set! cell.4 base_0)"
" base_0))"
" #f))))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(current-load-relative-directory)))"
"(if or-part_1 or-part_1(current-directory))))))))"
"((get-reg_0)"
"(lambda()(begin 'get-reg(namespace-module-registry$1(1/current-namespace)))))"
"((show-collection-err_0)"
"(lambda(msg_0)"
"(begin"
" 'show-collection-err"
"(let-values(((msg_1)"
"(string-append"
"(let-values(((or-part_0)"
"(if stx_0"
"(if(error-print-source-location)"
"(format-source-location stx_0)"
" #f)"
" #f)))"
"                                                           (if or-part_0 or-part_0 \"standard-module-name-resolver\"))"
"                                                         \": \""
"(regexp-replace"
"                                                          '#rx\"\\n\""
" msg_0"
"                                                          (format \"\\n  for module path: ~s\\n\" s_0)))))"
"(raise"
"(if stx_0"
"(1/make-exn:fail:syntax:missing-module"
" msg_1"
"(current-continuation-marks)"
"(list stx_0)"
" s_0)"
"(1/make-exn:fail:filesystem:missing-module"
" msg_1"
"(current-continuation-marks)"
" s_0)))))))"
"((invent-collection-dir_0)"
"(lambda(f-file_0 col_0 col-path_0 fail_0)"
"(begin"
" 'invent-collection-dir"
"(lambda(msg_0)"
"(string->uninterned-symbol"
"(path->string"
"(build-path(apply build-path col_0 col-path_0) f-file_0)))))))"
"((ss->rkt_0)"
"(lambda(s_1)"
"(begin"
" 'ss->rkt"
"(let-values(((len_0)(string-length s_1)))"
"(if(if(>= len_0 3)"
"(if(equal? '#\\.(string-ref s_1(- len_0 3)))"
"(if(equal? '#\\s(string-ref s_1(- len_0 2)))"
"(equal? '#\\s(string-ref s_1(- len_0 1)))"
" #f)"
" #f)"
" #f)"
"                                              (string-append (substring s_1 0 (- len_0 3)) \".rkt\")"
" s_1)))))"
"((path-ss->rkt_0)"
"(lambda(p_0)"
"(begin"
" 'path-ss->rkt"
"(let-values(((base_0 name_0 dir?_0)(split-path p_0)))"
"                                            (if (regexp-match '#rx\"[.]ss$\" (path->bytes name_0))"
"                                              (path-replace-extension p_0 #\".rkt\")"
" p_0)))))"
"((s_1)"
"(if(if(pair? s_0)(eq? 'submod(car s_0)) #f)"
"(let-values(((v_0)(cadr s_0)))"
"                                          (if (let-values (((or-part_0) (equal? v_0 \".\")))"
"                                                (if or-part_0 or-part_0 (equal? v_0 \"..\")))"
"(if relto_0"
"(let-values(((p_0)(1/resolved-module-path-name relto_0)))"
"(if(pair? p_0)(car p_0) p_0))"
"(error"
" 'standard-module-name-resolver"
"                                               \"no base path for relative submodule path: ~.s\""
" s_0))"
" v_0))"
" s_0))"
"((subm-path_0)"
"(if(if(pair? s_0)(eq? 'submod(car s_0)) #f)"
"(let-values(((p_0)"
"                                                      (if (if (let-values (((or-part_0) (equal? (cadr s_0) \".\")))"
"                                                                (if or-part_0 or-part_0 (equal? (cadr s_0) \"..\")))"
" relto_0"
" #f)"
"(let-values(((p_0)(1/resolved-module-path-name relto_0))"
"((r_0)"
"                                                                      (if (equal? (cadr s_0) \"..\")"
"(cdr s_0)"
"(cddr s_0))))"
"(if(pair? p_0)"
"(flatten-sub-path_0(car p_0)(append(cdr p_0) r_0))"
"(flatten-sub-path_0 p_0 r_0)))"
"(flatten-sub-path_0"
"                                                         \".\""
"                                                         (if (equal? (cadr s_0) \"..\") (cdr s_0) (cddr s_0))))))"
"(if(pair? p_0)(cdr p_0) #f))"
" #f)))"
"(let-values(((s-parsed_0)"
"(if(symbol? s_1)"
"(let-values()"
"(let-values(((or-part_0)(path-cache-get(cons s_1(get-reg_0)))))"
"(if or-part_0"
" or-part_0"
"(let-values(((cols_0 file_0)"
"(split-relative-string(symbol->string s_1) #f)))"
"(let-values(((f-file_0)"
"(if(null? cols_0)"
"                                                                  \"main.rkt\""
"                                                                  (string-append file_0 \".rkt\"))))"
"(let-values(((col_0)(if(null? cols_0) file_0(car cols_0))))"
"(let-values(((col-path_0)(if(null? cols_0) null(cdr cols_0))))"
"(find-col-file"
"(if(not subm-path_0)"
" show-collection-err_0"
"(invent-collection-dir_0"
" f-file_0"
" col_0"
" col-path_0"
" show-collection-err_0))"
" col_0"
" col-path_0"
" f-file_0"
" #t))))))))"
"(if(string? s_1)"
"(let-values()"
"(let-values(((dir_0)(get-dir_0)))"
"(let-values(((or-part_0)(path-cache-get(cons s_1 dir_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((cols_0 file_0)(split-relative-string s_1 #f)))"
"(if(null? cols_0)"
"(build-path dir_0(ss->rkt_0 file_0))"
"(apply"
" build-path"
" dir_0"
"(append"
"(map2"
"(lambda(s_2)"
"                                                             (if (string=? s_2 \".\")"
"(let-values() 'same)"
"                                                               (if (string=? s_2 \"..\")"
"(let-values() 'up)"
"(let-values() s_2))))"
" cols_0)"
"(list(ss->rkt_0 file_0))))))))))"
"(if(path? s_1)"
"(let-values()"
"(path-ss->rkt_0"
"(simplify-path"
"(if(complete-path? s_1) s_1(path->complete-path s_1(get-dir_0))))))"
"(if(eq?(car s_1) 'lib)"
"(let-values()"
"(let-values(((or-part_0)(path-cache-get(cons s_1(get-reg_0)))))"
"(if or-part_0"
" or-part_0"
"(let-values(((cols_0 file_0)"
"(split-relative-string(cadr s_1) #f)))"
"(let-values(((old-style?_0)"
"(if(null?(cddr s_1))"
"(if(null? cols_0)"
"                                                                          (regexp-match? '#rx\"[.]\" file_0)"
" #f)"
" #t)))"
"(let-values(((f-file_0)"
"(if old-style?_0"
"(ss->rkt_0 file_0)"
"(if(null? cols_0)"
"                                                                            \"main.rkt\""
"                                                                            (if (regexp-match? '#rx\"[.]\" file_0)"
"(ss->rkt_0 file_0)"
"                                                                              (string-append file_0 \".rkt\"))))))"
"(let-values(((cols_1)"
"(if old-style?_0"
"(append"
"(if(null?(cddr s_1))"
"                                                                               '(\"mzlib\")"
"(apply"
" append"
"(map2"
"(lambda(p_0)"
"(split-relative-string p_0 #t))"
"(cddr s_1))))"
" cols_0)"
"(if(null? cols_0)(list file_0) cols_0))))"
"(find-col-file"
" show-collection-err_0"
"(car cols_1)"
"(cdr cols_1)"
" f-file_0"
" #t))))))))"
"(if(eq?(car s_1) 'file)"
"(let-values()"
"(path-ss->rkt_0"
"(simplify-path"
"(path->complete-path(expand-user-path(cadr s_1))(get-dir_0)))))"
"(void))))))))"
"(if(symbol? s-parsed_0)"
"(let-values()(1/make-resolved-module-path(cons s-parsed_0 subm-path_0)))"
"(if(not"
"(let-values(((or-part_0)(path? s-parsed_0)))"
"(if or-part_0 or-part_0(vector? s-parsed_0))))"
"(let-values()"
"(if stx_0"
"(raise-syntax-error$1"
" 'require"
"                                     (format \"bad module path~a\" (if s-parsed_0 (car s-parsed_0) \"\"))"
" stx_0)"
"                                    (raise-argument-error 'standard-module-name-resolver \"module-path?\" s_1)))"
"(let-values()"
"(let-values(((filename_0)"
"(if(vector? s-parsed_0)"
"(vector-ref s-parsed_0 0)"
"(simplify-path(cleanse-path s-parsed_0) #f))))"
"(let-values(((normal-filename_0)"
"(if(vector? s-parsed_0)"
"(vector-ref s-parsed_0 1)"
"(normal-case-path filename_0))))"
"(let-values(((base_0 name_0 dir?_0)"
"(if(vector? s-parsed_0)"
"(values 'ignored(vector-ref s-parsed_0 2) 'ignored)"
"(split-path filename_0))))"
"(let-values(((no-sfx_0)"
"(if(vector? s-parsed_0)"
"(vector-ref s-parsed_0 3)"
"                                                        (path-replace-extension name_0 #\"\"))))"
"(let-values(((root-modname_0)"
"(if(vector? s-parsed_0)"
"(vector-ref s-parsed_0 4)"
"(1/make-resolved-module-path filename_0))))"
"(let-values(((hts_0)"
"(let-values(((or-part_0)(registry-table-ref(get-reg_0))))"
"(if or-part_0"
" or-part_0"
"(let-values(((hts_0)(cons(make-hasheq)(make-hasheq))))"
"(begin"
"(registry-table-set!(get-reg_0) hts_0)"
" hts_0))))))"
"(let-values(((modname_0)"
"(if subm-path_0"
"(1/make-resolved-module-path"
"(cons"
"(1/resolved-module-path-name root-modname_0)"
" subm-path_0))"
" root-modname_0)))"
"(begin"
"(if load?_0"
"(let-values()"
"(let-values(((got_0)(hash-ref(car hts_0) modname_0 #f)))"
"(if got_0"
"(void)"
"(let-values()"
"(let-values(((loading_0)"
"(let-values(((tag_0)"
"(if(continuation-prompt-available?"
" -loading-prompt-tag)"
" -loading-prompt-tag"
"(default-continuation-prompt-tag))))"
"(continuation-mark-set-first"
" #f"
" -loading-filename"
" null"
" tag_0)))"
"((nsr_0)(get-reg_0)))"
"(begin"
"(for-each2"
"(lambda(s_2)"
"(if(if(equal?(cdr s_2) normal-filename_0)"
"(eq?(car s_2) nsr_0)"
" #f)"
"(let-values()"
"(error"
" 'standard-module-name-resolver"
"                                                                        \"cycle in loading\\n  at path: ~a\\n  paths:~a\""
" filename_0"
"(apply"
" string-append"
"((letrec-values(((loop_0)"
"(lambda(l_0)"
"(begin"
" 'loop"
"(if(null? l_0)"
" '()"
"(list*"
"                                                                                                  \"\\n   \""
"(path->string"
"(cdar l_0))"
"(loop_0"
"(cdr l_0))))))))"
" loop_0)"
"(reverse$1 loading_0)))))"
"(void)))"
" loading_0)"
"((if(continuation-prompt-available?"
" -loading-prompt-tag)"
"(lambda(f_0)(f_0))"
"(lambda(f_0)"
"(call-with-continuation-prompt"
" f_0"
" -loading-prompt-tag)))"
"(lambda()"
"(with-continuation-mark"
" -loading-filename"
"(cons(cons nsr_0 normal-filename_0) loading_0)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-module-declare-name"
" root-modname_0"
" 1/current-module-path-for-load"
"((if stx_0"
"(lambda(p_0)(1/datum->syntax #f p_0 stx_0))"
" values)"
"(if(symbol? s_1)"
"(let-values() s_1)"
"(if(if(pair? s_1)(eq?(car s_1) 'lib) #f)"
"(let-values() s_1)"
"(let-values()"
"(if(1/resolved-module-path?"
" root-modname_0)"
"(let-values(((src_0)"
"(1/resolved-module-path-name"
" root-modname_0)))"
"(if(symbol? src_0)"
"(list 'quote src_0)"
" src_0))"
" root-modname_0))))))"
"(let-values()"
"((1/current-load/use-compiled)"
" filename_0"
"(let-values(((sym_0)"
"(string->symbol"
"(path->string no-sfx_0))))"
"(if subm-path_0"
"(if(hash-ref(car hts_0) root-modname_0 #f)"
"(cons #f subm-path_0)"
"(cons sym_0 subm-path_0))"
" sym_0))))))))))))))"
"(void))"
"(if(if(not(vector? s-parsed_0))"
"(if load?_0"
"(let-values(((or-part_0)(string? s_1)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(symbol? s_1)))"
"(if or-part_1"
" or-part_1"
"(if(pair? s_1)(eq?(car s_1) 'lib) #f)))))"
" #f)"
" #f)"
"(let-values()"
"(path-cache-set!"
"(if(string? s_1)(cons s_1(get-dir_0))(cons s_1(get-reg_0)))"
"(vector"
" filename_0"
" normal-filename_0"
" name_0"
" no-sfx_0"
" root-modname_0)))"
"(void))"
" modname_0))))))))))))))))))))))))))"
"(define-values"
"(default-eval-handler)"
"(lambda(s_0)"
"(begin"
"(1/eval"
" s_0"
"(1/current-namespace)"
"(let-values(((c_0)(1/current-compile)))"
"(lambda(e_0 ns_0)"
"(if(eq? ns_0(1/current-namespace))"
"(c_0 e_0 #t)"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization(continuation-mark-set-first #f parameterization-key) 1/current-namespace ns_0)"
"(let-values()(c_0 e_0 #t))))))))))"
"(define-values"
"(default-compile-handler)"
"(lambda(s_0 immediate-eval?_0)(begin(1/compile s_0(1/current-namespace)(not immediate-eval?_0)))))"
"(define-values"
"(default-read-interaction)"
"(lambda(src_0 in_0)"
"(begin"
"(begin"
"(if(input-port? in_0)"
"(void)"
"          (let-values () (raise-argument-error 'default-read-interaction \"input-port?\" in_0)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/read-accept-reader"
" #t"
" 1/read-accept-lang"
" #f)"
"(let-values()(1/read-syntax src_0 in_0)))))))"
"(define-values"
"(boot)"
"(lambda()"
"(begin"
"(begin"
"(unsafe-place-local-set! cell.1(make-weak-hasheq))"
"(unsafe-place-local-set! cell.2(make-vector CACHE-N #f))"
"(seal)"
"(1/current-module-name-resolver standard-module-name-resolver)"
"(1/current-load/use-compiled default-load/use-compiled)"
"(1/current-reader-guard default-reader-guard)"
"(1/current-eval default-eval-handler)"
"(1/current-compile default-compile-handler)"
"(1/current-load default-load-handler)"
"(current-read-interaction default-read-interaction)))))"
"(define-values"
"(seal)"
"(lambda()"
"(begin(unsafe-place-local-set! cell.5(reparameterize(continuation-mark-set-first #f parameterization-key))))))"
"(define-values(get-original-parameterization)(lambda()(begin(unsafe-place-local-ref cell.5))))"
"(define-values"
"(boot-primitives)"
"(hash 'boot boot 'seal seal 'get-original-parameterization get-original-parameterization))"
"(define-values"
"(prepare-next-phase-namespace)"
"(lambda(ctx_0)"
"(begin"
"(let-values(((phase_0)(add1(expand-context-phase ctx_0))))"
"(let-values(((ns_0)(namespace->namespace-at-phase(expand-context-namespace ctx_0) phase_0)))"
"(namespace-visit-available-modules! ns_0 phase_0))))))"
"(define-values"
"(expand-body7.1)"
"(lambda(source1_0 stratified?2_0 bodys5_0 ctx6_0)"
"(begin"
" 'expand-body7"
"(let-values(((bodys_0) bodys5_0))"
"(let-values(((ctx_0) ctx6_0))"
"(let-values(((s_0) source1_0))"
"(let-values(((stratified?_0) stratified?2_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'enter-block(datum->syntax$1 #f bodys_0))))"
"(void)))"
"(values))))"
"(let-values(((inside-sc_0)(new-scope 'intdef)))"
"(let-values(((init-bodys_0)"
"(reverse$1"
"(let-values(((lst_0) bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" body_0"
" inside-sc_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'block-renames"
"(datum->syntax$1 #f init-bodys_0)"
"(datum->syntax$1 #f bodys_0))))"
"(void)))"
"(values))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((frame-id_0)(make-reference-record)))"
"(let-values(((def-ctx-scopes_0)(box null)))"
"(let-values(((body-ctx_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context55_0)(list(make-liberal-define-context)))"
"((name56_0) #f)"
"((only-immediate?57_0) #t)"
"((def-ctx-scopes58_0) def-ctx-scopes_0)"
"((post-expansion59_0)"
"(lambda(s_1)"
"(begin"
" 'post-expansion59"
"(add-scope s_1 inside-sc_0))))"
"((scopes60_0)"
"(cons inside-sc_0(expand-context-scopes ctx_0)))"
"((use-site-scopes61_0)(box null))"
"((frame-id62_0) frame-id_0)"
"((reference-records63_0)"
"(cons"
" frame-id_0"
"(expand-context-reference-records ctx_0)))"
"((inner64_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner64_0"
" post-expansion59_0"
" use-site-scopes61_0"
" frame-id62_0"
" context55_0"
"(expand-context/outer-env the-struct_0)"
" scopes60_0"
" def-ctx-scopes58_0"
"(expand-context/outer-binding-layer the-struct_0)"
" reference-records63_0"
" only-immediate?57_0"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
" name56_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                   \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((maybe-increment-binding-layer_0)"
"(lambda(ids_0 body-ctx_1)"
"(begin"
" 'maybe-increment-binding-layer"
"(if(eq?"
"(expand-context-binding-layer body-ctx_1)"
"(expand-context-binding-layer ctx_0))"
"(increment-binding-layer ids_0 body-ctx_1 inside-sc_0)"
"(expand-context-binding-layer body-ctx_1))))))"
"(let-values(((name_0)(expand-context-name ctx_0)))"
"((letrec-values(((loop_0)"
"(lambda(body-ctx_1"
" bodys_1"
" done-bodys_0"
" val-idss_0"
" val-keyss_0"
" val-rhss_0"
" track-stxs_0"
" trans-idss_0"
" trans-stxs_0"
" stx-clauses_0"
" dups_0)"
"(begin"
" 'loop"
"(if(null? bodys_1)"
"(let-values()"
"(let-values(((body-ctx65_0) body-ctx_1)"
"((frame-id66_0) frame-id_0)"
"((def-ctx-scopes67_0) def-ctx-scopes_0)"
"((temp68_0)(reverse$1 val-idss_0))"
"((temp69_0)(reverse$1 val-keyss_0))"
"((temp70_0)(reverse$1 val-rhss_0))"
"((temp71_0)(reverse$1 track-stxs_0))"
"((temp72_0)(reverse$1 stx-clauses_0))"
"((temp73_0)(reverse$1 done-bodys_0))"
"((init-bodys74_0) init-bodys_0)"
"((s75_0) s_0)"
"((stratified?76_0) stratified?_0)"
"((name77_0) name_0)"
"((temp78_0)(reverse$1 trans-idss_0))"
"((temp79_0)(reverse$1 trans-stxs_0)))"
"(finish-expanding-body31.1"
" temp78_0"
" temp79_0"
" name77_0"
" init-bodys74_0"
" s75_0"
" stratified?76_0"
" body-ctx65_0"
" frame-id66_0"
" def-ctx-scopes67_0"
" temp68_0"
" temp69_0"
" temp70_0"
" temp71_0"
" temp72_0"
" temp73_0)))"
"(let-values()"
"(let-values(((rest-bodys_0)(cdr bodys_1)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-body_0)"
"(let-values(((temp80_0)(car bodys_1))"
"((temp81_0)"
"(if(if name_0"
"(null?"
"(cdr bodys_1))"
" #f)"
"(let-values(((v_0)"
" body-ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((name82_0)"
" name_0)"
"((inner83_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner83_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
" name82_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                       \"expand-context/outer?\""
" the-struct_0))))"
" body-ctx_1)))"
"(expand9.1"
" #f"
" #f"
" #f"
" temp80_0"
" temp81_0))))"
"(let-values(((disarmed-exp-body_0)"
"(syntax-disarm$1 exp-body_0)))"
"(let-values(((tmp_0)"
"(core-form-sym"
" disarmed-exp-body_0"
" phase_0)))"
"(if(equal? tmp_0 'begin)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-begin)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 begin84_0 e85_0)"
"(let-values(((s_1)"
" disarmed-exp-body_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((begin84_0"
" e85_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((begin86_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((e87_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_4)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                           \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin86_0"
" e87_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                   \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin84_0"
" e85_0))))))"
"(let-values(((track_0)"
"(lambda(e_0)"
"(begin"
" 'track"
"(syntax-track-origin$1"
" e_0"
" exp-body_0)))))"
"(let-values(((splice-bodys_0)"
"(append"
"(map2 track_0 e85_0)"
" rest-bodys_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'splice"
" splice-bodys_0)))"
"(void)))"
"(loop_0"
" body-ctx_1"
" splice-bodys_0"
" done-bodys_0"
" val-idss_0"
" val-keyss_0"
" val-rhss_0"
" track-stxs_0"
" trans-idss_0"
" trans-stxs_0"
" stx-clauses_0"
" dups_0)))))))"
"(if(equal? tmp_0 'define-values)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-define-values)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" define-values88_0"
" id89_0"
" rhs90_0)"
"(let-values(((s_1)"
" disarmed-exp-body_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((define-values88_0"
" id89_0"
" rhs90_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((define-values91_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((id92_0"
" rhs93_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((id94_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id97_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_7)"
"(symbol?"
"(syntax-e$1"
" s_7))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_7)))"
" s_7"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                               \"not an identifier\""
" orig-s_0"
" s_7)))))"
"(cons"
" id97_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_1"
" rest_0)"
" id_1)))"
" id_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"(reverse$1"
" id_0))))))))"
"((rhs95_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((rhs96_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null?"
" s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                 \"bad syntax\""
" orig-s_0))))))"
"(values"
" rhs96_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
" id94_0"
" rhs95_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                         \"bad syntax\""
" orig-s_0))))))"
"(values"
" define-values91_0"
" id92_0"
" rhs93_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                     \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" define-values88_0"
" id89_0"
" rhs90_0))))))"
"(let-values(((ids_0)"
"(remove-use-site-scopes"
" id89_0"
" body-ctx_1)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-one"
"(datum->syntax$1"
" #f"
"(list"
" ids_0"
" rhs90_0)))))"
"(void)))"
"(values))))"
"(let-values(((new-dups_0)"
"(let-values(((ids98_0)"
" ids_0)"
"((phase99_0)"
" phase_0)"
"((exp-body100_0)"
" exp-body_0)"
"((dups101_0)"
" dups_0))"
"(check-no-duplicate-ids7.1"
" unsafe-undefined"
" ids98_0"
" phase99_0"
" exp-body100_0"
" dups101_0))))"
"(let-values(((counter_0)"
"(root-expand-context-counter"
" ctx_0)))"
"(let-values(((local-sym_0)"
"(if(expand-context-normalize-locals?"
" ctx_0)"
" 'loc"
" #f)))"
"(let-values(((keys_0)"
"(reverse$1"
"(let-values(((lst_0)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((id102_0)"
" id_0)"
"((phase103_0)"
" phase_0)"
"((counter104_0)"
" counter_0)"
"((frame-id105_0)"
" frame-id_0)"
"((exp-body106_0)"
" exp-body_0)"
"((local-sym107_0)"
" local-sym_0))"
"(add-local-binding!39.1"
" frame-id105_0"
" exp-body106_0"
" local-sym107_0"
" id102_0"
" phase103_0"
" counter104_0)))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values(((extended-env_0)"
"(let-values(((lst_0)"
" keys_0)"
"((lst_1)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_0"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_2)"
"(pair?"
" lst_3)"
" #f)"
"(let-values(((key_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((env_1)"
"(let-values(((env_1)"
" env_0))"
"(let-values(((env_2)"
"(let-values()"
"(env-extend"
" env_1"
" key_0"
"(local-variable1.1"
" id_0)))))"
"(values"
" env_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" env_1"
" rest_0"
" rest_1)"
" env_1)))"
" env_0)))))"
" for-loop_0)"
"(expand-context-env"
" body-ctx_1)"
" lst_0"
" lst_1)))))"
"(loop_0"
"(let-values(((v_0)"
" body-ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((env108_0)"
" extended-env_0)"
"((binding-layer109_0)"
"(maybe-increment-binding-layer_0"
" ids_0"
" body-ctx_1))"
"((inner110_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner110_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
" env108_0"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
" binding-layer109_0"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                        \"expand-context/outer?\""
" the-struct_0))))"
" rest-bodys_0"
" null"
"(cons"
" ids_0"
"(append"
"(reverse$1"
"(let-values(((lst_0)"
" done-bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((done-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" null)"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
" val-idss_0))"
"(cons"
" keys_0"
"(append"
"(reverse$1"
"(let-values(((lst_0)"
" done-bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((done-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" null)"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
" val-keyss_0))"
"(cons"
" rhs90_0"
"(append"
"(reverse$1"
"(let-values(((lst_0)"
" done-bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((done-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(no-binds"
" done-body_0"
" s_0"
" phase_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
" val-rhss_0))"
"(cons"
"(let-values(((body-ctx111_0)"
" body-ctx_1)"
"((exp-body112_0)"
" exp-body_0)"
"((temp113_0)"
" #t))"
"(keep-as-needed119.1"
" temp113_0"
" #f"
" #f"
" body-ctx111_0"
" exp-body112_0))"
"(append"
"(reverse$1"
"(let-values(((lst_0)"
" done-bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((done-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
" #f)"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
" track-stxs_0))"
" trans-idss_0"
" trans-stxs_0"
" stx-clauses_0"
" new-dups_0)))))))))))"
"(if(equal? tmp_0 'define-syntaxes)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prim-define-syntaxes)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" define-syntaxes114_0"
" id115_0"
" rhs116_0)"
"(let-values(((s_1)"
" disarmed-exp-body_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((define-syntaxes114_0"
" id115_0"
" rhs116_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((define-syntaxes117_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((id118_0"
" rhs119_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((id120_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                   \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id123_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_7)"
"(symbol?"
"(syntax-e$1"
" s_7))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_7)))"
" s_7"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                 \"not an identifier\""
" orig-s_0"
" s_7)))))"
"(cons"
" id123_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_1"
" rest_0)"
" id_1)))"
" id_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"(reverse$1"
" id_0))))))))"
"((rhs121_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((rhs122_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null?"
" s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                   \"bad syntax\""
" orig-s_0))))))"
"(values"
" rhs122_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                               \"bad syntax\""
" orig-s_0))))))"
"(values"
" id120_0"
" rhs121_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                           \"bad syntax\""
" orig-s_0))))))"
"(values"
" define-syntaxes117_0"
" id118_0"
" rhs119_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                       \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" define-syntaxes114_0"
" id115_0"
" rhs116_0))))))"
"(let-values(((ids_0)"
"(remove-use-site-scopes"
" id115_0"
" body-ctx_1)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-one"
"(datum->syntax$1"
" #f"
"(list"
" ids_0"
" rhs116_0)))))"
"(void)))"
"(values))))"
"(let-values(((new-dups_0)"
"(let-values(((ids124_0)"
" ids_0)"
"((phase125_0)"
" phase_0)"
"((exp-body126_0)"
" exp-body_0)"
"((dups127_0)"
" dups_0))"
"(check-no-duplicate-ids7.1"
" unsafe-undefined"
" ids124_0"
" phase125_0"
" exp-body126_0"
" dups127_0))))"
"(let-values(((counter_0)"
"(root-expand-context-counter"
" ctx_0)))"
"(let-values(((local-sym_0)"
"(if(expand-context-normalize-locals?"
" ctx_0)"
" 'mac"
" #f)))"
"(let-values(((keys_0)"
"(reverse$1"
"(let-values(((lst_0)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((id128_0)"
" id_0)"
"((phase129_0)"
" phase_0)"
"((counter130_0)"
" counter_0)"
"((frame-id131_0)"
" frame-id_0)"
"((exp-body132_0)"
" exp-body_0)"
"((local-sym133_0)"
" local-sym_0))"
"(add-local-binding!39.1"
" frame-id131_0"
" exp-body132_0"
" local-sym133_0"
" id128_0"
" phase129_0"
" counter130_0)))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prepare-env)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(prepare-next-phase-namespace"
" ctx_0)"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-bind)))"
"(void)))"
"(values))))"
"(let-values(((vals_0)"
"(eval-for-syntaxes-binding"
" 'define-syntaxes"
" rhs116_0"
" ids_0"
" body-ctx_1)))"
"(let-values(((extended-env_0)"
"(let-values(((lst_0)"
" keys_0)"
"((lst_1)"
" vals_0)"
"((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_0"
" lst_3"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_3)"
"(if(pair?"
" lst_4)"
"(pair?"
" lst_5)"
" #f)"
" #f)"
"(let-values(((key_0)"
"(unsafe-car"
" lst_3))"
"((rest_0)"
"(unsafe-cdr"
" lst_3))"
"((val_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((id_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((env_1)"
"(let-values(((env_1)"
" env_0))"
"(let-values(((env_2)"
"(let-values()"
"(begin"
"(maybe-install-free=id-in-context!"
" val_0"
" id_0"
" phase_0"
" body-ctx_1)"
"(env-extend"
" env_1"
" key_0"
" val_0)))))"
"(values"
" env_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" env_1"
" rest_0"
" rest_1"
" rest_2)"
" env_1)))"
" env_0)))))"
" for-loop_0)"
"(expand-context-env"
" body-ctx_1)"
" lst_0"
" lst_1"
" lst_2)))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-bind)))"
"(void)))"
"(loop_0"
"(let-values(((v_0)"
" body-ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((env134_0)"
" extended-env_0)"
"((binding-layer135_0)"
"(maybe-increment-binding-layer_0"
" ids_0"
" body-ctx_1))"
"((inner136_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner136_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
" env134_0"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
" binding-layer135_0"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                    \"expand-context/outer?\""
" the-struct_0))))"
" rest-bodys_0"
" done-bodys_0"
" val-idss_0"
" val-keyss_0"
" val-rhss_0"
" track-stxs_0"
"(cons"
" ids_0"
" trans-idss_0)"
"(cons"
"(let-values(((body-ctx137_0)"
" body-ctx_1)"
"((exp-body138_0)"
" exp-body_0)"
"((temp139_0)"
" #t))"
"(keep-as-needed119.1"
" temp139_0"
" #f"
" #f"
" body-ctx137_0"
" exp-body138_0))"
" trans-stxs_0)"
"(cons"
"(datum->syntax$1"
" #f"
"(list"
" ids_0"
" rhs116_0)"
" exp-body_0)"
" stx-clauses_0)"
" new-dups_0))))))))))))))))"
"(let-values()"
"(if stratified?_0"
"(let-values()"
"(begin"
"(if(null? done-bodys_0)"
"(void)"
"(let-values()"
"(error"
"                                                                                           \"internal error: accumulated expressions not empty\")))"
"(loop_0"
" body-ctx_1"
" null"
"(if(if(null? val-idss_0)"
"(null? trans-idss_0)"
" #f)"
"(reverse$1"
"(cons"
" exp-body_0"
" rest-bodys_0))"
"(list"
"(datum->syntax$1"
" #f"
"(cons"
"(core-id"
" '#%stratified-body"
" phase_0)"
"(cons"
" exp-body_0"
" rest-bodys_0)))))"
" val-idss_0"
" val-keyss_0"
" val-rhss_0"
" track-stxs_0"
" trans-idss_0"
" trans-stxs_0"
" stx-clauses_0"
" dups_0)))"
"(let-values()"
"(loop_0"
" body-ctx_1"
" rest-bodys_0"
"(cons exp-body_0 done-bodys_0)"
" val-idss_0"
" val-keyss_0"
" val-rhss_0"
" track-stxs_0"
" trans-idss_0"
" trans-stxs_0"
" stx-clauses_0"
" dups_0))))))))))))))))))"
" loop_0)"
" body-ctx_0"
" init-bodys_0"
" null"
" null"
" null"
" null"
" null"
" null"
" null"
" null"
"(make-check-no-duplicate-table))))))))))))))))))))"
"(define-values"
"(finish-expanding-body31.1)"
"(lambda(disappeared-transformer-bindings14_0"
" disappeared-transformer-forms15_0"
" name13_0"
" original-bodys10_0"
" source11_0"
" stratified?12_0"
" body-ctx22_0"
" frame-id23_0"
" def-ctx-scopes24_0"
" val-idss25_0"
" val-keyss26_0"
" val-rhss27_0"
" track-stxs28_0"
" stx-clauses29_0"
" done-bodys30_0)"
"(begin"
" 'finish-expanding-body31"
"(let-values(((body-ctx_0) body-ctx22_0))"
"(let-values(((frame-id_0) frame-id23_0))"
"(let-values(((def-ctx-scopes_0) def-ctx-scopes24_0))"
"(let-values(((val-idss_0) val-idss25_0))"
"(let-values(((val-keyss_0) val-keyss26_0))"
"(let-values(((val-rhss_0) val-rhss27_0))"
"(let-values(((track-stxs_0) track-stxs28_0))"
"(let-values(((stx-clauses_0) stx-clauses29_0))"
"(let-values(((done-bodys_0) done-bodys30_0))"
"(let-values(((init-bodys_0) original-bodys10_0))"
"(let-values(((s_0) source11_0))"
"(let-values(((stratified?_0) stratified?12_0))"
"(let-values(((name_0) name13_0))"
"(let-values(((disappeared-transformer-bindings_0)"
" disappeared-transformer-bindings14_0))"
"(let-values(((disappeared-transformer-forms_0) disappeared-transformer-forms15_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(null? done-bodys_0)"
"(let-values()"
"(raise-syntax-error$1"
"                                                           (string->symbol \"begin (possibly implicit)\")"
"                                                           \"no expression after a sequence of internal definitions\""
"(datum->syntax$1 #f(cons 'begin init-bodys_0) s_0)"
" #f"
" init-bodys_0))"
"(void))"
"(values))))"
"(let-values(((finish-ctx_0)"
"(let-values(((v_0)"
"(accumulate-def-ctx-scopes"
" body-ctx_0"
" def-ctx-scopes_0)))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context140_0) 'expression)"
"((use-site-scopes141_0)(box null))"
"((scopes142_0)"
"(append"
"(unbox"
"(root-expand-context-use-site-scopes"
" body-ctx_0))"
"(expand-context-scopes body-ctx_0)))"
"((only-immediate?143_0) #f)"
"((def-ctx-scopes144_0) #f)"
"((post-expansion145_0) #f)"
"((inner146_0)"
"(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner146_0"
" post-expansion145_0"
" use-site-scopes141_0"
"(root-expand-context/outer-frame-id the-struct_0)"
" context140_0"
"(expand-context/outer-env the-struct_0)"
" scopes142_0"
" def-ctx-scopes144_0"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
" only-immediate?143_0"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                             \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((finish-bodys_0)"
"(lambda()"
"(begin"
" 'finish-bodys"
"(let-values(((block->list?_0)(null? val-idss_0)))"
"(let-values((()"
"(begin"
"(if block->list?_0"
"(void)"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void)))))"
"(values))))"
"(let-values(((last-i_0)(sub1(length done-bodys_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-list"
"(datum->syntax$1"
" #f"
" done-bodys_0))))"
"(void)))"
"(values))))"
"(let-values(((exp-bodys_0)"
"(reverse$1"
"(let-values(((lst_0) done-bodys_0)"
"((start_0) 0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-naturals start_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1"
" pos_0)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_1)"
" #t"
" #f)"
"(let-values(((done-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1))"
"((i_0)"
" pos_0))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(let-values(((done-body147_0)"
" done-body_0)"
"((temp148_0)"
"(if(if name_0"
"(="
" i_0"
" last-i_0)"
" #f)"
"(let-values(((v_0)"
" finish-ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((name149_0)"
" name_0)"
"((inner150_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner150_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
" name149_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                             \"expand-context/outer?\""
" the-struct_0))))"
" finish-ctx_0)))"
"(expand9.1"
" #f"
" #f"
" #f"
" done-body147_0"
" temp148_0))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0"
"(+"
" pos_0"
" 1))"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" start_0))))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-list"
"(datum->syntax$1 #f exp-bodys_0))))"
"(void)))"
"(reference-record-clear! frame-id_0)"
" exp-bodys_0))))))))))"
"(if(if(null? val-idss_0)(null? disappeared-transformer-bindings_0) #f)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer finish-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'block->list"
"(datum->syntax$1 s_0 done-bodys_0))))"
"(void)))"
"(finish-bodys_0)))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer finish-ctx_0)))"
"(if obs_0"
"(let-values()"
"(log-letrec-values$1"
" obs_0"
" finish-ctx_0"
" s_0"
" val-idss_0"
" val-rhss_0"
" track-stxs_0"
" stx-clauses_0"
" done-bodys_0))"
"(void)))"
"(values))))"
"(let-values(((exp-s_0)"
"(let-values(((val-idss151_0) val-idss_0)"
"((val-keyss152_0) val-keyss_0)"
"((val-rhss153_0) val-rhss_0)"
"((track-stxs154_0) track-stxs_0)"
"((temp155_0)(not stratified?_0))"
"((frame-id156_0) frame-id_0)"
"((finish-ctx157_0) finish-ctx_0)"
"((s158_0) s_0)"
"((temp159_0)(pair? stx-clauses_0))"
"((finish-bodys160_0) finish-bodys_0)"
"((temp161_0) #f))"
"(expand-and-split-bindings-by-reference52.1"
" finish-ctx157_0"
" frame-id156_0"
" finish-bodys160_0"
" temp159_0"
" s158_0"
" temp155_0"
" temp161_0"
" val-idss151_0"
" val-keyss152_0"
" val-rhss153_0"
" track-stxs154_0))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'exit-prim exp-s_0)"
"(call-expand-observe obs_0 'return exp-s_0))))"
"(void)))"
"(if(expand-context-to-parsed? body-ctx_0)"
"(list exp-s_0)"
"(let-values(((exp-s_1)"
"(attach-disappeared-transformer-bindings"
" exp-s_0"
" disappeared-transformer-bindings_0)))"
"(list"
"(let-values(((lst_0) disappeared-transformer-forms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(exp-s_2 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((form_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((exp-s_3)"
"(let-values(((exp-s_3)"
" exp-s_2))"
"(if form_0"
"(let-values(((exp-s_4)"
" exp-s_3))"
"(let-values(((exp-s_5)"
"(let-values()"
"(syntax-track-origin$1"
" exp-s_4"
" form_0))))"
"(values"
" exp-s_5)))"
" exp-s_3))))"
"(if(not #f)"
"(for-loop_0 exp-s_3 rest_0)"
" exp-s_3)))"
" exp-s_2)))))"
" for-loop_0)"
" exp-s_1"
" lst_0)))))))))))))))))))))))))))))))))"
"(define-values"
"(expand-and-split-bindings-by-reference52.1)"
"(lambda(ctx36_0"
" frame-id35_0"
" get-body39_0"
" had-stxes?38_0"
" source37_0"
" split?34_0"
" track?40_0"
" idss48_0"
" keyss49_0"
" rhss50_0"
" track-stxs51_0)"
"(begin"
" 'expand-and-split-bindings-by-reference52"
"(let-values(((idss_0) idss48_0))"
"(let-values(((keyss_0) keyss49_0))"
"(let-values(((rhss_0) rhss50_0))"
"(let-values(((track-stxs_0) track-stxs51_0))"
"(let-values(((split?_0) split?34_0))"
"(let-values(((frame-id_0) frame-id35_0))"
"(let-values(((ctx_0) ctx36_0))"
"(let-values(((s_0) source37_0))"
"(let-values(((had-stxes?_0) had-stxes?38_0))"
"(let-values(((get-body_0) get-body39_0))"
"(let-values(((track?_0) track?40_0))"
"(let-values()"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"((letrec-values(((loop_0)"
"(lambda(idss_1"
" keyss_1"
" rhss_1"
" track-stxs_1"
" accum-idss_0"
" accum-keyss_0"
" accum-rhss_0"
" accum-track-stxs_0"
" track?_1"
" get-list?_0"
" can-log?_0)"
"(begin"
" 'loop"
"(if(null? idss_1)"
"(let-values()"
"(if(if(null? accum-idss_0) get-list?_0 #f)"
"(let-values()(get-body_0))"
"(let-values()"
"(let-values(((exp-body_0)(get-body_0)))"
"(let-values(((result-s_0)"
"(if(expand-context-to-parsed? ctx_0)"
"(if(null? accum-idss_0)"
"(parsed-let-values17.1"
"(keep-properties-only s_0)"
" null"
" null"
" exp-body_0)"
"(parsed-letrec-values18.1"
"(keep-properties-only s_0)"
"(reverse$1 accum-idss_0)"
"(reverse$1"
"(map2"
" list"
" accum-keyss_0"
" accum-rhss_0))"
" exp-body_0))"
"(let-values(((track?162_0) track?_1)"
"((s163_0) s_0)"
"((temp164_0)"
"(list*"
"(if(null? accum-idss_0)"
"(core-id"
" 'let-values"
" phase_0)"
"(core-id"
" 'letrec-values"
" phase_0))"
"(build-clauses"
" accum-idss_0"
" accum-rhss_0"
" accum-track-stxs_0)"
" exp-body_0)))"
"(rebuild5.1"
" track?162_0"
" s163_0"
" temp164_0)))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(if can-log?_0"
"(log-tag? had-stxes?_0 ctx_0)"
" #f)"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'tag"
" result-s_0))"
"(void)))"
"(void)))"
"(if get-list?_0(list result-s_0) result-s_0)))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values(((ids_0)(car idss_1)))"
"(let-values(((expanded-rhs_0)"
"(let-values(((temp165_0)(car rhss_1))"
"((temp166_0)"
"(as-named-context"
" ctx_0"
" ids_0)))"
"(expand9.1"
" #f"
" #f"
" #f"
" temp165_0"
" temp166_0))))"
"(let-values(((track-stx_0)(car track-stxs_1)))"
"(let-values(((local-or-forward-references?_0)"
"(reference-record-forward-references?"
" frame-id_0)))"
"(let-values((()"
"(begin"
"(reference-record-bound!"
" frame-id_0"
"(car keyss_1))"
"(values))))"
"(let-values(((forward-references?_0)"
"(reference-record-forward-references?"
" frame-id_0)))"
"(if(if(not local-or-forward-references?_0)"
" split?_0"
" #f)"
"(let-values()"
"(let-values((()"
"(begin"
"(if(null? accum-idss_0)"
"(void)"
"(let-values()"
"(error"
"                                                                                                 \"internal error: accumulated ids not empty\")))"
"(values))))"
"(let-values(((exp-rest_0)"
"(loop_0"
"(cdr idss_1)"
"(cdr keyss_1)"
"(cdr rhss_1)"
"(cdr track-stxs_1)"
" null"
" null"
" null"
" null"
" #f"
" #t"
" #f)))"
"(let-values(((result-s_0)"
"(if(expand-context-to-parsed?"
" ctx_0)"
"(parsed-let-values17.1"
"(keep-properties-only"
" s_0)"
"(list ids_0)"
"(list"
"(list"
"(car keyss_1)"
" expanded-rhs_0))"
" exp-rest_0)"
"(let-values(((track?167_0)"
" track?_1)"
"((s168_0)"
" s_0)"
"((temp169_0)"
"(list*"
"(core-id"
" 'let-values"
" phase_0)"
"(list"
"(build-clause"
" ids_0"
" expanded-rhs_0"
" track-stx_0))"
" exp-rest_0)))"
"(rebuild5.1"
" track?167_0"
" s168_0"
" temp169_0)))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(if can-log?_0"
"(log-tag?"
" had-stxes?_0"
" ctx_0)"
" #f)"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'tag"
" result-s_0))"
"(void)))"
"(void)))"
"(if get-list?_0"
"(list result-s_0)"
" result-s_0))))))"
"(if(if(not forward-references?_0)"
"(let-values(((or-part_0) split?_0))"
"(if or-part_0"
" or-part_0"
"(null?(cdr idss_1))))"
" #f)"
"(let-values()"
"(let-values(((exp-rest_0)"
"(loop_0"
"(cdr idss_1)"
"(cdr keyss_1)"
"(cdr rhss_1)"
"(cdr track-stxs_1)"
" null"
" null"
" null"
" null"
" #f"
" #t"
" #f)))"
"(let-values(((result-s_0)"
"(if(expand-context-to-parsed?"
" ctx_0)"
"(parsed-letrec-values18.1"
"(keep-properties-only"
" s_0)"
"(reverse$1"
"(cons"
" ids_0"
" accum-idss_0))"
"(reverse$1"
"(cons"
"(list"
"(car keyss_1)"
" expanded-rhs_0)"
"(map2"
" list"
" accum-keyss_0"
" accum-rhss_0)))"
" exp-rest_0)"
"(let-values(((track?170_0)"
" track?_1)"
"((s171_0)"
" s_0)"
"((temp172_0)"
"(list*"
"(core-id"
" 'letrec-values"
" phase_0)"
"(build-clauses"
"(cons"
" ids_0"
" accum-idss_0)"
"(cons"
" expanded-rhs_0"
" accum-rhss_0)"
"(cons"
" track-stx_0"
" accum-track-stxs_0))"
" exp-rest_0)))"
"(rebuild5.1"
" track?170_0"
" s171_0"
" temp172_0)))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(if can-log?_0"
"(log-tag?"
" had-stxes?_0"
" ctx_0)"
" #f)"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'tag"
" result-s_0))"
"(void)))"
"(void)))"
"(if get-list?_0"
"(list result-s_0)"
" result-s_0)))))"
"(let-values()"
"(loop_0"
"(cdr idss_1)"
"(cdr keyss_1)"
"(cdr rhss_1)"
"(cdr track-stxs_1)"
"(cons ids_0 accum-idss_0)"
"(cons(car keyss_1) accum-keyss_0)"
"(cons expanded-rhs_0 accum-rhss_0)"
"(cons track-stx_0 accum-track-stxs_0)"
" track?_1"
" get-list?_0"
" can-log?_0)))))))))))))))))"
" loop_0)"
" idss_0"
" keyss_0"
" rhss_0"
" track-stxs_0"
" null"
" null"
" null"
" null"
" track?_0"
" #f"
" #t)))))))))))))))))"
"(define-values"
"(build-clauses)"
"(lambda(accum-idss_0 accum-rhss_0 accum-track-stxs_0)"
"(begin(map2 build-clause(reverse$1 accum-idss_0)(reverse$1 accum-rhss_0)(reverse$1 accum-track-stxs_0)))))"
"(define-values"
"(build-clause)"
"(lambda(ids_0 rhs_0 track-stx_0)"
"(begin"
"(let-values(((clause_0)(datum->syntax$1 #f(list ids_0 rhs_0))))"
"(if track-stx_0(syntax-track-origin$1 clause_0 track-stx_0) clause_0)))))"
"(define-values"
"(no-binds)"
"(lambda(expr_0 s_0 phase_0)"
"(begin"
"(let-values(((s-runtime-stx_0)(syntax-shift-phase-level$1 runtime-stx phase_0)))"
"(datum->syntax$1"
"(core-id '#%app phase_0)"
"(list(core-id 'begin phase_0) expr_0(list(datum->syntax$1 s-runtime-stx_0 'values)))"
" s_0)))))"
"(define-values"
"(log-tag?)"
"(lambda(had-stxes?_0 ctx_0)(begin(if had-stxes?_0(not(expand-context-only-immediate? ctx_0)) #f))))"
"(define-values"
"(log-letrec-values$1)"
"(lambda(obs_0 ctx_0 s_0 val-idss_0 val-rhss_0 track-stxs_0 stx-clauses_0 done-bodys_0)"
"(begin"
" 'log-letrec-values"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((clauses_0)"
"(reverse$1"
"(let-values(((lst_0) val-idss_0)((lst_1) val-rhss_0)((lst_2) track-stxs_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_3 lst_4 lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_3)(if(pair? lst_4)(pair? lst_5) #f) #f)"
"(let-values(((val-ids_0)(unsafe-car lst_3))"
"((rest_0)(unsafe-cdr lst_3))"
"((val-rhs_0)(unsafe-car lst_4))"
"((rest_1)(unsafe-cdr lst_4))"
"((track-stx_0)(unsafe-car lst_5))"
"((rest_2)(unsafe-cdr lst_5)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(datum->syntax$1"
" #f"
"(list val-ids_0 val-rhs_0)"
" track-stx_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0 rest_1 rest_2)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1"
" lst_2))))))"
"(let-values(((had-stxes?_0)(not(null? stx-clauses_0))))"
"(let-values(((lv-id_0)(core-id(if had-stxes?_0 'letrec-syntaxes+values 'letrec-values) phase_0)))"
"(let-values(((lv-s_0)"
"(datum->syntax$1"
" #f"
"(if had-stxes?_0"
"(list* lv-id_0 stx-clauses_0 clauses_0 done-bodys_0)"
"(list* lv-id_0 clauses_0 done-bodys_0))"
" s_0)))"
"(begin"
"(call-expand-observe obs_0 'block->letrec(list lv-s_0))"
"(call-expand-observe obs_0 'visit lv-s_0)"
"(call-expand-observe obs_0 'resolve lv-id_0)"
"(call-expand-observe obs_0 'enter-prim lv-s_0)"
"(if had-stxes?_0"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'prim-letrec-syntaxes+values)"
"(call-expand-observe"
" obs_0"
" 'letrec-syntaxes-renames"
" stx-clauses_0"
" clauses_0"
"(datum->syntax$1 #f done-bodys_0 s_0))"
"(call-expand-observe obs_0 'prepare-env)"
"(call-expand-observe obs_0 'next-group)"
"(if(null? val-idss_0)"
"(void)"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'prim-letrec-values)"
"(call-expand-observe"
" obs_0"
" 'let-renames"
" clauses_0"
"(datum->syntax$1 #f done-bodys_0 s_0)))))))"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'prim-letrec-values)"
"(call-expand-observe"
" obs_0"
" 'let-renames"
" clauses_0"
"(datum->syntax$1 #f done-bodys_0 s_0))))))))))))))"
"(define-values"
"(lambda-clause-expander)"
"(lambda(s_0 disarmed-s_0 formals_0 bodys_0 ctx_0 log-renames-tag_0)"
"(begin"
"(let-values(((sc_0)(new-scope 'local)))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((ids_0)(parse-and-flatten-formals formals_0 sc_0 disarmed-s_0)))"
"(let-values((()"
"(begin"
"(let-values(((ids33_0) ids_0)"
"((phase34_0) phase_0)"
"((s35_0) s_0)"
"                                         ((temp36_0) \"argument name\"))"
"(check-no-duplicate-ids7.1 temp36_0 ids33_0 phase34_0 s35_0 unsafe-undefined))"
"(values))))"
"(let-values(((counter_0)(root-expand-context-counter ctx_0)))"
"(let-values(((local-sym_0)(if(expand-context-normalize-locals? ctx_0) 'arg #f)))"
"(let-values(((keys_0)"
"(reverse$1"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((id37_0)"
" id_0)"
"((phase38_0)"
" phase_0)"
"((counter39_0)"
" counter_0)"
"((s40_0)"
" s_0)"
"((local-sym41_0)"
" local-sym_0))"
"(add-local-binding!39.1"
" #f"
" s40_0"
" local-sym41_0"
" id37_0"
" phase38_0"
" counter39_0)))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values(((body-env_0)"
"(let-values(((lst_0) keys_0)((lst_1) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((key_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((id_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((env_1)"
"(let-values(((env_1) env_0))"
"(let-values(((env_2)"
"(let-values()"
"(env-extend"
" env_1"
" key_0"
"(local-variable1.1"
" id_0)))))"
"(values env_2)))))"
"(if(not #f)(for-loop_0 env_1 rest_0 rest_1) env_1)))"
" env_0)))))"
" for-loop_0)"
"(expand-context-env ctx_0)"
" lst_0"
" lst_1)))))"
"(let-values(((sc-formals_0)(add-scope formals_0 sc_0)))"
"(let-values(((sc-bodys_0)"
"(reverse$1"
"(let-values(((lst_0) bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" body_0"
" sc_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" log-renames-tag_0"
" sc-formals_0"
"(datum->syntax$1 #f sc-bodys_0))))"
"(void)))"
"(values))))"
"(let-values(((body-ctx_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((env42_0) body-env_0)"
"((scopes43_0)(cons sc_0(expand-context-scopes ctx_0)))"
"((binding-layer44_0)"
"(increment-binding-layer ids_0 ctx_0 sc_0))"
"((frame-id45_0) #f)"
"((inner46_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner46_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
" frame-id45_0"
"(expand-context/outer-context the-struct_0)"
" env42_0"
" scopes43_0"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
" binding-layer44_0"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                 \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((exp-body_0)"
"(let-values(((sc-bodys47_0) sc-bodys_0)"
"((body-ctx48_0) body-ctx_0)"
"((temp49_0)"
"(let-values(((ctx50_0) ctx_0)((s51_0) s_0)((temp52_0) #t))"
"(keep-as-needed119.1 #f temp52_0 #f ctx50_0 s51_0))))"
"(expand-body7.1 temp49_0 #f sc-bodys47_0 body-ctx48_0))))"
"(values"
"(if(expand-context-to-parsed? ctx_0)"
"(unflatten-like-formals keys_0 formals_0)"
" sc-formals_0)"
" exp-body_0)))))))))))))))))"
"(void"
"(add-core-form!*"
" 'lambda"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-lambda)))(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 lambda53_0 formals54_0 body55_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((lambda53_0 formals54_0 body55_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((lambda56_0)(let-values(((s_3)(car s_2))) s_3))"
"((formals57_0 body58_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((formals59_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"((body60_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                          \"bad syntax\""
" orig-s_0))"
"(if(null? flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                            \"bad syntax\""
" orig-s_0))"
"(let-values() flat-s_0))))))))"
"(values formals59_0 body60_0))"
"                                                                 (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values lambda56_0 formals57_0 body58_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t lambda53_0 formals54_0 body55_0))))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx61_0) ctx_0)((s62_0) s_0)((temp63_0) #t))"
"(keep-as-needed119.1 #f #f temp63_0 ctx61_0 s62_0))))"
"(let-values(((formals_0 body_0)"
"(lambda-clause-expander s_0 disarmed-s_0 formals54_0 body55_0 ctx_0 'lambda-renames)))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-lambda5.1 rebuild-s_0 formals_0 body_0)"
"(let-values(((rebuild-s64_0) rebuild-s_0)((temp65_0)(list* lambda53_0 formals_0 body_0)))"
"(rebuild5.1 #t rebuild-s64_0 temp65_0)))))))))))"
"(void"
"(add-core-form!*"
" 'λ"
"(lambda(s_0)"
"(let-values(((ok?_0 lam-id66_0 formals67_0 _68_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((lam-id66_0 formals67_0 _68_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((lam-id69_0)(let-values(((s_3)(car s_2))) s_3))"
"((formals70_0 _71_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((formals72_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"((_73_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1 s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                      \"bad syntax\""
" orig-s_0))"
"(if(null? flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                        \"bad syntax\""
" orig-s_0))"
"(let-values() flat-s_0))))))))"
"(values formals72_0 _73_0))"
"                                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values lam-id69_0 formals70_0 _71_0))"
"                                         (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t lam-id66_0 formals67_0 _68_0))))))"
"(let-values(((ids_0)(parse-and-flatten-formals formals67_0 #f s_0)))"
"(let-values(((ctx_0)(let-values(((temp78_0) #t))(get-current-expand-context18.1 temp78_0 'unexpected))))"
"(let-values(((phase_0)(if ctx_0(expand-context-phase ctx_0) 0)))"
"(begin"
"               (let-values (((ids74_0) ids_0) ((phase75_0) phase_0) ((s76_0) s_0) ((temp77_0) \"argument name\"))"
"(check-no-duplicate-ids7.1 temp77_0 ids74_0 phase75_0 s76_0 unsafe-undefined))"
"(datum->syntax$1"
" s_0"
"(cons"
"(datum->syntax$1(syntax-shift-phase-level$1 core-stx phase_0) 'lambda lam-id66_0 lam-id66_0)"
"(cdr(syntax-e$1 s_0)))"
" s_0"
" s_0)))))))))"
"(void"
"(add-core-form!*"
" 'case-lambda"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-case-lambda)))(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 case-lambda79_0 formals80_0 body81_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((case-lambda79_0 formals80_0 body81_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((case-lambda82_0)(let-values(((s_3)(car s_2))) s_3))"
"((formals83_0 body84_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                     (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values()"
"(let-values(((formals_0 body_0)"
"(let-values(((lst_0) flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(formals_0"
" body_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_5)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((formals_1"
" body_1)"
"(let-values(((formals_1)"
" formals_0)"
"((body_1)"
" body_0))"
"(let-values(((formals_2"
" body_2)"
"(let-values()"
"(let-values(((formals91_0"
" body92_0)"
"(let-values()"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((formals85_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"((body86_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_1)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_1)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                              \"bad syntax\""
" orig-s_0))"
"(if(null?"
" flat-s_1)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_1))))))))"
"(values"
" formals85_0"
" body86_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                      \"bad syntax\""
" orig-s_0))))))"
"(values"
"(cons"
" formals91_0"
" formals_1)"
"(cons"
" body92_0"
" body_1))))))"
"(values"
" formals_2"
" body_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" formals_1"
" body_1"
" rest_0)"
"(values"
" formals_1"
" body_1))))"
"(values"
" formals_0"
" body_0))))))"
" for-loop_0)"
" null"
" null"
" lst_0)))))"
"(values"
"(reverse$1 formals_0)"
"(reverse$1 body_0))))))))))"
"(values case-lambda82_0 formals83_0 body84_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t case-lambda79_0 formals80_0 body81_0))))))"
"(let-values(((ok?_1 case-lambda87_0 clause88_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((case-lambda87_0 clause88_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((case-lambda89_0)(let-values(((s_3)(car s_2))) s_3))"
"((clause90_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                       (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0)))))))"
"(values case-lambda89_0 clause90_0))"
"                                               (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t case-lambda87_0 clause88_0))))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx93_0) ctx_0)((s94_0) s_0)((temp95_0) #t))"
"(keep-as-needed119.1 #f #f temp95_0 ctx93_0 s94_0))))"
"(let-values(((clauses_0)"
"(reverse$1"
"(let-values(((lst_0) formals80_0)((lst_1) body81_0)((lst_2) clause88_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_3 lst_4 lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_3)(if(pair? lst_4)(pair? lst_5) #f) #f)"
"(let-values(((formals_0)(unsafe-car lst_3))"
"((rest_0)(unsafe-cdr lst_3))"
"((body_0)(unsafe-car lst_4))"
"((rest_1)(unsafe-cdr lst_4))"
"((clause_0)(unsafe-car lst_5))"
"((rest_2)(unsafe-cdr lst_5)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((rebuild-clause_0)"
"(let-values(((ctx96_0)"
" ctx_0)"
"((clause97_0)"
" clause_0))"
"(keep-as-needed119.1"
" #f"
" #f"
" #f"
" ctx96_0"
" clause97_0))))"
"(let-values(((exp-formals_0"
" exp-body_0)"
"(lambda-clause-expander"
" s_0"
" disarmed-s_0"
" formals_0"
" body_0"
" ctx_0"
" 'lambda-renames)))"
"(if(expand-context-to-parsed?"
" ctx_0)"
"(list"
" exp-formals_0"
" exp-body_0)"
"(let-values(((rebuild-clause98_0)"
" rebuild-clause_0)"
"((temp99_0)"
"(list*"
" exp-formals_0"
" exp-body_0)))"
"(rebuild5.1"
" #t"
" rebuild-clause98_0"
" temp99_0)))))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0 rest_1 rest_2)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1"
" lst_2))))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-case-lambda6.1 rebuild-s_0 clauses_0)"
"(let-values(((rebuild-s100_0) rebuild-s_0)((temp101_0)(list* case-lambda79_0 clauses_0)))"
"(rebuild5.1 #t rebuild-s100_0 temp101_0))))))))))))"
"(define-values"
"(parse-and-flatten-formals)"
"(lambda(all-formals_0 sc_0 s_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(formals_0)"
"(begin"
" 'loop"
"(if(identifier? formals_0)"
"(let-values()(list(add-scope formals_0 sc_0)))"
"(if(syntax?$1 formals_0)"
"(let-values()"
"(let-values(((p_0)(syntax-e$1 formals_0)))"
"(if(pair? p_0)"
"(let-values()(loop_0 p_0))"
"(if(null? p_0)"
"(let-values() null)"
"                                        (let-values () (raise-syntax-error$1 #f \"not an identifier\" s_0 p_0))))))"
"(if(pair? formals_0)"
"(let-values()"
"(begin"
"(if(identifier?(car formals_0))"
"(void)"
"(let-values()"
"                                          (raise-syntax-error$1 #f \"not an identifier\" s_0 (car formals_0))))"
"(cons"
"(if sc_0(add-scope(car formals_0) sc_0)(car formals_0))"
"(loop_0(cdr formals_0)))))"
"(if(null? formals_0)"
"(let-values() null)"
"(let-values()"
"                                      (raise-syntax-error$1 \"bad argument sequence\" s_0 all-formals_0))))))))))"
" loop_0)"
" all-formals_0))))"
"(define-values"
"(unflatten-like-formals)"
"(lambda(keys_0 formals_0)"
"(begin"
"((letrec-values(((loop_0)"
"(lambda(keys_1 formals_1)"
"(begin"
" 'loop"
"(if(null? formals_1)"
"(let-values() null)"
"(if(pair? formals_1)"
"(let-values()(cons(car keys_1)(loop_0(cdr keys_1)(cdr formals_1))))"
"(if(syntax?$1 formals_1)"
"(let-values()(loop_0 keys_1(syntax-e$1 formals_1)))"
"(let-values()(car keys_1)))))))))"
" loop_0)"
" keys_0"
" formals_0))))"
"(define-values"
"(make-let-values-form11.1)"
"(lambda(log-tag1_0 rec?3_0 renames-log-tag5_0 split-by-reference?4_0 syntaxes?2_0)"
"(begin"
" 'make-let-values-form11"
"(let-values(((log-tag_0) log-tag1_0))"
"(let-values(((syntaxes?_0) syntaxes?2_0))"
"(let-values(((rec?_0) rec?3_0))"
"(let-values(((split-by-reference?_0) split-by-reference?4_0))"
"(let-values(((renames-log-tag_0) renames-log-tag5_0))"
"(let-values()"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 log-tag_0)))"
"(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0"
" letrec-syntaxes+values102_0"
" id:trans103_0"
" trans-rhs104_0"
" id:val105_0"
" val-rhs106_0"
" body107_0)"
"(let-values(((s_1) disarmed-s_0))"
"(if(if syntaxes?_0 #t #f)"
"(let-values(((orig-s_0) s_1))"
"(let-values(((letrec-syntaxes+values102_0"
" id:trans103_0"
" trans-rhs104_0"
" id:val105_0"
" val-rhs106_0"
" body107_0)"
"(let-values(((s_2)"
"(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((letrec-syntaxes+values108_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((id:trans109_0"
" trans-rhs110_0"
" id:val111_0"
" val-rhs112_0"
" body113_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((id:trans114_0"
" trans-rhs115_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                           \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:trans_0"
" trans-rhs_0)"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id:trans_0"
" trans-rhs_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id:trans_1"
" trans-rhs_1)"
"(let-values(((id:trans_1)"
" id:trans_0)"
"((trans-rhs_1)"
" trans-rhs_0))"
"(let-values(((id:trans_2"
" trans-rhs_2)"
"(let-values()"
"(let-values(((id:trans145_0"
" trans-rhs146_0)"
"(let-values()"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(pair?"
" s_8)"
"(let-values(((id:trans119_0)"
"(let-values(((s_9)"
"(car"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(let-values(((flat-s_1)"
"(to-syntax-list.1"
" s_10)))"
"(if(not"
" flat-s_1)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:trans_2)"
"(let-values(((lst_2)"
" flat-s_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id:trans_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((s_11)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id:trans_3)"
"(let-values(((id:trans_3)"
" id:trans_2))"
"(let-values(((id:trans_4)"
"(let-values()"
"(let-values(((id:trans147_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_11)"
"(symbol?"
"(syntax-e$1"
" s_11))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_11)))"
" s_11"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                 \"not an identifier\""
" orig-s_0"
" s_11)))))"
"(cons"
" id:trans147_0"
" id:trans_3)))))"
"(values"
" id:trans_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" id:trans_3"
" rest_1)"
" id:trans_3)))"
" id:trans_2)))))"
" for-loop_1)"
" null"
" lst_2)))))"
"(reverse$1"
" id:trans_2))))))))"
"((trans-rhs120_0)"
"(let-values(((s_9)"
"(cdr"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(if(pair?"
" s_10)"
"(let-values(((trans-rhs121_0)"
"(let-values(((s_11)"
"(car"
" s_10)))"
" s_11))"
"(()"
"(let-values(((s_11)"
"(cdr"
" s_10)))"
"(let-values(((s_12)"
"(if(syntax?$1"
" s_11)"
"(syntax-e$1"
" s_11)"
" s_11)))"
"(if(null?"
" s_12)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_0))))))"
"(values"
" trans-rhs121_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_0))))))"
"(values"
" id:trans119_0"
" trans-rhs120_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                           \"bad syntax\""
" orig-s_0))))))"
"(values"
"(cons"
" id:trans145_0"
" id:trans_1)"
"(cons"
" trans-rhs146_0"
" trans-rhs_1))))))"
"(values"
" id:trans_2"
" trans-rhs_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" id:trans_1"
" trans-rhs_1"
" rest_0)"
"(values"
" id:trans_1"
" trans-rhs_1))))"
"(values"
" id:trans_0"
" trans-rhs_0))))))"
" for-loop_0)"
" null"
" null"
" lst_0)))))"
"(values"
"(reverse$1"
" id:trans_0)"
"(reverse$1"
" trans-rhs_0)))))))))"
"((id:val116_0"
" val-rhs117_0"
" body118_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((id:val122_0"
" val-rhs123_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                               \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:val_0"
" val-rhs_0)"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id:val_0"
" val-rhs_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_9)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id:val_1"
" val-rhs_1)"
"(let-values(((id:val_1)"
" id:val_0)"
"((val-rhs_1)"
" val-rhs_0))"
"(let-values(((id:val_2"
" val-rhs_2)"
"(let-values()"
"(let-values(((id:val148_0"
" val-rhs149_0)"
"(let-values()"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(if(pair?"
" s_10)"
"(let-values(((id:val125_0)"
"(let-values(((s_11)"
"(car"
" s_10)))"
"(let-values(((s_12)"
"(if(syntax?$1"
" s_11)"
"(syntax-e$1"
" s_11)"
" s_11)))"
"(let-values(((flat-s_1)"
"(to-syntax-list.1"
" s_12)))"
"(if(not"
" flat-s_1)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:val_2)"
"(let-values(((lst_2)"
" flat-s_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id:val_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((s_13)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id:val_3)"
"(let-values(((id:val_3)"
" id:val_2))"
"(let-values(((id:val_4)"
"(let-values()"
"(let-values(((id:val150_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_13)"
"(symbol?"
"(syntax-e$1"
" s_13))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_13)))"
" s_13"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                                     \"not an identifier\""
" orig-s_0"
" s_13)))))"
"(cons"
" id:val150_0"
" id:val_3)))))"
"(values"
" id:val_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" id:val_3"
" rest_1)"
" id:val_3)))"
" id:val_2)))))"
" for-loop_1)"
" null"
" lst_2)))))"
"(reverse$1"
" id:val_2))))))))"
"((val-rhs126_0)"
"(let-values(((s_11)"
"(cdr"
" s_10)))"
"(let-values(((s_12)"
"(if(syntax?$1"
" s_11)"
"(syntax-e$1"
" s_11)"
" s_11)))"
"(if(pair?"
" s_12)"
"(let-values(((val-rhs127_0)"
"(let-values(((s_13)"
"(car"
" s_12)))"
" s_13))"
"(()"
"(let-values(((s_13)"
"(cdr"
" s_12)))"
"(let-values(((s_14)"
"(if(syntax?$1"
" s_13)"
"(syntax-e$1"
" s_13)"
" s_13)))"
"(if(null?"
" s_14)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_0))))))"
"(values"
" val-rhs127_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_0))))))"
"(values"
" id:val125_0"
" val-rhs126_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_0))))))"
"(values"
"(cons"
" id:val148_0"
" id:val_1)"
"(cons"
" val-rhs149_0"
" val-rhs_1))))))"
"(values"
" id:val_2"
" val-rhs_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" id:val_1"
" val-rhs_1"
" rest_0)"
"(values"
" id:val_1"
" val-rhs_1))))"
"(values"
" id:val_0"
" val-rhs_0))))))"
" for-loop_0)"
" null"
" null"
" lst_0)))))"
"(values"
"(reverse$1"
" id:val_0)"
"(reverse$1"
" val-rhs_0)))))))))"
"((body124_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                               \"bad syntax\""
" orig-s_0))"
"(if(null?"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0))))))))"
"(values"
" id:val122_0"
" val-rhs123_0"
" body124_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                       \"bad syntax\""
" orig-s_0))))))"
"(values"
" id:trans114_0"
" trans-rhs115_0"
" id:val116_0"
" val-rhs117_0"
" body118_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                   \"bad syntax\""
" orig-s_0))))))"
"(values"
" letrec-syntaxes+values108_0"
" id:trans109_0"
" trans-rhs110_0"
" id:val111_0"
" val-rhs112_0"
" body113_0))"
"                                                              (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values"
" #t"
" letrec-syntaxes+values102_0"
" id:trans103_0"
" trans-rhs104_0"
" id:val105_0"
" val-rhs106_0"
" body107_0)))"
"(values #f #f #f #f #f #f #f)))))"
"(let-values(((ok?_1 let-values128_0 id:val129_0 val-rhs130_0 body131_0)"
"(let-values(((s_1) disarmed-s_0))"
"(if(if(not syntaxes?_0) #t #f)"
"(let-values(((orig-s_0) s_1))"
"(let-values(((let-values128_0 id:val129_0 val-rhs130_0 body131_0)"
"(let-values(((s_2)"
"(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((let-values132_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((id:val133_0 val-rhs134_0 body135_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((id:val136_0"
" val-rhs137_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                             \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:val_0"
" val-rhs_0)"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id:val_0"
" val-rhs_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id:val_1"
" val-rhs_1)"
"(let-values(((id:val_1)"
" id:val_0)"
"((val-rhs_1)"
" val-rhs_0))"
"(let-values(((id:val_2"
" val-rhs_2)"
"(let-values()"
"(let-values(((id:val151_0"
" val-rhs152_0)"
"(let-values()"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(pair?"
" s_8)"
"(let-values(((id:val139_0)"
"(let-values(((s_9)"
"(car"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(let-values(((flat-s_1)"
"(to-syntax-list.1"
" s_10)))"
"(if(not"
" flat-s_1)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id:val_2)"
"(let-values(((lst_2)"
" flat-s_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id:val_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((s_11)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id:val_3)"
"(let-values(((id:val_3)"
" id:val_2))"
"(let-values(((id:val_4)"
"(let-values()"
"(let-values(((id:val153_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_11)"
"(symbol?"
"(syntax-e$1"
" s_11))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_11)))"
" s_11"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                   \"not an identifier\""
" orig-s_0"
" s_11)))))"
"(cons"
" id:val153_0"
" id:val_3)))))"
"(values"
" id:val_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" id:val_3"
" rest_1)"
" id:val_3)))"
" id:val_2)))))"
" for-loop_1)"
" null"
" lst_2)))))"
"(reverse$1"
" id:val_2))))))))"
"((val-rhs140_0)"
"(let-values(((s_9)"
"(cdr"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(if(pair?"
" s_10)"
"(let-values(((val-rhs141_0)"
"(let-values(((s_11)"
"(car"
" s_10)))"
" s_11))"
"(()"
"(let-values(((s_11)"
"(cdr"
" s_10)))"
"(let-values(((s_12)"
"(if(syntax?$1"
" s_11)"
"(syntax-e$1"
" s_11)"
" s_11)))"
"(if(null?"
" s_12)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" val-rhs141_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_0))))))"
"(values"
" id:val139_0"
" val-rhs140_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
"(cons"
" id:val151_0"
" id:val_1)"
"(cons"
" val-rhs152_0"
" val-rhs_1))))))"
"(values"
" id:val_2"
" val-rhs_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" id:val_1"
" val-rhs_1"
" rest_0)"
"(values"
" id:val_1"
" val-rhs_1))))"
"(values"
" id:val_0"
" val-rhs_0))))))"
" for-loop_0)"
" null"
" null"
" lst_0)))))"
"(values"
"(reverse$1"
" id:val_0)"
"(reverse$1"
" val-rhs_0)))))))))"
"((body138_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                             \"bad syntax\""
" orig-s_0))"
"(if(null?"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                               \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0))))))))"
"(values"
" id:val136_0"
" val-rhs137_0"
" body138_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" let-values132_0"
" id:val133_0"
" val-rhs134_0"
" body135_0))"
"                                                                (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t let-values128_0 id:val129_0 val-rhs130_0 body131_0)))"
"(values #f #f #f #f #f)))))"
"(let-values(((sc_0)(new-scope 'local)))"
"(let-values(((body-sc_0)(if rec?_0(new-scope 'letrec-body) #f)))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(let-values(((frame-id_0)(if syntaxes?_0(make-reference-record) #f)))"
"(let-values(((trans-idss_0)"
"(reverse$1"
"(let-values(((lst_0)(if syntaxes?_0 id:trans103_0 null)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((ids_0)(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" id_0"
" sc_0))"
" fold-var_3))))"
"(values"
" fold-var_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_3"
" rest_1)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
" lst_2)))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values(((val-idss_0)"
"(reverse$1"
"(let-values(((lst_0)(if syntaxes?_0 id:val105_0 id:val129_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((ids_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" id_0"
" sc_0))"
" fold-var_3))))"
"(values"
" fold-var_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_3"
" rest_1)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
" lst_2)))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values(((val-rhss_0)"
"(if rec?_0"
"(reverse$1"
"(let-values(((lst_0)"
"(if syntaxes?_0 val-rhs106_0 val-rhs130_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((rhs_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" rhs_0"
" sc_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
"(if syntaxes?_0 val-rhs106_0 val-rhs130_0))))"
"(let-values(((val-clauses_0)"
"(if syntaxes?_0"
"(let-values()"
"(let-values(((ok?_2 _154_0 _155_0 clause156_0 _157_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((_154_0"
" _155_0"
" clause156_0"
" _157_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair? s_2)"
"(let-values(((_158_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((_159_0"
" clause160_0"
" _161_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((_162_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
" s_5))"
"((clause163_0"
" _164_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((clause165_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0))))))"
"((_166_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
" s_7)))"
"(values"
" clause165_0"
" _166_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                         \"bad syntax\""
" orig-s_0))))))"
"(values"
" _162_0"
" clause163_0"
" _164_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" _158_0"
" _159_0"
" clause160_0"
" _161_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                 \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _154_0"
" _155_0"
" clause156_0"
" _157_0))))))"
" clause156_0))"
"(let-values()"
"(let-values(((ok?_2 _167_0 clause168_0 _169_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((_167_0 clause168_0 _169_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair? s_2)"
"(let-values(((_170_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((clause171_0"
" _172_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((clause173_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                             \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0))))))"
"((_174_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
" s_5)))"
"(values"
" clause173_0"
" _174_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" _170_0"
" clause171_0"
" _172_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                 \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _167_0"
" clause168_0"
" _169_0))))))"
" clause168_0)))))"
"(let-values((()"
"(begin"
"(let-values(((temp142_0)(list trans-idss_0 val-idss_0))"
"((phase143_0) phase_0)"
"((s144_0) s_0))"
"(check-no-duplicate-ids7.1"
" unsafe-undefined"
" temp142_0"
" phase143_0"
" s144_0"
" unsafe-undefined))"
"(values))))"
"(let-values(((counter_0)(root-expand-context-counter ctx_0)))"
"(let-values(((local-sym_0)"
"(if(expand-context-normalize-locals? ctx_0) 'loc #f)))"
"(let-values(((trans-keyss_0)"
"(reverse$1"
"(let-values(((lst_0) trans-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((ids_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((id175_0)"
" id_0)"
"((phase176_0)"
" phase_0)"
"((counter177_0)"
" counter_0)"
"((frame-id178_0)"
" frame-id_0)"
"((s179_0)"
" s_0)"
"((local-sym180_0)"
" local-sym_0))"
"(add-local-binding!39.1"
" frame-id178_0"
" s179_0"
" local-sym180_0"
" id175_0"
" phase176_0"
" counter177_0)))"
" fold-var_3))))"
"(values"
" fold-var_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_3"
" rest_1)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
" lst_2)))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values(((val-keyss_0)"
"(reverse$1"
"(let-values(((lst_0) val-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((ids_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((id181_0)"
" id_0)"
"((phase182_0)"
" phase_0)"
"((counter183_0)"
" counter_0)"
"((frame-id184_0)"
" frame-id_0)"
"((s185_0)"
" s_0)"
"((local-sym186_0)"
" local-sym_0))"
"(add-local-binding!39.1"
" frame-id184_0"
" s185_0"
" local-sym186_0"
" id181_0"
" phase182_0"
" counter183_0)))"
" fold-var_3))))"
"(values"
" fold-var_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_3"
" rest_1)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
" lst_2)))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values(((bodys_0)"
"(reverse$1"
"(let-values(((lst_0)"
"(if syntaxes?_0"
" body107_0"
" body131_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((new-body_0)"
"(add-scope"
" body_0"
" sc_0)))"
"(if rec?_0"
"(add-scope"
" new-body_0"
" body-sc_0)"
" new-body_0)))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(log-let-renames"
" obs_0"
" renames-log-tag_0"
" val-idss_0"
" val-rhss_0"
" bodys_0"
" trans-idss_0"
"(if syntaxes?_0 trans-rhs104_0 #f)"
" sc_0))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if syntaxes?_0"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prepare-env)))"
"(void)))"
"(prepare-next-phase-namespace ctx_0)))"
"(void))"
"(values))))"
"(let-values(((trans-valss_0)"
"(reverse$1"
"(let-values(((lst_0)"
"(if syntaxes?_0"
" trans-rhs104_0"
" '()))"
"((lst_1) trans-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_2)"
"(pair? lst_3)"
" #f)"
"(let-values(((rhs_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((ids_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe"
" obs_0"
" 'next)"
"(call-expand-observe"
" obs_0"
" 'enter-bind))))"
"(void)))"
"(values))))"
"(let-values(((trans-val_0)"
"(eval-for-syntaxes-binding"
" 'letrec-syntaxes+values"
"(add-scope"
" rhs_0"
" sc_0)"
" ids_0"
" ctx_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-bind)))"
"(void)))"
" trans-val_0))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not #f)"
"(for-loop_0"
" fold-var_1"
" rest_0"
" rest_1)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1))))))"
"(let-values(((rec-val-env_0)"
"(let-values(((lst_0) val-keyss_0)"
"((lst_1) val-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_0"
" lst_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_2)"
"(pair?"
" lst_3)"
" #f)"
"(let-values(((keys_0)"
"(unsafe-car"
" lst_2))"
"((rest_0)"
"(unsafe-cdr"
" lst_2))"
"((ids_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((env_1)"
"(let-values(((env_1)"
" env_0))"
"(let-values(((lst_4)"
" keys_0)"
"((lst_5)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_4)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_5)))"
"((letrec-values(((for-loop_1)"
"(lambda(env_2"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
"(let-values(((key_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((id_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((env_3)"
"(let-values(((env_3)"
" env_2))"
"(let-values(((env_4)"
"(let-values()"
"(env-extend"
" env_3"
" key_0"
"(local-variable1.1"
" id_0)))))"
"(values"
" env_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" env_3"
" rest_2"
" rest_3)"
" env_3)))"
" env_2)))))"
" for-loop_1)"
" env_1"
" lst_4"
" lst_5))))))"
"(if(not #f)"
"(for-loop_0"
" env_1"
" rest_0"
" rest_1)"
" env_1)))"
" env_0)))))"
" for-loop_0)"
"(expand-context-env ctx_0)"
" lst_0"
" lst_1)))))"
"(let-values(((rec-env_0)"
"(let-values(((lst_0) trans-keyss_0)"
"((lst_1) trans-valss_0)"
"((lst_2) trans-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(env_0"
" lst_3"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_3)"
"(if(pair?"
" lst_4)"
"(pair?"
" lst_5)"
" #f)"
" #f)"
"(let-values(((keys_0)"
"(unsafe-car"
" lst_3))"
"((rest_0)"
"(unsafe-cdr"
" lst_3))"
"((vals_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((ids_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values(((env_1)"
"(let-values(((env_1)"
" env_0))"
"(let-values(((env_2)"
"(let-values()"
"(let-values(((lst_6)"
" keys_0)"
"((lst_7)"
" vals_0)"
"((lst_8)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_6)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_7)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_8)))"
"((letrec-values(((for-loop_1)"
"(lambda(env_2"
" lst_9"
" lst_10"
" lst_11)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_9)"
"(if(pair?"
" lst_10)"
"(pair?"
" lst_11)"
" #f)"
" #f)"
"(let-values(((key_0)"
"(unsafe-car"
" lst_9))"
"((rest_3)"
"(unsafe-cdr"
" lst_9))"
"((val_0)"
"(unsafe-car"
" lst_10))"
"((rest_4)"
"(unsafe-cdr"
" lst_10))"
"((id_0)"
"(unsafe-car"
" lst_11))"
"((rest_5)"
"(unsafe-cdr"
" lst_11)))"
"(let-values(((env_3)"
"(let-values(((env_3)"
" env_2))"
"(let-values(((env_4)"
"(let-values()"
"(begin"
"(maybe-install-free=id-in-context!"
" val_0"
" id_0"
" phase_0"
" ctx_0)"
"(env-extend"
" env_3"
" key_0"
" val_0)))))"
"(values"
" env_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" env_3"
" rest_3"
" rest_4"
" rest_5)"
" env_3)))"
" env_2)))))"
" for-loop_1)"
" env_1"
" lst_6"
" lst_7"
" lst_8))))))"
"(values"
" env_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" env_1"
" rest_0"
" rest_1"
" rest_2)"
" env_1)))"
" env_0)))))"
" for-loop_0)"
" rec-val-env_0"
" lst_0"
" lst_1"
" lst_2)))))"
"(let-values(((expr-ctx_0)"
"(as-expression-context ctx_0)))"
"(let-values(((orig-rrs_0)"
"(expand-context-reference-records"
" expr-ctx_0)))"
"(let-values(((rec-ctx_0)"
"(let-values(((v_0) expr-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((env187_0)"
" rec-env_0)"
"((scopes188_0)"
"(let-values(((scopes_0)"
"(cons"
" sc_0"
"(expand-context-scopes"
" ctx_0))))"
"(if rec?_0"
"(cons"
" body-sc_0"
" scopes_0)"
" scopes_0)))"
"((reference-records189_0)"
"(if split-by-reference?_0"
"(cons"
" frame-id_0"
" orig-rrs_0)"
" orig-rrs_0))"
"((binding-layer190_0)"
"(increment-binding-layer"
"(cons"
" trans-idss_0"
" val-idss_0)"
" ctx_0"
" sc_0))"
"((inner191_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner191_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
" env187_0"
" scopes188_0"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
" binding-layer190_0"
" reference-records189_0"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                           \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((letrec-values-id_0)"
"(if(not"
"(expand-context-to-parsed?"
" ctx_0))"
"(if syntaxes?_0"
"(core-id"
" 'letrec-values"
" phase_0)"
" let-values128_0)"
" #f)))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx192_0) ctx_0)"
"((s193_0) s_0)"
"((temp194_0) #t))"
"(keep-as-needed119.1"
" #f"
" temp194_0"
" #f"
" ctx192_0"
" s193_0))))"
"(let-values(((val-name-idss_0)"
"(if(expand-context-to-parsed?"
" ctx_0)"
"(reverse$1"
"(let-values(((lst_0)"
" val-idss_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((val-ids_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(reverse$1"
"(let-values(((lst_2)"
" val-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(fold-var_2"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((val-id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((fold-var_3)"
"(let-values(((fold-var_3)"
" fold-var_2))"
"(let-values(((fold-var_4)"
"(let-values()"
"(cons"
"(let-values()"
"(datum->syntax$1"
" #f"
"(syntax-e$1"
" val-id_0)"
" val-id_0"
" val-id_0))"
" fold-var_3))))"
"(values"
" fold-var_4)))))"
"(if(not"
" #f)"
"(for-loop_1"
" fold-var_3"
" rest_1)"
" fold-var_3)))"
" fold-var_2)))))"
" for-loop_1)"
" null"
" lst_2)))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
" val-idss_0)))"
"(let-values((()"
"(begin"
"(if syntaxes?_0"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(log-letrec-values"
" obs_0"
" val-idss_0"
" val-rhss_0"
" bodys_0))"
"(void))))"
"(void))"
"(values))))"
"(let-values(((get-body_0)"
"(lambda()"
"(begin"
" 'get-body"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(if(not"
"(if syntaxes?_0"
"(null?"
" val-idss_0)"
" #f))"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group))"
"(void)))"
"(void)))"
"(values))))"
"(let-values(((body-ctx_0)"
"(let-values(((v_0)"
" rec-ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((reference-records198_0)"
" orig-rrs_0)"
"((inner199_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner199_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
" reference-records198_0"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                         \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((bodys195_0)"
" bodys_0)"
"((temp196_0)"
"(let-values(((body-ctx200_0)"
" body-ctx_0)"
"((ctx201_0)"
" ctx_0))"
"(as-tail-context24.1"
" ctx201_0"
" body-ctx200_0)))"
"((rebuild-s197_0)"
" rebuild-s_0))"
"(expand-body7.1"
" rebuild-s197_0"
" #f"
" bodys195_0"
" temp196_0))))))))"
"(let-values(((result-s_0)"
"(if(not"
" split-by-reference?_0)"
"(let-values()"
"(let-values(((clauses_0)"
"(reverse$1"
"(let-values(((lst_0)"
" val-name-idss_0)"
"((lst_1)"
" val-keyss_0)"
"((lst_2)"
" val-rhss_0)"
"((lst_3)"
" val-clauses_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_3)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_4"
" lst_5"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_4)"
"(if(pair?"
" lst_5)"
"(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
" #f)"
" #f)"
"(let-values(((ids_0)"
"(unsafe-car"
" lst_4))"
"((rest_0)"
"(unsafe-cdr"
" lst_4))"
"((keys_0)"
"(unsafe-car"
" lst_5))"
"((rest_1)"
"(unsafe-cdr"
" lst_5))"
"((rhs_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((clause_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-rhs_0)"
"(let-values(((rhs202_0)"
" rhs_0)"
"((temp203_0)"
"(if rec?_0"
"(as-named-context"
" rec-ctx_0"
" ids_0)"
"(as-named-context"
" expr-ctx_0"
" ids_0))))"
"(expand9.1"
" #f"
" #f"
" #f"
" rhs202_0"
" temp203_0))))"
"(if(expand-context-to-parsed?"
" ctx_0)"
"(list"
" keys_0"
" exp-rhs_0)"
"(datum->syntax$1"
" #f"
"(list"
" ids_0"
" exp-rhs_0)"
" clause_0"
" clause_0)))))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0"
" rest_1"
" rest_2"
" rest_3)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1"
" lst_2"
" lst_3))))))"
"(let-values(((exp-body_0)"
"(get-body_0)))"
"(begin"
"(if frame-id_0"
"(let-values()"
"(reference-record-clear!"
" frame-id_0))"
"(void))"
"(if(expand-context-to-parsed?"
" ctx_0)"
"(if rec?_0"
"(parsed-letrec-values18.1"
" rebuild-s_0"
" val-name-idss_0"
" clauses_0"
" exp-body_0)"
"(parsed-let-values17.1"
" rebuild-s_0"
" val-name-idss_0"
" clauses_0"
" exp-body_0))"
"(let-values(((rebuild-s204_0)"
" rebuild-s_0)"
"((temp205_0)"
"(list*"
" letrec-values-id_0"
" clauses_0"
" exp-body_0)))"
"(rebuild5.1"
" #t"
" rebuild-s204_0"
" temp205_0)))))))"
"(let-values()"
"(let-values(((val-idss206_0)"
" val-idss_0)"
"((val-keyss207_0)"
" val-keyss_0)"
"((val-rhss208_0)"
" val-rhss_0)"
"((val-clauses209_0)"
" val-clauses_0)"
"((temp210_0)"
" #t)"
"((frame-id211_0)"
" frame-id_0)"
"((rec-ctx212_0)"
" rec-ctx_0)"
"((rebuild-s213_0)"
" rebuild-s_0)"
"((syntaxes?214_0)"
" syntaxes?_0)"
"((get-body215_0)"
" get-body_0)"
"((temp216_0)"
" #t))"
"(expand-and-split-bindings-by-reference52.1"
" rec-ctx212_0"
" frame-id211_0"
" get-body215_0"
" syntaxes?214_0"
" rebuild-s213_0"
" temp210_0"
" temp216_0"
" val-idss206_0"
" val-keyss207_0"
" val-rhss208_0"
" val-clauses209_0))))))"
"(if(expand-context-to-parsed?"
" ctx_0)"
" result-s_0"
"(attach-disappeared-transformer-bindings"
" result-s_0"
" trans-idss_0))))))))))))))))))))))))))))))))))))))))))))"
"(define-values"
"(log-let-renames)"
"(lambda(obs_0 renames-log-tag_0 val-idss_0 val-rhss_0 bodys_0 trans-idss_0 trans-rhss_0 sc_0)"
"(begin"
"(let-values(((vals+body_0)"
"(cons"
"(reverse$1"
"(let-values(((lst_0) val-idss_0)((lst_1) val-rhss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((val-ids_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((val-rhs_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(datum->syntax$1"
" #f"
"(list val-ids_0 val-rhs_0)))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0 rest_1) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1))))"
"(datum->syntax$1 #f bodys_0))))"
"(call-expand-observe"
" obs_0"
" renames-log-tag_0"
"(if(not trans-rhss_0)"
" vals+body_0"
"(cons"
"(reverse$1"
"(let-values(((lst_0) trans-idss_0)((lst_1) trans-rhss_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_1)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_2 lst_3)"
"(begin"
" 'for-loop"
"(if(if(pair? lst_2)(pair? lst_3) #f)"
"(let-values(((trans-ids_0)(unsafe-car lst_2))"
"((rest_0)(unsafe-cdr lst_2))"
"((trans-rhs_0)(unsafe-car lst_3))"
"((rest_1)(unsafe-cdr lst_3)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(datum->syntax$1"
" #f"
"(list"
" trans-ids_0"
"(add-scope trans-rhs_0 sc_0))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0 rest_1) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0"
" lst_1))))"
" vals+body_0)))))))"
"(define-values"
"(log-letrec-values)"
"(lambda(obs_0 val-idss_0 val-rhss_0 bodys_0)"
"(begin"
"(begin"
"(call-expand-observe obs_0 'next-group)"
"(if(null? val-idss_0)"
"(void)"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'prim-letrec-values)"
"(log-let-renames obs_0 'let-renames val-idss_0 val-rhss_0 bodys_0 #f #f #f))))))))"
"(void"
"(add-core-form!*"
" 'let-values"
"(let-values(((temp217_0) 'prim-let-values))(make-let-values-form11.1 temp217_0 #f 'let-renames #f #f))))"
"(void"
"(add-core-form!*"
" 'letrec-values"
"(let-values(((temp218_0) #t)((temp219_0) 'prim-letrec-values))"
"(make-let-values-form11.1 temp219_0 temp218_0 'let-renames #f #f))))"
"(void"
"(add-core-form!*"
" 'letrec-syntaxes+values"
"(let-values(((temp220_0) #t)"
"((temp221_0) #t)"
"((temp222_0) #t)"
"((temp223_0) 'prim-letrec-syntaxes+values)"
"((temp224_0) 'letrec-syntaxes-renames))"
"(make-let-values-form11.1 temp223_0 temp221_0 temp224_0 temp222_0 temp220_0))))"
"(void"
"(add-core-form!*"
" '#%stratified-body"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-#%stratified)))(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 #%stratified-body225_0 body226_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%stratified-body225_0 body226_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%stratified-body227_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((body228_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                     (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(if(null? flat-s_0)"
"(let-values()"
"                                                                       (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0))))))))"
"(values #%stratified-body227_0 body228_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%stratified-body225_0 body226_0))))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx229_0) ctx_0)((s230_0) s_0)((temp231_0) #t))"
"(keep-as-needed119.1 #f temp231_0 #f ctx229_0 s230_0))))"
"(let-values(((exp-body_0)"
"(let-values(((temp232_0) body226_0)"
"((ctx233_0) ctx_0)"
"((temp234_0) #t)"
"((rebuild-s235_0) rebuild-s_0))"
"(expand-body7.1 rebuild-s235_0 temp234_0 temp232_0 ctx233_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-begin12.1 rebuild-s_0 exp-body_0)"
"(let-values(((rebuild-s236_0) rebuild-s_0)"
"((temp237_0)"
"(if(null?(cdr exp-body_0))"
"(car exp-body_0)"
"(list*(core-id 'begin(expand-context-phase ctx_0)) exp-body_0))))"
"(rebuild5.1 #t rebuild-s236_0 temp237_0)))))))))))"
"(void"
"(add-core-form!*"
" '#%datum"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-#%datum)))(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 #%datum238_0 datum239_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%datum238_0 datum239_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%datum240_0)(let-values(((s_3)(car s_2))) s_3))"
"((datum241_0)(let-values(((s_3)(cdr s_2))) s_3)))"
"(values #%datum240_0 datum241_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%datum238_0 datum239_0))))))"
"(let-values(((datum_0) datum239_0))"
"(let-values((()"
"(begin"
"(if(if(syntax?$1 datum_0)(keyword?(syntax-e$1 datum_0)) #f)"
"(let-values()"
"                                 (raise-syntax-error$1 '#%datum \"keyword misused as an expression\" #f datum_0))"
"(void))"
"(values))))"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(if(if(expand-context-to-parsed? ctx_0)(free-id-set-empty?(expand-context-stops ctx_0)) #f)"
"(parsed-quote14.1(keep-properties-only~ s_0)(syntax->datum$1 datum_0))"
"(let-values(((s242_0) s_0)((temp243_0)(list(core-id 'quote phase_0) datum_0)))"
"(rebuild5.1 #t s242_0 temp243_0))))))))))))"
"(void"
"(add-core-form!*"
" '#%app"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-#%app)))(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 #%app244_0 e245_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%app244_0 e245_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%app246_0)(let-values(((s_3)(car s_2))) s_3))"
"((e247_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                     (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0)))))))"
"(values #%app246_0 e247_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%app244_0 e245_0))))))"
"(let-values(((es_0) e245_0))"
"(if(null? es_0)"
"(let-values()"
"(let-values(((phase_0)(expand-context-phase ctx_0)))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-quote14.1(keep-properties-only~ s_0) null)"
"(let-values(((s248_0) s_0)((temp249_0)(list(core-id 'quote phase_0) null)))"
"(rebuild5.1 #t s248_0 temp249_0)))))"
"(let-values()"
"(let-values(((keep-for-parsed?_0)(eq?(system-type 'vm) 'chez-scheme)))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx250_0) ctx_0)"
"((s251_0) s_0)"
"((keep-for-parsed?252_0) keep-for-parsed?_0))"
"(keep-as-needed119.1 #f #f keep-for-parsed?252_0 ctx250_0 s251_0))))"
"(let-values(((prefixless_0)(cdr(syntax-e$1 disarmed-s_0))))"
"(let-values(((rebuild-prefixless_0)"
"(if(syntax?$1 prefixless_0)"
"(let-values(((ctx253_0) ctx_0)"
"((prefixless254_0) prefixless_0)"
"((keep-for-parsed?255_0) keep-for-parsed?_0))"
"(keep-as-needed119.1 #f #f keep-for-parsed?255_0 ctx253_0 prefixless254_0))"
" #f)))"
"(let-values(((expr-ctx_0)(as-expression-context ctx_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer expr-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe"
" obs_0"
" 'enter-list"
"(datum->syntax$1 #f es_0 s_0))"
"(call-expand-observe obs_0 'next))))"
"(void)))"
"(values))))"
"(let-values(((rest-es_0)(cdr es_0)))"
"(let-values(((exp-rator_0)"
"(let-values(((temp256_0)(car es_0))((expr-ctx257_0) expr-ctx_0))"
"(expand9.1 #f #f #f temp256_0 expr-ctx257_0))))"
"(let-values(((exp-es_0)"
"(reverse$1"
"(let-values(((lst_0) rest-es_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" expr-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(let-values(((e258_0)"
" e_0)"
"((expr-ctx259_0)"
" expr-ctx_0))"
"(expand9.1"
" #f"
" #f"
" #f"
" e258_0"
" expr-ctx259_0))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(if(expand-context-to-parsed? ctx_0)"
"(let-values()"
"(parsed-app7.1"
"(let-values(((or-part_0) rebuild-prefixless_0))"
"(if or-part_0 or-part_0 rebuild-s_0))"
" exp-rator_0"
" exp-es_0))"
"(let-values()"
"(let-values(((es_1)"
"(let-values(((exp-es_1)(cons exp-rator_0 exp-es_0)))"
"(if rebuild-prefixless_0"
"(let-values(((rebuild-prefixless262_0) rebuild-prefixless_0)"
"((exp-es263_0) exp-es_1))"
"(rebuild5.1 #t rebuild-prefixless262_0 exp-es263_0))"
" exp-es_1))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer expr-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-list"
"(datum->syntax$1 #f es_1 rebuild-s_0))))"
"(void)))"
"(let-values(((rebuild-s260_0) rebuild-s_0)"
"((temp261_0)(cons #%app244_0 es_1)))"
"(rebuild5.1 #t rebuild-s260_0 temp261_0))))))))))))))))))))))))"
"(void"
"(add-core-form!*"
" 'quote"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-quote)))(void)))"
"(values))))"
"(let-values(((ok?_0 quote264_0 datum265_0)"
"(let-values(((s_1)(syntax-disarm$1 s_0)))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((quote264_0 datum265_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((quote266_0)(let-values(((s_3)(car s_2))) s_3))"
"((datum267_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((datum268_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(null? s_6)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                    \"bad syntax\""
" orig-s_0))))))"
"(values datum268_0))"
"                                                               (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values quote266_0 datum267_0))"
"                                           (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t quote264_0 datum265_0))))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-quote14.1(keep-properties-only~ s_0)(syntax->datum$1 datum265_0))"
" s_0))))))"
"(void"
"(add-core-form!*"
" 'quote-syntax"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-quote-syntax)))(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 quote-syntax269_0 datum270_0)"
"(let-values(((s_1) disarmed-s_0))"
"(if(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2))) #t)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(if(let-values(((s_5)(car s_4))) #t)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)(if(syntax?$1 s_5)(syntax-e$1 s_5) s_5)))"
"(if(pair? s_6)"
"(if(let-values(((s_7)(car s_6)))"
"(let-values(((s_8)(if(syntax?$1 s_7)(syntax-e$1 s_7) s_7)))"
"(eq? '#:local s_8)))"
"(let-values(((s_7)(cdr s_6)))"
"(let-values(((s_8)(if(syntax?$1 s_7)(syntax-e$1 s_7) s_7)))"
"(null? s_8)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((quote-syntax269_0 datum270_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((quote-syntax271_0)(let-values(((s_3)(car s_2))) s_3))"
"((datum272_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((datum273_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values((()"
"(let-values(((s_7)"
"(car s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(values))))"
"(()"
"(let-values(((s_7)"
"(cdr s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(values)))))"
"(values))))))"
"(values datum273_0))))))"
"(values quote-syntax271_0 datum272_0)))))"
"(values #t quote-syntax269_0 datum270_0)))"
"(values #f #f #f)))))"
"(let-values(((ok?_1 quote-syntax274_0 datum275_0)"
"(let-values(((s_1) disarmed-s_0))"
"(if(if(not ok?_0) #t #f)"
"(let-values(((orig-s_0) s_1))"
"(let-values(((quote-syntax274_0 datum275_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((quote-syntax276_0)(let-values(((s_3)(car s_2))) s_3))"
"((datum277_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((datum278_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(null? s_6)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                          \"bad syntax\""
" orig-s_0))))))"
"(values datum278_0))"
"(raise-syntax-error$1"
" #f"
"                                                                      \"bad syntax\""
" orig-s_0))))))"
"(values quote-syntax276_0 datum277_0))"
"                                                 (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t quote-syntax274_0 datum275_0)))"
"(values #f #f #f)))))"
"(if ok?_0"
"(let-values()"
"(let-values((()"
"(begin(reference-records-all-used!(expand-context-reference-records ctx_0))(values))))"
"(let-values(((ok?_2 _279_0 _280_0 kw281_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((_279_0 _280_0 kw281_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((_282_0)(let-values(((s_3)(car s_2))) s_3))"
"((_283_0 kw284_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((_285_0)"
"(let-values(((s_5)(car s_4)))"
" s_5))"
"((kw286_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((kw287_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null?"
" s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                    \"bad syntax\""
" orig-s_0))))))"
"(values kw287_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                \"bad syntax\""
" orig-s_0))))))"
"(values _285_0 kw286_0))"
"(raise-syntax-error$1"
" #f"
"                                                                            \"bad syntax\""
" orig-s_0))))))"
"(values _282_0 _283_0 kw284_0))"
"                                                       (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t _279_0 _280_0 kw281_0))))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-quote-syntax15.1(keep-properties-only~ s_0) datum270_0)"
"(let-values(((s288_0) s_0)((temp289_0)(list quote-syntax269_0 datum270_0 kw281_0)))"
"(rebuild5.1 #t s288_0 temp289_0))))))"
"(let-values()"
"(let-values(((use-site-scopes_0)(root-expand-context-use-site-scopes ctx_0)))"
"(let-values(((datum-s_0)"
"(remove-scopes"
"(remove-scopes datum275_0(expand-context-scopes ctx_0))"
"(if use-site-scopes_0(unbox use-site-scopes_0) '()))))"
"(if(if(expand-context-to-parsed? ctx_0)(free-id-set-empty?(expand-context-stops ctx_0)) #f)"
"(parsed-quote-syntax15.1(keep-properties-only~ s_0) datum-s_0)"
"(let-values(((s290_0) s_0)((temp291_0)(list quote-syntax274_0 datum-s_0)))"
"(rebuild5.1 #t s290_0 temp291_0))))))))))))))"
"(void"
"(add-core-form!*"
" 'if"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-if)))(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 _292_0 _293_0 _294_0)"
"(let-values(((s_1) disarmed-s_0))"
"(if(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2))) #t)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(if(let-values(((s_5)(car s_4))) #t)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)(if(syntax?$1 s_5)(syntax-e$1 s_5) s_5)))"
"(if(pair? s_6)"
"(if(let-values(((s_7)(car s_6))) #t)"
"(let-values(((s_7)(cdr s_6)))"
"(let-values(((s_8)(if(syntax?$1 s_7)(syntax-e$1 s_7) s_7)))"
"(null? s_8)))"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((_292_0 _293_0 _294_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((_295_0)(let-values(((s_3)(car s_2))) s_3))"
"((_296_0 _297_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((_298_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"((_299_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((_300_0)"
"(let-values(((s_7)"
"(car s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(values)))))"
"(values _300_0))))))"
"(values _298_0 _299_0))))))"
"(values _295_0 _296_0 _297_0)))))"
"(values #t _292_0 _293_0 _294_0)))"
"(values #f #f #f #f)))))"
"(let-values((()"
"(begin"
"(if ok?_0"
"                             (let-values () (raise-syntax-error$1 #f \"missing an \\\"else\\\" expression\" s_0))"
"(void))"
"(values))))"
"(let-values(((ok?_1 if301_0 tst302_0 thn303_0 els304_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((if301_0 tst302_0 thn303_0 els304_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((if305_0)(let-values(((s_3)(car s_2))) s_3))"
"((tst306_0 thn307_0 els308_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((tst309_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"((thn310_0 els311_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((thn312_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"((els313_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(pair?"
" s_8)"
"(let-values(((els314_0)"
"(let-values(((s_9)"
"(car"
" s_8)))"
" s_9))"
"(()"
"(let-values(((s_9)"
"(cdr"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(if(null?"
" s_10)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                  \"bad syntax\""
" orig-s_0))))))"
"(values"
" els314_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                              \"bad syntax\""
" orig-s_0))))))"
"(values thn312_0 els313_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                          \"bad syntax\""
" orig-s_0))))))"
"(values tst309_0 thn310_0 els311_0))"
"(raise-syntax-error$1"
" #f"
"                                                                      \"bad syntax\""
" orig-s_0))))))"
"(values if305_0 tst306_0 thn307_0 els308_0))"
"                                                 (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t if301_0 tst302_0 thn303_0 els304_0))))))"
"(let-values(((expr-ctx_0)(as-expression-context ctx_0)))"
"(let-values(((tail-ctx_0)"
"(let-values(((expr-ctx315_0) expr-ctx_0)((ctx316_0) ctx_0))"
"(as-tail-context24.1 ctx316_0 expr-ctx315_0))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx317_0) ctx_0)((s318_0) s_0))"
"(keep-as-needed119.1 #f #f #f ctx317_0 s318_0))))"
"(let-values(((exp-tst_0)"
"(let-values(((temp319_0) tst302_0)((expr-ctx320_0) expr-ctx_0))"
"(expand9.1 #f #f #f temp319_0 expr-ctx320_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-thn_0)"
"(let-values(((temp321_0) thn303_0)((tail-ctx322_0) tail-ctx_0))"
"(expand9.1 #f #f #f temp321_0 tail-ctx322_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-els_0)"
"(let-values(((temp323_0) els304_0)((tail-ctx324_0) tail-ctx_0))"
"(expand9.1 #f #f #f temp323_0 tail-ctx324_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-if8.1 rebuild-s_0 exp-tst_0 exp-thn_0 exp-els_0)"
"(let-values(((rebuild-s325_0) rebuild-s_0)"
"((temp326_0)(list if301_0 exp-tst_0 exp-thn_0 exp-els_0)))"
"(rebuild5.1 #t rebuild-s325_0 temp326_0)))))))))))))))))))"
"(void"
"(add-core-form!*"
" 'with-continuation-mark"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-with-continuation-mark)))"
"(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 with-continuation-mark327_0 key328_0 val329_0 body330_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((with-continuation-mark327_0 key328_0 val329_0 body330_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((with-continuation-mark331_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((key332_0 val333_0 body334_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((key335_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"((val336_0 body337_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((val338_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"((body339_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(pair? s_8)"
"(let-values(((body340_0)"
"(let-values(((s_9)"
"(car"
" s_8)))"
" s_9))"
"(()"
"(let-values(((s_9)"
"(cdr"
" s_8)))"
"(let-values(((s_10)"
"(if(syntax?$1"
" s_9)"
"(syntax-e$1"
" s_9)"
" s_9)))"
"(if(null?"
" s_10)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                              \"bad syntax\""
" orig-s_0))))))"
"(values"
" body340_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                          \"bad syntax\""
" orig-s_0))))))"
"(values val338_0 body339_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                      \"bad syntax\""
" orig-s_0))))))"
"(values key335_0 val336_0 body337_0))"
"                                                                 (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values with-continuation-mark331_0 key332_0 val333_0 body334_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t with-continuation-mark327_0 key328_0 val329_0 body330_0))))))"
"(let-values(((expr-ctx_0)(as-expression-context ctx_0)))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx341_0) ctx_0)((s342_0) s_0))"
"(keep-as-needed119.1 #f #f #f ctx341_0 s342_0))))"
"(let-values(((exp-key_0)"
"(let-values(((temp343_0) key328_0)((expr-ctx344_0) expr-ctx_0))"
"(expand9.1 #f #f #f temp343_0 expr-ctx344_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'next)))(void)))"
"(values))))"
"(let-values(((exp-val_0)"
"(let-values(((temp345_0) val329_0)((expr-ctx346_0) expr-ctx_0))"
"(expand9.1 #f #f #f temp345_0 expr-ctx346_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-body_0)"
"(let-values(((temp347_0) body330_0)"
"((temp348_0)"
"(let-values(((expr-ctx349_0) expr-ctx_0)((ctx350_0) ctx_0))"
"(as-tail-context24.1 ctx350_0 expr-ctx349_0))))"
"(expand9.1 #f #f #f temp347_0 temp348_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-with-continuation-mark10.1 rebuild-s_0 exp-key_0 exp-val_0 exp-body_0)"
"(let-values(((rebuild-s351_0) rebuild-s_0)"
"((temp352_0)(list with-continuation-mark327_0 exp-key_0 exp-val_0 exp-body_0)))"
"(rebuild5.1 #t rebuild-s351_0 temp352_0))))))))))))))))"
"(define-values"
"(make-begin20.1)"
"(lambda(last-is-tail?15_0 list-start-index14_0 log-tag18_0 parsed-begin19_0)"
"(begin"
" 'make-begin20"
"(let-values(((log-tag_0) log-tag18_0))"
"(let-values(((parsed-begin_0) parsed-begin19_0))"
"(let-values(((list-start-index_0) list-start-index14_0))"
"(let-values(((last-is-tail?_0) last-is-tail?15_0))"
"(let-values()"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 log-tag_0)))"
"(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 begin353_0 e354_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((begin353_0 e354_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((begin355_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((e356_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                   \"bad syntax\""
" orig-s_0))"
"(if(null? flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values() flat-s_0))))))))"
"(values begin355_0 e356_0))"
"                                                          (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t begin353_0 e354_0))))))"
"(let-values(((expr-ctx_0)"
"(if last-is-tail?_0"
"(as-begin-expression-context ctx_0)"
"(as-expression-context ctx_0))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx357_0) ctx_0)((s358_0) s_0))"
"(keep-as-needed119.1 #f #f #f ctx357_0 s358_0))))"
"(let-values(((exp-es_0)"
"((letrec-values(((loop_0)"
"(lambda(es_0 index_0)"
"(begin"
" 'loop"
"(begin"
"(if(zero? index_0)"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(begin"
"(if(zero? list-start-index_0)"
"(void)"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(call-expand-observe"
" obs_0"
" 'enter-list"
"(datum->syntax$1 #f es_0 rebuild-s_0))))"
"(void))))"
"(void))"
"(if(null? es_0)"
"(let-values() null)"
"(let-values()"
"(let-values(((rest-es_0)(cdr es_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(cons"
"(let-values(((temp359_0)(car es_0))"
"((temp360_0)"
"(if(if last-is-tail?_0"
"(null? rest-es_0)"
" #f)"
"(let-values(((expr-ctx361_0)"
" expr-ctx_0)"
"((ctx362_0)"
" ctx_0))"
"(as-tail-context24.1"
" ctx362_0"
" expr-ctx361_0))"
" expr-ctx_0)))"
"(expand9.1 #f #f #f temp359_0 temp360_0))"
"(loop_0 rest-es_0(sub1 index_0))))))))))))"
" loop_0)"
" e354_0"
" list-start-index_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-list"
"(datum->syntax$1 #f(list-tail exp-es_0 list-start-index_0) rebuild-s_0))))"
"(void)))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-begin_0 rebuild-s_0 exp-es_0)"
"(let-values(((rebuild-s363_0) rebuild-s_0)((temp364_0)(cons begin353_0 exp-es_0)))"
"(rebuild5.1 #t rebuild-s363_0 temp364_0)))))))))))))))))))"
"(void"
"(add-core-form!*"
" 'begin"
"(let-values(((nonempty-begin_0)"
"(let-values(((temp365_0) 'prim-begin)"
"((parsed-begin366_0) parsed-begin12.1)"
"((temp367_0) 0)"
"((temp368_0) #t))"
"(make-begin20.1 temp368_0 temp367_0 temp365_0 parsed-begin366_0))))"
"(lambda(s_0 ctx_0)"
"(let-values(((context_0)(expand-context-context ctx_0)))"
"(if(let-values(((or-part_0)(eq? context_0 'top-level)))(if or-part_0 or-part_0(eq? context_0 'module)))"
"(let-values()"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 begin369_0)"
"(let-values(((s_1) disarmed-s_0))"
"(if(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2))) #t)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))(null? s_4)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((begin369_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((begin370_0)(let-values(((s_3)(car s_2))) s_3))"
"(()"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(values)))))"
"(values begin370_0)))))"
"(values #t begin369_0)))"
"(values #f #f)))))"
"(if ok?_0 s_0(nonempty-begin_0 s_0 ctx_0)))))"
"(let-values()(nonempty-begin_0 s_0 ctx_0))))))))"
"(void"
"(add-core-form!*"
" 'begin0"
"(let-values(((temp371_0) 'prim-begin0)((parsed-begin0372_0) parsed-begin013.1)((temp373_0) 1)((temp374_0) #f))"
"(make-begin20.1 temp374_0 temp373_0 temp371_0 parsed-begin0372_0))))"
"(define-values"
"(register-eventual-variable!?)"
"(lambda(id_0 ctx_0)"
"(begin"
"(if(if(expand-context-need-eventually-defined ctx_0)(>=(expand-context-phase ctx_0) 1) #f)"
"(let-values()"
"(begin"
"(hash-update!"
"(expand-context-need-eventually-defined ctx_0)"
"(expand-context-phase ctx_0)"
"(lambda(l_0)(cons id_0 l_0))"
" null)"
" #t))"
"(let-values() #f)))))"
"(void"
"(add-core-form!*"
" '#%top"
"(let-values(((core378_0)"
"(lambda(s376_0 ctx377_0 implicit-omitted?375_0)"
"(begin"
" 'core378"
"(let-values(((s_0) s376_0))"
"(let-values(((ctx_0) ctx377_0))"
"(let-values(((implicit-omitted?_0) implicit-omitted?375_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-#%top)))"
"(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((id_0)"
"(if implicit-omitted?_0"
"(let-values() s_0)"
"(let-values()"
"(let-values(((ok?_0 #%top380_0 id381_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%top380_0 id381_0)"
"(let-values(((s_2)"
"(if(syntax?$1 s_1)"
"(syntax-e$1 s_1)"
" s_1)))"
"(if(pair? s_2)"
"(let-values(((#%top382_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((id383_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_3)"
"(symbol?"
"(syntax-e$1"
" s_3))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_3)))"
" s_3"
"(raise-syntax-error$1"
" #f"
"                                                                                                          \"not an identifier\""
" orig-s_0"
" s_3)))))"
"(values #%top382_0 id383_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                        \"bad syntax\""
" orig-s_0)))))"
"(values #t #%top380_0 id381_0))))))"
" id381_0)))))"
"(let-values(((b_0)"
"(let-values(((id384_0) id_0)"
"((temp385_0)(expand-context-phase ctx_0))"
"((temp386_0) 'ambiguous))"
"(resolve+shift28.1"
" temp386_0"
" #f"
" null"
" unsafe-undefined"
" #f"
" id384_0"
" temp385_0))))"
"(if(eq? b_0 'ambiguous)"
"(let-values()(raise-ambiguous-error id_0 ctx_0))"
"(if(if b_0"
"(if(module-binding? b_0)"
"(eq?(module-binding-module b_0)(root-expand-context-self-mpi ctx_0))"
" #f)"
" #f)"
"(let-values()"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-id2.1 id_0 b_0 #f)"
"(if(top-level-module-path-index?(module-binding-module b_0))"
"(let-values() s_0)"
"(let-values() id_0))))"
"(if(register-eventual-variable!? id_0 ctx_0)"
"(let-values()"
"(if(expand-context-to-parsed? ctx_0)(parsed-id2.1 id_0 b_0 #f) id_0))"
"(let-values()"
"(if(not(expand-context-allow-unbound? ctx_0))"
"(let-values()"
"(raise-unbound-syntax-error"
" #f"
"                                                  \"unbound identifier\""
" id_0"
" #f"
" null"
"(syntax-debug-info-string id_0 ctx_0)))"
"(let-values()"
"(let-values(((tl-id_0)"
"(add-scope"
" id_0"
"(root-expand-context-top-level-bind-scope ctx_0))))"
"(let-values(((tl-b_0)"
"(let-values(((tl-id387_0) tl-id_0)"
"((temp388_0)"
"(expand-context-phase ctx_0)))"
"(resolve40.1 #f #f null #f tl-id387_0 temp388_0))))"
"(if tl-b_0"
"(let-values()"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-top-id4.1 tl-id_0 tl-b_0 #f)"
"(if implicit-omitted?_0"
"(let-values() id_0)"
"(let-values()"
"(let-values(((ok?_0 #%top389_0 id390_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%top389_0 id390_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair? s_2)"
"(let-values(((#%top391_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((id392_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_3)"
"(symbol?"
"(syntax-e$1"
" s_3))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_3)))"
" s_3"
"(raise-syntax-error$1"
" #f"
"                                                                                                                      \"not an identifier\""
" orig-s_0"
" s_3)))))"
"(values"
" #%top391_0"
" id392_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                    \"bad syntax\""
" orig-s_0)))))"
"(values #t #%top389_0 id390_0))))))"
"(let-values(((s393_0) s_0)"
"((temp394_0)(cons #%top389_0 id_0)))"
"(rebuild5.1 #t s393_0 temp394_0)))))))"
"(let-values()"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-top-id4.1 id_0 b_0 #f)"
" s_0)))))))))))))))))))))))"
"(case-lambda"
"((s_0 ctx_0)(core378_0 s_0 ctx_0 #f))"
"((s_0 ctx_0 implicit-omitted?375_0)(core378_0 s_0 ctx_0 implicit-omitted?375_0))))))"
"(void"
"(add-core-form!*"
" 'set!"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-set!)))(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 set!395_0 id396_0 rhs397_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((set!395_0 id396_0 rhs397_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((set!398_0)(let-values(((s_3)(car s_2))) s_3))"
"((id399_0 rhs400_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((id401_0)"
"(let-values(((s_5)(car s_4)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1 s_5)"
"(symbol?"
"(syntax-e$1 s_5))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol? s_5)))"
" s_5"
"(raise-syntax-error$1"
" #f"
"                                                                                    \"not an identifier\""
" orig-s_0"
" s_5))))"
"((rhs402_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((rhs403_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null? s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                          \"bad syntax\""
" orig-s_0))))))"
"(values rhs403_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                      \"bad syntax\""
" orig-s_0))))))"
"(values id401_0 rhs402_0))"
"                                                                 (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values set!398_0 id399_0 rhs400_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t set!395_0 id396_0 rhs397_0))))))"
"(let-values(((orig-id_0) id396_0))"
"((letrec-values(((rename-loop_0)"
"(lambda(id_0 from-rename?_0)"
"(begin"
" 'rename-loop"
"(let-values(((binding_0)"
"(let-values(((id404_0) id_0)"
"((temp405_0)(expand-context-phase ctx_0))"
"((temp406_0) 'ambiguous)"
"((temp407_0) #t))"
"(resolve+shift28.1"
" temp406_0"
" #f"
" null"
" temp407_0"
" #f"
" id404_0"
" temp405_0))))"
"(let-values((()"
"(begin"
"(if(eq? binding_0 'ambiguous)"
"(let-values()(raise-ambiguous-error id_0 ctx_0))"
"(void))"
"(values))))"
"(let-values(((t_0 primitive?_0 insp_0 protected?_0)"
"(if binding_0"
"(let-values(((binding408_0) binding_0)"
"((ctx409_0) ctx_0)"
"((s410_0) s_0))"
"(lookup62.1 #f #f binding408_0 ctx409_0 s410_0))"
"(values #f #f #f #f))))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'resolve id_0)))"
"(void)))"
"(if(let-values(((or-part_0)(variable? t_0)))"
"(if or-part_0"
" or-part_0"
"(if(not binding_0)"
"(let-values(((or-part_1)"
"(register-eventual-variable!? id_0 ctx_0)))"
"(if or-part_1 or-part_1(expand-context-allow-unbound? ctx_0)))"
" #f)))"
"(let-values()"
"(let-values((()"
"(begin"
"(if(if(module-binding? binding_0)"
"(not"
"(inside-module-context?"
"(module-binding-module binding_0)"
"(root-expand-context-self-mpi ctx_0)))"
" #f)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                    \"cannot mutate module-required identifier\""
" s_0"
" id_0))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(register-variable-referenced-if-local! binding_0)"
"(values))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx411_0) ctx_0)((s412_0) s_0))"
"(keep-as-needed119.1 #f #f #f ctx411_0 s412_0))))"
"(let-values(((exp-rhs_0)"
"(let-values(((temp413_0) rhs397_0)"
"((temp414_0)"
"(as-expression-context ctx_0)))"
"(expand9.1 #f #f #f temp413_0 temp414_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-set!9.1"
" rebuild-s_0"
"(parsed-id2.1 id_0 binding_0 #f)"
" exp-rhs_0)"
"(let-values(((rebuild-s415_0) rebuild-s_0)"
"((temp416_0)"
"(list"
" set!395_0"
"(let-values(((id417_0) id_0)"
"((t418_0) t_0)"
"((temp419_0)"
"(free-id-set-empty-or-just-module*?"
"(expand-context-stops ctx_0))))"
"(substitute-variable6.1"
" temp419_0"
" id417_0"
" t418_0))"
" exp-rhs_0)))"
"(rebuild5.1 #t rebuild-s415_0 temp416_0)))))))))"
"(if(not binding_0)"
"(let-values()"
"(raise-unbound-syntax-error"
" #f"
"                                                  \"unbound identifier\""
" s_0"
" id_0"
" null"
"(syntax-debug-info-string id_0 ctx_0)))"
"(if(1/set!-transformer? t_0)"
"(let-values()"
"(if(not-in-this-expand-context? t_0 ctx_0)"
"(let-values()"
"(let-values(((temp420_0)"
"(avoid-current-expand-context"
"(substitute-set!-rename"
" s_0"
" disarmed-s_0"
" set!395_0"
" rhs397_0"
" id_0"
" from-rename?_0"
" ctx_0)"
" t_0"
" ctx_0))"
"((ctx421_0) ctx_0))"
"(expand9.1 #f #f #f temp420_0 ctx421_0)))"
"(let-values()"
"(let-values(((exp-s_0 re-ctx_0)"
"(let-values(((t422_0) t_0)"
"((insp423_0) insp_0)"
"((s424_0) s_0)"
"((orig-id425_0) orig-id_0)"
"((ctx426_0) ctx_0)"
"((binding427_0) binding_0)"
"((orig-id428_0) orig-id_0))"
"(apply-transformer52.1"
" orig-id428_0"
" t422_0"
" insp423_0"
" s424_0"
" orig-id425_0"
" ctx426_0"
" binding427_0))))"
"(if(expand-context-just-once? ctx_0)"
"(let-values() exp-s_0)"
"(let-values()"
"(let-values(((exp-s429_0) exp-s_0)"
"((re-ctx430_0) re-ctx_0))"
"(expand9.1 #f #f #f exp-s429_0 re-ctx430_0))))))))"
"(if(1/rename-transformer? t_0)"
"(let-values()"
"(if(not-in-this-expand-context? t_0 ctx_0)"
"(let-values()"
"(let-values(((temp431_0)"
"(avoid-current-expand-context"
"(substitute-set!-rename"
" s_0"
" disarmed-s_0"
" set!395_0"
" rhs397_0"
" id_0"
" from-rename?_0"
" ctx_0"
" t_0)"
" t_0"
" ctx_0))"
"((ctx432_0) ctx_0))"
"(expand9.1 #f #f #f temp431_0 ctx432_0)))"
"(let-values()"
"(rename-loop_0"
"(syntax-track-origin$1"
"(rename-transformer-target-in-context t_0 ctx_0)"
" id_0"
" id_0)"
" #t))))"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                      \"cannot mutate syntax identifier\""
" s_0"
" id_0))))))))))))))"
" rename-loop_0)"
" orig-id_0"
" #f))))))))"
"(define-values"
"(substitute-set!-rename)"
"(let-values(((substitute-set!-rename31_0)"
"(lambda(s24_0 disarmed-s25_0 set!-id26_0 id27_0 rhs-s28_0 from-rename?29_0 ctx30_0 t23_0)"
"(begin"
" 'substitute-set!-rename31"
"(let-values(((s_0) s24_0))"
"(let-values(((disarmed-s_0) disarmed-s25_0))"
"(let-values(((set!-id_0) set!-id26_0))"
"(let-values(((id_0) id27_0))"
"(let-values(((rhs-s_0) rhs-s28_0))"
"(let-values(((from-rename?_0) from-rename?29_0))"
"(let-values(((ctx_0) ctx30_0))"
"(let-values(((t_0) t23_0))"
"(let-values()"
"(if(let-values(((or-part_0) t_0))(if or-part_0 or-part_0 from-rename?_0))"
"(let-values()"
"(let-values(((new-id_0)"
"(if t_0(rename-transformer-target-in-context t_0 ctx_0) id_0)))"
"(syntax-rearm$1"
"(datum->syntax$1"
" disarmed-s_0"
"(list set!-id_0 new-id_0 rhs-s_0)"
" disarmed-s_0"
" disarmed-s_0)"
" s_0)))"
"(let-values() s_0)))))))))))))))"
"(case-lambda"
"((s_0 disarmed-s_0 set!-id_0 id_0 rhs-s_0 from-rename?_0 ctx_0)"
"(begin(substitute-set!-rename31_0 s_0 disarmed-s_0 set!-id_0 id_0 rhs-s_0 from-rename?_0 ctx_0 #f)))"
"((s_0 disarmed-s_0 set!-id_0 id_0 rhs-s_0 from-rename?_0 ctx_0 t23_0)"
"(substitute-set!-rename31_0 s_0 disarmed-s_0 set!-id_0 id_0 rhs-s_0 from-rename?_0 ctx_0 t23_0)))))"
"(void"
"(add-core-form!*"
" '#%variable-reference"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-#%variable-reference)))"
"(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 #%variable-reference433_0 id434_0)"
"(let-values(((s_1) disarmed-s_0))"
"(if(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2))) #t)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(if(let-values(((s_5)(car s_4)))"
"(let-values(((or-part_0)"
"(if(syntax?$1 s_5)(symbol?(syntax-e$1 s_5)) #f)))"
"(if or-part_0 or-part_0(symbol? s_5))))"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)(if(syntax?$1 s_5)(syntax-e$1 s_5) s_5)))"
"(null? s_6)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((#%variable-reference433_0 id434_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((#%variable-reference435_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((id436_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((id437_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(values)))))"
"(values id437_0))))))"
"(values #%variable-reference435_0 id436_0)))))"
"(values #t #%variable-reference433_0 id434_0)))"
"(values #f #f #f)))))"
"(let-values(((ok?_1 #%variable-reference438_0 #%top439_0 id440_0)"
"(let-values(((s_1) disarmed-s_0))"
"(if(if(not ok?_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(if(let-values(((s_3)(car s_2))) #t)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(if(let-values(((s_5)(car s_4)))"
"(let-values(((s_6)(if(syntax?$1 s_5)(syntax-e$1 s_5) s_5)))"
"(if(pair? s_6)"
"(if(let-values(((s_7)(car s_6))) #t)"
"(let-values(((s_7)(cdr s_6)))"
"(let-values(((or-part_0)"
"(if(syntax?$1 s_7)"
"(symbol?(syntax-e$1 s_7))"
" #f)))"
"(if or-part_0 or-part_0(symbol? s_7))))"
" #f)"
" #f)))"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)(if(syntax?$1 s_5)(syntax-e$1 s_5) s_5)))"
"(null? s_6)))"
" #f)"
" #f)))"
" #f)"
" #f))"
" #f)"
"(let-values()"
"(let-values(((#%variable-reference438_0 #%top439_0 id440_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(let-values(((#%variable-reference441_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((#%top442_0 id443_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((#%top444_0 id445_0)"
"(let-values(((s_5)(car s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((#%top446_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"((id447_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
" s_7)))"
"(values #%top446_0 id447_0)))))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(values)))))"
"(values #%top444_0 id445_0))))))"
"(values #%variable-reference441_0 #%top442_0 id443_0)))))"
"(values #t #%variable-reference438_0 #%top439_0 id440_0)))"
"(values #f #f #f #f)))))"
"(let-values(((ok?_2 #%variable-reference448_0)"
"(let-values(((s_1) disarmed-s_0))"
"(if(if(not(let-values(((or-part_0) ok?_0))(if or-part_0 or-part_0 ok?_1))) #t #f)"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%variable-reference448_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%variable-reference449_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"(()"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(null? s_4)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                        \"bad syntax\""
" orig-s_0))))))"
"(values #%variable-reference449_0))"
"                                                   (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%variable-reference448_0)))"
"(values #f #f)))))"
"(if(let-values(((or-part_0) ok?_0))(if or-part_0 or-part_0 ok?_1))"
"(let-values()"
"(let-values(((var-id_0)(if ok?_0 id434_0 id440_0)))"
"(let-values(((binding_0)"
"(let-values(((var-id450_0) var-id_0)"
"((temp451_0)(expand-context-phase ctx_0))"
"((temp452_0) 'ambiguous))"
"(resolve+shift28.1 temp452_0 #f null unsafe-undefined #f var-id450_0 temp451_0))))"
"(let-values((()"
"(begin"
"(if(eq? binding_0 'ambiguous)"
"(let-values()(raise-ambiguous-error var-id_0 ctx_0))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0) binding_0))"
"(if or-part_0 or-part_0(expand-context-allow-unbound? ctx_0)))"
"(void)"
"(let-values()"
"(raise-unbound-syntax-error"
" #f"
"                                              \"unbound identifier\""
" s_0"
" var-id_0"
" null"
"(syntax-debug-info-string var-id_0 ctx_0))))"
"(values))))"
"(let-values(((t_0 primitive?_0 insp-of-t_0 protected?_0)"
"(if binding_0"
"(let-values(((binding453_0) binding_0)"
"((ctx454_0) ctx_0)"
"((var-id455_0) var-id_0)"
"((s456_0) s_0)"
"((temp457_0)(expand-context-in-local-expand? ctx_0)))"
"(lookup62.1 s456_0 temp457_0 binding453_0 ctx454_0 var-id455_0))"
"(values #f #f #f #f))))"
"(begin"
"(if(if t_0(not(variable? t_0)) #f)"
"(let-values()"
"                                   (raise-syntax-error$1 #f \"identifier does not refer to a variable\" var-id_0 s_0))"
"(void))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-#%variable-reference11.1"
"(keep-properties-only~ s_0)"
"(if ok?_1"
"(let-values()(parsed-top-id4.1 var-id_0 binding_0 #f))"
"(if primitive?_0"
"(let-values()(parsed-primitive-id3.1 var-id_0 binding_0 #f))"
"(let-values()(parsed-id2.1 var-id_0 binding_0 #f)))))"
" s_0))))))))"
"(let-values()"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-#%variable-reference11.1(keep-properties-only~ s_0) #f)"
" s_0)))))))))))"
"(void"
"(add-core-form!*"
" '#%expression"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-#%expression)))(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 #%expression458_0 e459_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%expression458_0 e459_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%expression460_0)(let-values(((s_3)(car s_2))) s_3))"
"((e461_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((e462_0)"
"(let-values(((s_5)(car s_4))) s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(null? s_6)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                      \"bad syntax\""
" orig-s_0))))))"
"(values e462_0))"
"                                                                 (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values #%expression460_0 e461_0))"
"                                             (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%expression458_0 e459_0))))))"
"(let-values(((rebuild-s_0)"
"(let-values(((ctx463_0) ctx_0)((s464_0) s_0)((temp465_0) #t))"
"(keep-as-needed119.1 temp465_0 #f #f ctx463_0 s464_0))))"
"(let-values(((exp-e_0)"
"(let-values(((temp466_0) e459_0)"
"((temp467_0)"
"(let-values(((temp468_0)(as-expression-context ctx_0))((ctx469_0) ctx_0))"
"(as-tail-context24.1 ctx469_0 temp468_0))))"
"(expand9.1 #f #f #f temp466_0 temp467_0))))"
"(if(expand-context-to-parsed? ctx_0)"
" exp-e_0"
"(if(let-values(((or-part_0)"
"(if(expand-context-in-local-expand? ctx_0)"
"(expand-context-keep-#%expression? ctx_0)"
" #f)))"
"(if or-part_0 or-part_0(eq? 'top-level(expand-context-context ctx_0))))"
"(let-values()"
"(let-values(((rebuild-s470_0) rebuild-s_0)((temp471_0)(list #%expression458_0 exp-e_0)))"
"(rebuild5.1 #t rebuild-s470_0 temp471_0)))"
"(let-values()"
"(let-values(((result-s_0)(syntax-track-origin$1 exp-e_0 rebuild-s_0)))"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'tag result-s_0)))"
"(void)))"
" result-s_0)))))))))))))"
" (void (add-core-form!* 'unquote (lambda (s_0 ctx_0) (raise-syntax-error$1 #f \"not in quasiquote\" s_0))))"
" (void (add-core-form!* 'unquote-splicing (lambda (s_0 ctx_0) (raise-syntax-error$1 #f \"not in quasiquote\" s_0))))"
"(define-values"
"(binding-for-transformer?)"
"(lambda(b_0 id_0 at-phase_0 ns_0)"
"(begin"
"(if(not at-phase_0)"
"(let-values()"
"(let-values(((m_0)"
"(namespace->module ns_0(1/module-path-index-resolve(module-binding-nominal-module b_0)))))"
"(let-values(((b/p_0)"
"(hash-ref"
"(hash-ref(module-provides m_0)(module-binding-nominal-phase b_0) '#hasheq())"
"(module-binding-nominal-sym b_0)"
" #f)))"
"(provided-as-transformer? b/p_0))))"
"(let-values()"
"(let-values(((val_0 primitive?_0 insp_0 protected?_0)"
"(let-values(((b1_0) b_0)"
"((empty-env2_0) empty-env)"
"((null3_0) null)"
"((ns4_0) ns_0)"
"((at-phase5_0) at-phase_0)"
"((id6_0) id_0))"
"(binding-lookup52.1 #f #f b1_0 empty-env2_0 null3_0 ns4_0 at-phase5_0 id6_0))))"
"(not(variable? val_0))))))))"
"(define-values(layers) '(raw phaseless id))"
"(define-values(provide-form-name) 'provide)"
"(define-values"
"(parse-and-expand-provides!)"
"(lambda(specs_0 orig-s_0 rp_0 self_0 phase_0 ctx_0)"
"(begin"
"(let-values(((ns_0)(expand-context-namespace ctx_0)))"
"((letrec-values(((loop_0)"
"(lambda(specs_1 at-phase_0 protected?_0 layer_0)"
"(begin"
" 'loop"
"(let-values(((track-stxess_0 exp-specss_0)"
"(let-values(((track-stxes_0 exp-specs_0)"
"(let-values(((lst_0) specs_1))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(track-stxes_0"
" exp-specs_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((spec_0)"
"(unsafe-car lst_1))"
"((rest_0)"
"(unsafe-cdr lst_1)))"
"(let-values(((track-stxes_1"
" exp-specs_1)"
"(let-values(((track-stxes_1)"
" track-stxes_0)"
"((exp-specs_1)"
" exp-specs_0))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(let-values()"
"(let-values(((track-stxes1_0"
" exp-specs2_0)"
"(let-values()"
"(let-values(((disarmed-spec_0)"
"(syntax-disarm$1"
" spec_0)))"
"(let-values(((fm_0)"
"(if(pair?"
"(syntax-e$1"
" disarmed-spec_0))"
"(if(identifier?"
"(car"
"(syntax-e$1"
" disarmed-spec_0)))"
"(syntax-e$1"
"(car"
"(syntax-e$1"
" disarmed-spec_0)))"
" #f)"
" #f)))"
"(let-values(((check-nested_0)"
"(lambda(want-layer_0)"
"(begin"
" 'check-nested"
"(if(member"
" want-layer_0"
"(member"
" layer_0"
" layers))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"(format"
"                                                                                                                                                                    \"nested `~a' not allowed\""
" fm_0)"
" orig-s_0"
" spec_0)))))))"
"(let-values(((tmp_0)"
" fm_0))"
"(let-values(((index_0)"
"(if(symbol?"
" tmp_0)"
"(hash-ref"
" '#hasheq((all-defined"
" ."
" 9)"
"(all-defined-except"
" ."
" 10)"
"(all-from"
" ."
" 7)"
"(all-from-except"
" ."
" 8)"
"(expand"
" ."
" 13)"
"(for-label"
" ."
" 3)"
"(for-meta"
" ."
" 1)"
"(for-syntax"
" ."
" 2)"
"(prefix-all-defined"
" ."
" 11)"
"(prefix-all-defined-except"
" ."
" 12)"
"(protect"
" ."
" 4)"
"(rename ."
" 5)"
"(struct"
" ."
" 6))"
" tmp_0"
"(lambda()"
" 0))"
" 0)))"
"(if(unsafe-fx<"
" index_0"
" 6)"
"(if(unsafe-fx<"
" index_0"
" 2)"
"(if(unsafe-fx<"
" index_0"
" 1)"
"(let-values()"
"(if(identifier?"
" spec_0)"
"(let-values()"
"(begin"
"(parse-identifier!"
" spec_0"
" orig-s_0"
"(syntax-e$1"
" spec_0)"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                                                                                                                                               \"bad syntax\""
" orig-s_0"
" spec_0))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw)"
"(values))))"
"(let-values(((ok?_0"
" for-meta3_0"
" phase-level4_0"
" spec5_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-meta3_0"
" phase-level4_0"
" spec5_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-meta6_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((phase-level7_0"
" spec8_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((phase-level9_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((spec10_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                             \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" phase-level9_0"
" spec10_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_1))))))"
"(values"
" for-meta6_0"
" phase-level7_0"
" spec8_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-meta3_0"
" phase-level4_0"
" spec5_0))))))"
"(let-values(((p_0)"
"(syntax-e$1"
" phase-level4_0)))"
"(let-values((()"
"(begin"
"(if(phase?"
" p_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                                                                                                                                                                     \"bad `for-meta' phase\""
" orig-s_0"
" spec_0)))"
"(values))))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(loop_0"
" spec5_0"
"(phase+"
" p_0"
" at-phase_0)"
" protected?_0"
" 'phaseless)))"
"(values"
" null"
"(list"
"(syntax-track-origin*"
" track-stxes_2"
"(let-values(((spec11_0)"
" spec_0)"
"((temp12_0)"
"(list*"
" for-meta3_0"
" phase-level4_0"
" exp-specs_2)))"
"(rebuild5.1"
" #t"
" spec11_0"
" temp12_0))))))))))))"
"(if(unsafe-fx<"
" index_0"
" 3)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw)"
"(values))))"
"(let-values(((ok?_0"
" for-syntax13_0"
" spec14_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-syntax13_0"
" spec14_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-syntax15_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec16_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" for-syntax15_0"
" spec16_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-syntax13_0"
" spec14_0))))))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(loop_0"
" spec14_0"
"(phase+"
" 1"
" at-phase_0)"
" protected?_0"
" 'phaseless)))"
"(values"
" null"
"(list"
"(syntax-track-origin*"
" track-stxes_2"
"(let-values(((spec17_0)"
" spec_0)"
"((temp18_0)"
"(list*"
" for-syntax13_0"
" exp-specs_2)))"
"(rebuild5.1"
" #t"
" spec17_0"
" temp18_0)))))))))"
"(if(unsafe-fx<"
" index_0"
" 4)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'raw)"
"(values))))"
"(let-values(((ok?_0"
" for-label19_0"
" spec20_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((for-label19_0"
" spec20_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((for-label21_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec22_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" for-label21_0"
" spec22_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" for-label19_0"
" spec20_0))))))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(loop_0"
" spec20_0"
" #f"
" protected?_0"
" 'phaseless)))"
"(values"
" null"
"(list"
"(syntax-track-origin*"
" track-stxes_2"
"(let-values(((spec23_0)"
" spec_0)"
"((temp24_0)"
"(list*"
" for-label19_0"
" exp-specs_2)))"
"(rebuild5.1"
" #t"
" spec23_0"
" temp24_0)))))))))"
"(if(unsafe-fx<"
" index_0"
" 5)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values((()"
"(begin"
"(if protected?_0"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                                                                                                                                                                     \"nested `protect' not allowed\""
" orig-s_0"
" spec_0))"
"(void))"
"(values))))"
"(let-values(((ok?_0"
" protect25_0"
" p-spec26_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((protect25_0"
" p-spec26_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((protect27_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((p-spec28_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" protect27_0"
" p-spec28_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" protect25_0"
" p-spec26_0))))))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(loop_0"
" p-spec26_0"
" at-phase_0"
" #t"
" layer_0)))"
"(values"
" null"
"(list"
"(syntax-track-origin*"
" track-stxes_2"
"(let-values(((spec29_0)"
" spec_0)"
"((temp30_0)"
"(list*"
" protect25_0"
" exp-specs_2)))"
"(rebuild5.1"
" #t"
" spec29_0"
" temp30_0))))))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" rename31_0"
" id:from32_0"
" id:to33_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((rename31_0"
" id:from32_0"
" id:to33_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((rename34_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:from35_0"
" id:to36_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:from37_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                           \"not an identifier\""
" orig-s_1"
" s_4))))"
"((id:to38_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((id:to39_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                               \"not an identifier\""
" orig-s_1"
" s_6))))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:to39_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                             \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:from37_0"
" id:to38_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))))))"
"(values"
" rename34_0"
" id:from35_0"
" id:to36_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                     \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" rename31_0"
" id:from32_0"
" id:to33_0))))))"
"(begin"
"(parse-identifier!"
" id:from32_0"
" orig-s_0"
"(syntax-e$1"
" id:to33_0)"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))))))))"
"(if(unsafe-fx<"
" index_0"
" 9)"
"(if(unsafe-fx<"
" index_0"
" 7)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" struct40_0"
" id:struct41_0"
" id:field42_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((struct40_0"
" id:struct41_0"
" id:field42_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((struct43_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:struct44_0"
" id:field45_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:struct46_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                       \"not an identifier\""
" orig-s_1"
" s_4))))"
"((id:field47_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((id:field48_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_7)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))"
"(let-values()"
"(let-values(((id:field_0)"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id:field_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((s_8)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id:field_1)"
"(let-values(((id:field_1)"
" id:field_0))"
"(let-values(((id:field_2)"
"(let-values()"
"(let-values(((id:field49_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_8)"
"(symbol?"
"(syntax-e$1"
" s_8))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_8)))"
" s_8"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                                               \"not an identifier\""
" orig-s_1"
" s_8)))))"
"(cons"
" id:field49_0"
" id:field_1)))))"
"(values"
" id:field_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" id:field_1"
" rest_1)"
" id:field_1)))"
" id:field_0)))))"
" for-loop_1)"
" null"
" lst_2)))))"
"(reverse$1"
" id:field_0))))))))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                             \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:field48_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:struct46_0"
" id:field47_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_1))))))"
"(values"
" struct43_0"
" id:struct44_0"
" id:field45_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" struct40_0"
" id:struct41_0"
" id:field42_0))))))"
"(begin"
"(parse-struct!"
" id:struct41_0"
" orig-s_0"
" id:field42_0"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))))"
"(if(unsafe-fx<"
" index_0"
" 8)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" all-from50_0"
" mod-path51_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((all-from50_0"
" mod-path51_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((all-from52_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((mod-path53_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((mod-path54_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"(()"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(null?"
" s_5)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1))))))"
"(values"
" mod-path54_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))))))"
"(values"
" all-from52_0"
" mod-path53_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" all-from50_0"
" mod-path51_0))))))"
"(begin"
"(parse-all-from"
" mod-path51_0"
" orig-s_0"
" self_0"
" null"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0"
" ctx_0)"
"(values"
" null"
"(list"
" spec_0))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" all-from-except55_0"
" mod-path56_0"
" id57_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((all-from-except55_0"
" mod-path56_0"
" id57_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((all-from-except58_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((mod-path59_0"
" id60_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((mod-path61_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((id62_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                               \"bad syntax\""
" orig-s_1))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id63_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                             \"not an identifier\""
" orig-s_1"
" s_6)))))"
"(cons"
" id63_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_1"
" rest_1)"
" id_1)))"
" id_0)))))"
" for-loop_1)"
" null"
" lst_2)))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" mod-path61_0"
" id62_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))))))"
"(values"
" all-from-except58_0"
" mod-path59_0"
" id60_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" all-from-except55_0"
" mod-path56_0"
" id57_0))))))"
"(begin"
"(parse-all-from"
" mod-path56_0"
" orig-s_0"
" self_0"
" id57_0"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0"
" ctx_0)"
"(values"
" null"
"(list"
" spec_0))))))))"
"(if(unsafe-fx<"
" index_0"
" 11)"
"(if(unsafe-fx<"
" index_0"
" 10)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" all-defined64_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((all-defined64_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((all-defined65_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"(()"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(null?"
" s_3)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))))))"
"(values"
" all-defined65_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" all-defined64_0))))))"
"(begin"
"(parse-all-from-module"
" self_0"
" spec_0"
" orig-s_0"
" null"
" #f"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))))"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" all-defined-except66_0"
" id67_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((all-defined-except66_0"
" id67_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((all-defined-except68_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id69_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((s_4)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id70_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                         \"not an identifier\""
" orig-s_1"
" s_4)))))"
"(cons"
" id70_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_1"
" rest_1)"
" id_1)))"
" id_0)))))"
" for-loop_1)"
" null"
" lst_2)))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" all-defined-except68_0"
" id69_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" all-defined-except66_0"
" id67_0))))))"
"(begin"
"(parse-all-from-module"
" self_0"
" spec_0"
" orig-s_0"
" id67_0"
" #f"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0)))))))"
"(if(unsafe-fx<"
" index_0"
" 12)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" prefix-all-defined71_0"
" id:prefix72_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((prefix-all-defined71_0"
" id:prefix72_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((prefix-all-defined73_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:prefix74_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:prefix75_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                         \"not an identifier\""
" orig-s_1"
" s_4))))"
"(()"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(null?"
" s_5)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1))))))"
"(values"
" id:prefix75_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))))))"
"(values"
" prefix-all-defined73_0"
" id:prefix74_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" prefix-all-defined71_0"
" id:prefix72_0))))))"
"(begin"
"(parse-all-from-module"
" self_0"
" spec_0"
" orig-s_0"
" null"
"(syntax-e$1"
" id:prefix72_0)"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))))"
"(if(unsafe-fx<"
" index_0"
" 13)"
"(let-values()"
"(let-values((()"
"(begin"
"(check-nested_0"
" 'phaseless)"
"(values))))"
"(let-values(((ok?_0"
" prefix-all-defined-except76_0"
" id:prefix77_0"
" id78_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((prefix-all-defined-except76_0"
" id:prefix77_0"
" id78_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((prefix-all-defined-except79_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id:prefix80_0"
" id81_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id:prefix82_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_4)"
"(symbol?"
"(syntax-e$1"
" s_4))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_4)))"
" s_4"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                           \"not an identifier\""
" orig-s_1"
" s_4))))"
"((id83_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                 \"bad syntax\""
" orig-s_1))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_2)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(id_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id84_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                                                               \"not an identifier\""
" orig-s_1"
" s_6)))))"
"(cons"
" id84_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_1"
" id_1"
" rest_1)"
" id_1)))"
" id_0)))))"
" for-loop_1)"
" null"
" lst_2)))))"
"(reverse$1"
" id_0)))))))))"
"(values"
" id:prefix82_0"
" id83_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))))))"
"(values"
" prefix-all-defined-except79_0"
" id:prefix80_0"
" id81_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                     \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" prefix-all-defined-except76_0"
" id:prefix77_0"
" id78_0))))))"
"(begin"
"(parse-all-from-module"
" self_0"
" spec_0"
" orig-s_0"
" id78_0"
"(syntax-e$1"
" id:prefix77_0)"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0)"
"(values"
" null"
"(list"
" spec_0))))))"
"(let-values()"
"(let-values(((ok?_0"
" expand85_0"
" id86_0"
" datum87_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((expand85_0"
" id86_0"
" datum87_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((expand88_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id89_0"
" datum90_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id91_0"
" datum92_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((id93_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                             \"not an identifier\""
" orig-s_1"
" s_6))))"
"((datum94_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
" s_6)))"
"(values"
" id93_0"
" datum94_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1)))))"
"(()"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(null?"
" s_5)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1))))))"
"(values"
" id91_0"
" datum92_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                       \"bad syntax\""
" orig-s_1))))))"
"(values"
" expand88_0"
" id89_0"
" datum90_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" expand85_0"
" id86_0"
" datum87_0))))))"
"(let-values(((ok?_1"
" expand95_0"
" form96_0)"
"(let-values(((s_0)"
" disarmed-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((expand95_0"
" form96_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((expand97_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((form98_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((form99_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"(()"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(null?"
" s_5)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                             \"bad syntax\""
" orig-s_1))))))"
"(values"
" form99_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                         \"bad syntax\""
" orig-s_1))))))"
"(values"
" expand97_0"
" form98_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                     \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" expand95_0"
" form96_0))))))"
"(let-values(((exp-spec_0)"
"(let-values(((temp104_0)"
" form96_0)"
"((temp105_0)"
"(let-values(((v_0)"
" ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((def-ctx-scopes106_0)"
" #f)"
"((inner107_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((stops108_0)"
"(free-id-set"
" at-phase_0"
"(list"
"(core-id"
" 'begin"
" at-phase_0)))))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
" stops108_0"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                       \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner107_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
" def-ctx-scopes106_0"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                     \"expand-context/outer?\""
" the-struct_0))))))"
"(expand9.1"
" #f"
" #f"
" #f"
" temp104_0"
" temp105_0))))"
"(let-values((()"
"(begin"
"(if(if(pair?"
"(syntax-e$1"
" exp-spec_0))"
"(if(identifier?"
"(car"
"(syntax-e$1"
" exp-spec_0)))"
"(eq?"
" 'begin"
"(core-form-sym"
" exp-spec_0"
" at-phase_0))"
" #f)"
" #f)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                                                                                                                                                                                         \"expansion was not a `begin' sequence\""
" orig-s_0"
" spec_0)))"
"(values))))"
"(let-values(((ok?_2"
" begin100_0"
" spec101_0)"
"(let-values(((s_0)"
" exp-spec_0))"
"(let-values(((orig-s_1)"
" s_0))"
"(let-values(((begin100_0"
" spec101_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((begin102_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec103_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                   \"bad syntax\""
" orig-s_1))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin102_0"
" spec103_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                           \"bad syntax\""
" orig-s_1)))))"
"(values"
" #t"
" begin100_0"
" spec101_0))))))"
"(let-values(((track-stxes_2"
" exp-specs_2)"
"(loop_0"
" spec101_0"
" at-phase_0"
" protected?_0"
" layer_0)))"
"(values"
"(list*"
" spec_0"
" exp-spec_0"
" track-stxes_2)"
" exp-specs_2)))))))))))))))))))))"
"(values"
"(cons"
" track-stxes1_0"
" track-stxes_1)"
"(cons"
" exp-specs2_0"
" exp-specs_1))))))"
"(values"
" track-stxes_2"
" exp-specs_2)))))"
"(if(not #f)"
"(for-loop_0"
" track-stxes_1"
" exp-specs_1"
" rest_0)"
"(values"
" track-stxes_1"
" exp-specs_1))))"
"(values"
" track-stxes_0"
" exp-specs_0))))))"
" for-loop_0)"
" null"
" null"
" lst_0)))))"
"(values(reverse$1 track-stxes_0)(reverse$1 exp-specs_0)))))"
"(values(apply append track-stxess_0)(apply append exp-specss_0)))))))"
" loop_0)"
" specs_0"
" phase_0"
" #f"
" 'raw)))))"
"(define-values"
"(parse-identifier!)"
"(lambda(spec_0 orig-s_0 sym_0 at-phase_0 ns_0 rp_0 protected?_0)"
"(begin"
"(let-values(((b_0)(resolve+shift/extra-inspector spec_0 at-phase_0 ns_0)))"
"(let-values((()"
"(begin"
"(if b_0"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                             \"provided identifier is not defined or required\""
" orig-s_0"
" spec_0)))"
"(values))))"
"(let-values(((as-transformer?_0)(binding-for-transformer? b_0 spec_0 at-phase_0 ns_0)))"
"(let-values(((immed-b_0)"
"(let-values(((spec118_0) spec_0)((at-phase119_0) at-phase_0)((temp120_0) #t))"
"(resolve+shift28.1 #f #f null temp120_0 #f spec118_0 at-phase119_0))))"
"(let-values(((rp109_0) rp_0)"
"((sym110_0) sym_0)"
"((at-phase111_0) at-phase_0)"
"((b112_0) b_0)"
"((immed-b113_0) immed-b_0)"
"((spec114_0) spec_0)"
"((orig-s115_0) orig-s_0)"
"((protected?116_0) protected?_0)"
"((as-transformer?117_0) as-transformer?_0))"
"(add-provide!117.1"
" protected?116_0"
" as-transformer?117_0"
" rp109_0"
" sym110_0"
" at-phase111_0"
" b112_0"
" immed-b113_0"
" spec114_0"
" orig-s115_0)))))))))"
"(define-values"
"(parse-struct!)"
"(lambda(id:struct_0 orig-s_0 fields_0 at-phase_0 ns_0 rp_0 protected?_0)"
"(begin"
"(let-values(((mk_0)"
"(lambda(fmt_0)"
"(begin"
" 'mk"
"(let-values(((sym_0)(string->symbol(format fmt_0(syntax-e$1 id:struct_0)))))"
"(datum->syntax$1 id:struct_0 sym_0 id:struct_0))))))"
"(let-values(((mk2_0)"
"(lambda(fmt_0 field-id_0)"
"(begin"
" 'mk2"
"(let-values(((sym_0)"
"(string->symbol"
"(format fmt_0(syntax-e$1 id:struct_0)(syntax-e$1 field-id_0)))))"
"(datum->syntax$1 id:struct_0 sym_0 id:struct_0))))))"
"(begin"
"            (let-values (((lst_0) (list \"~a\" \"make-~a\" \"struct:~a\" \"~a?\")))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((fmt_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((id_0)(mk_0 fmt_0)))"
"(parse-identifier!"
" id_0"
" orig-s_0"
"(syntax-e$1 id_0)"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(let-values(((lst_0) fields_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((field_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((get-id_0)"
"                                                                                            (mk2_0 \"~a-~a\" field_0)))"
"(let-values(((set-id_0)"
"(mk2_0"
"                                                                                               \"set-~a-~a!\""
" field_0)))"
"(begin"
"(parse-identifier!"
" get-id_0"
" orig-s_0"
"(syntax-e$1 get-id_0)"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0)"
"(parse-identifier!"
" set-id_0"
" orig-s_0"
"(syntax-e$1 set-id_0)"
" at-phase_0"
" ns_0"
" rp_0"
" protected?_0)))))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))))))"
"(define-values"
"(parse-all-from)"
"(lambda(mod-path-stx_0 orig-s_0 self_0 except-ids_0 at-phase_0 ns_0 rp_0 protected?_0 ctx_0)"
"(begin"
"(let-values(((mod-path_0)(syntax->datum$1 mod-path-stx_0)))"
"(let-values((()"
"(begin"
"(if(1/module-path? mod-path_0)"
"(void)"
"(let-values()"
"                            (raise-syntax-error$1 provide-form-name \"not a module path\" orig-s_0 mod-path-stx_0)))"
"(values))))"
"(let-values(((mpi_0)(module-path->mpi/context mod-path_0 ctx_0)))"
"(parse-all-from-module mpi_0 #f orig-s_0 except-ids_0 #f at-phase_0 ns_0 rp_0 protected?_0)))))))"
"(define-values"
"(parse-all-from-module)"
"(lambda(mpi_0 matching-stx_0 orig-s_0 except-ids_0 prefix-sym_0 at-phase_0 ns_0 rp_0 protected?_0)"
"(begin"
"(let-values(((requireds_0)(extract-module-requires rp_0 mpi_0 at-phase_0)))"
"(let-values(((phase-desc_0)"
"(lambda()"
"(begin"
" 'phase-desc"
"(if(zero-phase? at-phase_0)"
"                            (let-values () \"\")"
"(if(label-phase? at-phase_0)"
"                              (let-values () \" for-label\")"
"                              (let-values () (format \" for phase ~a\" at-phase_0))))))))"
"(let-values((()"
"(begin"
"(if requireds_0"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"                               (format \"cannot provide from a module without a matching require~a\" (phase-desc_0))"
" orig-s_0"
" matching-stx_0)))"
"(values))))"
"(let-values(((add-prefix_0)"
"(lambda(sym_0)"
"(begin"
" 'add-prefix"
"(if prefix-sym_0"
"(string->symbol(string-append(symbol->string prefix-sym_0)(symbol->string sym_0)))"
" sym_0)))))"
"(let-values(((found_0)(make-hasheq)))"
"(begin"
"(let-values(((lst_0) requireds_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((i_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((id_0)"
"(required-id i_0)))"
"(let-values(((phase_0)"
"(required-phase"
" i_0)))"
"(if(let-values(((or-part_0)"
"(if matching-stx_0"
"(not"
"(if(eqv?"
" phase_0"
" at-phase_0)"
"(free-identifier=?$1"
" id_0"
"(datum->syntax$1"
" matching-stx_0"
"(syntax-e$1"
" id_0))"
" phase_0"
" phase_0)"
" #f))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((lst_2)"
" except-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(result_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((except-id_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(if(free-identifier=?$1"
" id_0"
" except-id_0"
" phase_0"
" phase_0)"
"(hash-set!"
" found_0"
" except-id_0"
" #t)"
" #f)))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
" result_1)"
" except-id_0))"
"(not"
" #f)"
" #f)"
"(for-loop_1"
" result_1"
" rest_1)"
" result_1)))"
" result_0)))))"
" for-loop_1)"
" #f"
" lst_2)))))"
"(void)"
"(let-values()"
"(let-values(((b_0)"
"(resolve+shift/extra-inspector"
" id_0"
" phase_0"
" ns_0)))"
"(let-values(((immed-b_0)"
"(let-values(((id130_0)"
" id_0)"
"((phase131_0)"
" phase_0)"
"((temp132_0)"
" #t))"
"(resolve+shift28.1"
" #f"
" #f"
" null"
" temp132_0"
" #f"
" id130_0"
" phase131_0))))"
"(let-values(((rp121_0)"
" rp_0)"
"((temp122_0)"
"(add-prefix_0"
"(syntax-e$1"
" id_0)))"
"((phase123_0)"
" phase_0)"
"((b124_0)"
" b_0)"
"((immed-b125_0)"
" immed-b_0)"
"((id126_0)"
" id_0)"
"((orig-s127_0)"
" orig-s_0)"
"((protected?128_0)"
" protected?_0)"
"((temp129_0)"
"(required-as-transformer?"
" i_0)))"
"(add-provide!117.1"
" protected?128_0"
" temp129_0"
" rp121_0"
" temp122_0"
" phase123_0"
" b124_0"
" immed-b125_0"
" id126_0"
" orig-s127_0)))))))))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(if(=(hash-count found_0)(length except-ids_0))"
"(void)"
"(let-values()"
"(begin"
"(let-values(((lst_0) except-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((except-id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(if(let-values(((or-part_0)"
"(hash-ref"
" found_0"
" except-id_0"
" #f)))"
"(if or-part_0"
" or-part_0"
"(let-values(((lst_2)"
" requireds_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_1)"
"(lambda(result_0"
" lst_3)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_3)"
"(let-values(((i_0)"
"(unsafe-car"
" lst_3))"
"((rest_1)"
"(unsafe-cdr"
" lst_3)))"
"(let-values(((result_1)"
"(let-values()"
"(let-values(((result_1)"
"(let-values()"
"(let-values()"
"(let-values(((id_0)"
"(required-id"
" i_0)))"
"(let-values(((phase_0)"
"(required-phase"
" i_0)))"
"(free-identifier=?$1"
" id_0"
" except-id_0"
" phase_0"
" phase_0)))))))"
"(values"
" result_1)))))"
"(if(if(not"
"((lambda x_0"
" result_1)"
" i_0))"
"(not"
" #f)"
" #f)"
"(for-loop_1"
" result_1"
" rest_1)"
" result_1)))"
" result_0)))))"
" for-loop_1)"
" #f"
" lst_2)))))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" provide-form-name"
"(format"
"(if matching-stx_0"
"                                                                                                  \"excluded identifier was not defined or required in the module~a\""
"                                                                                                  \"excluded identifier was not required from the specified module~a\")"
"(phase-desc_0))"
" orig-s_0"
" except-id_0))))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))))))))))))"
"(define-values"
"(check-cross-phase-persistent-form)"
"(lambda(bodys_0 self-mpi_0)"
"(begin"
"(letrec-values(((check-body_0)"
"(lambda(bodys_1)"
"(begin"
" 'check-body"
"(begin"
"(let-values(((lst_0) bodys_1))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((p_0)"
"(if(expanded+parsed?"
" body_0)"
"(expanded+parsed-parsed"
" body_0)"
" body_0)))"
"(if(parsed-define-values?"
" p_0)"
"(let-values()"
"(check-expr_0"
"(parsed-define-values-rhs"
" p_0)"
"(length"
"(parsed-define-values-syms"
" p_0))"
" p_0))"
"(if(let-values(((or-part_0)"
"(parsed-#%declare?"
" p_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(parsed-module?"
" p_0)))"
"(if or-part_1"
" or-part_1"
"(syntax?$1"
" p_0)))))"
"(let-values()"
"(void))"
"(let-values()"
"(disallow"
" p_0))))))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))))"
"((check-expr_0)"
"(lambda(e_0 num-results_0 enclosing_0)"
"(begin"
" 'check-expr"
"(if(parsed-lambda? e_0)"
"(let-values()"
"(begin(check-count 1 num-results_0 enclosing_0)(check-no-disallowed-expr_0 e_0)))"
"(if(parsed-case-lambda? e_0)"
"(let-values()"
"(begin(check-count 1 num-results_0 enclosing_0)(check-no-disallowed-expr_0 e_0)))"
"(if(parsed-quote? e_0)"
"(let-values()"
"(begin"
"(check-datum(parsed-quote-datum e_0) e_0)"
"(check-count 1 num-results_0 enclosing_0)))"
"(if(parsed-app? e_0)"
"(let-values()"
"(let-values(((rands_0)(parsed-app-rands e_0)))"
"(begin"
"(let-values(((lst_0) rands_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((rand_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(check-expr_0"
" rand_0"
" 1"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(let-values(((tmp_0)(cross-phase-primitive-name(parsed-app-rator e_0))))"
"(if(if(equal? tmp_0 'cons) #t(equal? tmp_0 'list))"
"(let-values()(check-count 1 num-results_0 enclosing_0))"
"(if(equal? tmp_0 'make-struct-type)"
"(let-values()(check-count 5 num-results_0 enclosing_0))"
"(if(equal? tmp_0 'make-struct-type-property)"
"(let-values()(check-count 3 num-results_0 enclosing_0))"
"(if(equal? tmp_0 'gensym)"
"(let-values()"
"(if(let-values(((or-part_0)(= 0(length rands_0))))"
"(if or-part_0"
" or-part_0"
"(if(= 1(length rands_0))"
"(quoted-string?(car rands_0))"
" #f)))"
"(void)"
"(let-values()(disallow e_0))))"
"(if(equal? tmp_0 'string->uninterned-symbol)"
"(let-values()"
"(if(if(= 1(length rands_0))(quoted-string?(car rands_0)) #f)"
"(void)"
"(let-values()(disallow e_0))))"
"(let-values()(disallow e_0)))))))))))"
"(let-values()(check-no-disallowed-expr_0 e_0)))))))))"
"((check-no-disallowed-expr_0)"
"(lambda(e_0)"
"(begin"
" 'check-no-disallowed-expr"
"(if(parsed-lambda? e_0)"
"(let-values()(check-body-no-disallowed-expr_0(parsed-lambda-body e_0)))"
"(if(parsed-case-lambda? e_0)"
"(let-values()"
"(begin"
"(let-values(((lst_0)(parsed-case-lambda-clauses e_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((clause_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(check-body-no-disallowed-expr_0"
"(cadr clause_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))"
"(if(parsed-app? e_0)"
"(let-values()"
"(begin"
"(check-no-disallowed-expr_0(parsed-app-rator e_0))"
"(let-values(((lst_0)(parsed-app-rands e_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_1)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(check-no-disallowed-expr_0"
" e_1))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))"
"(if(parsed-if? e_0)"
"(let-values()"
"(begin"
"(check-no-disallowed-expr_0(parsed-if-tst e_0))"
"(check-no-disallowed-expr_0(parsed-if-thn e_0))"
"(check-no-disallowed-expr_0(parsed-if-els e_0))))"
"(if(parsed-set!? e_0)"
"(let-values()"
"(let-values(((id_0)(parsed-set!-id e_0)))"
"(let-values(((normal-b_0)(parsed-id-binding id_0)))"
"(begin"
"(if(let-values(((or-part_0)(not normal-b_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(parsed-top-id? id_0)))"
"(if or-part_1"
" or-part_1"
"(if(not(symbol? normal-b_0))"
"(eq?(module-binding-module normal-b_0) self-mpi_0)"
" #f)))))"
"(let-values()(disallow e_0))"
"(void))"
"(check-no-disallowed-expr_0(parsed-set!-rhs e_0))))))"
"(if(parsed-with-continuation-mark? e_0)"
"(let-values()"
"(begin"
"(check-no-disallowed-expr_0(parsed-with-continuation-mark-key e_0))"
"(check-no-disallowed-expr_0(parsed-with-continuation-mark-val e_0))"
"(check-no-disallowed-expr_0(parsed-with-continuation-mark-body e_0))))"
"(if(parsed-begin? e_0)"
"(let-values()(check-body-no-disallowed-expr_0(parsed-begin-body e_0)))"
"(if(parsed-begin0? e_0)"
"(let-values()(check-body-no-disallowed-expr_0(parsed-begin0-body e_0)))"
"(if(parsed-let_-values? e_0)"
"(let-values()"
"(begin"
"(let-values(((lst_0)(parsed-let_-values-clauses e_0)))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((clause_0)"
"(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(check-no-disallowed-expr_0"
"(cadr"
" clause_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_0 rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(check-body-no-disallowed-expr_0(parsed-let_-values-body e_0))))"
"(if(let-values(((or-part_0)(parsed-quote-syntax? e_0)))"
"(if or-part_0 or-part_0(parsed-#%variable-reference? e_0)))"
"(let-values()(disallow e_0))"
"(let-values()(void)))))))))))))))"
"((check-body-no-disallowed-expr_0)"
"(lambda(l_0)"
"(begin"
" 'check-body-no-disallowed-expr"
"(begin"
"(let-values(((lst_0) l_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((e_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(check-no-disallowed-expr_0"
" e_0))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void))))))"
"(check-body_0 bodys_0)))))"
"(define-values"
"(check-count)"
"(lambda(is-num_0 expected-num_0 enclosing_0)"
"(begin(if(= is-num_0 expected-num_0)(void)(let-values()(disallow enclosing_0))))))"
"(define-values"
"(check-datum)"
"(lambda(d_0 e_0)"
"(begin"
"(if(let-values(((or-part_0)(number? d_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)(boolean? d_0)))"
"(if or-part_1"
" or-part_1"
"(let-values(((or-part_2)(symbol? d_0)))"
"(if or-part_2"
" or-part_2"
"(let-values(((or-part_3)(string? d_0)))"
"(if or-part_3"
" or-part_3"
"(let-values(((or-part_4)(bytes? d_0)))(if or-part_4 or-part_4(null? d_0)))))))))))"
"(let-values()(void))"
"(let-values()(disallow e_0))))))"
"(define-values(quoted-string?)(lambda(e_0)(begin(if(parsed-quote? e_0)(string?(parsed-quote-datum e_0)) #f))))"
"(define-values"
"(cross-phase-primitive-name)"
"(lambda(id_0)"
"(begin"
"(if(parsed-id? id_0)"
"(let-values()"
"(let-values(((b_0)(parsed-id-binding id_0)))"
"(if(module-binding? b_0)"
"(if(eq? runtime-module-name(1/module-path-index-resolve(module-binding-module b_0)))"
"(module-binding-sym b_0)"
" #f)"
" #f)))"
"(let-values() #f)))))"
"(define-values"
"(disallow)"
"(lambda(body_0)"
"(begin"
"(raise-syntax-error$1"
" 'module"
"       \"not allowed in a cross-phase persistent module\""
"(if(parsed? body_0)(datum->syntax$1 #f body_0(parsed-s body_0)) body_0)))))"
"(void"
"(add-core-form!*"
" 'module"
"(lambda(s_0 ctx_0)"
"(begin"
"(if(eq?(expand-context-context ctx_0) 'top-level)"
"(void)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-module)))(void)))"
"             (raise-syntax-error$1 #f \"allowed only at the top level\" s_0))))"
"(if log-performance?(let-values()(start-performance-region 'expand 'module))(void))"
"(begin0"
"(let-values()"
"(let-values(((s219_0) s_0)((ctx220_0) ctx_0)((temp221_0) #f))"
"(expand-module16.1 #f #f #f #f unsafe-undefined #f s219_0 ctx220_0 temp221_0)))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))"
"(void"
"(add-core-form!*"
" 'module*"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-module)))(void)))"
"       (raise-syntax-error$1 #f \"illegal use (not in a module top-level)\" s_0)))))"
"(void"
"(add-core-form!*"
" '#%module-begin"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-module-begin)))(void)))"
"(if(eq?(expand-context-context ctx_0) 'module-begin)"
"(void)"
"         (let-values () (raise-syntax-error$1 #f \"not in a module-definition context\" s_0)))"
"(if(expand-context-module-begin-k ctx_0)"
"(void)"
"         (let-values () (raise-syntax-error$1 #f \"not currently transforming a module\" s_0)))"
"((expand-context-module-begin-k ctx_0)"
" s_0"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner222_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((module-begin-k223_0) #f))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
"(root-expand-context/inner-lift-key the-struct_1)"
"(expand-context/inner-to-parsed? the-struct_1)"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
"(expand-context/inner-just-once? the-struct_1)"
" module-begin-k223_0"
"(expand-context/inner-allow-unbound? the-struct_1)"
"(expand-context/inner-in-local-expand? the-struct_1)"
"(expand-context/inner-keep-#%expression? the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names the-struct_1)"
"(expand-context/inner-lifts the-struct_1)"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-should-not-encounter-macros? the-struct_1)))"
"                                (raise-argument-error 'struct-copy \"expand-context/inner?\" the-struct_1)))))"
"(expand-context/outer1.1"
" inner222_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"              (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0)))))))))"
"(void"
"(add-core-form!*"
" '#%declare"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-declare)))(void)))"
"       (raise-syntax-error$1 #f \"not allowed outside of a module body\" s_0)))))"
"(define-values"
"(expand-module16.1)"
"(lambda(always-produce-compiled?1_0"
" enclosing-is-cross-phase-persistent?3_0"
" enclosing-requires+provides4_0"
" keep-enclosing-scope-at-phase2_0"
" modules-being-compiled6_0"
" mpis-for-enclosing-reset5_0"
" s13_0"
" init-ctx14_0"
" enclosing-self15_0)"
"(begin"
" 'expand-module16"
"(let-values(((s_0) s13_0))"
"(let-values(((init-ctx_0) init-ctx14_0))"
"(let-values(((enclosing-self_0) enclosing-self15_0))"
"(let-values(((always-produce-compiled?_0) always-produce-compiled?1_0))"
"(let-values(((keep-enclosing-scope-at-phase_0) keep-enclosing-scope-at-phase2_0))"
"(let-values(((enclosing-is-cross-phase-persistent?_0) enclosing-is-cross-phase-persistent?3_0))"
"(let-values(((enclosing-r+p_0) enclosing-requires+provides4_0))"
"(let-values(((mpis-for-enclosing-reset_0) mpis-for-enclosing-reset5_0))"
"(let-values(((modules-being-compiled_0)"
"(if(eq? modules-being-compiled6_0 unsafe-undefined)"
"(make-hasheq)"
" modules-being-compiled6_0)))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer init-ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-module)))"
"(void)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 module224_0 id:module-name225_0 initial-require226_0 body227_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((module224_0"
" id:module-name225_0"
" initial-require226_0"
" body227_0)"
"(let-values(((s_2)"
"(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((module228_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((id:module-name229_0"
" initial-require230_0"
" body231_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((id:module-name232_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_5)"
"(symbol?"
"(syntax-e$1"
" s_5))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_5)))"
" s_5"
"(raise-syntax-error$1"
" #f"
"                                                                                                         \"not an identifier\""
" orig-s_0"
" s_5))))"
"((initial-require233_0"
" body234_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((initial-require235_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"((body236_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                   \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" initial-require235_0"
" body236_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                           \"bad syntax\""
" orig-s_0))))))"
"(values"
" id:module-name232_0"
" initial-require233_0"
" body234_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                       \"bad syntax\""
" orig-s_0))))))"
"(values"
" module228_0"
" id:module-name229_0"
" initial-require230_0"
" body231_0))"
"                                                                  (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values"
" #t"
" module224_0"
" id:module-name225_0"
" initial-require226_0"
" body227_0))))))"
"(let-values(((rebuild-s_0)"
"(let-values(((init-ctx249_0) init-ctx_0)"
"((s250_0) s_0)"
"((temp251_0) #t)"
"((temp252_0) #t))"
"(keep-as-needed119.1 #f temp252_0 temp251_0 init-ctx249_0 s250_0))))"
"(let-values(((initial-require_0)(syntax->datum$1 initial-require226_0)))"
"(let-values((()"
"(begin"
"(if(let-values(((or-part_0) keep-enclosing-scope-at-phase_0))"
"(if or-part_0 or-part_0(1/module-path? initial-require_0)))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                         \"not a module path\""
" s_0"
" initial-require226_0)))"
"(values))))"
"(let-values(((phase_0) 0))"
"(let-values(((module-name-sym_0)(syntax-e$1 id:module-name225_0)))"
"(let-values(((outside-scope_0)(new-scope 'module)))"
"(let-values(((inside-scope_0)(new-multi-scope module-name-sym_0)))"
"(let-values(((self_0)"
"(make-self-module-path-index"
"(if enclosing-self_0"
" module-name-sym_0"
"(string->uninterned-symbol"
"(symbol->string module-name-sym_0)))"
" enclosing-self_0)))"
"(let-values(((enclosing-mod_0)"
"(if enclosing-self_0"
"                                                                (1/module-path-index-join '(submod \"..\") self_0)"
" #f)))"
"(let-values((()"
"(begin"
"(if(if enclosing-mod_0 mpis-for-enclosing-reset_0 #f)"
"(let-values()"
"(set-box!"
" mpis-for-enclosing-reset_0"
"(cons"
" enclosing-mod_0"
"(unbox mpis-for-enclosing-reset_0))))"
"(void))"
"(values))))"
"(let-values(((apply-module-scopes_0)"
"(make-apply-module-scopes"
" outside-scope_0"
" inside-scope_0"
" init-ctx_0"
" keep-enclosing-scope-at-phase_0"
" self_0"
" enclosing-self_0"
" enclosing-mod_0)))"
"(let-values(((initial-require-s_0)"
"(apply-module-scopes_0 initial-require226_0)))"
"(let-values(((all-scopes-s_0) initial-require-s_0))"
"(let-values(((root-ctx_0)"
"(let-values(((self253_0) self_0)"
"((temp254_0)"
"(if keep-enclosing-scope-at-phase_0"
"(root-expand-context-module-scopes"
" init-ctx_0)"
" null))"
"((outside-scope255_0)"
" outside-scope_0)"
"((inside-scope256_0)"
" inside-scope_0)"
"((all-scopes-s257_0)"
" all-scopes-s_0))"
"(make-root-expand-context13.1"
" all-scopes-s257_0"
" temp254_0"
" outside-scope255_0"
" inside-scope256_0"
" self253_0))))"
"(let-values(((new-module-scopes_0)"
"(root-expand-context-module-scopes"
" root-ctx_0)))"
"(let-values(((frame-id_0)"
"(root-expand-context-frame-id root-ctx_0)))"
"(let-values(((make-m-ns240_0)"
"(lambda(for-submodule?237_0 ns239_0)"
"(begin"
" 'make-m-ns240"
"(let-values(((ns_0) ns239_0))"
"(let-values(((for-submodule?_0)"
"(if(eq?"
" for-submodule?237_0"
" unsafe-undefined)"
"(if enclosing-self_0"
" #t"
" #f)"
" for-submodule?237_0)))"
"(let-values()"
"(let-values(((ns258_0) ns_0)"
"((self259_0)"
" self_0)"
"((root-ctx260_0)"
" root-ctx_0)"
"((for-submodule?261_0)"
" for-submodule?_0))"
"(make-module-namespace50.1"
" for-submodule?261_0"
" self259_0"
" root-ctx260_0"
" ns258_0)))))))))"
"(let-values()"
"(let-values()"
"(let-values(((m-ns_0)"
"(let-values(((temp262_0)"
"(expand-context-namespace"
" init-ctx_0)))"
"(make-m-ns240_0"
" unsafe-undefined"
" temp262_0))))"
"(let-values(((ctx_0)"
"(let-values(((v_0)"
"(copy-root-expand-context"
" init-ctx_0"
" root-ctx_0)))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((post-expansion263_0)"
"(lambda(s_1)"
"(begin"
" 'post-expansion263"
"(add-scope"
" s_1"
" inside-scope_0))))"
"((inner264_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((allow-unbound?265_0)"
" #f)"
"((namespace266_0)"
" m-ns_0)"
"((phase267_0)"
" phase_0)"
"((just-once?268_0)"
" #f))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
" phase267_0"
" namespace266_0"
" just-once?268_0"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
" allow-unbound?265_0"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                               \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner264_0"
" post-expansion263_0"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                             \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((bodys_0)"
"(let-values(((scoped-s_0)"
"(apply-module-scopes_0"
" disarmed-s_0)))"
"(let-values(((ok?_1"
" _269_0"
" _270_0"
" _271_0"
" body272_0)"
"(let-values(((s_1)"
" scoped-s_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((_269_0"
" _270_0"
" _271_0"
" body272_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((_273_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((_274_0"
" _275_0"
" body276_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((_277_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
" s_5))"
"((_278_0"
" body279_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((_280_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"((body281_0)"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_8)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                               \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" _280_0"
" body281_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                       \"bad syntax\""
" orig-s_0))))))"
"(values"
" _277_0"
" _278_0"
" body279_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                   \"bad syntax\""
" orig-s_0))))))"
"(values"
" _273_0"
" _274_0"
" _275_0"
" body276_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                               \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" _269_0"
" _270_0"
" _271_0"
" body272_0))))))"
" body272_0))))"
"(let-values(((requires+provides_0)"
"(let-values(((self282_0)"
" self_0))"
"(make-requires+provides8.1"
" #f"
" self282_0))))"
"(let-values(((defined-syms_0)"
"(root-expand-context-defined-syms"
" root-ctx_0)))"
"(let-values(((compiled-submodules_0)"
"(make-hasheq)))"
"(let-values(((compiled-module-box_0)"
"(box #f)))"
"(let-values(((mpis-to-reset_0)"
"(box null)))"
"(let-values(((initial-require!245_0)"
"(lambda(bind?243_0)"
"(begin"
" 'initial-require!245"
"(let-values(((bind?_0)"
" bind?243_0))"
"(let-values()"
"(if(not"
" keep-enclosing-scope-at-phase_0)"
"(let-values()"
"(let-values(((initial-require283_0)"
" initial-require_0)"
"((self284_0)"
" self_0)"
"((all-scopes-s285_0)"
" all-scopes-s_0)"
"((m-ns286_0)"
" m-ns_0)"
"((requires+provides287_0)"
" requires+provides_0)"
"((bind?288_0)"
" bind?_0)"
"((temp289_0)"
" 'module))"
"(perform-initial-require!42.1"
" bind?288_0"
" temp289_0"
" initial-require283_0"
" self284_0"
" all-scopes-s285_0"
" m-ns286_0"
" requires+provides287_0)))"
"(let-values()"
"(begin"
"(add-required-module!"
" requires+provides_0"
" enclosing-mod_0"
" keep-enclosing-scope-at-phase_0"
" enclosing-is-cross-phase-persistent?_0)"
"(let-values(((requires+provides290_0)"
" requires+provides_0)"
"((enclosing-r+p291_0)"
" enclosing-r+p_0)"
"((enclosing-mod292_0)"
" enclosing-mod_0)"
"((keep-enclosing-scope-at-phase293_0)"
" keep-enclosing-scope-at-phase_0))"
"(add-enclosing-module-defined-and-required!67.1"
" enclosing-r+p291_0"
" requires+provides290_0"
" enclosing-mod292_0"
" keep-enclosing-scope-at-phase293_0))"
"(let-values(((m-ns294_0)"
" m-ns_0)"
"((enclosing-mod295_0)"
" enclosing-mod_0)"
"((keep-enclosing-scope-at-phase296_0)"
" keep-enclosing-scope-at-phase_0))"
"(namespace-module-visit!104.1"
" unsafe-undefined"
" m-ns294_0"
" enclosing-mod295_0"
" keep-enclosing-scope-at-phase296_0)))))))))))"
"(let-values()"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" init-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'prepare-env)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((temp248_0)"
" #t))"
"(initial-require!245_0"
" temp248_0))"
"(values))))"
"(let-values(((again?_0)"
" #f))"
"(letrec-values(((module-begin-k_0)"
"(lambda(mb-s_0"
" mb-init-ctx_0)"
"(begin"
" 'module-begin-k"
"(let-values((()"
"(begin"
"(if again?_0"
"(let-values()"
"(begin"
"(requires+provides-reset!"
" requires+provides_0)"
"(let-values(((temp301_0)"
" #f))"
"(initial-require!245_0"
" temp301_0))"
"(hash-clear!"
" compiled-submodules_0)"
"(set-box!"
" compiled-module-box_0"
" #f)))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(set! again?_0"
" #t)"
"(values))))"
"(let-values(((ctx_1)"
"(let-values(((v_0)"
" mb-init-ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((post-expansion302_0)"
"(lambda(s_1)"
"(begin"
" 'post-expansion302"
"(add-scope"
" s_1"
" inside-scope_0))))"
"((inner303_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((module-begin-k304_0)"
"(lambda(s_1"
" ctx_1)"
"(begin"
" 'module-begin-k304"
"(let-values(((new-requires+provides_0)"
"(let-values(((self313_0)"
" self_0)"
"((requires+provides314_0)"
" requires+provides_0))"
"(make-requires+provides8.1"
" requires+provides314_0"
" self313_0))))"
"(let-values(((requires+provides305_0)"
" requires+provides_0)"
"((compiled-submodules306_0)"
" compiled-submodules_0)"
"((compiled-module-box307_0)"
" compiled-module-box_0)"
"((defined-syms308_0)"
" defined-syms_0)"
"((requires+provides309_0)"
" new-requires+provides_0)"
"((compiled-submodules310_0)"
"(make-hasheq))"
"((compiled-module-box311_0)"
"(box"
" #f))"
"((defined-syms312_0)"
"(make-hasheq)))"
"(dynamic-wind"
"(lambda()"
"(begin"
"(set! requires+provides_0"
" requires+provides309_0)"
"(set! compiled-submodules_0"
" compiled-submodules310_0)"
"(set! compiled-module-box_0"
" compiled-module-box311_0)"
"(set! defined-syms_0"
" defined-syms312_0)))"
"(lambda()"
"(module-begin-k_0"
" s_1"
" ctx_1))"
"(lambda()"
"(begin"
"(set! requires+provides_0"
" requires+provides305_0)"
"(set! compiled-submodules_0"
" compiled-submodules306_0)"
"(set! compiled-module-box_0"
" compiled-module-box307_0)"
"(set! defined-syms_0"
" defined-syms308_0))))))))))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
" module-begin-k304_0"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                  \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner303_0"
" post-expansion302_0"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((added-s_0)"
"(add-scope"
" mb-s_0"
" inside-scope_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-one"
" added-s_0)))"
"(void)))"
"(values))))"
"(let-values(((disarmed-mb-s_0)"
"(syntax-disarm$1"
" added-s_0)))"
"(let-values(((ok?_1"
" #%module-begin297_0"
" body298_0)"
"(let-values(((s_1)"
" disarmed-mb-s_0))"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((#%module-begin297_0"
" body298_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((#%module-begin299_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((body300_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_4)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" #%module-begin299_0"
" body300_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                        \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" #%module-begin297_0"
" body298_0))))))"
"(let-values(((bodys_1)"
" body298_0))"
"(let-values(((rebuild-mb-s_0)"
"(let-values(((ctx315_0)"
" ctx_1)"
"((mb-s316_0)"
" mb-s_0))"
"(keep-as-needed119.1"
" #f"
" #f"
" #f"
" ctx315_0"
" mb-s316_0))))"
"(let-values(((need-eventually-defined_0)"
"(make-hasheqv)))"
"(let-values(((module-ends_0)"
"(make-shared-module-ends)))"
"(let-values(((declared-keywords_0)"
"(make-hasheq)))"
"(let-values(((declared-submodule-names_0)"
"(make-hasheq)))"
"(let-values(((expression-expanded-bodys_0)"
"((letrec-values(((pass-1-and-2-loop_0)"
"(lambda(bodys_2"
" phase_1"
" keep-stops?_0)"
"(begin"
" 'pass-1-and-2-loop"
"(let-values(((def-ctx-scopes_0)"
"(box"
" null)))"
"(let-values(((partial-body-ctx_0)"
"(let-values(((v_0)"
" ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((context325_0)"
" 'module)"
"((def-ctx-scopes326_0)"
" def-ctx-scopes_0)"
"((need-eventually-defined327_0)"
" need-eventually-defined_0)"
"((inner328_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((phase329_0)"
" phase_1)"
"((namespace330_0)"
"(namespace->namespace-at-phase"
" m-ns_0"
" phase_1))"
"((stops331_0)"
"(free-id-set"
" phase_1"
"(module-expand-stop-ids"
" phase_1)))"
"((declared-submodule-names332_0)"
" declared-submodule-names_0)"
"((lift-key333_0)"
"(generate-lift-key))"
"((lifts334_0)"
"(let-values(((temp338_0)"
"(make-wrap-as-definition"
" self_0"
" frame-id_0"
" inside-scope_0"
" all-scopes-s_0"
" defined-syms_0"
" requires+provides_0)))"
"(make-lift-context6.1"
" #f"
" temp338_0)))"
"((module-lifts335_0)"
"(make-module-lift-context"
" phase_1"
" #t))"
"((require-lifts336_0)"
"(make-require-lift-context"
" phase_1"
"(let-values(((m-ns339_0)"
" m-ns_0)"
"((self340_0)"
" self_0)"
"((requires+provides341_0)"
" requires+provides_0)"
"((declared-submodule-names342_0)"
" declared-submodule-names_0))"
"(make-parse-lifted-require216.1"
" declared-submodule-names342_0"
" m-ns339_0"
" self340_0"
" requires+provides341_0))))"
"((to-module-lifts337_0)"
"(let-values(((phase343_0)"
" phase_1)"
"((module-ends344_0)"
" module-ends_0)"
"((temp345_0)"
" #f))"
"(make-to-module-lift-context27.1"
" temp345_0"
" module-ends344_0"
" phase343_0))))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
" lift-key333_0"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
" phase329_0"
" namespace330_0"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
" stops331_0"
" declared-submodule-names332_0"
" lifts334_0"
"(expand-context/inner-lift-envs"
" the-struct_1)"
" module-lifts335_0"
" require-lifts336_0"
" to-module-lifts337_0"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                              \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner328_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
" context325_0"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
" def-ctx-scopes326_0"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
" need-eventually-defined327_0"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                            \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((partially-expanded-bodys_0)"
"(let-values(((bodys346_0)"
" bodys_2)"
"((phase347_0)"
" phase_1)"
"((partial-body-ctx348_0)"
" partial-body-ctx_0)"
"((m-ns349_0)"
" m-ns_0)"
"((self350_0)"
" self_0)"
"((frame-id351_0)"
" frame-id_0)"
"((requires+provides352_0)"
" requires+provides_0)"
"((need-eventually-defined353_0)"
" need-eventually-defined_0)"
"((all-scopes-s354_0)"
" all-scopes-s_0)"
"((defined-syms355_0)"
" defined-syms_0)"
"((declared-keywords356_0)"
" declared-keywords_0)"
"((declared-submodule-names357_0)"
" declared-submodule-names_0)"
"((compiled-submodules358_0)"
" compiled-submodules_0)"
"((modules-being-compiled359_0)"
" modules-being-compiled_0)"
"((mpis-to-reset360_0)"
" mpis-to-reset_0)"
"((pass-1-and-2-loop361_0)"
" pass-1-and-2-loop_0))"
"(partially-expand-bodys79.1"
" all-scopes-s354_0"
" compiled-submodules358_0"
" partial-body-ctx348_0"
" declared-keywords356_0"
" declared-submodule-names357_0"
" defined-syms355_0"
" frame-id351_0"
" pass-1-and-2-loop361_0"
" modules-being-compiled359_0"
" mpis-to-reset360_0"
" m-ns349_0"
" need-eventually-defined353_0"
" phase347_0"
" requires+provides352_0"
" self350_0"
" bodys346_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void)))"
"(values))))"
"(let-values(((body-ctx_0)"
"(let-values(((v_0)"
"(accumulate-def-ctx-scopes"
" partial-body-ctx_0"
" def-ctx-scopes_0)))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((def-ctx-scopes362_0)"
" #f)"
"((post-expansion363_0)"
" #f)"
"((inner364_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((stops365_0)"
"(if keep-stops?_0"
"(expand-context-stops"
" ctx_1)"
" empty-free-id-set))"
"((to-module-lifts366_0)"
"(let-values(((phase367_0)"
" phase_1)"
"((module-ends368_0)"
" module-ends_0)"
"((temp369_0)"
" #t))"
"(make-to-module-lift-context27.1"
" temp369_0"
" module-ends368_0"
" phase367_0))))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
" stops365_0"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
" to-module-lifts366_0"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                                    \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner364_0"
" post-expansion363_0"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
" def-ctx-scopes362_0"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                                  \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((partially-expanded-bodys317_0)"
" partially-expanded-bodys_0)"
"((phase318_0)"
" phase_1)"
"((body-ctx319_0)"
" body-ctx_0)"
"((self320_0)"
" self_0)"
"((declared-submodule-names321_0)"
" declared-submodule-names_0)"
"((compiled-submodules322_0)"
" compiled-submodules_0)"
"((modules-being-compiled323_0)"
" modules-being-compiled_0)"
"((mpis-to-reset324_0)"
" mpis-to-reset_0))"
"(finish-expanding-body-expressons97.1"
" compiled-submodules322_0"
" body-ctx319_0"
" declared-submodule-names321_0"
" modules-being-compiled323_0"
" mpis-to-reset324_0"
" phase318_0"
" self320_0"
" partially-expanded-bodys317_0)))))))))))"
" pass-1-and-2-loop_0)"
" bodys_1"
" phase_0"
"(stop-at-module*?"
" ctx_1))))"
"(let-values((()"
"(begin"
"(check-defined-by-now"
" need-eventually-defined_0"
" self_0"
" ctx_1"
" requires+provides_0)"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void)))"
"(values))))"
"(let-values(((fully-expanded-bodys-except-post-submodules_0)"
"(let-values(((expression-expanded-bodys370_0)"
" expression-expanded-bodys_0)"
"((requires+provides371_0)"
" requires+provides_0)"
"((declared-submodule-names372_0)"
" declared-submodule-names_0)"
"((m-ns373_0)"
" m-ns_0)"
"((phase374_0)"
" phase_0)"
"((self375_0)"
" self_0)"
"((ctx376_0)"
" ctx_1))"
"(resolve-provides113.1"
" ctx376_0"
" declared-submodule-names372_0"
" m-ns373_0"
" phase374_0"
" requires+provides371_0"
" self375_0"
" expression-expanded-bodys370_0))))"
"(let-values(((is-cross-phase-persistent?_0)"
"(hash-ref"
" declared-keywords_0"
" '#:cross-phase-persistent"
" #f)))"
"(let-values((()"
"(begin"
"(if is-cross-phase-persistent?_0"
"(let-values()"
"(begin"
"(if(requires+provides-can-cross-phase-persistent?"
" requires+provides_0)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                      \"cannot be cross-phase persistent due to required modules\""
" rebuild-s_0"
"(hash-ref"
" declared-keywords_0"
" '#:cross-phase-persistent))))"
"(check-cross-phase-persistent-form"
" fully-expanded-bodys-except-post-submodules_0"
" self_0)))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_1)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((submod-m-ns_0)"
"(let-values(((m-ns377_0)"
" m-ns_0)"
"((temp378_0)"
" #t))"
"(make-m-ns240_0"
" temp378_0"
" m-ns377_0))))"
"(let-values(((submod-ctx_0)"
"(let-values(((v_0)"
" ctx_1))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((frame-id379_0)"
" #f)"
"((post-expansion380_0)"
" #f)"
"((inner381_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((namespace382_0)"
" submod-m-ns_0))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
" namespace382_0"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                                        \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner381_0"
" post-expansion380_0"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
" frame-id379_0"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                      \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((declare-enclosing-module_0)"
"(promise1.1"
"(lambda()"
"(let-values(((fully-expanded-bodys-except-post-submodules383_0)"
" fully-expanded-bodys-except-post-submodules_0)"
"((temp384_0)"
" id:module-name225_0)"
"((rebuild-s385_0)"
" rebuild-s_0)"
"((requires+provides386_0)"
" requires+provides_0)"
"((submod-m-ns387_0)"
" submod-m-ns_0)"
"((self388_0)"
" self_0)"
"((enclosing-self389_0)"
" enclosing-self_0)"
"((root-ctx390_0)"
" root-ctx_0)"
"((submod-ctx391_0)"
" submod-ctx_0)"
"((modules-being-compiled392_0)"
" modules-being-compiled_0)"
"((compiled-module-box393_0)"
" compiled-module-box_0))"
"(declare-module-for-expansion137.1"
" submod-ctx391_0"
" enclosing-self389_0"
" compiled-module-box393_0"
" temp384_0"
" modules-being-compiled392_0"
" submod-m-ns387_0"
" rebuild-s385_0"
" requires+provides386_0"
" root-ctx390_0"
" self388_0"
" fully-expanded-bodys-except-post-submodules383_0)))"
" #f)))"
"(let-values(((fully-expanded-bodys_0)"
"(if(stop-at-module*?"
" submod-ctx_0)"
"(let-values()"
" fully-expanded-bodys-except-post-submodules_0)"
"(let-values()"
"(let-values(((fully-expanded-bodys-except-post-submodules394_0)"
" fully-expanded-bodys-except-post-submodules_0)"
"((declare-enclosing-module395_0)"
" declare-enclosing-module_0)"
"((phase396_0)"
" phase_0)"
"((self397_0)"
" self_0)"
"((requires+provides398_0)"
" requires+provides_0)"
"((is-cross-phase-persistent?399_0)"
" is-cross-phase-persistent?_0)"
"((all-scopes-s400_0)"
" all-scopes-s_0)"
"((mpis-to-reset401_0)"
" mpis-to-reset_0)"
"((declared-submodule-names402_0)"
" declared-submodule-names_0)"
"((compiled-submodules403_0)"
" compiled-submodules_0)"
"((modules-being-compiled404_0)"
" modules-being-compiled_0)"
"((submod-ctx405_0)"
" submod-ctx_0))"
"(expand-post-submodules163.1"
" all-scopes-s400_0"
" compiled-submodules403_0"
" submod-ctx405_0"
" declare-enclosing-module395_0"
" declared-submodule-names402_0"
" is-cross-phase-persistent?399_0"
" modules-being-compiled404_0"
" mpis-to-reset401_0"
" phase396_0"
" requires+provides398_0"
" self397_0"
" fully-expanded-bodys-except-post-submodules394_0))))))"
"(if(expand-context-to-parsed?"
" submod-ctx_0)"
"(let-values()"
"(parsed-#%module-begin24.1"
" rebuild-mb-s_0"
"(parsed-only"
" fully-expanded-bodys_0)))"
"(let-values()"
"(let-values(((mb-result-s_0)"
"(let-values(((rebuild-mb-s406_0)"
" rebuild-mb-s_0)"
"((temp407_0)"
"(list*"
" #%module-begin297_0"
"(syntax-only"
" fully-expanded-bodys_0))))"
"(rebuild5.1"
" #t"
" rebuild-mb-s406_0"
" temp407_0))))"
"(if(not"
"(expand-context-in-local-expand?"
" submod-ctx_0))"
"(let-values()"
"(expanded+parsed1.1"
" mb-result-s_0"
"(parsed-#%module-begin24.1"
" rebuild-mb-s_0"
"(parsed-only"
" fully-expanded-bodys_0))))"
"(let-values()"
" mb-result-s_0)))))))))))))))))))))))))))))))))"
"(let-values(((mb-ctx_0)"
"(let-values(((v_0)"
" ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((context408_0)"
" 'module-begin)"
"((inner409_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((module-begin-k410_0)"
" module-begin-k_0)"
"((in-local-expand?411_0)"
" #f)"
"((lifts412_0)"
" #f)"
"((module-lifts413_0)"
" #f)"
"((to-module-lifts414_0)"
" #f)"
"((require-lifts415_0)"
" #f))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
" module-begin-k410_0"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
" in-local-expand?411_0"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
" lifts412_0"
"(expand-context/inner-lift-envs"
" the-struct_1)"
" module-lifts413_0"
" require-lifts415_0"
" to-module-lifts414_0"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                           \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner409_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
" context408_0"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                         \"expand-context/outer?\""
" the-struct_0))))))"
"(let-values(((mb-scopes-s_0)"
"(if keep-enclosing-scope-at-phase_0"
"(apply-module-scopes_0"
" disarmed-s_0)"
" all-scopes-s_0)))"
"(let-values(((mb-def-ctx-scopes_0)"
"(box"
" null)))"
"(let-values(((mb_0)"
"(let-values(((bodys416_0)"
" bodys_0)"
"((module-name-sym417_0)"
" module-name-sym_0)"
"((mb-scopes-s418_0)"
" mb-scopes-s_0)"
"((m-ns419_0)"
" m-ns_0)"
"((mb-ctx420_0)"
" mb-ctx_0)"
"((mb-def-ctx-scopes421_0)"
" mb-def-ctx-scopes_0)"
"((phase422_0)"
" phase_0)"
"((s423_0)"
" s_0))"
"(ensure-module-begin34.1"
" mb-ctx420_0"
" mb-def-ctx-scopes421_0"
" m-ns419_0"
" module-name-sym417_0"
" phase422_0"
" s423_0"
" mb-scopes-s418_0"
" bodys416_0))))"
"(let-values(((expanded-mb_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'expand"
" 'module-begin))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((mb424_0)"
" mb_0)"
"((temp425_0)"
"(let-values(((v_0)"
"(accumulate-def-ctx-scopes"
" mb-ctx_0"
" mb-def-ctx-scopes_0)))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((def-ctx-scopes426_0)"
" #f)"
"((inner427_0)"
"(root-expand-context/outer-inner"
" v_0)))"
"(expand-context/outer1.1"
" inner427_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
" def-ctx-scopes426_0"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                     \"expand-context/outer?\""
" the-struct_0))))))"
"(expand9.1"
" #f"
" #f"
" #f"
" mb424_0"
" temp425_0)))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(let-values(((requires_0"
" provides_0)"
"(extract-requires-and-provides"
" requires+provides_0"
" self_0"
" self_0)))"
"(let-values(((result-form_0)"
"(if(let-values(((or-part_0)"
"(expand-context-to-parsed?"
" init-ctx_0)))"
"(if or-part_0"
" or-part_0"
" always-produce-compiled?_0))"
"(parsed-module25.1"
" rebuild-s_0"
" #f"
" id:module-name225_0"
" self_0"
" requires_0"
" provides_0"
"(requires+provides-all-bindings-simple?"
" requires+provides_0)"
"(root-expand-context-encode-for-module"
" root-ctx_0"
" self_0"
" self_0)"
"(parsed-#%module-begin-body"
"(if(expanded+parsed?"
" expanded-mb_0)"
"(expanded+parsed-parsed"
" expanded-mb_0)"
" expanded-mb_0))"
"(unbox"
" compiled-module-box_0)"
" compiled-submodules_0)"
" #f)))"
"(let-values(((result-s_0)"
"(if(not"
"(expand-context-to-parsed?"
" init-ctx_0))"
"(let-values()"
"(let-values(((generic-self_0)"
"(make-generic-self-module-path-index"
" self_0)))"
"(begin"
"(imitate-generic-module-path-index!"
" self_0)"
"(let-values(((lst_0)"
"(unbox"
" mpis-to-reset_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((mpi_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(imitate-generic-module-path-index!"
" mpi_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(let-values(((result-s_0)"
"(let-values(((rebuild-s428_0)"
" rebuild-s_0)"
"((temp429_0)"
"(list"
" module224_0"
" id:module-name225_0"
" initial-require-s_0"
"(expanded+parsed-s"
" expanded-mb_0))))"
"(rebuild5.1"
" #t"
" rebuild-s428_0"
" temp429_0))))"
"(let-values(((result-s_1)"
"(let-values(((result-s430_0)"
" result-s_0)"
"((self431_0)"
" self_0)"
"((generic-self432_0)"
" generic-self_0))"
"(syntax-module-path-index-shift13.1"
" #f"
" result-s430_0"
" self431_0"
" generic-self432_0"
" #f))))"
"(let-values(((result-s_2)"
"(attach-root-expand-context-properties"
" result-s_1"
" root-ctx_0"
" self_0"
" generic-self_0)))"
"(let-values(((result-s_3)"
"(if(requires+provides-all-bindings-simple?"
" requires+provides_0)"
"(syntax-property$1"
" result-s_2"
" 'module-body-context-simple?"
" #t)"
" result-s_2)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" init-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-one"
" result-s_3)))"
"(void)))"
" result-s_3))))))))"
"(void))))"
"(if(expand-context-to-parsed?"
" init-ctx_0)"
"(let-values()"
" result-form_0)"
"(if always-produce-compiled?_0"
"(let-values()"
"(expanded+parsed1.1"
" result-s_0"
" result-form_0))"
"(let-values()"
" result-s_0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"
"(define-values"
"(ensure-module-begin34.1)"
"(lambda(ctx22_0 def-ctx-scopes23_0 m-ns21_0 module-name-sym19_0 phase24_0 s25_0 scopes-s20_0 bodys33_0)"
"(begin"
" 'ensure-module-begin34"
"(let-values(((bodys_0) bodys33_0))"
"(let-values(((module-name-sym_0) module-name-sym19_0))"
"(let-values(((scopes-s_0) scopes-s20_0))"
"(let-values()"
"(let-values(((ctx_0) ctx22_0))"
"(let-values(((def-ctx-scopes_0) def-ctx-scopes23_0))"
"(let-values(((phase_0) phase24_0))"
"(let-values(((s_0) s25_0))"
"(let-values()"
"(let-values(((make-mb-ctx_0)"
"(lambda()"
"(begin"
" 'make-mb-ctx"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context433_0) 'module-begin)"
"((only-immediate?434_0) #t)"
"((def-ctx-scopes435_0) def-ctx-scopes_0)"
"((inner436_0)(root-expand-context/outer-inner v_0)))"
"(expand-context/outer1.1"
" inner436_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
" context433_0"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
" def-ctx-scopes435_0"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
" only-immediate?434_0"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                 \"expand-context/outer?\""
" the-struct_0))))))))"
"(let-values(((mb_0)"
"(if(= 1(length bodys_0))"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'rename-one(car bodys_0))))"
"(void)))"
"(if(eq?"
" '#%module-begin"
"(core-form-sym(syntax-disarm$1(car bodys_0)) phase_0))"
"(let-values()(car bodys_0))"
"(let-values()"
"(let-values(((partly-expanded-body_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region 'expand 'module-begin))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((temp437_0)"
"(add-enclosing-name-property"
"(car bodys_0)"
" module-name-sym_0))"
"((temp438_0)(make-mb-ctx_0)))"
"(expand9.1 #f #f #f temp437_0 temp438_0)))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void))))))"
"(if(eq?"
" '#%module-begin"
"(core-form-sym"
"(syntax-disarm$1 partly-expanded-body_0)"
" phase_0))"
"(let-values() partly-expanded-body_0)"
"(let-values()"
"(let-values(((temp439_0)(list partly-expanded-body_0))"
"((s440_0) s_0)"
"((scopes-s441_0) scopes-s_0)"
"((phase442_0) phase_0)"
"((module-name-sym443_0) module-name-sym_0)"
"((temp444_0)(make-mb-ctx_0))"
"((temp445_0) #f))"
"(add-module-begin45.1"
" temp445_0"
" temp439_0"
" s440_0"
" scopes-s441_0"
" phase442_0"
" module-name-sym443_0"
" temp444_0)))))))))"
"(let-values()"
"(let-values(((bodys446_0) bodys_0)"
"((s447_0) s_0)"
"((scopes-s448_0) scopes-s_0)"
"((phase449_0) phase_0)"
"((module-name-sym450_0) module-name-sym_0)"
"((temp451_0)(make-mb-ctx_0)))"
"(add-module-begin45.1"
" #t"
" bodys446_0"
" s447_0"
" scopes-s448_0"
" phase449_0"
" module-name-sym450_0"
" temp451_0))))))"
"(add-enclosing-name-property mb_0 module-name-sym_0)))))))))))))))"
"(define-values"
"(add-module-begin45.1)"
"(lambda(log-rename-one?37_0 bodys39_0 s40_0 scopes-s41_0 phase42_0 module-name-sym43_0 mb-ctx44_0)"
"(begin"
" 'add-module-begin45"
"(let-values(((bodys_0) bodys39_0))"
"(let-values(((s_0) s40_0))"
"(let-values(((scopes-s_0) scopes-s41_0))"
"(let-values(((phase_0) phase42_0))"
"(let-values(((module-name-sym_0) module-name-sym43_0))"
"(let-values(((mb-ctx_0) mb-ctx44_0))"
"(let-values(((log-rename-one?_0) log-rename-one?37_0))"
"(let-values()"
"(let-values(((disarmed-scopes-s_0)(syntax-disarm$1 scopes-s_0)))"
"(let-values(((mb-id_0)(datum->syntax$1 disarmed-scopes-s_0 '#%module-begin)))"
"(let-values((()"
"(begin"
"(if(let-values(((mb-id452_0) mb-id_0)((phase453_0) phase_0))"
"(resolve40.1 #f #f null #f mb-id452_0 phase453_0))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                               \"no #%module-begin binding in the module's language\""
" s_0)))"
"(values))))"
"(let-values(((mb_0)(datum->syntax$1 disarmed-scopes-s_0(list* mb-id_0 bodys_0) s_0 s_0)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer mb-ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'tag mb_0)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if log-rename-one?_0"
"(let-values()"
"(let-values(((obs_0)(expand-context-observer mb-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()(call-expand-observe obs_0 'rename-one mb_0)))"
"(void))))"
"(void))"
"(values))))"
"(let-values(((partly-expanded-mb_0)"
"(begin"
"(if log-performance?"
"(let-values()(start-performance-region 'expand 'module-begin))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((temp454_0)"
"(add-enclosing-name-property"
" mb_0"
" module-name-sym_0))"
"((mb-ctx455_0) mb-ctx_0))"
"(expand9.1 #f #f #f temp454_0 mb-ctx455_0)))"
"(if log-performance?"
"(let-values()(end-performance-region))"
"(void))))))"
"(begin"
"(if(eq?"
" '#%module-begin"
"(core-form-sym(syntax-disarm$1 partly-expanded-mb_0) phase_0))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                           \"expansion of #%module-begin is not a #%plain-module-begin form\""
" s_0"
" partly-expanded-mb_0)))"
" partly-expanded-mb_0)))))))))))))))))))"
"(define-values"
"(add-enclosing-name-property)"
"(lambda(stx_0 module-name-sym_0)(begin(syntax-property$1 stx_0 'enclosing-module-name module-name-sym_0))))"
"(define-values"
"(make-apply-module-scopes)"
"(lambda(inside-scope_0"
" outside-scope_0"
" init-ctx_0"
" keep-enclosing-scope-at-phase_0"
" self_0"
" enclosing-self_0"
" enclosing-mod_0)"
"(begin"
"(lambda(s_0)"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'expand 'module 'scopes))(void))"
"(begin0"
"(let-values()"
"(let-values(((s-without-enclosing_0)"
"(if keep-enclosing-scope-at-phase_0"
" s_0"
"(remove-use-site-scopes"
"(remove-scopes s_0(root-expand-context-module-scopes init-ctx_0))"
" init-ctx_0))))"
"(let-values(((s-with-edges_0)"
"(add-scope(add-scope s-without-enclosing_0 outside-scope_0) inside-scope_0)))"
"(let-values(((s-with-suitable-enclosing_0)"
"(if keep-enclosing-scope-at-phase_0"
"(let-values()"
"(let-values(((s-with-edges460_0) s-with-edges_0)"
"((enclosing-self461_0) enclosing-self_0)"
"((enclosing-mod462_0) enclosing-mod_0))"
"(syntax-module-path-index-shift13.1"
" #f"
" s-with-edges460_0"
" enclosing-self461_0"
" enclosing-mod462_0"
" #f)))"
"(let-values() s-with-edges_0))))"
"(let-values(((s-with-suitable-enclosing456_0) s-with-suitable-enclosing_0)"
"((temp457_0)(make-generic-self-module-path-index self_0))"
"((self458_0) self_0)"
"((temp459_0)(current-code-inspector)))"
"(syntax-module-path-index-shift13.1"
" #f"
" s-with-suitable-enclosing456_0"
" temp457_0"
" self458_0"
" temp459_0))))))"
"(if log-performance?(let-values()(end-performance-region))(void))))))))"
"(define-values"
"(partially-expand-bodys79.1)"
"(lambda(all-scopes-stx55_0"
" compiled-submodules59_0"
" ctx49_0"
" declared-keywords57_0"
" declared-submodule-names58_0"
" defined-syms56_0"
" frame-id52_0"
" loop62_0"
" modules-being-compiled60_0"
" mpis-to-reset61_0"
" namespace50_0"
" need-eventually-defined54_0"
" phase48_0"
" requires-and-provides53_0"
" self51_0"
" bodys78_0)"
"(begin"
" 'partially-expand-bodys79"
"(let-values(((bodys_0) bodys78_0))"
"(let-values(((phase_0) phase48_0))"
"(let-values(((partial-body-ctx_0) ctx49_0))"
"(let-values(((m-ns_0) namespace50_0))"
"(let-values(((self_0) self51_0))"
"(let-values(((frame-id_0) frame-id52_0))"
"(let-values(((requires+provides_0) requires-and-provides53_0))"
"(let-values(((need-eventually-defined_0) need-eventually-defined54_0))"
"(let-values(((all-scopes-stx_0) all-scopes-stx55_0))"
"(let-values(((defined-syms_0) defined-syms56_0))"
"(let-values(((declared-keywords_0) declared-keywords57_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names58_0))"
"(let-values(((compiled-submodules_0) compiled-submodules59_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled60_0))"
"(let-values(((mpis-to-reset_0) mpis-to-reset61_0))"
"(let-values(((pass-1-and-2-loop_0) loop62_0))"
"(let-values()"
"(begin"
"(namespace-visit-available-modules! m-ns_0 phase_0)"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 bodys_1)"
"(begin"
" 'loop"
"(if(null? bodys_1)"
"(let-values()"
"(if(if tail?_0(not(zero? phase_0)) #f)"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'module-lift-end-loop"
" '())))"
"(void)))"
" null))"
"(if tail?_0"
"(let-values()"
"(let-values(((bodys_2)"
"(append"
"(get-and-clear-end-lifts!"
"(expand-context-to-module-lifts"
" partial-body-ctx_0))"
"(get-and-clear-provide-lifts!"
"(expand-context-to-module-lifts"
" partial-body-ctx_0)))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'module-lift-end-loop"
" bodys_2)))"
"(void)))"
"(if(null? bodys_2)"
"(let-values() null)"
"(let-values()"
"(loop_0"
" #t"
"(add-post-expansion-scope"
" bodys_2"
" partial-body-ctx_0)))))))"
"(let-values() null))))"
"(let-values()"
"(let-values(((rest-bodys_0)(cdr bodys_1)))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-body_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'expand"
" 'form-in-module/1))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((temp463_0)"
"(car bodys_1))"
"((partial-body-ctx464_0)"
" partial-body-ctx_0))"
"(expand9.1"
" #f"
" #f"
" #f"
" temp463_0"
" partial-body-ctx464_0)))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(let-values(((disarmed-exp-body_0)"
"(syntax-disarm$1 exp-body_0)))"
"(let-values(((lifted-defns_0)"
"(get-and-clear-lifts!"
"(expand-context-lifts"
" partial-body-ctx_0))))"
"(begin"
"(if(pair? lifted-defns_0)"
"(let-values()"
"(log-lifted-defns"
" partial-body-ctx_0"
" lifted-defns_0"
" exp-body_0"
" rest-bodys_0))"
"(void))"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'rename-one"
" exp-body_0)))"
"(void)))"
"(let-values(((finish_0)"
"(lambda()"
"(begin"
" 'finish"
"(let-values(((tmp_0)"
"(core-form-sym"
" disarmed-exp-body_0"
" phase_0)))"
"(if(equal?"
" tmp_0"
" 'begin)"
"(let-values()"
"(let-values(((ok?_0"
" begin465_0"
" e466_0)"
"(let-values(((s_0)"
" disarmed-exp-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((begin465_0"
" e466_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((begin467_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e468_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin467_0"
" e468_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                             \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin465_0"
" e466_0))))))"
"(let-values(((track_0)"
"(lambda(e_0)"
"(begin"
" 'track"
"(syntax-track-origin$1"
" e_0"
" exp-body_0)))))"
"(let-values(((spliced-bodys_0)"
"(append"
"(map2"
" track_0"
" e466_0)"
" rest-bodys_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'splice"
" spliced-bodys_0)))"
"(void)))"
"(loop_0"
" tail?_0"
" spliced-bodys_0))))))"
"(if(equal?"
" tmp_0"
" 'begin-for-syntax)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe"
" obs_0"
" 'enter-prim"
" exp-body_0)"
"(call-expand-observe"
" obs_0"
" 'prim-begin-for-syntax)"
"(call-expand-observe"
" obs_0"
" 'prepare-env))))"
"(void)))"
"(values))))"
"(let-values(((ct-m-ns_0)"
"(namespace->namespace-at-phase"
" m-ns_0"
"(add1"
" phase_0))))"
"(let-values((()"
"(begin"
"(prepare-next-phase-namespace"
" partial-body-ctx_0)"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'phase-up)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" begin-for-syntax469_0"
" e470_0)"
"(let-values(((s_0)"
" disarmed-exp-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((begin-for-syntax469_0"
" e470_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((begin-for-syntax471_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((e472_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                               \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin-for-syntax471_0"
" e472_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                       \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin-for-syntax469_0"
" e470_0))))))"
"(let-values(((nested-bodys_0)"
"(pass-1-and-2-loop_0"
" e470_0"
"(add1"
" phase_0)"
" #f)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next-group)))"
"(void)))"
"(namespace-run-available-modules!"
" m-ns_0"
"(add1"
" phase_0))"
"(eval-nested-bodys"
" nested-bodys_0"
"(add1"
" phase_0)"
" ct-m-ns_0"
" self_0"
" partial-body-ctx_0)"
"(namespace-visit-available-modules!"
" m-ns_0"
" phase_0)"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
"(let-values(((s-nested-bodys_0)"
"(reverse$1"
"(let-values(((lst_0)"
" nested-bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((nested-body_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1)"
" fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(extract-syntax"
" nested-body_0))"
" fold-var_1))))"
"(values"
" fold-var_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" fold-var_1"
" rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(datum->syntax$1"
" #f"
"(cons"
" begin-for-syntax469_0"
" s-nested-bodys_0)"
" exp-body_0)))))"
"(void)))"
"(cons"
"(semi-parsed-begin-for-syntax3.1"
" exp-body_0"
" nested-bodys_0)"
"(loop_0"
" tail?_0"
" rest-bodys_0))))))))))"
"(if(equal?"
" tmp_0"
" 'define-values)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe"
" obs_0"
" 'enter-prim"
" exp-body_0)"
"(call-expand-observe"
" obs_0"
" 'prim-define-values))))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" define-values473_0"
" id474_0"
" rhs475_0)"
"(let-values(((s_0)"
" disarmed-exp-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((define-values473_0"
" id474_0"
" rhs475_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((define-values476_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id477_0"
" rhs478_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id479_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                               \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id492_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                             \"not an identifier\""
" orig-s_0"
" s_6)))))"
"(cons"
" id492_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_1"
" rest_0)"
" id_1)))"
" id_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"(reverse$1"
" id_0))))))))"
"((rhs480_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((rhs481_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                               \"bad syntax\""
" orig-s_0))))))"
"(values"
" rhs481_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                           \"bad syntax\""
" orig-s_0))))))"
"(values"
" id479_0"
" rhs480_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                       \"bad syntax\""
" orig-s_0))))))"
"(values"
" define-values476_0"
" id477_0"
" rhs478_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                   \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" define-values473_0"
" id474_0"
" rhs475_0))))))"
"(let-values(((ids_0)"
"(remove-use-site-scopes"
" id474_0"
" partial-body-ctx_0)))"
"(let-values((()"
"(begin"
"(let-values(((ids482_0)"
" ids_0)"
"((phase483_0)"
" phase_0)"
"((exp-body484_0)"
" exp-body_0))"
"(check-no-duplicate-ids7.1"
" unsafe-undefined"
" ids482_0"
" phase483_0"
" exp-body484_0"
" unsafe-undefined))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((ids485_0)"
" ids_0)"
"((phase486_0)"
" phase_0)"
"((requires+provides487_0)"
" requires+provides_0)"
"((exp-body488_0)"
" exp-body_0))"
"(check-ids-unbound171.1"
" exp-body488_0"
" ids485_0"
" phase486_0"
" requires+provides487_0))"
"(values))))"
"(let-values(((syms_0)"
"(let-values(((ids493_0)"
" ids_0)"
"((defined-syms494_0)"
" defined-syms_0)"
"((self495_0)"
" self_0)"
"((phase496_0)"
" phase_0)"
"((all-scopes-stx497_0)"
" all-scopes-stx_0)"
"((frame-id498_0)"
" frame-id_0)"
"((requires+provides499_0)"
" requires+provides_0)"
"((exp-body500_0)"
" exp-body_0))"
"(select-defined-syms-and-bind!16.1"
" #f"
" frame-id498_0"
" exp-body500_0"
" requires+provides499_0"
" #f"
" ids493_0"
" defined-syms494_0"
" self495_0"
" phase496_0"
" all-scopes-stx497_0))))"
"(begin"
"(let-values(((lst_0)"
" syms_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(namespace-unset-transformer!"
" m-ns_0"
" phase_0"
" sym_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)"
"(let-values(((requires+provides489_0)"
" requires+provides_0)"
"((syms490_0)"
" syms_0)"
"((phase491_0)"
" phase_0))"
"(add-defined-syms!103.1"
" #f"
" requires+provides489_0"
" syms490_0"
" phase491_0))"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
"(datum->syntax$1"
" #f"
"(list"
" define-values473_0"
" ids_0"
" rhs475_0)"
" exp-body_0))))"
"(void)))"
"(cons"
"(semi-parsed-define-values2.1"
" exp-body_0"
" syms_0"
" ids_0"
" rhs475_0)"
"(loop_0"
" tail?_0"
" rest-bodys_0))))))))))"
"(if(equal?"
" tmp_0"
" 'define-syntaxes)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe"
" obs_0"
" 'enter-prim"
" exp-body_0)"
"(call-expand-observe"
" obs_0"
" 'prim-define-syntaxes)"
"(call-expand-observe"
" obs_0"
" 'prepare-env))))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(prepare-next-phase-namespace"
" partial-body-ctx_0)"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'phase-up)))"
"(void)))"
"(values))))"
"(let-values(((ok?_0"
" define-syntaxes501_0"
" id502_0"
" rhs503_0)"
"(let-values(((s_0)"
" disarmed-exp-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((define-syntaxes501_0"
" id502_0"
" rhs503_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((define-syntaxes504_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((id505_0"
" rhs506_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(let-values(((id507_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_5)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_6)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id521_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_6)"
"(symbol?"
"(syntax-e$1"
" s_6))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_6)))"
" s_6"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                                                                                                   \"not an identifier\""
" orig-s_0"
" s_6)))))"
"(cons"
" id521_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_1"
" rest_0)"
" id_1)))"
" id_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"(reverse$1"
" id_0))))))))"
"((rhs508_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(let-values(((rhs509_0)"
"(let-values(((s_6)"
"(car"
" s_5)))"
" s_6))"
"(()"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(if(null?"
" s_7)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                     \"bad syntax\""
" orig-s_0))))))"
"(values"
" rhs509_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                 \"bad syntax\""
" orig-s_0))))))"
"(values"
" id507_0"
" rhs508_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                             \"bad syntax\""
" orig-s_0))))))"
"(values"
" define-syntaxes504_0"
" id505_0"
" rhs506_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                         \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" define-syntaxes501_0"
" id502_0"
" rhs503_0))))))"
"(let-values(((ids_0)"
"(remove-use-site-scopes"
" id502_0"
" partial-body-ctx_0)))"
"(let-values((()"
"(begin"
"(let-values(((ids510_0)"
" ids_0)"
"((phase511_0)"
" phase_0)"
"((exp-body512_0)"
" exp-body_0))"
"(check-no-duplicate-ids7.1"
" unsafe-undefined"
" ids510_0"
" phase511_0"
" exp-body512_0"
" unsafe-undefined))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((ids513_0)"
" ids_0)"
"((phase514_0)"
" phase_0)"
"((requires+provides515_0)"
" requires+provides_0)"
"((exp-body516_0)"
" exp-body_0))"
"(check-ids-unbound171.1"
" exp-body516_0"
" ids513_0"
" phase514_0"
" requires+provides515_0))"
"(values))))"
"(let-values(((syms_0)"
"(let-values(((ids522_0)"
" ids_0)"
"((defined-syms523_0)"
" defined-syms_0)"
"((self524_0)"
" self_0)"
"((phase525_0)"
" phase_0)"
"((all-scopes-stx526_0)"
" all-scopes-stx_0)"
"((frame-id527_0)"
" frame-id_0)"
"((requires+provides528_0)"
" requires+provides_0)"
"((exp-body529_0)"
" exp-body_0)"
"((temp530_0)"
" #t))"
"(select-defined-syms-and-bind!16.1"
" temp530_0"
" frame-id527_0"
" exp-body529_0"
" requires+provides528_0"
" #f"
" ids522_0"
" defined-syms523_0"
" self524_0"
" phase525_0"
" all-scopes-stx526_0))))"
"(let-values((()"
"(begin"
"(let-values(((requires+provides517_0)"
" requires+provides_0)"
"((syms518_0)"
" syms_0)"
"((phase519_0)"
" phase_0)"
"((temp520_0)"
" #t))"
"(add-defined-syms!103.1"
" temp520_0"
" requires+provides517_0"
" syms518_0"
" phase519_0))"
"(values))))"
"(let-values(((exp-rhs_0"
" parsed-rhs_0"
" vals_0)"
"(let-values(((temp531_0)"
" 'define-syntaxes)"
"((temp532_0)"
" rhs503_0)"
"((ids533_0)"
" ids_0)"
"((temp534_0)"
"(let-values(((v_0)"
" partial-body-ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((need-eventually-defined536_0)"
" need-eventually-defined_0)"
"((inner537_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((lifts538_0)"
" #f)"
"((module-lifts539_0)"
" #f)"
"((to-module-lifts540_0)"
" #f))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
" lifts538_0"
"(expand-context/inner-lift-envs"
" the-struct_1)"
" module-lifts539_0"
"(expand-context/inner-require-lifts"
" the-struct_1)"
" to-module-lifts540_0"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                                     \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner537_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
"(expand-context/outer-context"
" the-struct_0)"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
" need-eventually-defined536_0"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                                                                   \"expand-context/outer?\""
" the-struct_0)))))"
"((temp535_0)"
" #f))"
"(expand+eval-for-syntaxes-binding108.1"
" temp535_0"
" temp531_0"
" temp532_0"
" ids533_0"
" temp534_0))))"
"(let-values((()"
"(begin"
"(let-values(((lst_0)"
" syms_0)"
"((lst_1)"
" vals_0)"
"((lst_2)"
" ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_1)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_2)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_3"
" lst_4"
" lst_5)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_3)"
"(if(pair?"
" lst_4)"
"(pair?"
" lst_5)"
" #f)"
" #f)"
"(let-values(((sym_0)"
"(unsafe-car"
" lst_3))"
"((rest_0)"
"(unsafe-cdr"
" lst_3))"
"((val_0)"
"(unsafe-car"
" lst_4))"
"((rest_1)"
"(unsafe-cdr"
" lst_4))"
"((id_0)"
"(unsafe-car"
" lst_5))"
"((rest_2)"
"(unsafe-cdr"
" lst_5)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(maybe-install-free=id-in-context!"
" val_0"
" id_0"
" phase_0"
" partial-body-ctx_0)"
"(namespace-set-transformer!"
" m-ns_0"
" phase_0"
" sym_0"
" val_0)))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0"
" rest_1"
" rest_2)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0"
" lst_1"
" lst_2)))"
"(values))))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
"(datum->syntax$1"
" #f"
"(list"
" define-syntaxes501_0"
" ids_0"
" exp-rhs_0)))))"
"(void)))"
"(values))))"
"(let-values(((parsed-body_0)"
"(parsed-define-syntaxes20.1"
"(keep-properties-only"
" exp-body_0)"
" ids_0"
" syms_0"
" parsed-rhs_0)))"
"(cons"
"(if(expand-context-to-parsed?"
" partial-body-ctx_0)"
" parsed-body_0"
"(expanded+parsed1.1"
"(let-values(((exp-body541_0)"
" exp-body_0)"
"((temp542_0)"
"(list"
" define-syntaxes501_0"
" ids_0"
" exp-rhs_0)))"
"(rebuild5.1"
" #t"
" exp-body541_0"
" temp542_0))"
" parsed-body_0))"
"(loop_0"
" tail?_0"
" rest-bodys_0)))))))))))))))))"
"(if(equal?"
" tmp_0"
" '#%require)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe"
" obs_0"
" 'enter-prim"
" exp-body_0)"
"(call-expand-observe"
" obs_0"
" 'prim-require))))"
"(void)))"
"(values))))"
"(let-values(((ready-body_0)"
"(remove-use-site-scopes"
" disarmed-exp-body_0"
" partial-body-ctx_0)))"
"(let-values(((ok?_0"
" #%require543_0"
" req544_0)"
"(let-values(((s_0)"
" ready-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((#%require543_0"
" req544_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((#%require545_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((req546_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" #%require545_0"
" req546_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                         \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" #%require543_0"
" req544_0))))))"
"(begin"
"(let-values(((temp547_0)"
" req544_0)"
"((exp-body548_0)"
" exp-body_0)"
"((self549_0)"
" self_0)"
"((m-ns550_0)"
" m-ns_0)"
"((phase551_0)"
" phase_0)"
"((phase552_0)"
" phase_0)"
"((requires+provides553_0)"
" requires+provides_0)"
"((declared-submodule-names554_0)"
" declared-submodule-names_0)"
"((temp555_0)"
" 'module))"
"(parse-and-perform-requires!30.1"
" #f"
" #f"
" declared-submodule-names554_0"
" #f"
" phase552_0"
" #f"
" self549_0"
" #f"
" #t"
" temp555_0"
" temp547_0"
" exp-body548_0"
" m-ns550_0"
" phase551_0"
" requires+provides553_0))"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
" ready-body_0)))"
"(void)))"
"(cons"
" exp-body_0"
"(loop_0"
" tail?_0"
" rest-bodys_0)))))))"
"(if(equal?"
" tmp_0"
" '#%provide)"
"(let-values()"
"(cons"
" exp-body_0"
"(loop_0"
" tail?_0"
" rest-bodys_0)))"
"(if(equal?"
" tmp_0"
" 'module)"
"(let-values()"
"(let-values(((ready-body_0)"
"(remove-use-site-scopes"
" exp-body_0"
" partial-body-ctx_0)))"
"(let-values(((submod_0)"
"(let-values(((ready-body556_0)"
" ready-body_0)"
"((self557_0)"
" self_0)"
"((partial-body-ctx558_0)"
" partial-body-ctx_0)"
"((temp559_0)"
" #f)"
"((declared-submodule-names560_0)"
" declared-submodule-names_0)"
"((mpis-to-reset561_0)"
" mpis-to-reset_0)"
"((compiled-submodules562_0)"
" compiled-submodules_0)"
"((modules-being-compiled563_0)"
" modules-being-compiled_0))"
"(expand-submodule193.1"
" compiled-submodules562_0"
" declared-submodule-names560_0"
" #f"
" #f"
" temp559_0"
" #f"
" modules-being-compiled563_0"
" mpis-to-reset561_0"
" ready-body556_0"
" self557_0"
" partial-body-ctx558_0))))"
"(cons"
" submod_0"
"(loop_0"
" tail?_0"
" rest-bodys_0)))))"
"(if(equal?"
" tmp_0"
" 'module*)"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe"
" obs_0"
" 'enter-prim"
" exp-body_0)"
"(call-expand-observe"
" obs_0"
" 'prim-submodule*)"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
" exp-body_0))))"
"(void)))"
"(cons"
" exp-body_0"
"(loop_0"
" tail?_0"
" rest-bodys_0))))"
"(if(equal?"
" tmp_0"
" '#%declare)"
"(let-values()"
"(let-values(((ok?_0"
" #%declare564_0"
" kw565_0)"
"(let-values(((s_0)"
" disarmed-exp-body_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((#%declare564_0"
" kw565_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((#%declare566_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((kw567_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                     \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" #%declare566_0"
" kw567_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                             \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" #%declare564_0"
" kw565_0))))))"
"(let-values((()"
"(begin"
"(let-values(((lst_0)"
" kw565_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((kw_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(if(keyword?"
"(syntax-e$1"
" kw_0))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                   \"expected a keyword\""
" exp-body_0"
" kw_0)))"
"(if(memq"
"(syntax-e$1"
" kw_0)"
" '(#:cross-phase-persistent"
" #:empty-namespace))"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                   \"not an allowed declaration keyword\""
" exp-body_0"
" kw_0)))"
"(if(hash-ref"
" declared-keywords_0"
"(syntax-e$1"
" kw_0)"
" #f)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                                                   \"keyword declared multiple times\""
" exp-body_0"
" kw_0))"
"(void))"
"(hash-set!"
" declared-keywords_0"
"(syntax-e$1"
" kw_0)"
" kw_0)))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_0"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(values))))"
"(let-values()"
"(let-values(((parsed-body_0)"
"(parsed-#%declare22.1"
" exp-body_0)))"
"(cons"
"(if(expand-context-to-parsed?"
" partial-body-ctx_0)"
" parsed-body_0"
"(expanded+parsed1.1"
" exp-body_0"
" parsed-body_0))"
"(loop_0"
" tail?_0"
" rest-bodys_0)))))))"
"(let-values()"
"(cons"
" exp-body_0"
"(loop_0"
" tail?_0"
" rest-bodys_0)))))))))))))))))"
"(let-values(((l_0)"
"(append"
"(get-and-clear-require-lifts!"
"(expand-context-require-lifts"
" partial-body-ctx_0))"
" lifted-defns_0"
"(loop_0"
" #f"
"(add-post-expansion-scope"
"(get-and-clear-module-lifts!"
"(expand-context-module-lifts"
" partial-body-ctx_0))"
" partial-body-ctx_0)))))"
"(if(null? l_0)"
"(finish_0)"
"(append"
" l_0"
"(finish_0)))))))))))))))))"
" loop_0)"
" #t"
" bodys_0))))))))))))))))))))))"
"(define-values"
"(make-wrap-as-definition)"
"(lambda(self_0 frame-id_0 inside-scope_0 all-scopes-stx_0 defined-syms_0 requires+provides_0)"
"(begin"
"(lambda(ids_0 rhs_0 phase_0)"
"(let-values(((scoped-ids_0)"
"(reverse$1"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope id_0 inside-scope_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values(((syms_0)"
"(let-values(((scoped-ids568_0) scoped-ids_0)"
"((defined-syms569_0) defined-syms_0)"
"((self570_0) self_0)"
"((phase571_0) phase_0)"
"((all-scopes-stx572_0) all-scopes-stx_0)"
"((frame-id573_0) frame-id_0)"
"((requires+provides574_0) requires+provides_0))"
"(select-defined-syms-and-bind!16.1"
" #f"
" frame-id573_0"
" #f"
" requires+provides574_0"
" #f"
" scoped-ids568_0"
" defined-syms569_0"
" self570_0"
" phase571_0"
" all-scopes-stx572_0))))"
"(let-values(((s_0)"
"(add-scope"
"(datum->syntax$1"
" #f"
"(list"
"(datum->syntax$1(syntax-shift-phase-level$1 core-stx phase_0) 'define-values)"
" scoped-ids_0"
" rhs_0))"
" inside-scope_0)))"
"(values scoped-ids_0(semi-parsed-define-values2.1 s_0 syms_0 scoped-ids_0 rhs_0)))))))))"
"(define-values"
"(add-post-expansion-scope)"
"(lambda(bodys_0 ctx_0)"
"(begin"
"(let-values(((pe_0)(root-expand-context-post-expansion ctx_0)))"
"(if pe_0"
"(reverse$1"
"(let-values(((lst_0) bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(apply-post-expansion pe_0 body_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))"
" bodys_0)))))"
"(define-values"
"(finish-expanding-body-expressons97.1)"
"(lambda(compiled-submodules86_0"
" ctx83_0"
" declared-submodule-names85_0"
" modules-being-compiled87_0"
" mpis-to-reset88_0"
" phase82_0"
" self84_0"
" partially-expanded-bodys96_0)"
"(begin"
" 'finish-expanding-body-expressons97"
"(let-values(((partially-expanded-bodys_0) partially-expanded-bodys96_0))"
"(let-values(((phase_0) phase82_0))"
"(let-values(((body-ctx_0) ctx83_0))"
"(let-values(((self_0) self84_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names85_0))"
"(let-values(((compiled-submodules_0) compiled-submodules86_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled87_0))"
"(let-values(((mpis-to-reset_0) mpis-to-reset88_0))"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(tail?_0 bodys_0)"
"(begin"
" 'loop"
"(if(null? bodys_0)"
"(let-values()"
"(if(if tail?_0(not(zero? phase_0)) #f)"
"(let-values()"
"(begin"
"(let-values(((obs_0)(expand-context-observer body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'module-lift-end-loop '())))"
"(void)))"
" null))"
"(if tail?_0"
"(let-values()"
"(let-values(((bodys_1)"
"(append"
"(get-and-clear-end-lifts!"
"(expand-context-to-module-lifts body-ctx_0))"
"(get-and-clear-provide-lifts!"
"(expand-context-to-module-lifts body-ctx_0)))))"
"(if(null? bodys_1)"
"(let-values()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'module-lift-end-loop"
" '())))"
"(void)))"
" null))"
"(let-values()"
"(loop_0"
" #t"
"(add-post-expansion-scope bodys_1 body-ctx_0))))))"
"(let-values() null))))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'next)))"
"(void)))"
"(values))))"
"(let-values(((body_0)(car bodys_0)))"
"(let-values(((rest-bodys_0)(cdr bodys_0)))"
"(let-values(((exp-body_0)"
"(if(let-values(((or-part_0)(parsed? body_0)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(expanded+parsed? body_0)))"
"(if or-part_1"
" or-part_1"
"(semi-parsed-begin-for-syntax?"
" body_0)))))"
"(let-values() body_0)"
"(if(semi-parsed-define-values? body_0)"
"(let-values()"
"(let-values(((ids_0)"
"(semi-parsed-define-values-ids"
" body_0)))"
"(let-values(((rhs-ctx_0)"
"(as-named-context"
"(as-expression-context"
" body-ctx_0)"
" ids_0)))"
"(let-values(((syms_0)"
"(semi-parsed-define-values-syms"
" body_0)))"
"(let-values(((s_0)"
"(semi-parsed-define-values-s"
" body_0)))"
"(let-values(((ok?_0"
" define-values575_0"
" _576_0"
" _577_0)"
"(let-values(((s_1)"
"(syntax-disarm$1"
" s_0)))"
"(if(if(not"
"(expand-context-to-parsed?"
" rhs-ctx_0))"
" #t"
" #f)"
"(let-values(((orig-s_0)"
" s_1))"
"(let-values(((define-values575_0"
" _576_0"
" _577_0)"
"(let-values(((s_2)"
"(if(syntax?$1"
" s_1)"
"(syntax-e$1"
" s_1)"
" s_1)))"
"(if(pair?"
" s_2)"
"(let-values(((define-values578_0)"
"(let-values(((s_3)"
"(car"
" s_2)))"
" s_3))"
"((_579_0"
" _580_0)"
"(let-values(((s_3)"
"(cdr"
" s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1"
" s_3)"
"(syntax-e$1"
" s_3)"
" s_3)))"
"(if(pair?"
" s_4)"
"(let-values(((_581_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
" s_5))"
"((_582_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(pair?"
" s_6)"
"(let-values(((_583_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null?"
" s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                       \"bad syntax\""
" orig-s_0))))))"
"(values"
" _583_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                   \"bad syntax\""
" orig-s_0))))))"
"(values"
" _581_0"
" _582_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                               \"bad syntax\""
" orig-s_0))))))"
"(values"
" define-values578_0"
" _579_0"
" _580_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                           \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" define-values575_0"
" _576_0"
" _577_0)))"
"(values"
" #f"
" #f"
" #f"
" #f)))))"
"(let-values(((rebuild-s_0)"
"(let-values(((rhs-ctx584_0)"
" rhs-ctx_0)"
"((s585_0)"
" s_0)"
"((temp586_0)"
" #t))"
"(keep-as-needed119.1"
" #f"
" #f"
" temp586_0"
" rhs-ctx584_0"
" s585_0))))"
"(let-values((()"
"(begin"
"(log-defn-enter"
" body-ctx_0"
" body_0)"
"(values))))"
"(let-values(((exp-rhs_0)"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'expand"
" 'form-in-module/2))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((temp587_0)"
"(semi-parsed-define-values-rhs"
" body_0))"
"((rhs-ctx588_0)"
" rhs-ctx_0))"
"(expand9.1"
" #f"
" #f"
" #f"
" temp587_0"
" rhs-ctx588_0)))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void))))))"
"(let-values((()"
"(begin"
"(log-defn-exit"
" body-ctx_0"
" body_0"
" exp-rhs_0)"
"(values))))"
"(let-values(((comp-form_0)"
"(parsed-define-values19.1"
" rebuild-s_0"
" ids_0"
" syms_0"
"(if(expand-context-to-parsed?"
" rhs-ctx_0)"
" exp-rhs_0"
"(let-values(((exp-rhs589_0)"
" exp-rhs_0)"
"((temp590_0)"
"(as-to-parsed-context"
" rhs-ctx_0)))"
"(expand9.1"
" #f"
" #f"
" #f"
" exp-rhs589_0"
" temp590_0))))))"
"(if(expand-context-to-parsed?"
" rhs-ctx_0)"
" comp-form_0"
"(expanded+parsed1.1"
"(let-values(((rebuild-s591_0)"
" rebuild-s_0)"
"((temp592_0)"
"(list"
" define-values575_0"
" ids_0"
" exp-rhs_0)))"
"(rebuild5.1"
" #t"
" rebuild-s591_0"
" temp592_0))"
" comp-form_0)))))))))))))"
"(let-values()"
"(let-values(((disarmed-body_0)"
"(syntax-disarm$1 body_0)))"
"(let-values(((tmp_0)"
"(core-form-sym"
" disarmed-body_0"
" phase_0)))"
"(if(if(equal? tmp_0 '#%require)"
" #t"
"(if(equal? tmp_0 '#%provide)"
" #t"
"(equal? tmp_0 'module*)))"
"(let-values() body_0)"
"(let-values()"
"(begin"
"(if log-performance?"
"(let-values()"
"(start-performance-region"
" 'expand"
" 'form-in-module/2))"
"(void))"
"(begin0"
"(let-values()"
"(let-values(((exp-body_0)"
"(let-values(((body593_0)"
" body_0)"
"((temp594_0)"
"(as-expression-context"
" body-ctx_0)))"
"(expand9.1"
" #f"
" #f"
" #f"
" body593_0"
" temp594_0))))"
"(if(expand-context-to-parsed?"
" body-ctx_0)"
" exp-body_0"
"(expanded+parsed1.1"
" exp-body_0"
"(let-values(((exp-body595_0)"
" exp-body_0)"
"((temp596_0)"
"(as-to-parsed-context"
" body-ctx_0)))"
"(expand9.1"
" #f"
" #f"
" #f"
" exp-body595_0"
" temp596_0))))))"
"(if log-performance?"
"(let-values()"
"(end-performance-region))"
"(void)))))))))))))"
"(let-values(((lifted-defns_0)"
"(get-and-clear-lifts!"
"(expand-context-lifts body-ctx_0))))"
"(let-values(((lifted-requires_0)"
"(get-and-clear-require-lifts!"
"(expand-context-require-lifts body-ctx_0))))"
"(let-values(((lifted-modules_0)"
"(get-and-clear-module-lifts!"
"(expand-context-module-lifts body-ctx_0))))"
"(let-values(((no-lifts?_0)"
"(if(null? lifted-defns_0)"
"(if(null? lifted-modules_0)"
"(null? lifted-requires_0)"
" #f)"
" #f)))"
"(let-values((()"
"(begin"
"(if no-lifts?_0"
"(void)"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'module-lift-loop"
"(append"
" lifted-requires_0"
"(lifted-defns-extract-syntax"
" lifted-defns_0)"
"(add-post-expansion-scope"
" lifted-modules_0"
" body-ctx_0)))))"
"(void)))))"
"(values))))"
"(let-values(((exp-lifted-modules_0)"
"(let-values(((lifted-modules597_0)"
" lifted-modules_0)"
"((phase598_0) phase_0)"
"((self599_0) self_0)"
"((body-ctx600_0)"
" body-ctx_0)"
"((mpis-to-reset601_0)"
" mpis-to-reset_0)"
"((declared-submodule-names602_0)"
" declared-submodule-names_0)"
"((compiled-submodules603_0)"
" compiled-submodules_0)"
"((modules-being-compiled604_0)"
" modules-being-compiled_0))"
"(expand-non-module*-submodules208.1"
" compiled-submodules603_0"
" declared-submodule-names602_0"
" modules-being-compiled604_0"
" mpis-to-reset601_0"
" lifted-modules597_0"
" phase598_0"
" self599_0"
" body-ctx600_0))))"
"(let-values(((exp-lifted-defns_0)"
"(loop_0 #f lifted-defns_0)))"
"(begin"
"(if no-lifts?_0"
"(void)"
"(let-values()"
"(let-values(((obs_0)"
"(expand-context-observer"
" body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))))"
"(append"
" lifted-requires_0"
" exp-lifted-defns_0"
" exp-lifted-modules_0"
"(cons"
" exp-body_0"
"(loop_0"
" tail?_0"
" rest-bodys_0)))))))))))))))))))))"
" loop_0)"
" #t"
" partially-expanded-bodys_0)))))))))))))"
"(define-values"
"(check-defined-by-now)"
"(lambda(need-eventually-defined_0 self_0 ctx_0 requires+provides_0)"
"(begin"
"(begin"
"(let-values(((ht_0) need-eventually-defined_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-in-hash ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((phase_0 l_0)(hash-iterate-key+value ht_0 i_0)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(begin"
"(let-values(((lst_0)(reverse$1 l_0)))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((b_0)"
"(let-values(((id605_0)"
" id_0)"
"((phase606_0)"
" phase_0))"
"(resolve+shift28.1"
" #f"
" #f"
" null"
" unsafe-undefined"
" #f"
" id605_0"
" phase606_0))))"
"(let-values(((bound-here?_0)"
"(if b_0"
"(if(module-binding?"
" b_0)"
"(if(eq?"
"(module-binding-sym"
" b_0)"
"(syntax-e$1"
" id_0))"
"(eq?"
"(module-binding-module"
" b_0)"
" self_0)"
" #f)"
" #f)"
" #f)))"
"(let-values(((bound-kind_0)"
"(if bound-here?_0"
"(defined-sym-kind"
" requires+provides_0"
"(module-binding-sym"
" b_0)"
" phase_0)"
" #f)))"
"(if(eq?"
" bound-kind_0"
" 'variable)"
"(void)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"(string-append"
"(if(not"
" b_0)"
"(let-values()"
"                                                                                                                                                              \"reference to an unbound identifier\")"
"(if(eq?"
" bound-kind_0"
" 'transformer)"
"(let-values()"
"                                                                                                                                                                \"identifier treated as a variable, but later defined as syntax\")"
"(let-values()"
"                                                                                                                                                                \"identifier treated as a variable, but later bound differently\")))"
"(format"
"                                                                                                                                                           \"\\n  at phase: ~a\""
"(let-values(((tmp_0)"
" phase_0))"
"(if(equal?"
" tmp_0"
" 1)"
"(let-values()"
"                                                                                                                                                                 \"1; the transformer environment\")"
"(let-values()"
" phase_0)))))"
" id_0"
" #f"
" null"
"(syntax-debug-info-string"
" id_0"
" ctx_0))))))))"
"(values)))))"
"(values)))))"
"(if(not #f)"
"(for-loop_1"
" rest_0)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_0)))"
"(void)))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0(hash-iterate-next ht_0 i_0))(values))))"
"(values))))))"
" for-loop_0)"
"(hash-iterate-first ht_0))))"
"(void)))))"
"(define-values"
"(resolve-provides113.1)"
"(lambda(ctx105_0"
" declared-submodule-names101_0"
" namespace102_0"
" phase103_0"
" requires-and-provides100_0"
" self104_0"
" expression-expanded-bodys112_0)"
"(begin"
" 'resolve-provides113"
"(let-values(((expression-expanded-bodys_0) expression-expanded-bodys112_0))"
"(let-values(((requires+provides_0) requires-and-provides100_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names101_0))"
"(let-values(((m-ns_0) namespace102_0))"
"(let-values(((phase_0) phase103_0))"
"(let-values(((self_0) self104_0))"
"(let-values(((ctx_0) ctx105_0))"
"(let-values()"
"(begin"
"(if log-performance?(let-values()(start-performance-region 'expand 'provide))(void))"
"(begin0"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(bodys_0 phase_1)"
"(begin"
" 'loop"
"(if(null? bodys_0)"
"(let-values() null)"
"(if(let-values(((or-part_0)(parsed?(car bodys_0))))"
"(if or-part_0 or-part_0(expanded+parsed?(car bodys_0))))"
"(let-values()"
"(cons(car bodys_0)(loop_0(cdr bodys_0) phase_1)))"
"(if(semi-parsed-begin-for-syntax?(car bodys_0))"
"(let-values()"
"(let-values(((nested-bodys_0)"
"(loop_0"
"(semi-parsed-begin-for-syntax-body"
"(car bodys_0))"
"(add1 phase_1))))"
"(cons"
"(let-values(((the-struct_0)(car bodys_0)))"
"(if(semi-parsed-begin-for-syntax? the-struct_0)"
"(let-values(((body607_0) nested-bodys_0))"
"(semi-parsed-begin-for-syntax3.1"
"(semi-parsed-begin-for-syntax-s the-struct_0)"
" body607_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                  \"semi-parsed-begin-for-syntax?\""
" the-struct_0)))"
"(loop_0(cdr bodys_0) phase_1))))"
"(let-values()"
"(let-values(((disarmed-body_0)"
"(syntax-disarm$1(car bodys_0))))"
"(let-values(((tmp_0)"
"(core-form-sym disarmed-body_0 phase_1)))"
"(if(equal? tmp_0 '#%provide)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe"
" obs_0"
" 'enter-prim"
"(car bodys_0))"
"(call-expand-observe"
" obs_0"
" 'prim-provide))))"
"(void)))"
"(values))))"
"(let-values(((ok?_0 #%provide608_0 spec609_0)"
"(let-values(((s_0) disarmed-body_0))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((#%provide608_0"
" spec609_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((#%provide610_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((spec611_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" #%provide610_0"
" spec611_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                         \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" #%provide608_0"
" spec609_0))))))"
"(let-values(((track-stxes_0 specs_0)"
"(parse-and-expand-provides!"
" spec609_0"
"(car bodys_0)"
" requires+provides_0"
" self_0"
" phase_1"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0)"
" v_0))"
"(if(expand-context/outer?"
" the-struct_0)"
"(let-values(((context612_0)"
" 'top-level)"
"((inner613_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((phase614_0)"
" phase_1)"
"((namespace615_0)"
"(namespace->namespace-at-phase"
" m-ns_0"
" phase_1))"
"((requires+provides616_0)"
" requires+provides_0)"
"((declared-submodule-names617_0)"
" declared-submodule-names_0))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
" phase614_0"
" namespace615_0"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
"(expand-context/inner-stops"
" the-struct_1)"
" declared-submodule-names617_0"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
" requires+provides616_0"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                              \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner613_0"
"(root-expand-context/outer-post-expansion"
" the-struct_0)"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
" context612_0"
"(expand-context/outer-env"
" the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                            \"expand-context/outer?\""
" the-struct_0)))))))"
"(if(expand-context-to-parsed? ctx_0)"
"(let-values()(loop_0(cdr bodys_0) phase_1))"
"(let-values()"
"(let-values(((new-s_0)"
"(syntax-track-origin*"
" track-stxes_0"
"(let-values(((temp618_0)"
"(car bodys_0))"
"((temp619_0)"
"(list*"
" #%provide608_0"
" specs_0)))"
"(rebuild5.1"
" #t"
" temp618_0"
" temp619_0)))))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
" new-s_0)))"
"(void)))"
"(cons"
" new-s_0"
"(loop_0(cdr bodys_0) phase_1))))))))))"
"(let-values()"
"(cons"
"(car bodys_0)"
"(loop_0(cdr bodys_0) phase_1))))))))))))))"
" loop_0)"
" expression-expanded-bodys_0"
" phase_0))"
"(if log-performance?(let-values()(end-performance-region))(void)))))))))))))))"
"(define-values"
"(declare-module-for-expansion137.1)"
"(lambda(ctx123_0"
" enclosing121_0"
" fill125_0"
" module-name-id116_0"
" modules-being-compiled124_0"
" namespace119_0"
" rebuild-s117_0"
" requires-and-provides118_0"
" root-ctx122_0"
" self120_0"
" fully-expanded-bodys-except-post-submodules136_0)"
"(begin"
" 'declare-module-for-expansion137"
"(let-values(((fully-expanded-bodys-except-post-submodules_0) fully-expanded-bodys-except-post-submodules136_0))"
"(let-values(((module-name-id_0) module-name-id116_0))"
"(let-values(((rebuild-s_0) rebuild-s117_0))"
"(let-values(((requires+provides_0) requires-and-provides118_0))"
"(let-values(((m-ns_0) namespace119_0))"
"(let-values(((self_0) self120_0))"
"(let-values(((enclosing-self_0) enclosing121_0))"
"(let-values(((root-ctx_0) root-ctx122_0))"
"(let-values(((ctx_0) ctx123_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled124_0))"
"(let-values(((compiled-module-box_0) fill125_0))"
"(let-values()"
"(let-values(((requires_0 provides_0)"
"(extract-requires-and-provides requires+provides_0 self_0 self_0)))"
"(let-values(((parsed-mod_0)"
"(parsed-module25.1"
" rebuild-s_0"
" #f"
" module-name-id_0"
" self_0"
" requires_0"
" provides_0"
"(requires+provides-all-bindings-simple? requires+provides_0)"
"(root-expand-context-encode-for-module root-ctx_0 self_0 self_0)"
"(parsed-only fully-expanded-bodys-except-post-submodules_0)"
" #f"
"(hasheq))))"
"(let-values(((module-name_0)"
"(1/module-path-index-resolve"
"(let-values(((or-part_0) enclosing-self_0))"
"(if or-part_0 or-part_0 self_0)))))"
"(let-values(((compiled-module_0)"
"(let-values(((parsed-mod620_0) parsed-mod_0)"
"((temp621_0)"
"(let-values(((m-ns626_0) m-ns_0)"
"((enclosing-self627_0) enclosing-self_0)"
"((temp628_0)"
"(if enclosing-self_0"
"(1/resolved-module-path-name"
" module-name_0)"
" #f)))"
"(make-compile-context14.1"
" temp628_0"
" unsafe-undefined"
" enclosing-self627_0"
" m-ns626_0"
" unsafe-undefined"
" unsafe-undefined)))"
"((temp622_0)(expand-context-for-serializable? ctx_0))"
"((temp623_0)"
"(expand-context-to-correlated-linklet? ctx_0))"
"((modules-being-compiled624_0) modules-being-compiled_0)"
"((temp625_0) #f))"
"(compile-module13.1"
" #f"
" modules-being-compiled624_0"
" temp625_0"
" temp622_0"
" temp623_0"
" parsed-mod620_0"
" temp621_0))))"
"(let-values((()"
"(begin"
"(set-box! compiled-module-box_0 compiled-module_0)"
"(values))))"
"(let-values(((root-module-name_0)"
"(resolved-module-path-root-name module-name_0)))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
" m-ns_0"
" 1/current-module-declare-name"
"(1/make-resolved-module-path root-module-name_0))"
"(let-values()"
"(let-values(((compiled-module629_0) compiled-module_0)((temp630_0) #f))"
"(eval-module8.1"
" unsafe-undefined"
" #f"
" temp630_0"
" compiled-module629_0)))))))))))))))))))))))))"
"(define-values"
"(attach-root-expand-context-properties)"
"(lambda(s_0 root-ctx_0 orig-self_0 new-self_0)"
"(begin"
"(let-values(((s_1)(syntax-property$1 s_0 'module-body-context(root-expand-context-all-scopes-stx root-ctx_0))))"
"(let-values(((s_2)"
"(syntax-property$1"
" s_1"
" 'module-body-inside-context"
"(apply-post-expansion(root-expand-context-post-expansion root-ctx_0) empty-syntax))))"
" s_2)))))"
"(define-values"
"(expand-post-submodules163.1)"
"(lambda(all-scopes-s145_0"
" compiled-submodules148_0"
" ctx150_0"
" declare-enclosing140_0"
" declared-submodule-names147_0"
" enclosing-is-cross-phase-persistent?144_0"
" modules-being-compiled149_0"
" mpis-to-reset146_0"
" phase141_0"
" requires-and-provides143_0"
" self142_0"
" fully-expanded-bodys-except-post-submodules162_0)"
"(begin"
" 'expand-post-submodules163"
"(let-values(((fully-expanded-bodys-except-post-submodules_0) fully-expanded-bodys-except-post-submodules162_0))"
"(let-values(((declare-enclosing-module_0) declare-enclosing140_0))"
"(let-values(((phase_0) phase141_0))"
"(let-values(((self_0) self142_0))"
"(let-values(((requires+provides_0) requires-and-provides143_0))"
"(let-values(((enclosing-is-cross-phase-persistent?_0) enclosing-is-cross-phase-persistent?144_0))"
"(let-values()"
"(let-values(((mpis-to-reset_0) mpis-to-reset146_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names147_0))"
"(let-values(((compiled-submodules_0) compiled-submodules148_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled149_0))"
"(let-values(((submod-ctx_0) ctx150_0))"
"(let-values()"
"((letrec-values(((loop_0)"
"(lambda(bodys_0 phase_1)"
"(begin"
" 'loop"
"(if(null? bodys_0)"
"(let-values() null)"
"(let-values()"
"(let-values(((body_0)(car bodys_0)))"
"(let-values(((rest-bodys_0)(cdr bodys_0)))"
"(if(semi-parsed-begin-for-syntax? body_0)"
"(let-values()"
"(let-values(((body-s_0)"
"(semi-parsed-begin-for-syntax-s"
" body_0)))"
"(let-values(((ok?_0 begin-for-syntax631_0 _632_0)"
"(let-values(((s_0)"
"(syntax-disarm$1"
" body-s_0)))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((begin-for-syntax631_0"
" _632_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(let-values(((begin-for-syntax633_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((_634_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" begin-for-syntax633_0"
" _634_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                         \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" begin-for-syntax631_0"
" _632_0))))))"
"(let-values(((rebuild-body-s_0)"
"(let-values(((submod-ctx635_0)"
" submod-ctx_0)"
"((body-s636_0)"
" body-s_0))"
"(keep-as-needed119.1"
" #f"
" #f"
" #f"
" submod-ctx635_0"
" body-s636_0))))"
"(let-values(((nested-bodys_0)"
"(loop_0"
"(semi-parsed-begin-for-syntax-body"
" body_0)"
"(add1 phase_1))))"
"(let-values(((parsed-bfs_0)"
"(parsed-begin-for-syntax21.1"
" rebuild-body-s_0"
"(parsed-only nested-bodys_0))))"
"(cons"
"(if(expand-context-to-parsed?"
" submod-ctx_0)"
" parsed-bfs_0"
"(expanded+parsed1.1"
"(let-values(((rebuild-body-s637_0)"
" rebuild-body-s_0)"
"((temp638_0)"
"(list*"
" begin-for-syntax631_0"
"(syntax-only"
" nested-bodys_0))))"
"(rebuild5.1"
" #t"
" rebuild-body-s637_0"
" temp638_0))"
" parsed-bfs_0))"
"(loop_0 rest-bodys_0 phase_1))))))))"
"(if(let-values(((or-part_0)(parsed? body_0)))"
"(if or-part_0"
" or-part_0"
"(expanded+parsed? body_0)))"
"(let-values()"
"(cons body_0(loop_0 rest-bodys_0 phase_1)))"
"(let-values()"
"(let-values(((disarmed-body_0)"
"(syntax-disarm$1 body_0)))"
"(let-values(((tmp_0)"
"(core-form-sym"
" disarmed-body_0"
" phase_1)))"
"(if(equal? tmp_0 'module*)"
"(let-values()"
"(let-values((()"
"(begin"
"(force"
" declare-enclosing-module_0)"
"(values))))"
"(let-values(((ready-body_0)"
"(remove-use-site-scopes"
" body_0"
" submod-ctx_0)))"
"(let-values(((ok?_0"
" module*639_0"
" name640_0"
" _641_0)"
"(let-values(((s_0)"
" disarmed-body_0))"
"(if(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair? s_1)"
"(if(let-values(((s_2)"
"(car"
" s_1)))"
" #t)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(if(pair?"
" s_3)"
"(if(let-values(((s_4)"
"(car"
" s_3)))"
" #t)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(if(pair?"
" s_5)"
"(if(let-values(((s_6)"
"(car"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(eq?"
" #f"
" s_7)))"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
" #t)"
" #f)"
" #f)))"
" #f)"
" #f)))"
" #f)"
" #f))"
"(let-values()"
"(let-values(((module*639_0"
" name640_0"
" _641_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(let-values(((module*642_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((name643_0"
" _644_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((name645_0)"
"(let-values(((s_4)"
"(car"
" s_3)))"
" s_4))"
"((_646_0)"
"(let-values(((s_4)"
"(cdr"
" s_3)))"
"(let-values(((s_5)"
"(if(syntax?$1"
" s_4)"
"(syntax-e$1"
" s_4)"
" s_4)))"
"(let-values((()"
"(let-values(((s_6)"
"(car"
" s_5)))"
"(let-values(((s_7)"
"(if(syntax?$1"
" s_6)"
"(syntax-e$1"
" s_6)"
" s_6)))"
"(values))))"
"((_647_0)"
"(let-values(((s_6)"
"(cdr"
" s_5)))"
" s_6)))"
"(values"
" _647_0))))))"
"(values"
" name645_0"
" _646_0))))))"
"(values"
" module*642_0"
" name643_0"
" _644_0)))))"
"(values"
" #t"
" module*639_0"
" name640_0"
" _641_0)))"
"(values"
" #f"
" #f"
" #f"
" #f)))))"
"(let-values(((submod_0)"
"(if ok?_0"
"(let-values()"
"(let-values(((neg-phase_0)"
"(phase-"
" 0"
" phase_1)))"
"(let-values(((shifted-s_0)"
"(syntax-shift-phase-level$1"
" ready-body_0"
" neg-phase_0)))"
"(let-values(((submod_0)"
"(let-values(((shifted-s648_0)"
" shifted-s_0)"
"((self649_0)"
" self_0)"
"((submod-ctx650_0)"
" submod-ctx_0)"
"((temp651_0)"
" #t)"
"((neg-phase652_0)"
" neg-phase_0)"
"((requires+provides653_0)"
" requires+provides_0)"
"((enclosing-is-cross-phase-persistent?654_0)"
" enclosing-is-cross-phase-persistent?_0)"
"((mpis-to-reset655_0)"
" mpis-to-reset_0)"
"((declared-submodule-names656_0)"
" declared-submodule-names_0)"
"((compiled-submodules657_0)"
" compiled-submodules_0)"
"((modules-being-compiled658_0)"
" modules-being-compiled_0))"
"(expand-submodule193.1"
" compiled-submodules657_0"
" declared-submodule-names656_0"
" enclosing-is-cross-phase-persistent?654_0"
" requires+provides653_0"
" temp651_0"
" neg-phase652_0"
" modules-being-compiled658_0"
" mpis-to-reset655_0"
" shifted-s648_0"
" self649_0"
" submod-ctx650_0))))"
"(if(parsed?"
" submod_0)"
"(let-values()"
" submod_0)"
"(if(expanded+parsed?"
" submod_0)"
"(let-values()"
"(let-values(((the-struct_0)"
" submod_0))"
"(if(expanded+parsed?"
" the-struct_0)"
"(let-values(((s659_0)"
"(syntax-shift-phase-level$1"
"(expanded+parsed-s"
" submod_0)"
" phase_1)))"
"(expanded+parsed1.1"
" s659_0"
"(expanded+parsed-parsed"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                                                     \"expanded+parsed?\""
" the-struct_0))))"
"(let-values()"
"(syntax-shift-phase-level$1"
" submod_0"
" phase_1))))))))"
"(let-values()"
"(let-values(((ready-body660_0)"
" ready-body_0)"
"((self661_0)"
" self_0)"
"((submod-ctx662_0)"
" submod-ctx_0)"
"((temp663_0)"
" #t)"
"((mpis-to-reset664_0)"
" mpis-to-reset_0)"
"((declared-submodule-names665_0)"
" declared-submodule-names_0)"
"((compiled-submodules666_0)"
" compiled-submodules_0)"
"((modules-being-compiled667_0)"
" modules-being-compiled_0))"
"(expand-submodule193.1"
" compiled-submodules666_0"
" declared-submodule-names665_0"
" #f"
" #f"
" temp663_0"
" #f"
" modules-being-compiled667_0"
" mpis-to-reset664_0"
" ready-body660_0"
" self661_0"
" submod-ctx662_0))))))"
"(cons"
" submod_0"
"(loop_0 rest-bodys_0 phase_1)))))))"
"(let-values()"
"(cons"
" body_0"
"(loop_0"
" rest-bodys_0"
" phase_1)))))))))))))))))"
" loop_0)"
" fully-expanded-bodys-except-post-submodules_0"
" phase_0)))))))))))))))))"
"(define-values"
"(stop-at-module*?)"
"(lambda(ctx_0)"
"(begin"
"(free-id-set-member?"
"(expand-context-stops ctx_0)"
"(expand-context-phase ctx_0)"
"(syntax-shift-phase-level$1(datum->syntax$1 core-stx 'module*)(expand-context-phase ctx_0))))))"
"(define-values"
"(check-ids-unbound171.1)"
"(lambda(in166_0 ids168_0 phase169_0 requires+provides170_0)"
"(begin"
" 'check-ids-unbound171"
"(let-values(((ids_0) ids168_0))"
"(let-values(((phase_0) phase169_0))"
"(let-values(((requires+provides_0) requires+provides170_0))"
"(let-values(((s_0) in166_0))"
"(let-values()"
"(begin"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((requires+provides668_0)"
" requires+provides_0)"
"((id669_0) id_0)"
"((phase670_0) phase_0)"
"((s671_0) s_0)"
"((temp672_0) 'module))"
"(check-not-defined95.1"
" #f"
" #f"
" #f"
" s671_0"
" #f"
" #f"
" temp672_0"
" requires+provides668_0"
" id669_0"
" phase670_0)))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void))))))))))"
"(define-values"
"(eval-nested-bodys)"
"(lambda(bodys_0 phase_0 m-ns_0 self_0 ctx_0)"
"(begin"
"(begin"
"(let-values(((lst_0) bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((p_0)"
"(if(expanded+parsed? body_0)"
"(expanded+parsed-parsed"
" body_0)"
" body_0)))"
"(if(parsed-define-values? p_0)"
"(let-values()"
"(let-values(((ids_0)"
"(parsed-define-values-ids"
" p_0)))"
"(let-values(((vals_0)"
"(eval-for-bindings"
" 'define-values"
" ids_0"
"(parsed-define-values-rhs"
" p_0)"
" phase_0"
" m-ns_0"
" ctx_0)))"
"(begin"
"(let-values(((lst_2) ids_0)"
"((lst_3)"
"(parsed-define-values-syms"
" p_0))"
"((lst_4) vals_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_2)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_3)))"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list lst_4)))"
"((letrec-values(((for-loop_1)"
"(lambda(lst_5"
" lst_6"
" lst_7)"
"(begin"
" 'for-loop"
"(if(if(pair?"
" lst_5)"
"(if(pair?"
" lst_6)"
"(pair?"
" lst_7)"
" #f)"
" #f)"
"(let-values(((id_0)"
"(unsafe-car"
" lst_5))"
"((rest_1)"
"(unsafe-cdr"
" lst_5))"
"((sym_0)"
"(unsafe-car"
" lst_6))"
"((rest_2)"
"(unsafe-cdr"
" lst_6))"
"((val_0)"
"(unsafe-car"
" lst_7))"
"((rest_3)"
"(unsafe-cdr"
" lst_7)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(namespace-set-variable!"
" m-ns_0"
" phase_0"
" sym_0"
" val_0))"
"(values)))))"
"(values)))))"
"(if(not"
" #f)"
"(for-loop_1"
" rest_1"
" rest_2"
" rest_3)"
"(values))))"
"(values))))))"
" for-loop_1)"
" lst_2"
" lst_3"
" lst_4)))"
"(void)))))"
"(if(let-values(((or-part_0)"
"(parsed-define-syntaxes?"
" p_0)))"
"(if or-part_0"
" or-part_0"
"(semi-parsed-begin-for-syntax?"
" p_0)))"
"(let-values()(void))"
"(if(let-values(((or-part_0)"
"(parsed-#%declare?"
" p_0)))"
"(if or-part_0"
" or-part_0"
"(syntax?$1 p_0)))"
"(let-values()(void))"
"(let-values()"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first"
" #f"
" parameterization-key)"
" 1/current-namespace"
" m-ns_0)"
"(let-values()"
"(with-continuation-mark"
" current-expand-context"
" ctx_0"
"(let-values()"
"(eval-single-top"
"(compile-single"
" p_0"
"(let-values(((m-ns673_0)"
" m-ns_0)"
"((phase674_0)"
" phase_0))"
"(make-compile-context14.1"
" #f"
" unsafe-undefined"
" #f"
" m-ns673_0"
" phase674_0"
" unsafe-undefined)))"
" m-ns_0)))))))))))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void)))))"
"(define-values"
"(expand-submodule193.1)"
"(lambda(compiled-submodules180_0"
" declared-submodule-names179_0"
" enclosing-is-cross-phase-persistent?177_0"
" enclosing-requires+provides176_0"
" is-star?174_0"
" keep-enclosing-scope-at-phase175_0"
" modules-being-compiled181_0"
" mpis-to-reset178_0"
" s190_0"
" self191_0"
" ctx192_0)"
"(begin"
" 'expand-submodule193"
"(let-values(((s_0) s190_0))"
"(let-values(((self_0) self191_0))"
"(let-values(((ctx_0) ctx192_0))"
"(let-values(((is-star?_0) is-star?174_0))"
"(let-values(((keep-enclosing-scope-at-phase_0) keep-enclosing-scope-at-phase175_0))"
"(let-values(((enclosing-r+p_0) enclosing-requires+provides176_0))"
"(let-values(((enclosing-is-cross-phase-persistent?_0) enclosing-is-cross-phase-persistent?177_0))"
"(let-values(((mpis-to-reset_0) mpis-to-reset178_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names179_0))"
"(let-values(((compiled-submodules_0) compiled-submodules180_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled181_0))"
"(let-values()"
"(let-values((()"
"(begin"
"(if is-star?_0"
"(void)"
"(let-values()"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(begin"
"(call-expand-observe obs_0 'enter-prim s_0)"
"(call-expand-observe"
" obs_0"
"(if is-star?_0 'prim-submodule* 'prim-submodule)))))"
"(void)))))"
"(values))))"
"(let-values(((ok?_0 module675_0 name676_0 _677_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((module675_0 name676_0 _677_0)"
"(let-values(((s_2)"
"(if(syntax?$1 s_1)"
"(syntax-e$1 s_1)"
" s_1)))"
"(if(pair? s_2)"
"(let-values(((module678_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((name679_0 _680_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((name681_0)"
"(let-values(((s_5)"
"(car"
" s_4)))"
" s_5))"
"((_682_0)"
"(let-values(((s_5)"
"(cdr"
" s_4)))"
" s_5)))"
"(values name681_0 _682_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                         \"bad syntax\""
" orig-s_0))))))"
"(values module678_0 name679_0 _680_0))"
"                                                                    (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t module675_0 name676_0 _677_0))))))"
"(let-values(((name_0)(syntax-e$1 name676_0)))"
"(let-values((()"
"(begin"
"(if(hash-ref declared-submodule-names_0 name_0 #f)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                         \"submodule already declared with the same name\""
" s_0"
" name_0))"
"(void))"
"(values))))"
"(let-values((()"
"(begin"
"(hash-set!"
" declared-submodule-names_0"
" name_0"
"(syntax-e$1 module675_0))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe obs_0 'enter-prim s_0)))"
"(void)))"
"(values))))"
"(let-values(((submod_0)"
"(let-values(((s683_0) s_0)"
"((temp684_0)"
"(let-values(((v_0) ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((context692_0) 'module)"
"((post-expansion693_0) #f)"
"((inner694_0)"
"(let-values(((the-struct_1)"
"(root-expand-context/outer-inner"
" v_0)))"
"(if(expand-context/inner?"
" the-struct_1)"
"(let-values(((stops695_0)"
" empty-free-id-set))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi"
" the-struct_1)"
"(root-expand-context/inner-module-scopes"
" the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope"
" the-struct_1)"
"(root-expand-context/inner-all-scopes-stx"
" the-struct_1)"
"(root-expand-context/inner-defined-syms"
" the-struct_1)"
"(root-expand-context/inner-counter"
" the-struct_1)"
"(root-expand-context/inner-lift-key"
" the-struct_1)"
"(expand-context/inner-to-parsed?"
" the-struct_1)"
"(expand-context/inner-phase"
" the-struct_1)"
"(expand-context/inner-namespace"
" the-struct_1)"
"(expand-context/inner-just-once?"
" the-struct_1)"
"(expand-context/inner-module-begin-k"
" the-struct_1)"
"(expand-context/inner-allow-unbound?"
" the-struct_1)"
"(expand-context/inner-in-local-expand?"
" the-struct_1)"
"(expand-context/inner-keep-#%expression?"
" the-struct_1)"
" stops695_0"
"(expand-context/inner-declared-submodule-names"
" the-struct_1)"
"(expand-context/inner-lifts"
" the-struct_1)"
"(expand-context/inner-lift-envs"
" the-struct_1)"
"(expand-context/inner-module-lifts"
" the-struct_1)"
"(expand-context/inner-require-lifts"
" the-struct_1)"
"(expand-context/inner-to-module-lifts"
" the-struct_1)"
"(expand-context/inner-requires+provides"
" the-struct_1)"
"(expand-context/inner-observer"
" the-struct_1)"
"(expand-context/inner-for-serializable?"
" the-struct_1)"
"(expand-context/inner-to-correlated-linklet?"
" the-struct_1)"
"(expand-context/inner-normalize-locals?"
" the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                               \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner694_0"
" post-expansion693_0"
"(root-expand-context/outer-use-site-scopes"
" the-struct_0)"
"(root-expand-context/outer-frame-id"
" the-struct_0)"
" context692_0"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes"
" the-struct_0)"
"(expand-context/outer-def-ctx-scopes"
" the-struct_0)"
"(expand-context/outer-binding-layer"
" the-struct_0)"
"(expand-context/outer-reference-records"
" the-struct_0)"
"(expand-context/outer-only-immediate?"
" the-struct_0)"
"(expand-context/outer-need-eventually-defined"
" the-struct_0)"
"(expand-context/outer-current-introduction-scopes"
" the-struct_0)"
"(expand-context/outer-current-use-scopes"
" the-struct_0)"
"(expand-context/outer-name"
" the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                             \"expand-context/outer?\""
" the-struct_0)))))"
"((self685_0) self_0)"
"((temp686_0) #t)"
"((keep-enclosing-scope-at-phase687_0)"
" keep-enclosing-scope-at-phase_0)"
"((enclosing-r+p688_0) enclosing-r+p_0)"
"((enclosing-is-cross-phase-persistent?689_0)"
" enclosing-is-cross-phase-persistent?_0)"
"((mpis-to-reset690_0) mpis-to-reset_0)"
"((modules-being-compiled691_0)"
" modules-being-compiled_0))"
"(expand-module16.1"
" temp686_0"
" enclosing-is-cross-phase-persistent?689_0"
" enclosing-r+p688_0"
" keep-enclosing-scope-at-phase687_0"
" modules-being-compiled691_0"
" mpis-to-reset690_0"
" s683_0"
" temp684_0"
" self685_0))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
"(extract-syntax submod_0))))"
"(void)))"
"(values))))"
"(let-values(((ns_0)(expand-context-namespace ctx_0)))"
"(let-values(((module-name_0)(1/module-path-index-resolve self_0)))"
"(let-values(((root-module-name_0)"
"(resolved-module-path-root-name module-name_0)))"
"(let-values(((compiled-submodule_0)"
"(let-values(((temp696_0)"
"(if(expanded+parsed? submod_0)"
"(expanded+parsed-parsed submod_0)"
" submod_0))"
"((temp697_0)"
"(let-values(((ns703_0) ns_0)"
"((self704_0) self_0)"
"((temp705_0)"
"(1/resolved-module-path-name"
" module-name_0)))"
"(make-compile-context14.1"
" temp705_0"
" unsafe-undefined"
" self704_0"
" ns703_0"
" unsafe-undefined"
" unsafe-undefined)))"
"((temp698_0) #t)"
"((temp699_0)"
"(expand-context-for-serializable?"
" ctx_0))"
"((temp700_0)"
"(expand-context-to-correlated-linklet?"
" ctx_0))"
"((modules-being-compiled701_0)"
" modules-being-compiled_0)"
"((temp702_0) #f))"
"(compile-module13.1"
" temp698_0"
" modules-being-compiled701_0"
" temp702_0"
" temp699_0"
" temp700_0"
" temp696_0"
" temp697_0))))"
"(begin"
"(hash-set!"
" compiled-submodules_0"
" name_0"
"(cons is-star?_0 compiled-submodule_0))"
"(with-continuation-mark"
" parameterization-key"
"(extend-parameterization"
"(continuation-mark-set-first #f parameterization-key)"
" 1/current-namespace"
" ns_0"
" 1/current-module-declare-name"
"(1/make-resolved-module-path root-module-name_0))"
"(let-values()"
"(let-values(((compiled-submodule706_0) compiled-submodule_0)"
"((temp707_0) #f))"
"(eval-module8.1"
" unsafe-undefined"
" #f"
" temp707_0"
" compiled-submodule706_0))))"
"(if is-star?_0"
"(void)"
"(let-values()"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
"(extract-syntax submod_0))))"
"(void)))))"
"(if(not is-star?_0)"
"(let-values() submod_0)"
"(if(expanded+parsed? submod_0)"
"(let-values()"
"(let-values(((the-struct_0) submod_0))"
"(if(expanded+parsed? the-struct_0)"
"(let-values(((parsed708_0)"
"(let-values(((the-struct_1)"
"(expanded+parsed-parsed"
" submod_0)))"
"(if(parsed-module? the-struct_1)"
"(let-values(((star?709_0) #t))"
"(parsed-module25.1"
"(parsed-s the-struct_1)"
" star?709_0"
"(parsed-module-name-id"
" the-struct_1)"
"(parsed-module-self the-struct_1)"
"(parsed-module-requires"
" the-struct_1)"
"(parsed-module-provides"
" the-struct_1)"
"(parsed-module-root-ctx-simple?"
" the-struct_1)"
"(parsed-module-encoded-root-ctx"
" the-struct_1)"
"(parsed-module-body the-struct_1)"
"(parsed-module-compiled-module"
" the-struct_1)"
"(parsed-module-compiled-submodules"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                                     \"parsed-module?\""
" the-struct_1)))))"
"(expanded+parsed1.1"
"(expanded+parsed-s the-struct_0)"
" parsed708_0))"
"(raise-argument-error"
" 'struct-copy"
"                                                                   \"expanded+parsed?\""
" the-struct_0))))"
"(let-values()"
"(let-values(((the-struct_0) submod_0))"
"(if(parsed-module? the-struct_0)"
"(let-values(((star?710_0) #t))"
"(parsed-module25.1"
"(parsed-s the-struct_0)"
" star?710_0"
"(parsed-module-name-id the-struct_0)"
"(parsed-module-self the-struct_0)"
"(parsed-module-requires the-struct_0)"
"(parsed-module-provides the-struct_0)"
"(parsed-module-root-ctx-simple? the-struct_0)"
"(parsed-module-encoded-root-ctx the-struct_0)"
"(parsed-module-body the-struct_0)"
"(parsed-module-compiled-module the-struct_0)"
"(parsed-module-compiled-submodules the-struct_0)))"
"(raise-argument-error"
" 'struct-copy"
"                                                                   \"parsed-module?\""
" the-struct_0))))))))))))))))))))))))))))))))))"
"(define-values"
"(expand-non-module*-submodules208.1)"
"(lambda(compiled-submodules198_0"
" declared-submodule-names197_0"
" modules-being-compiled199_0"
" mpis-to-reset196_0"
" bodys204_0"
" phase205_0"
" self206_0"
" ctx207_0)"
"(begin"
" 'expand-non-module*-submodules208"
"(let-values(((bodys_0) bodys204_0))"
"(let-values(((phase_0) phase205_0))"
"(let-values(((self_0) self206_0))"
"(let-values(((ctx_0) ctx207_0))"
"(let-values(((mpis-to-reset_0) mpis-to-reset196_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names197_0))"
"(let-values(((compiled-submodules_0) compiled-submodules198_0))"
"(let-values(((modules-being-compiled_0) modules-being-compiled199_0))"
"(let-values()"
"(reverse$1"
"(let-values(((lst_0) bodys_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((body_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(let-values(((tmp_0)"
"(core-form-sym"
"(syntax-disarm$1"
" body_0)"
" phase_0)))"
"(if(equal? tmp_0 'module)"
"(let-values()"
"(let-values(((body711_0)"
" body_0)"
"((self712_0)"
" self_0)"
"((ctx713_0)"
" ctx_0)"
"((temp714_0)"
" #f)"
"((mpis-to-reset715_0)"
" mpis-to-reset_0)"
"((declared-submodule-names716_0)"
" declared-submodule-names_0)"
"((compiled-submodules717_0)"
" compiled-submodules_0)"
"((modules-being-compiled718_0)"
" modules-being-compiled_0))"
"(expand-submodule193.1"
" compiled-submodules717_0"
" declared-submodule-names716_0"
" #f"
" #f"
" temp714_0"
" #f"
" modules-being-compiled718_0"
" mpis-to-reset715_0"
" body711_0"
" self712_0"
" ctx713_0)))"
"(let-values() body_0))))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))))))))))))"
"(define-values"
"(make-parse-lifted-require216.1)"
"(lambda(declared-submodule-names211_0 m-ns213_0 self214_0 requires+provides215_0)"
"(begin"
" 'make-parse-lifted-require216"
"(let-values(((m-ns_0) m-ns213_0))"
"(let-values(((self_0) self214_0))"
"(let-values(((requires+provides_0) requires+provides215_0))"
"(let-values(((declared-submodule-names_0) declared-submodule-names211_0))"
"(let-values()"
"(lambda(s_0 phase_0)"
"(let-values(((ok?_0 #%require719_0 req720_0)"
"(let-values(((s_1)(syntax-disarm$1 s_0)))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%require719_0 req720_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%require721_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((req722_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((req723_0)"
"(let-values(((s_5)(car s_4)))"
" s_5))"
"(()"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1"
" s_5)"
"(syntax-e$1"
" s_5)"
" s_5)))"
"(if(null? s_6)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                               \"bad syntax\""
" orig-s_0))))))"
"(values req723_0))"
"(raise-syntax-error$1"
" #f"
"                                                                           \"bad syntax\""
" orig-s_0))))))"
"(values #%require721_0 req722_0))"
"                                                      (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%require719_0 req720_0))))))"
"(let-values(((temp724_0)(list req720_0))"
"((s725_0) s_0)"
"((self726_0) self_0)"
"((m-ns727_0) m-ns_0)"
"((phase728_0) phase_0)"
"((phase729_0) phase_0)"
"((requires+provides730_0) requires+provides_0)"
"((declared-submodule-names731_0) declared-submodule-names_0)"
"((temp732_0) 'require))"
"(parse-and-perform-requires!30.1"
" #f"
" #f"
" declared-submodule-names731_0"
" #f"
" phase729_0"
" #f"
" self726_0"
" #f"
" #t"
" temp732_0"
" temp724_0"
" s725_0"
" m-ns727_0"
" phase728_0"
" requires+provides730_0))))))))))))"
"(define-values"
"(defn-extract-syntax)"
"(lambda(defn_0)"
"(begin"
"(datum->syntax$1"
" #f"
"(list 'define-values(semi-parsed-define-values-ids defn_0)(semi-parsed-define-values-rhs defn_0))"
"(semi-parsed-define-values-s defn_0)))))"
"(define-values"
"(lifted-defns-extract-syntax)"
"(lambda(lifted-defns_0)"
"(begin"
"(reverse$1"
"(let-values(((lst_0) lifted-defns_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((lifted-defn_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(defn-extract-syntax lifted-defn_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))))"
"(define-values"
"(log-lifted-defns)"
"(lambda(partial-body-ctx_0 lifted-defns_0 exp-body_0 rest-bodys_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer partial-body-ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values(((s-lifted-defns_0)(lifted-defns-extract-syntax lifted-defns_0)))"
"(let-values((()"
"(begin(call-expand-observe obs_0 'rename-list(cons exp-body_0 rest-bodys_0))(values))))"
"(let-values((()(begin(call-expand-observe obs_0 'module-lift-loop s-lifted-defns_0)(values))))"
"(let-values((()"
"(begin"
"(let-values(((lst_0) s-lifted-defns_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((s-lifted-defn_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((ok?_0"
" define-values737_0"
" _738_0)"
"(let-values(((s_0)"
" s-lifted-defn_0))"
"(let-values(((orig-s_0)"
" s_0))"
"(let-values(((define-values737_0"
" _738_0)"
"(let-values(((s_1)"
"(if(syntax?$1"
" s_0)"
"(syntax-e$1"
" s_0)"
" s_0)))"
"(if(pair?"
" s_1)"
"(let-values(((define-values739_0)"
"(let-values(((s_2)"
"(car"
" s_1)))"
" s_2))"
"((_740_0)"
"(let-values(((s_2)"
"(cdr"
" s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1"
" s_2)"
"(syntax-e$1"
" s_2)"
" s_2)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_3)))"
"(if(not"
" flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                 \"bad syntax\""
" orig-s_0))"
"(let-values()"
" flat-s_0)))))))"
"(values"
" define-values739_0"
" _740_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                         \"bad syntax\""
" orig-s_0)))))"
"(values"
" #t"
" define-values737_0"
" _738_0))))))"
"(begin"
"(call-expand-observe"
" obs_0"
" 'next)"
"(call-expand-observe"
" obs_0"
" 'visit"
" s-lifted-defn_0)"
"(call-expand-observe"
" obs_0"
" 'resolve"
" define-values737_0)"
"(call-expand-observe"
" obs_0"
" 'enter-prim"
" s-lifted-defn_0)"
"(call-expand-observe"
" obs_0"
" 'prim-stop)"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
" s-lifted-defn_0)"
"(call-expand-observe"
" obs_0"
" 'return"
" s-lifted-defn_0)"
"(call-expand-observe"
" obs_0"
" 'rename-one"
" s-lifted-defn_0)"
"(call-expand-observe"
" obs_0"
" 'enter-prim"
" s-lifted-defn_0)"
"(call-expand-observe"
" obs_0"
" 'prim-define-values)"
"(call-expand-observe"
" obs_0"
" 'exit-prim"
" s-lifted-defn_0))))"
"(values)))))"
"(values)))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(values))))"
"(let-values()"
"(let-values(((ok?_0 form-id733_0 _734_0)"
"(let-values(((s_0) exp-body_0))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((form-id733_0 _734_0)"
"(let-values(((s_1)(if(syntax?$1 s_0)(syntax-e$1 s_0) s_0)))"
"(if(pair? s_1)"
"(let-values(((form-id735_0)"
"(let-values(((s_2)(car s_1))) s_2))"
"((_736_0)(let-values(((s_2)(cdr s_1))) s_2)))"
"(values form-id735_0 _736_0))"
"                                                          (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t form-id733_0 _734_0))))))"
"(begin"
"(call-expand-observe obs_0 'next)"
"(call-expand-observe obs_0 'visit exp-body_0)"
"(call-expand-observe obs_0 'resolve form-id733_0)"
"(call-expand-observe obs_0 'enter-prim exp-body_0)"
"(call-expand-observe obs_0 'prim-stop)"
"(call-expand-observe obs_0 'exit-prim exp-body_0)"
"(call-expand-observe obs_0 'return exp-body_0)))))))))"
"(void))))))"
"(define-values"
"(log-defn-enter)"
"(lambda(ctx_0 defn_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values(((s-defn_0)(defn-extract-syntax defn_0)))"
"(let-values(((ok?_0 define-values741_0 _742_0)"
"(let-values(((s_0) s-defn_0))"
"(let-values(((orig-s_0) s_0))"
"(let-values(((define-values741_0 _742_0)"
"(let-values(((s_1)(if(syntax?$1 s_0)(syntax-e$1 s_0) s_0)))"
"(if(pair? s_1)"
"(let-values(((define-values743_0)"
"(let-values(((s_2)(car s_1))) s_2))"
"((_744_0)"
"(let-values(((s_2)(cdr s_1)))"
"(let-values(((s_3)"
"(if(syntax?$1 s_2)"
"(syntax-e$1 s_2)"
" s_2)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_3)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                           \"bad syntax\""
" orig-s_0))"
"(let-values() flat-s_0)))))))"
"(values define-values743_0 _744_0))"
"                                                  (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t define-values741_0 _742_0))))))"
"(begin"
"(call-expand-observe obs_0 'visit s-defn_0)"
"(call-expand-observe obs_0 'resolve define-values741_0)"
"(call-expand-observe obs_0 'enter-prim s-defn_0)"
"(call-expand-observe obs_0 'prim-define-values)))))"
"(void))))))"
"(define-values"
"(log-defn-exit)"
"(lambda(ctx_0 defn_0 exp-rhs_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values(((s-defn_0)"
"(datum->syntax$1"
" #f"
"(list 'define-values(semi-parsed-define-values-ids defn_0) exp-rhs_0)"
"(semi-parsed-define-values-s defn_0))))"
"(begin(call-expand-observe obs_0 'exit-prim s-defn_0)(call-expand-observe obs_0 'return s-defn_0))))"
"(void))))))"
"(define-values"
"(as-expand-time-top-level-bindings)"
"(lambda(ids_0 s_0 ctx_0)"
"(begin"
"(let-values(((top-level-bind-scope_0)(root-expand-context-top-level-bind-scope ctx_0)))"
"(let-values(((tl-ids_0)"
"(reverse$1"
"(let-values(((lst_0) ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(remove-use-site-scopes"
" id_0"
" ctx_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(let-values((()"
"(begin"
"(let-values(((tl-ids1_0) tl-ids_0)((temp2_0)(expand-context-phase ctx_0))((s3_0) s_0))"
"(check-no-duplicate-ids7.1 unsafe-undefined tl-ids1_0 temp2_0 s3_0 unsafe-undefined))"
"(values))))"
"(let-values(((tmp-bind-ids_0)"
"(reverse$1"
"(let-values(((lst_0) tl-ids_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((id_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope"
" id_0"
" top-level-bind-scope_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)(for-loop_0 fold-var_1 rest_0) fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0))))))"
"(values tl-ids_0(select-defined-syms-and-bind!/ctx tmp-bind-ids_0 ctx_0)))))))))"
"(void"
"(add-core-form!*"
" 'define-values"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-define-values)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(eq?(expand-context-context ctx_0) 'top-level)"
"(void)"
"                         (let-values () (raise-syntax-error$1 #f \"not allowed in an expression position\" s_0)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 define-values1_0 id2_0 rhs3_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((define-values1_0 id2_0 rhs3_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((define-values4_0)(let-values(((s_3)(car s_2))) s_3))"
"((id5_0 rhs6_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(if(pair? s_4)"
"(let-values(((id7_0)"
"(let-values(((s_5)(car s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                            \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id10_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_7)"
"(symbol?"
"(syntax-e$1"
" s_7))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_7)))"
" s_7"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                          \"not an identifier\""
" orig-s_0"
" s_7)))))"
"(cons"
" id10_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_1"
" rest_0)"
" id_1)))"
" id_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"(reverse$1 id_0))))))))"
"((rhs8_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((rhs9_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null? s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                            \"bad syntax\""
" orig-s_0))))))"
"(values rhs9_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                        \"bad syntax\""
" orig-s_0))))))"
"(values id7_0 rhs8_0))"
"                                                                   (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))))))"
"(values define-values4_0 id5_0 rhs6_0))"
"                                               (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t define-values1_0 id2_0 rhs3_0))))))"
"(let-values(((ids_0 syms_0)(as-expand-time-top-level-bindings id2_0 s_0 ctx_0)))"
"(let-values(((exp-rhs_0)"
"(let-values(((temp11_0) rhs3_0)"
"((temp12_0)(as-named-context(as-expression-context ctx_0) ids_0)))"
"(expand9.1 #f #f #f temp11_0 temp12_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-define-values19.1 s_0 ids_0 syms_0 exp-rhs_0)"
"(let-values(((s13_0) s_0)((temp14_0)(list define-values1_0 ids_0 exp-rhs_0)))"
"(rebuild5.1 #t s13_0 temp14_0))))))))))))"
"(void"
"(add-core-form!*"
" 'define-syntaxes"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-define-syntaxes)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prepare-env)))(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(eq?(expand-context-context ctx_0) 'top-level)"
"(void)"
"                           (let-values () (raise-syntax-error$1 #f \"not in a definition context\" s_0)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 define-syntaxes15_0 id16_0 rhs17_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((define-syntaxes15_0 id16_0 rhs17_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((define-syntaxes18_0)"
"(let-values(((s_3)(car s_2))) s_3))"
"((id19_0 rhs20_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)"
"(syntax-e$1 s_3)"
" s_3)))"
"(if(pair? s_4)"
"(let-values(((id21_0)"
"(let-values(((s_5)(car s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(let-values(((flat-s_0)"
"(to-syntax-list.1"
" s_6)))"
"(if(not flat-s_0)"
"(let-values()"
"(raise-syntax-error$1"
" #f"
"                                                                                              \"bad syntax\""
" orig-s_0))"
"(let-values()"
"(let-values(((id_0)"
"(let-values(((lst_0)"
" flat-s_0))"
"(begin"
"(if(variable-reference-from-unsafe?"
"(#%variable-reference))"
"(void)"
"(let-values()"
"(check-list"
" lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(id_0"
" lst_1)"
"(begin"
" 'for-loop"
"(if(pair?"
" lst_1)"
"(let-values(((s_7)"
"(unsafe-car"
" lst_1))"
"((rest_0)"
"(unsafe-cdr"
" lst_1)))"
"(let-values(((id_1)"
"(let-values(((id_1)"
" id_0))"
"(let-values(((id_2)"
"(let-values()"
"(let-values(((id24_0)"
"(let-values()"
"(if(let-values(((or-part_0)"
"(if(syntax?$1"
" s_7)"
"(symbol?"
"(syntax-e$1"
" s_7))"
" #f)))"
"(if or-part_0"
" or-part_0"
"(symbol?"
" s_7)))"
" s_7"
"(raise-syntax-error$1"
" #f"
"                                                                                                                                                                                            \"not an identifier\""
" orig-s_0"
" s_7)))))"
"(cons"
" id24_0"
" id_1)))))"
"(values"
" id_2)))))"
"(if(not"
" #f)"
"(for-loop_0"
" id_1"
" rest_0)"
" id_1)))"
" id_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"(reverse$1 id_0))))))))"
"((rhs22_0)"
"(let-values(((s_5)(cdr s_4)))"
"(let-values(((s_6)"
"(if(syntax?$1 s_5)"
"(syntax-e$1 s_5)"
" s_5)))"
"(if(pair? s_6)"
"(let-values(((rhs23_0)"
"(let-values(((s_7)"
"(car"
" s_6)))"
" s_7))"
"(()"
"(let-values(((s_7)"
"(cdr"
" s_6)))"
"(let-values(((s_8)"
"(if(syntax?$1"
" s_7)"
"(syntax-e$1"
" s_7)"
" s_7)))"
"(if(null?"
" s_8)"
"(values)"
"(raise-syntax-error$1"
" #f"
"                                                                                                              \"bad syntax\""
" orig-s_0))))))"
"(values rhs23_0))"
"(raise-syntax-error$1"
" #f"
"                                                                                          \"bad syntax\""
" orig-s_0))))))"
"(values id21_0 rhs22_0))"
"(raise-syntax-error$1"
" #f"
"                                                                      \"bad syntax\""
" orig-s_0))))))"
"(values define-syntaxes18_0 id19_0 rhs20_0))"
"                                                 (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t define-syntaxes15_0 id16_0 rhs17_0))))))"
"(let-values(((ids_0 syms_0)(as-expand-time-top-level-bindings id16_0 s_0 ctx_0)))"
"(let-values(((exp-rhs_0)"
"(let-values(((temp25_0) rhs17_0)((temp26_0)(as-named-context ctx_0 ids_0)))"
"(expand-transformer92.1 #f #f 'expression #t #f unsafe-undefined temp25_0 temp26_0))))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-define-syntaxes20.1 s_0 ids_0 syms_0 exp-rhs_0)"
"(let-values(((s27_0) s_0)((temp28_0)(list define-syntaxes15_0 ids_0 exp-rhs_0)))"
"(rebuild5.1 #t s27_0 temp28_0)))))))))))))"
"(void"
"(add-core-form!*"
" 'begin-for-syntax"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(if(eq?(expand-context-context ctx_0) 'top-level)"
"(void)"
"                       (let-values () (raise-syntax-error$1 #f \"not in a definition context\" s_0)))"
"(values))))"
"(let-values(((ok?_0 begin-for-syntax29_0 form30_0)"
"(let-values(((s_1) s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((begin-for-syntax29_0 form30_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((begin-for-syntax31_0)(let-values(((s_3)(car s_2))) s_3))"
"((form32_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                   (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0)))))))"
"(values begin-for-syntax31_0 form32_0))"
"                                           (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t begin-for-syntax29_0 form30_0))))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()(let-values()(call-expand-observe obs_0 'prim-begin-for-syntax)))"
"(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prepare-env)))(void)))"
"(values))))"
"(let-values(((trans-ctx_0)"
"(let-values(((ctx33_0) ctx_0)((temp34_0) 'top-level)((temp35_0) #t))"
"(context->transformer-context99.1 temp35_0 ctx33_0 temp34_0))))"
"(let-values(((lift-ctx_0)"
"(let-values(((temp36_0)(make-top-level-lift trans-ctx_0)))"
"(make-lift-context6.1 #f temp36_0))))"
"(let-values(((capture-ctx_0)"
"(let-values(((v_0) trans-ctx_0))"
"(let-values(((the-struct_0) v_0))"
"(if(expand-context/outer? the-struct_0)"
"(let-values(((inner37_0)"
"(let-values(((the-struct_1)(root-expand-context/outer-inner v_0)))"
"(if(expand-context/inner? the-struct_1)"
"(let-values(((lift-key38_0)(generate-lift-key))"
"((lifts39_0) lift-ctx_0))"
"(expand-context/inner2.1"
"(root-expand-context/inner-self-mpi the-struct_1)"
"(root-expand-context/inner-module-scopes the-struct_1)"
"(root-expand-context/inner-top-level-bind-scope the-struct_1)"
"(root-expand-context/inner-all-scopes-stx the-struct_1)"
"(root-expand-context/inner-defined-syms the-struct_1)"
"(root-expand-context/inner-counter the-struct_1)"
" lift-key38_0"
"(expand-context/inner-to-parsed? the-struct_1)"
"(expand-context/inner-phase the-struct_1)"
"(expand-context/inner-namespace the-struct_1)"
"(expand-context/inner-just-once? the-struct_1)"
"(expand-context/inner-module-begin-k the-struct_1)"
"(expand-context/inner-allow-unbound? the-struct_1)"
"(expand-context/inner-in-local-expand? the-struct_1)"
"(expand-context/inner-keep-#%expression? the-struct_1)"
"(expand-context/inner-stops the-struct_1)"
"(expand-context/inner-declared-submodule-names the-struct_1)"
" lifts39_0"
"(expand-context/inner-lift-envs the-struct_1)"
"(expand-context/inner-module-lifts the-struct_1)"
"(expand-context/inner-require-lifts the-struct_1)"
"(expand-context/inner-to-module-lifts the-struct_1)"
"(expand-context/inner-requires+provides the-struct_1)"
"(expand-context/inner-observer the-struct_1)"
"(expand-context/inner-for-serializable? the-struct_1)"
"(expand-context/inner-to-correlated-linklet? the-struct_1)"
"(expand-context/inner-normalize-locals? the-struct_1)"
"(expand-context/inner-should-not-encounter-macros?"
" the-struct_1)))"
"(raise-argument-error"
" 'struct-copy"
"                                                        \"expand-context/inner?\""
" the-struct_1)))))"
"(expand-context/outer1.1"
" inner37_0"
"(root-expand-context/outer-post-expansion the-struct_0)"
"(root-expand-context/outer-use-site-scopes the-struct_0)"
"(root-expand-context/outer-frame-id the-struct_0)"
"(expand-context/outer-context the-struct_0)"
"(expand-context/outer-env the-struct_0)"
"(expand-context/outer-scopes the-struct_0)"
"(expand-context/outer-def-ctx-scopes the-struct_0)"
"(expand-context/outer-binding-layer the-struct_0)"
"(expand-context/outer-reference-records the-struct_0)"
"(expand-context/outer-only-immediate? the-struct_0)"
"(expand-context/outer-need-eventually-defined the-struct_0)"
"(expand-context/outer-current-introduction-scopes the-struct_0)"
"(expand-context/outer-current-use-scopes the-struct_0)"
"(expand-context/outer-name the-struct_0)))"
"                                     (raise-argument-error 'struct-copy \"expand-context/outer?\" the-struct_0))))))"
"(let-values(((all-exp-forms_0)"
"((letrec-values(((loop_0)"
"(lambda(forms_0)"
"(begin"
" 'loop"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'enter-list"
"(datum->syntax$1 #f form30_0 s_0))))"
"(void)))"
"(values))))"
"(let-values(((exp-forms_0)"
"((letrec-values(((loop_1)"
"(lambda(forms_1 accum_0)"
"(begin"
" 'loop"
"(if(null? forms_1)"
"(let-values()"
"(let-values(((forms_2)"
"(reverse$1"
" accum_0)))"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'exit-list"
"(datum->syntax$1"
" #f"
" forms_2"
" s_0))))"
"(void)))"
" forms_2)))"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'next)))"
"(void)))"
"(values))))"
"(let-values(((exp-form_0)"
"(let-values(((temp40_0)"
"(car"
" forms_1))"
"((capture-ctx41_0)"
" capture-ctx_0))"
"(expand9.1"
" #f"
" #f"
" #f"
" temp40_0"
" capture-ctx41_0))))"
"(loop_1"
"(cdr forms_1)"
"(cons"
" exp-form_0"
" accum_0))))))))))"
" loop_1)"
" forms_0"
" null)))"
"(let-values(((lifts_0)(get-and-clear-lifts! lift-ctx_0)))"
"(if(null? lifts_0)"
"(let-values() exp-forms_0)"
"(let-values()"
"(let-values((()"
"(begin"
"(let-values(((obs_0)"
"(expand-context-observer"
" ctx_0)))"
"(if obs_0"
"(let-values()"
"(let-values()"
"(call-expand-observe"
" obs_0"
" 'module-lift-loop"
" lifts_0)))"
"(void)))"
"(values))))"
"(let-values(((beg_0)"
"(let-values(((lifts42_0) lifts_0)"
"((temp43_0) #f)"
"((temp44_0)"
"(expand-context-phase"
" trans-ctx_0)))"
"(wrap-lifts-as-begin16.1"
" unsafe-undefined"
" unsafe-undefined"
" lifts42_0"
" temp43_0"
" temp44_0))))"
"(let-values(((exprs_0)"
"(reverse$1"
"(cdr"
"(reverse$1"
"(cdr(syntax-e$1 beg_0)))))))"
"(append(loop_0 exprs_0) exp-forms_0)))))))))))))"
" loop_0)"
" form30_0)))"
"(if(expand-context-to-parsed? ctx_0)"
"(parsed-begin-for-syntax21.1 s_0 all-exp-forms_0)"
"(let-values(((s45_0) s_0)((temp46_0)(cons begin-for-syntax29_0 all-exp-forms_0)))"
"(rebuild5.1 #t s45_0 temp46_0))))))))))))))"
"(void"
"(add-core-form!*"
" '#%require"
"(lambda(s_0 ctx_0)"
"(let-values((()"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-require)))(void)))"
"(values))))"
"(let-values((()"
"(begin"
"(if(eq?(expand-context-context ctx_0) 'top-level)"
"(void)"
"                         (let-values () (raise-syntax-error$1 #f \"allowed only in a module or the top level\" s_0)))"
"(values))))"
"(let-values(((disarmed-s_0)(syntax-disarm$1 s_0)))"
"(let-values(((ok?_0 #%require47_0 req48_0)"
"(let-values(((s_1) disarmed-s_0))"
"(let-values(((orig-s_0) s_1))"
"(let-values(((#%require47_0 req48_0)"
"(let-values(((s_2)(if(syntax?$1 s_1)(syntax-e$1 s_1) s_1)))"
"(if(pair? s_2)"
"(let-values(((#%require49_0)(let-values(((s_3)(car s_2))) s_3))"
"((req50_0)"
"(let-values(((s_3)(cdr s_2)))"
"(let-values(((s_4)"
"(if(syntax?$1 s_3)(syntax-e$1 s_3) s_3)))"
"(let-values(((flat-s_0)(to-syntax-list.1 s_4)))"
"(if(not flat-s_0)"
"(let-values()"
"                                                                       (raise-syntax-error$1 #f \"bad syntax\" orig-s_0))"
"(let-values() flat-s_0)))))))"
"(values #%require49_0 req50_0))"
"                                               (raise-syntax-error$1 #f \"bad syntax\" orig-s_0)))))"
"(values #t #%require47_0 req48_0))))))"
"(let-values(((sc_0)(new-scope 'macro)))"
"(begin"
"(let-values(((temp51_0)"
"(reverse$1"
"(let-values(((lst_0) req48_0))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(fold-var_0 lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((req_0)(unsafe-car lst_1))"
"((rest_0)(unsafe-cdr lst_1)))"
"(let-values(((fold-var_1)"
"(let-values(((fold-var_1) fold-var_0))"
"(let-values(((fold-var_2)"
"(let-values()"
"(cons"
"(let-values()"
"(add-scope req_0 sc_0))"
" fold-var_1))))"
"(values fold-var_2)))))"
"(if(not #f)"
"(for-loop_0 fold-var_1 rest_0)"
" fold-var_1)))"
" fold-var_0)))))"
" for-loop_0)"
" null"
" lst_0)))))"
"((s52_0) s_0)"
"((temp53_0) #f)"
"((temp54_0)(expand-context-namespace ctx_0))"
"((temp55_0)(expand-context-phase ctx_0))"
"((temp56_0)(let-values(((temp59_0) #f))(make-requires+provides8.1 #f temp59_0)))"
"((temp57_0) 'require)"
"((temp58_0) #t))"
"(parse-and-perform-requires!30.1"
" #f"
" #f"
" unsafe-undefined"
" temp58_0"
" unsafe-undefined"
" #f"
" #f"
" #f"
" temp53_0"
" temp57_0"
" temp51_0"
" s52_0"
" temp54_0"
" temp55_0"
" temp56_0))"
"(if(expand-context-to-parsed? ctx_0)(parsed-require23.1 s_0) s_0))))))))))"
"(void"
"(add-core-form!*"
" '#%provide"
"(lambda(s_0 ctx_0)"
"(begin"
"(let-values(((obs_0)(expand-context-observer ctx_0)))"
"(if obs_0(let-values()(let-values()(call-expand-observe obs_0 'prim-provide)))(void)))"
"       (raise-syntax-error$1 #f \"not allowed outside of a module body\" s_0)))))"
"(define-values"
"(namespace-init!)"
"(lambda()"
"(begin"
"(let-values(((ns_0)(make-namespace)))"
"(void"
"(begin"
"(declare-core-module! ns_0)"
"(let-values(((temp1_0) '#%read)((read-primitives2_0) read-primitives)((ns3_0) ns_0))"
"(declare-hash-based-module!39.1 ns3_0 #f null #f #f temp1_0 read-primitives2_0))"
"(let-values(((temp4_0) '#%main)((main-primitives5_0) main-primitives)((ns6_0) ns_0))"
"(declare-hash-based-module!39.1 ns6_0 #f null #f #f temp4_0 main-primitives5_0))"
"(let-values(((temp7_0) '#%utils)((utils-primitives8_0) utils-primitives)((ns9_0) ns_0))"
"(declare-hash-based-module!39.1 ns9_0 #f null #f #f temp7_0 utils-primitives8_0))"
"(let-values(((temp10_0) '#%place-struct)"
"((place-struct-primitives11_0) place-struct-primitives)"
"((ns12_0) ns_0)"
"((temp13_0) '(dynamic-place)))"
"(declare-hash-based-module!39.1 ns12_0 #f temp13_0 #f #f temp10_0 place-struct-primitives11_0))"
"(let-values(((temp14_0) '#%boot)((boot-primitives15_0) boot-primitives)((ns16_0) ns_0))"
"(declare-hash-based-module!39.1 ns16_0 #f null #f #f temp14_0 boot-primitives15_0))"
"(let-values(((linklet-primitives_0)"
"(hash-remove"
"(hash-remove linklet-primitives 'variable-reference?)"
" 'variable-reference-constant?)))"
"(begin"
"(let-values(((temp17_0) '#%linklet-primitive)"
"((linklet-primitives18_0) linklet-primitives_0)"
"((ns19_0) ns_0)"
"((temp20_0) #t)"
"((temp21_0) #t))"
"(declare-hash-based-module!39.1 ns19_0 temp20_0 null #f temp21_0 temp17_0 linklet-primitives18_0))"
"(let-values(((temp22_0) '#%linklet-expander)"
"((linklet-expander-primitives23_0) linklet-expander-primitives)"
"((ns24_0) ns_0))"
"(declare-hash-based-module!39.1 ns24_0 #f null #f #f temp22_0 linklet-expander-primitives23_0))"
"(let-values(((temp25_0) '#%linklet)"
"((temp26_0)(list '#%linklet-primitive '#%linklet-expander))"
"((ns27_0) ns_0))"
"(declare-reexporting-module!48.1 ns27_0 #t temp25_0 temp26_0))))"
"(let-values(((temp28_0) '#%expobs)"
"((expobs-primitives29_0) expobs-primitives)"
"((ns30_0) ns_0)"
"((temp31_0) #t))"
"(declare-hash-based-module!39.1 ns30_0 #f null temp31_0 #f temp28_0 expobs-primitives29_0))"
"(let-values(((ns32_0) ns_0)"
"((temp33_0)"
"(let-values(((ht_0) main-primitives))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((name_0)(hash-iterate-key ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
" name_0)"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first ht_0)))))"
"((temp34_0)"
"(let-values(((ht_0) read-primitives))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))"
"(void)"
"(let-values()(check-in-hash-keys ht_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(table_0 i_0)"
"(begin"
" 'for-loop"
"(if i_0"
"(let-values(((name_0)(hash-iterate-key ht_0 i_0)))"
"(let-values(((table_1)"
"(let-values(((table_1) table_0))"
"(let-values(((table_2)"
"(let-values()"
"(let-values(((key_0 val_0)"
"(let-values()"
"(values"
"(let-values()"
" name_0)"
" #t))))"
"(hash-set"
" table_1"
" key_0"
" val_0)))))"
"(values table_2)))))"
"(if(not #f)"
"(for-loop_0 table_1(hash-iterate-next ht_0 i_0))"
" table_1)))"
" table_0)))))"
" for-loop_0)"
" '#hash()"
"(hash-iterate-first ht_0))))))"
"(declare-kernel-module!6.1 temp33_0 temp34_0 ns32_0))"
"(begin"
"(let-values(((lst_0) runtime-instances))"
"(begin"
"(if(variable-reference-from-unsafe?(#%variable-reference))(void)(let-values()(check-list lst_0)))"
"((letrec-values(((for-loop_0)"
"(lambda(lst_1)"
"(begin"
" 'for-loop"
"(if(pair? lst_1)"
"(let-values(((name_0)(unsafe-car lst_1))((rest_0)(unsafe-cdr lst_1)))"
"(let-values((()"
"(let-values()"
"(if(eq? name_0 '#%kernel)"
"(values)"
"(let-values()"
"(let-values((()"
"(let-values()"
"(begin"
"(let-values()"
"(let-values(((name35_0) name_0)"
"((ns36_0) ns_0)"
"((temp37_0)"
"(let-values(((or-part_0)"
"(eq?"
" name_0"
" '#%foreign)))"
"(if or-part_0"
" or-part_0"
"(let-values(((or-part_1)"
"(eq?"
" name_0"
" '#%futures)))"
"(if or-part_1"
" or-part_1"
"(eq?"
" name_0"
" '#%unsafe)))))))"
"(copy-runtime-module!24.1"
" unsafe-undefined"
" unsafe-undefined"
" ns36_0"
" #t"
" temp37_0"
" unsafe-undefined"
" unsafe-undefined"
" name35_0)))"
"(values)))))"
"(values)))))))"
"(if(not #f)(for-loop_0 rest_0)(values))))"
"(values))))))"
" for-loop_0)"
" lst_0)))"
"(void))"
"(let-values(((temp38_0) '#%builtin)"
"((temp39_0)(list* '#%place-struct '#%utils '#%boot '#%expobs '#%linklet runtime-instances))"
"((ns40_0) ns_0)"
"((temp41_0) #f))"
"(declare-reexporting-module!48.1 ns40_0 temp41_0 temp38_0 temp39_0))"
"(1/current-namespace ns_0)"
"(1/dynamic-require ''#%kernel 0)))))))"
"(call-with-values(lambda()(namespace-init!)) print-values)"
"(define-values(datum->kernel-syntax)(lambda(s_0)(begin(1/datum->syntax core-stx s_0))))"
"(define-values"
"(expander-place-init!)"
"(lambda()"
"(begin"
"(begin"
"(scope-place-init!)"
"(cache-place-init!)"
"(core-place-init!)"
"(module-path-place-init!)"
"(module-cache-place-init!)"
"(collection-place-init!)"
"(performance-place-init!)"
"(namespace-init!))))))"
;
