/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

#ifdef MARKS_FOR_TYPE_C

static int variable_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
}

static int variable_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcMARK2(b->key, gc);
  gcMARK2(b->val, gc);
  gcMARK2(((Scheme_Bucket_With_Home *)b)->home, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
}

static int variable_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcFIXUP2(b->key, gc);
  gcFIXUP2(b->val, gc);
  gcFIXUP2(((Scheme_Bucket_With_Home *)b)->home, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
}

#define variable_obj_IS_ATOMIC 0
#define variable_obj_IS_CONST_SIZE 1


static int module_var_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Module_Variable));
}

static int module_var_MARK(void *p, struct NewGC *gc) {
  Module_Variable *mv = (Module_Variable *)p;

  gcMARK2(mv->modidx, gc);
  gcMARK2(mv->sym, gc);
  gcMARK2(mv->insp, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Module_Variable));
}

static int module_var_FIXUP(void *p, struct NewGC *gc) {
  Module_Variable *mv = (Module_Variable *)p;

  gcFIXUP2(mv->modidx, gc);
  gcFIXUP2(mv->sym, gc);
  gcFIXUP2(mv->insp, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Module_Variable));
}

#define module_var_IS_ATOMIC 0
#define module_var_IS_CONST_SIZE 1


static int bucket_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
}

static int bucket_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcMARK2(b->key, gc);
  gcMARK2(b->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
}

static int bucket_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcFIXUP2(b->key, gc);
  gcFIXUP2(b->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
}

#define bucket_obj_IS_ATOMIC 0
#define bucket_obj_IS_CONST_SIZE 1


static int local_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
}

static int local_obj_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
}

static int local_obj_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
}

#define local_obj_IS_ATOMIC 1
#define local_obj_IS_CONST_SIZE 1


static int toplevel_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
}

static int toplevel_obj_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
}

static int toplevel_obj_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
}

#define toplevel_obj_IS_ATOMIC 1
#define toplevel_obj_IS_CONST_SIZE 1


static int quotesyntax_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Quote_Syntax));
}

static int quotesyntax_obj_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Quote_Syntax));
}

static int quotesyntax_obj_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Quote_Syntax));
}

#define quotesyntax_obj_IS_ATOMIC 1
#define quotesyntax_obj_IS_CONST_SIZE 1


static int cpointer_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cptr));
}

static int cpointer_obj_MARK(void *p, struct NewGC *gc) {
  if (!(SCHEME_CPTR_FLAGS(p) & 0x1)) {
    gcMARK2(SCHEME_CPTR_VAL(p), gc);
  }
  gcMARK2(SCHEME_CPTR_TYPE(p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cptr));
}

static int cpointer_obj_FIXUP(void *p, struct NewGC *gc) {
  if (!(SCHEME_CPTR_FLAGS(p) & 0x1)) {
    gcFIXUP2(SCHEME_CPTR_VAL(p), gc);
  }
  gcFIXUP2(SCHEME_CPTR_TYPE(p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cptr));
}

#define cpointer_obj_IS_ATOMIC 0
#define cpointer_obj_IS_CONST_SIZE 1


static int offset_cpointer_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Offset_Cptr));
}

static int offset_cpointer_obj_MARK(void *p, struct NewGC *gc) {
  if (!(SCHEME_CPTR_FLAGS(p) & 0x1)) {
    gcMARK2(SCHEME_CPTR_VAL(p), gc);
  }
  gcMARK2(SCHEME_CPTR_TYPE(p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Offset_Cptr));
}

static int offset_cpointer_obj_FIXUP(void *p, struct NewGC *gc) {
  if (!(SCHEME_CPTR_FLAGS(p) & 0x1)) {
    gcFIXUP2(SCHEME_CPTR_VAL(p), gc);
  }
  gcFIXUP2(SCHEME_CPTR_TYPE(p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Offset_Cptr));
}

#define offset_cpointer_obj_IS_ATOMIC 0
#define offset_cpointer_obj_IS_CONST_SIZE 1


static int twoptr_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int twoptr_obj_MARK(void *p, struct NewGC *gc) {
  gcMARK2(SCHEME_PTR1_VAL((Scheme_Object *)p), gc);
  gcMARK2(SCHEME_PTR2_VAL((Scheme_Object *)p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int twoptr_obj_FIXUP(void *p, struct NewGC *gc) {
  gcFIXUP2(SCHEME_PTR1_VAL((Scheme_Object *)p), gc);
  gcFIXUP2(SCHEME_PTR2_VAL((Scheme_Object *)p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define twoptr_obj_IS_ATOMIC 0
#define twoptr_obj_IS_CONST_SIZE 1


static int iptr_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int iptr_obj_MARK(void *p, struct NewGC *gc) {
  gcMARK2(SCHEME_IPTR_VAL((Scheme_Object *)p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int iptr_obj_FIXUP(void *p, struct NewGC *gc) {
  gcFIXUP2(SCHEME_IPTR_VAL((Scheme_Object *)p), gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define iptr_obj_IS_ATOMIC 0
#define iptr_obj_IS_CONST_SIZE 1


static int small_object_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int small_object_MARK(void *p, struct NewGC *gc) {
  gcMARK2(((Scheme_Small_Object *)p)->u.ptr_value, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int small_object_FIXUP(void *p, struct NewGC *gc) {
  gcFIXUP2(((Scheme_Small_Object *)p)->u.ptr_value, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

#define small_object_IS_ATOMIC 0
#define small_object_IS_CONST_SIZE 1


static int app_rec_SIZE(void *p, struct NewGC *gc) {
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + (r->num_args * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
}

static int app_rec_MARK(void *p, struct NewGC *gc) {
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  int i = r->num_args + 1;
  while (i--) 
    gcMARK2(r->args[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + (r->num_args * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
}

static int app_rec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  int i = r->num_args + 1;
  while (i--) 
    gcFIXUP2(r->args[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + (r->num_args * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
}

#define app_rec_IS_ATOMIC 0
#define app_rec_IS_CONST_SIZE 0


static int app2_rec_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
}

static int app2_rec_MARK(void *p, struct NewGC *gc) {
  Scheme_App2_Rec *r = (Scheme_App2_Rec *)p;
  gcMARK2(r->rator, gc);
  gcMARK2(r->rand, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
}

static int app2_rec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_App2_Rec *r = (Scheme_App2_Rec *)p;
  gcFIXUP2(r->rator, gc);
  gcFIXUP2(r->rand, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
}

#define app2_rec_IS_ATOMIC 0
#define app2_rec_IS_CONST_SIZE 1


static int app3_rec_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
}

static int app3_rec_MARK(void *p, struct NewGC *gc) {
  Scheme_App3_Rec *r = (Scheme_App3_Rec *)p;
  gcMARK2(r->rator, gc);
  gcMARK2(r->rand1, gc);
  gcMARK2(r->rand2, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
}

static int app3_rec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_App3_Rec *r = (Scheme_App3_Rec *)p;
  gcFIXUP2(r->rator, gc);
  gcFIXUP2(r->rand1, gc);
  gcFIXUP2(r->rand2, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
}

#define app3_rec_IS_ATOMIC 0
#define app3_rec_IS_CONST_SIZE 1


static int seq_rec_SIZE(void *p, struct NewGC *gc) {
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - 1) * sizeof(Scheme_Object *))));
}

static int seq_rec_MARK(void *p, struct NewGC *gc) {
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  int i = s->count;
  while (i--)
    gcMARK2(s->array[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - 1) * sizeof(Scheme_Object *))));
}

static int seq_rec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  int i = s->count;
  while (i--)
    gcFIXUP2(s->array[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - 1) * sizeof(Scheme_Object *))));
}

#define seq_rec_IS_ATOMIC 0
#define seq_rec_IS_CONST_SIZE 0


static int branch_rec_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
}

static int branch_rec_MARK(void *p, struct NewGC *gc) {
  Scheme_Branch_Rec *b = (Scheme_Branch_Rec *)p;
  
  gcMARK2(b->test, gc);
  gcMARK2(b->tbranch, gc);
  gcMARK2(b->fbranch, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
}

static int branch_rec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Branch_Rec *b = (Scheme_Branch_Rec *)p;
  
  gcFIXUP2(b->test, gc);
  gcFIXUP2(b->tbranch, gc);
  gcFIXUP2(b->fbranch, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
}

#define branch_rec_IS_ATOMIC 0
#define branch_rec_IS_CONST_SIZE 1


static int unclosed_proc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Closure_Data));
}

static int unclosed_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Closure_Data *d = (Scheme_Closure_Data *)p;

  gcMARK2(d->name, gc);
  gcMARK2(d->code, gc);
  gcMARK2(d->closure_map, gc);
#ifdef MZ_USE_JIT
  gcMARK2(d->u.native_code, gc);
  gcMARK2(d->context, gc);
#endif

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Closure_Data));
}

static int unclosed_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Closure_Data *d = (Scheme_Closure_Data *)p;

  gcFIXUP2(d->name, gc);
  gcFIXUP2(d->code, gc);
  gcFIXUP2(d->closure_map, gc);
#ifdef MZ_USE_JIT
  gcFIXUP2(d->u.native_code, gc);
  gcFIXUP2(d->context, gc);
#endif

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Closure_Data));
}

#define unclosed_proc_IS_ATOMIC 0
#define unclosed_proc_IS_CONST_SIZE 1


static int let_value_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
}

static int let_value_MARK(void *p, struct NewGC *gc) {
  Scheme_Let_Value *l = (Scheme_Let_Value *)p;
  
  gcMARK2(l->value, gc);
  gcMARK2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
}

static int let_value_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Let_Value *l = (Scheme_Let_Value *)p;
  
  gcFIXUP2(l->value, gc);
  gcFIXUP2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
}

#define let_value_IS_ATOMIC 0
#define let_value_IS_CONST_SIZE 1


static int let_void_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
}

static int let_void_MARK(void *p, struct NewGC *gc) {
  Scheme_Let_Void *l = (Scheme_Let_Void *)p;

  gcMARK2(l->body, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
}

static int let_void_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Let_Void *l = (Scheme_Let_Void *)p;

  gcFIXUP2(l->body, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
}

#define let_void_IS_ATOMIC 0
#define let_void_IS_CONST_SIZE 1


static int letrec_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
}

static int letrec_MARK(void *p, struct NewGC *gc) {
  Scheme_Letrec *l = (Scheme_Letrec *)p;
  
  gcMARK2(l->procs, gc);
  gcMARK2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
}

static int letrec_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Letrec *l = (Scheme_Letrec *)p;
  
  gcFIXUP2(l->procs, gc);
  gcFIXUP2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
}

#define letrec_IS_ATOMIC 0
#define letrec_IS_CONST_SIZE 1


static int let_one_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
}

static int let_one_MARK(void *p, struct NewGC *gc) {
  Scheme_Let_One *l = (Scheme_Let_One *)p;
  
  gcMARK2(l->value, gc);
  gcMARK2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
}

static int let_one_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Let_One *l = (Scheme_Let_One *)p;
  
  gcFIXUP2(l->value, gc);
  gcFIXUP2(l->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
}

#define let_one_IS_ATOMIC 0
#define let_one_IS_CONST_SIZE 1


static int with_cont_mark_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
}

static int with_cont_mark_MARK(void *p, struct NewGC *gc) {
  Scheme_With_Continuation_Mark *w = (Scheme_With_Continuation_Mark *)p;

  gcMARK2(w->key, gc);
  gcMARK2(w->val, gc);
  gcMARK2(w->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
}

static int with_cont_mark_FIXUP(void *p, struct NewGC *gc) {
  Scheme_With_Continuation_Mark *w = (Scheme_With_Continuation_Mark *)p;

  gcFIXUP2(w->key, gc);
  gcFIXUP2(w->val, gc);
  gcFIXUP2(w->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
}

#define with_cont_mark_IS_ATOMIC 0
#define with_cont_mark_IS_CONST_SIZE 1


static int comp_let_value_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compiled_Let_Value));
}

static int comp_let_value_MARK(void *p, struct NewGC *gc) {
  Scheme_Compiled_Let_Value *c = (Scheme_Compiled_Let_Value *)p;

  gcMARK2(c->flags, gc);
  gcMARK2(c->value, gc);
  gcMARK2(c->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compiled_Let_Value));
}

static int comp_let_value_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Compiled_Let_Value *c = (Scheme_Compiled_Let_Value *)p;

  gcFIXUP2(c->flags, gc);
  gcFIXUP2(c->value, gc);
  gcFIXUP2(c->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compiled_Let_Value));
}

#define comp_let_value_IS_ATOMIC 0
#define comp_let_value_IS_CONST_SIZE 1


static int let_header_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Header));
}

static int let_header_MARK(void *p, struct NewGC *gc) {
  Scheme_Let_Header *h = (Scheme_Let_Header *)p;
  
  gcMARK2(h->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Header));
}

static int let_header_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Let_Header *h = (Scheme_Let_Header *)p;
  
  gcFIXUP2(h->body, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Header));
}

#define let_header_IS_ATOMIC 0
#define let_header_IS_CONST_SIZE 1


static int prim_proc_SIZE(void *p, struct NewGC *gc) {
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  return
  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - 1)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
}

static int prim_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  gcMARK2(prim->name, gc);
  if (prim->mina < 0) {
    gcMARK2(prim->mu.cases, gc);
  }
  if (prim->pp.flags & SCHEME_PRIM_IS_CLOSURE) {
    Scheme_Primitive_Closure *cc = (Scheme_Primitive_Closure *)prim;
    int i;
    for (i = cc->count; i--; ) {
      gcMARK2(cc->val[i], gc);
    }
  }  
  
  return
  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - 1)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
}

static int prim_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  gcFIXUP2(prim->name, gc);
  if (prim->mina < 0) {
    gcFIXUP2(prim->mu.cases, gc);
  }
  if (prim->pp.flags & SCHEME_PRIM_IS_CLOSURE) {
    Scheme_Primitive_Closure *cc = (Scheme_Primitive_Closure *)prim;
    int i;
    for (i = cc->count; i--; ) {
      gcFIXUP2(cc->val[i], gc);
    }
  }  
  
  return
  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - 1)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
}

#define prim_proc_IS_ATOMIC 0
#define prim_proc_IS_CONST_SIZE 0


static int closed_prim_proc_SIZE(void *p, struct NewGC *gc) {
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  return
  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
}

static int closed_prim_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  gcMARK2(c->name, gc);
  gcMARK2(SCHEME_CLSD_PRIM_DATA(c), gc);
  if (c->mina == -2) {
    gcMARK2(((Scheme_Closed_Case_Primitive_Proc *)c)->cases, gc);
  }
  
  return
  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
}

static int closed_prim_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  gcFIXUP2(c->name, gc);
  gcFIXUP2(SCHEME_CLSD_PRIM_DATA(c), gc);
  if (c->mina == -2) {
    gcFIXUP2(((Scheme_Closed_Case_Primitive_Proc *)c)->cases, gc);
  }
  
  return
  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
}

#define closed_prim_proc_IS_ATOMIC 0
#define closed_prim_proc_IS_CONST_SIZE 0


static int scm_closure_SIZE(void *p, struct NewGC *gc) {
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = (c->code 
                      ? ((Scheme_Closure_Data *)GC_resolve(c->code))->closure_size
                      : 0);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

static int scm_closure_MARK(void *p, struct NewGC *gc) {
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = (c->code 
                      ? ((Scheme_Closure_Data *)GC_resolve(c->code))->closure_size
                      : 0);


  int i = closure_size;
  while (i--)
    gcMARK2(c->vals[i], gc);
  gcMARK2(c->code, gc);
  
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

static int scm_closure_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = (c->code 
                      ? ((Scheme_Closure_Data *)GC_resolve(c->code))->closure_size
                      : 0);


  int i = closure_size;
  while (i--)
    gcFIXUP2(c->vals[i], gc);
  gcFIXUP2(c->code, gc);
  
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

#define scm_closure_IS_ATOMIC 0
#define scm_closure_IS_CONST_SIZE 0


static int case_closure_SIZE(void *p, struct NewGC *gc) {
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - 1) * sizeof(Scheme_Object *))));
}

static int case_closure_MARK(void *p, struct NewGC *gc) {
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  int i;
  
  for (i = c->count; i--; )
    gcMARK2(c->array[i], gc);
  gcMARK2(c->name, gc);
#ifdef MZ_USE_JIT
  gcMARK2(c->native_code, gc);
#endif

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - 1) * sizeof(Scheme_Object *))));
}

static int case_closure_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  int i;
  
  for (i = c->count; i--; )
    gcFIXUP2(c->array[i], gc);
  gcFIXUP2(c->name, gc);
#ifdef MZ_USE_JIT
  gcFIXUP2(c->native_code, gc);
#endif

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - 1) * sizeof(Scheme_Object *))));
}

#define case_closure_IS_ATOMIC 0
#define case_closure_IS_CONST_SIZE 0


static int cont_proc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
}

static int cont_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Cont *c = (Scheme_Cont *)p;
  
  gcMARK2(c->dw, gc);
  gcMARK2(c->prompt_tag, gc);
  gcMARK2(c->meta_continuation, gc);
  gcMARK2(c->common_dw, gc);
  gcMARK2(c->save_overflow, gc);
  gcMARK2(c->runstack_copied, gc);
  gcMARK2(c->runstack_owner, gc);
  gcMARK2(c->cont_mark_stack_copied, gc);
  gcMARK2(c->cont_mark_stack_owner, gc);
  gcMARK2(c->init_config, gc);
  gcMARK2(c->init_break_cell, gc);
#ifdef MZ_USE_JIT
  gcMARK2(c->native_trace, gc);
#endif

  MARK_jmpup(&c->buf, gc);
  MARK_cjs(&c->cjs, gc);
  MARK_stack_state(&c->ss, gc);
  gcMARK2(c->barrier_prompt, gc);
  if (!GC_merely_accounting()) {
    gcMARK2(c->runstack_start, gc);
    gcMARK2(c->runstack_saved, gc);
  }

  gcMARK2(c->prompt_id, gc);
  gcMARK2(c->prompt_buf, gc);

  gcMARK2(c->escape_cont, gc);

  gcMARK2(c->value, gc);
  gcMARK2(c->resume_to, gc);
  gcMARK2(c->use_next_cont, gc);
  gcMARK2(c->extra_marks, gc);
  gcMARK2(c->shortcut_prompt, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
}

static int cont_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Cont *c = (Scheme_Cont *)p;
  
  gcFIXUP2(c->dw, gc);
  gcFIXUP2(c->prompt_tag, gc);
  gcFIXUP2(c->meta_continuation, gc);
  gcFIXUP2(c->common_dw, gc);
  gcFIXUP2(c->save_overflow, gc);
  gcFIXUP2(c->runstack_copied, gc);
  gcFIXUP2(c->runstack_owner, gc);
  gcFIXUP2(c->cont_mark_stack_copied, gc);
  gcFIXUP2(c->cont_mark_stack_owner, gc);
  gcFIXUP2(c->init_config, gc);
  gcFIXUP2(c->init_break_cell, gc);
#ifdef MZ_USE_JIT
  gcFIXUP2(c->native_trace, gc);
#endif

  FIXUP_jmpup(&c->buf, gc);
  FIXUP_cjs(&c->cjs, gc);
  FIXUP_stack_state(&c->ss, gc);
  gcFIXUP2(c->barrier_prompt, gc);
  if (!GC_merely_accounting()) {
    gcFIXUP2(c->runstack_start, gc);
    gcFIXUP2(c->runstack_saved, gc);
  }

  gcFIXUP2(c->prompt_id, gc);
  gcFIXUP2(c->prompt_buf, gc);

  gcFIXUP2(c->escape_cont, gc);

  gcFIXUP2(c->value, gc);
  gcFIXUP2(c->resume_to, gc);
  gcFIXUP2(c->use_next_cont, gc);
  gcFIXUP2(c->extra_marks, gc);
  gcFIXUP2(c->shortcut_prompt, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
}

#define cont_proc_IS_ATOMIC 0
#define cont_proc_IS_CONST_SIZE 1


static int meta_cont_proc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Meta_Continuation));
}

static int meta_cont_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Meta_Continuation *c = (Scheme_Meta_Continuation *)p;
  
  gcMARK2(c->prompt_tag, gc);
  gcMARK2(c->overflow, gc);
  gcMARK2(c->next, gc);
  gcMARK2(c->cont_mark_stack_copied, gc);
  gcMARK2(c->cont, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Meta_Continuation));
}

static int meta_cont_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Meta_Continuation *c = (Scheme_Meta_Continuation *)p;
  
  gcFIXUP2(c->prompt_tag, gc);
  gcFIXUP2(c->overflow, gc);
  gcFIXUP2(c->next, gc);
  gcFIXUP2(c->cont_mark_stack_copied, gc);
  gcFIXUP2(c->cont, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Meta_Continuation));
}

#define meta_cont_proc_IS_ATOMIC 0
#define meta_cont_proc_IS_CONST_SIZE 1


static int mark_dyn_wind_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
}

static int mark_dyn_wind_MARK(void *p, struct NewGC *gc) {
  Scheme_Dynamic_Wind *dw = (Scheme_Dynamic_Wind *)p;
  
  gcMARK2(dw->id, gc);
  gcMARK2(dw->data, gc);
  gcMARK2(dw->prompt_tag, gc);
  gcMARK2(dw->prev, gc);
    
  MARK_stack_state(&dw->envss, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
}

static int mark_dyn_wind_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Dynamic_Wind *dw = (Scheme_Dynamic_Wind *)p;
  
  gcFIXUP2(dw->id, gc);
  gcFIXUP2(dw->data, gc);
  gcFIXUP2(dw->prompt_tag, gc);
  gcFIXUP2(dw->prev, gc);
    
  FIXUP_stack_state(&dw->envss, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
}

#define mark_dyn_wind_IS_ATOMIC 0
#define mark_dyn_wind_IS_CONST_SIZE 1


static int mark_overflow_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
}

static int mark_overflow_MARK(void *p, struct NewGC *gc) {
  Scheme_Overflow *o = (Scheme_Overflow *)p;

  gcMARK2(o->prev, gc);
  gcMARK2(o->jmp, gc);
  gcMARK2(o->id, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
}

static int mark_overflow_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Overflow *o = (Scheme_Overflow *)p;

  gcFIXUP2(o->prev, gc);
  gcFIXUP2(o->jmp, gc);
  gcFIXUP2(o->id, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
}

#define mark_overflow_IS_ATOMIC 0
#define mark_overflow_IS_CONST_SIZE 1


static int mark_overflow_jmp_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow_Jmp));
}

static int mark_overflow_jmp_MARK(void *p, struct NewGC *gc) {
  Scheme_Overflow_Jmp *o = (Scheme_Overflow_Jmp *)p;

  MARK_jmpup(&o->cont, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow_Jmp));
}

static int mark_overflow_jmp_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Overflow_Jmp *o = (Scheme_Overflow_Jmp *)p;

  FIXUP_jmpup(&o->cont, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow_Jmp));
}

#define mark_overflow_jmp_IS_ATOMIC 0
#define mark_overflow_jmp_IS_CONST_SIZE 1


static int escaping_cont_proc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
}

static int escaping_cont_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Escaping_Cont *c = (Scheme_Escaping_Cont *)p;

#ifdef MZ_USE_JIT
  gcMARK2(c->native_trace, gc);
#endif

  gcMARK2(c->barrier_prompt, gc);
  MARK_stack_state(&c->envss, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
}

static int escaping_cont_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Escaping_Cont *c = (Scheme_Escaping_Cont *)p;

#ifdef MZ_USE_JIT
  gcFIXUP2(c->native_trace, gc);
#endif

  gcFIXUP2(c->barrier_prompt, gc);
  FIXUP_stack_state(&c->envss, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
}

#define escaping_cont_proc_IS_ATOMIC 0
#define escaping_cont_proc_IS_CONST_SIZE 1


static int char_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int char_obj_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int char_obj_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

#define char_obj_IS_ATOMIC 1
#define char_obj_IS_CONST_SIZE 1


static int bignum_obj_SIZE(void *p, struct NewGC *gc) {
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  return
  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
}

static int bignum_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  if (!SCHEME_BIGINLINE(b)) {
    gcMARK2(b->digits, gc);
  } else {
    
  }

  return
  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
}

static int bignum_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  if (!SCHEME_BIGINLINE(b)) {
    gcFIXUP2(b->digits, gc);
  } else {
    b->digits = ((Small_Bignum *)GC_fixup_self(b))->v;
  }

  return
  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
}

#define bignum_obj_IS_ATOMIC 0
#define bignum_obj_IS_CONST_SIZE 0


static int rational_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
}

static int rational_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Rational *r = (Scheme_Rational *)p;
  
  gcMARK2(r->num, gc);
  gcMARK2(r->denom, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
}

static int rational_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Rational *r = (Scheme_Rational *)p;
  
  gcFIXUP2(r->num, gc);
  gcFIXUP2(r->denom, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
}

#define rational_obj_IS_ATOMIC 0
#define rational_obj_IS_CONST_SIZE 1


static int float_obj_SIZE(void *p, struct NewGC *gc) {
  return
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
}

static int float_obj_MARK(void *p, struct NewGC *gc) {
  return
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
}

static int float_obj_FIXUP(void *p, struct NewGC *gc) {
  return
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
}

#define float_obj_IS_ATOMIC 1
#define float_obj_IS_CONST_SIZE 0


static int double_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
}

static int double_obj_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
}

static int double_obj_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
}

#define double_obj_IS_ATOMIC 1
#define double_obj_IS_CONST_SIZE 1


static int complex_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
}

static int complex_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Complex *c = (Scheme_Complex *)p;
  
  gcMARK2(c->r, gc);
  gcMARK2(c->i, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
}

static int complex_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Complex *c = (Scheme_Complex *)p;
  
  gcFIXUP2(c->r, gc);
  gcFIXUP2(c->i, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
}

#define complex_obj_IS_ATOMIC 0
#define complex_obj_IS_CONST_SIZE 1


static int string_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int string_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcMARK2(SCHEME_CHAR_STR_VAL(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int string_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcFIXUP2(SCHEME_CHAR_STR_VAL(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define string_obj_IS_ATOMIC 0
#define string_obj_IS_CONST_SIZE 1


static int bstring_obj_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int bstring_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcMARK2(SCHEME_BYTE_STR_VAL(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int bstring_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcFIXUP2(SCHEME_BYTE_STR_VAL(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define bstring_obj_IS_ATOMIC 0
#define bstring_obj_IS_CONST_SIZE 1


static int symbol_obj_SIZE(void *p, struct NewGC *gc) {
  Scheme_Symbol *s = (Scheme_Symbol *)p;

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + s->len - 3);
}

static int symbol_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Symbol *s = (Scheme_Symbol *)p;

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + s->len - 3);
}

static int symbol_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Symbol *s = (Scheme_Symbol *)p;

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + s->len - 3);
}

#define symbol_obj_IS_ATOMIC 1
#define symbol_obj_IS_CONST_SIZE 0


static int cons_cell_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int cons_cell_MARK(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  
  gcMARK2(SCHEME_CAR(o), gc);
  gcMARK2(SCHEME_CDR(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int cons_cell_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;
  
  gcFIXUP2(SCHEME_CAR(o), gc);
  gcFIXUP2(SCHEME_CDR(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define cons_cell_IS_ATOMIC 0
#define cons_cell_IS_CONST_SIZE 1


static int vector_obj_SIZE(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - 1) * sizeof(Scheme_Object *))));
}

static int vector_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  int i;
  for (i = vec->size; i--; )
    gcMARK2(vec->els[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - 1) * sizeof(Scheme_Object *))));
}

static int vector_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  int i;
  for (i = vec->size; i--; )
    gcFIXUP2(vec->els[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - 1) * sizeof(Scheme_Object *))));
}

#define vector_obj_IS_ATOMIC 0
#define vector_obj_IS_CONST_SIZE 0


static int fxvector_obj_SIZE(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - 1) * sizeof(Scheme_Object *))));
}

static int fxvector_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - 1) * sizeof(Scheme_Object *))));
}

static int fxvector_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - 1) * sizeof(Scheme_Object *))));
}

#define fxvector_obj_IS_ATOMIC 1
#define fxvector_obj_IS_CONST_SIZE 0


static int flvector_obj_SIZE(void *p, struct NewGC *gc) {
  Scheme_Double_Vector *vec = (Scheme_Double_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Double_Vector) 
		    + ((vec->size - 1) * sizeof(double))));
}

static int flvector_obj_MARK(void *p, struct NewGC *gc) {
  Scheme_Double_Vector *vec = (Scheme_Double_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Double_Vector) 
		    + ((vec->size - 1) * sizeof(double))));
}

static int flvector_obj_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Double_Vector *vec = (Scheme_Double_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Double_Vector) 
		    + ((vec->size - 1) * sizeof(double))));
}

#define flvector_obj_IS_ATOMIC 1
#define flvector_obj_IS_CONST_SIZE 0


static int input_port_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
}

static int input_port_MARK(void *p, struct NewGC *gc) {
  Scheme_Input_Port *ip = (Scheme_Input_Port *)p;
  
  gcMARK2(ip->sub_type, gc);
  gcMARK2(ip->port_data, gc);
  gcMARK2(ip->name, gc);
  gcMARK2(ip->peeked_read, gc);
  gcMARK2(ip->peeked_write, gc);
  gcMARK2(ip->read_handler, gc);
  gcMARK2(ip->mref, gc);
  gcMARK2(ip->output_half, gc);
  gcMARK2(ip->special, gc);
  gcMARK2(ip->ungotten_special, gc);
  gcMARK2(ip->progress_evt, gc);
  gcMARK2(ip->input_lock, gc);
  gcMARK2(ip->input_giveup, gc);
  gcMARK2(ip->input_extras, gc);
  gcMARK2(ip->input_extras_ready, gc);
  gcMARK2(ip->unless, gc);
  gcMARK2(ip->unless_cache, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
}

static int input_port_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Input_Port *ip = (Scheme_Input_Port *)p;
  
  gcFIXUP2(ip->sub_type, gc);
  gcFIXUP2(ip->port_data, gc);
  gcFIXUP2(ip->name, gc);
  gcFIXUP2(ip->peeked_read, gc);
  gcFIXUP2(ip->peeked_write, gc);
  gcFIXUP2(ip->read_handler, gc);
  gcFIXUP2(ip->mref, gc);
  gcFIXUP2(ip->output_half, gc);
  gcFIXUP2(ip->special, gc);
  gcFIXUP2(ip->ungotten_special, gc);
  gcFIXUP2(ip->progress_evt, gc);
  gcFIXUP2(ip->input_lock, gc);
  gcFIXUP2(ip->input_giveup, gc);
  gcFIXUP2(ip->input_extras, gc);
  gcFIXUP2(ip->input_extras_ready, gc);
  gcFIXUP2(ip->unless, gc);
  gcFIXUP2(ip->unless_cache, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
}

#define input_port_IS_ATOMIC 0
#define input_port_IS_CONST_SIZE 1


static int output_port_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
}

static int output_port_MARK(void *p, struct NewGC *gc) {
  Scheme_Output_Port *op = (Scheme_Output_Port *)p;

  gcMARK2(op->sub_type, gc);
  gcMARK2(op->port_data, gc);
  gcMARK2(op->name, gc);
  gcMARK2(op->display_handler, gc);
  gcMARK2(op->write_handler, gc);
  gcMARK2(op->print_handler, gc);
  gcMARK2(op->mref, gc);
  gcMARK2(op->input_half, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
}

static int output_port_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Output_Port *op = (Scheme_Output_Port *)p;

  gcFIXUP2(op->sub_type, gc);
  gcFIXUP2(op->port_data, gc);
  gcFIXUP2(op->name, gc);
  gcFIXUP2(op->display_handler, gc);
  gcFIXUP2(op->write_handler, gc);
  gcFIXUP2(op->print_handler, gc);
  gcFIXUP2(op->mref, gc);
  gcFIXUP2(op->input_half, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
}

#define output_port_IS_ATOMIC 0
#define output_port_IS_CONST_SIZE 1



static int syntax_compiler_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int syntax_compiler_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int syntax_compiler_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define syntax_compiler_IS_ATOMIC 1
#define syntax_compiler_IS_CONST_SIZE 1


static int thread_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
}

static int thread_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Thread *pr = (Scheme_Thread *)p;
  
  gcMARK2(pr->next, gc);
  gcMARK2(pr->prev, gc);

  gcMARK2(pr->t_set_parent, gc);
  gcMARK2(pr->t_set_next, gc);
  gcMARK2(pr->t_set_prev, gc);

  MARK_cjs(&pr->cjs, gc);
  gcMARK2(pr->decompose_mc, gc);

  gcMARK2(pr->cell_values, gc);
  gcMARK2(pr->init_config, gc);
  gcMARK2(pr->init_break_cell, gc);

  if (!pr->runstack_owner
      || !GC_merely_accounting()
      || (*pr->runstack_owner == pr)) {
    Scheme_Object **rs = pr->runstack_start;
    gcMARK2( pr->runstack_start, gc);
    if (pr->runstack != pr->runstack_start + (pr->runstack - rs))
      pr->runstack = pr->runstack_start + (pr->runstack - rs);

    gcMARK2(pr->runstack_saved, gc);
  }
  gcMARK2(pr->runstack_owner, gc);
  gcMARK2(pr->runstack_swapped, gc);
  pr->spare_runstack = NULL; /* just in case */

  gcMARK2(pr->meta_prompt, gc);
  gcMARK2(pr->meta_continuation, gc);
  
  gcMARK2(pr->cont_mark_stack_segments, gc);
  gcMARK2(pr->cont_mark_stack_owner, gc);
  gcMARK2(pr->cont_mark_stack_swapped, gc);

  MARK_jmpup(&pr->jmpup_buf, gc);
  
  gcMARK2(pr->dw, gc);
  
  gcMARK2(pr->nester, gc);
  gcMARK2(pr->nestee, gc);

  gcMARK2(pr->current_ft, gc);
  
  gcMARK2(pr->blocker, gc);
  gcMARK2(pr->overflow, gc);

  gcMARK2(pr->return_marks_to, gc);
  gcMARK2(pr->returned_marks, gc);
  
  gcMARK2(pr->current_local_env, gc);
  gcMARK2(pr->current_local_mark, gc);
  gcMARK2(pr->current_local_name, gc);
  gcMARK2(pr->current_local_certs, gc);
  gcMARK2(pr->current_local_modidx, gc);
  gcMARK2(pr->current_local_menv, gc);
  gcMARK2(pr->current_local_bindings, gc);

  gcMARK2(pr->current_mt, gc);

  gcMARK2(pr->constant_folding, gc);
  gcMARK2(pr->reading_delayed, gc);
  
  gcMARK2(pr->overflow_reply, gc);

  gcMARK2(pr->values_buffer, gc);

  gcMARK2(pr->tail_buffer, gc);
  
  gcMARK2(pr->ku.eval.wait_expr, gc);

  gcMARK2(pr->ku.apply.tail_rator, gc);
  gcMARK2(pr->ku.apply.tail_rands, gc);

  gcMARK2(pr->ku.multiple.array, gc);

  gcMARK2(pr->ku.k.p1, gc);
  gcMARK2(pr->ku.k.p2, gc);
  gcMARK2(pr->ku.k.p3, gc);
  gcMARK2(pr->ku.k.p4, gc);
  gcMARK2(pr->ku.k.p5, gc);
  
  gcMARK2(pr->list_stack, gc);
  
  gcMARK2(pr->kill_data, gc);
  gcMARK2(pr->private_kill_data, gc);
  gcMARK2(pr->private_kill_next, gc);
  
  gcMARK2(pr->user_tls, gc);
  gcMARK2(pr->gmp_tls_data, gc);
  
  gcMARK2(pr->mr_hop, gc);
  gcMARK2(pr->mref, gc);
  gcMARK2(pr->extra_mrefs, gc);

  gcMARK2(pr->name, gc);

  gcMARK2(pr->transitive_resumes, gc);

  gcMARK2(pr->suspended_box, gc);
  gcMARK2(pr->resumed_box, gc);
  gcMARK2(pr->dead_box, gc);
  gcMARK2(pr->running_box, gc);

  gcMARK2(pr->mbox_first, gc);
  gcMARK2(pr->mbox_last, gc);
  gcMARK2(pr->mbox_sema, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
}

static int thread_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Thread *pr = (Scheme_Thread *)p;
  
  gcFIXUP2(pr->next, gc);
  gcFIXUP2(pr->prev, gc);

  gcFIXUP2(pr->t_set_parent, gc);
  gcFIXUP2(pr->t_set_next, gc);
  gcFIXUP2(pr->t_set_prev, gc);

  FIXUP_cjs(&pr->cjs, gc);
  gcFIXUP2(pr->decompose_mc, gc);

  gcFIXUP2(pr->cell_values, gc);
  gcFIXUP2(pr->init_config, gc);
  gcFIXUP2(pr->init_break_cell, gc);

  if (!pr->runstack_owner
      || !GC_merely_accounting()
      || (*pr->runstack_owner == pr)) {
    Scheme_Object **rs = pr->runstack_start;
    gcFIXUP2_TYPED_NOW(Scheme_Object **, pr->runstack_start, gc);
    if (pr->runstack != pr->runstack_start + (pr->runstack - rs))
      pr->runstack = pr->runstack_start + (pr->runstack - rs);

    gcFIXUP2(pr->runstack_saved, gc);
  }
  gcFIXUP2(pr->runstack_owner, gc);
  gcFIXUP2(pr->runstack_swapped, gc);
  pr->spare_runstack = NULL; /* just in case */

  gcFIXUP2(pr->meta_prompt, gc);
  gcFIXUP2(pr->meta_continuation, gc);
  
  gcFIXUP2(pr->cont_mark_stack_segments, gc);
  gcFIXUP2(pr->cont_mark_stack_owner, gc);
  gcFIXUP2(pr->cont_mark_stack_swapped, gc);

  FIXUP_jmpup(&pr->jmpup_buf, gc);
  
  gcFIXUP2(pr->dw, gc);
  
  gcFIXUP2(pr->nester, gc);
  gcFIXUP2(pr->nestee, gc);

  gcFIXUP2(pr->current_ft, gc);
  
  gcFIXUP2(pr->blocker, gc);
  gcFIXUP2(pr->overflow, gc);

  gcFIXUP2(pr->return_marks_to, gc);
  gcFIXUP2(pr->returned_marks, gc);
  
  gcFIXUP2(pr->current_local_env, gc);
  gcFIXUP2(pr->current_local_mark, gc);
  gcFIXUP2(pr->current_local_name, gc);
  gcFIXUP2(pr->current_local_certs, gc);
  gcFIXUP2(pr->current_local_modidx, gc);
  gcFIXUP2(pr->current_local_menv, gc);
  gcFIXUP2(pr->current_local_bindings, gc);

  gcFIXUP2(pr->current_mt, gc);

  gcFIXUP2(pr->constant_folding, gc);
  gcFIXUP2(pr->reading_delayed, gc);
  
  gcFIXUP2(pr->overflow_reply, gc);

  gcFIXUP2(pr->values_buffer, gc);

  gcFIXUP2(pr->tail_buffer, gc);
  
  gcFIXUP2(pr->ku.eval.wait_expr, gc);

  gcFIXUP2(pr->ku.apply.tail_rator, gc);
  gcFIXUP2(pr->ku.apply.tail_rands, gc);

  gcFIXUP2(pr->ku.multiple.array, gc);

  gcFIXUP2(pr->ku.k.p1, gc);
  gcFIXUP2(pr->ku.k.p2, gc);
  gcFIXUP2(pr->ku.k.p3, gc);
  gcFIXUP2(pr->ku.k.p4, gc);
  gcFIXUP2(pr->ku.k.p5, gc);
  
  gcFIXUP2(pr->list_stack, gc);
  
  gcFIXUP2(pr->kill_data, gc);
  gcFIXUP2(pr->private_kill_data, gc);
  gcFIXUP2(pr->private_kill_next, gc);
  
  gcFIXUP2(pr->user_tls, gc);
  gcFIXUP2(pr->gmp_tls_data, gc);
  
  gcFIXUP2(pr->mr_hop, gc);
  gcFIXUP2(pr->mref, gc);
  gcFIXUP2(pr->extra_mrefs, gc);

  gcFIXUP2(pr->name, gc);

  gcFIXUP2(pr->transitive_resumes, gc);

  gcFIXUP2(pr->suspended_box, gc);
  gcFIXUP2(pr->resumed_box, gc);
  gcFIXUP2(pr->dead_box, gc);
  gcFIXUP2(pr->running_box, gc);

  gcFIXUP2(pr->mbox_first, gc);
  gcFIXUP2(pr->mbox_last, gc);
  gcFIXUP2(pr->mbox_sema, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
}

#define thread_val_IS_ATOMIC 0
#define thread_val_IS_CONST_SIZE 1


static int runstack_val_SIZE(void *p, struct NewGC *gc) {
  long *s = (long *)p;
  return
  s[1];
}

static int runstack_val_MARK(void *p, struct NewGC *gc) {
  long *s = (long *)p;
  void **a, **b;
  a = (void **)s + 4 + s[2];
  b = (void **)s + 4 + s[3];
  while (a < b) {
    gcMARK2(*a, gc);
    a++;
  }
  return
  s[1];
}

static int runstack_val_FIXUP(void *p, struct NewGC *gc) {
  long *s = (long *)p;
  void **a, **b;
  a = (void **)s + 4 + s[2];
  b = (void **)s + 4 + s[3];
  while (a < b) {
    gcFIXUP2(*a, gc);
    a++;
  }

  /* Zero out the part that we didn't mark, in case it becomes
     live later. */
  a = (void **)s + 4;
  b = (void **)s + 4 + s[2];
  while (a < b) {
    *a = RUNSTACK_ZERO_VAL;
    a++;
  }
  a = (void **)s + 4 + s[3];
  b = (void **)s + 4 + (s[1] - 4);
  while (a < b) {
    *a = RUNSTACK_ZERO_VAL;
    a++;
  }
  return
  s[1];
}

#define runstack_val_IS_ATOMIC 0
#define runstack_val_IS_CONST_SIZE 0


static int prompt_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Prompt));
}

static int prompt_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Prompt *pr = (Scheme_Prompt *)p;
  gcMARK2(pr->boundary_overflow_id, gc);
  if (!GC_merely_accounting())
    gcMARK2(pr->runstack_boundary_start, gc);
  gcMARK2(pr->tag, gc);
  gcMARK2(pr->id, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Prompt));
}

static int prompt_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Prompt *pr = (Scheme_Prompt *)p;
  gcFIXUP2(pr->boundary_overflow_id, gc);
  if (!GC_merely_accounting())
    gcFIXUP2(pr->runstack_boundary_start, gc);
  gcFIXUP2(pr->tag, gc);
  gcFIXUP2(pr->id, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Prompt));
}

#define prompt_val_IS_ATOMIC 0
#define prompt_val_IS_CONST_SIZE 1


static int cont_mark_set_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
}

static int cont_mark_set_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Cont_Mark_Set *s = (Scheme_Cont_Mark_Set *)p;
  gcMARK2(s->chain, gc);
  gcMARK2(s->native_stack_trace, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
}

static int cont_mark_set_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Cont_Mark_Set *s = (Scheme_Cont_Mark_Set *)p;
  gcFIXUP2(s->chain, gc);
  gcFIXUP2(s->native_stack_trace, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
}

#define cont_mark_set_val_IS_ATOMIC 0
#define cont_mark_set_val_IS_CONST_SIZE 1


static int sema_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
}

static int sema_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Sema *s = (Scheme_Sema *)p;

  gcMARK2(s->first, gc);
  gcMARK2(s->last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
}

static int sema_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Sema *s = (Scheme_Sema *)p;

  gcFIXUP2(s->first, gc);
  gcFIXUP2(s->last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
}

#define sema_val_IS_ATOMIC 0
#define sema_val_IS_CONST_SIZE 1


static int channel_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
}

static int channel_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Channel *s = (Scheme_Channel *)p;

  gcMARK2(s->get_first, gc);
  gcMARK2(s->get_last, gc);
  gcMARK2(s->put_first, gc);
  gcMARK2(s->put_last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
}

static int channel_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Channel *s = (Scheme_Channel *)p;

  gcFIXUP2(s->get_first, gc);
  gcFIXUP2(s->get_last, gc);
  gcFIXUP2(s->put_first, gc);
  gcFIXUP2(s->put_last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
}

#define channel_val_IS_ATOMIC 0
#define channel_val_IS_CONST_SIZE 1


static int channel_put_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
}

static int channel_put_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Channel_Put *s = (Scheme_Channel_Put *)p;

  gcMARK2(s->ch, gc);
  gcMARK2(s->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
}

static int channel_put_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Channel_Put *s = (Scheme_Channel_Put *)p;

  gcFIXUP2(s->ch, gc);
  gcFIXUP2(s->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
}

#define channel_put_val_IS_ATOMIC 0
#define channel_put_val_IS_CONST_SIZE 1


static int hash_table_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
}

static int hash_table_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Hash_Table *ht = (Scheme_Hash_Table *)p;

  gcMARK2(ht->keys, gc);
  gcMARK2(ht->vals, gc);
  gcMARK2(ht->mutex, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
}

static int hash_table_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Hash_Table *ht = (Scheme_Hash_Table *)p;

  gcFIXUP2(ht->keys, gc);
  gcFIXUP2(ht->vals, gc);
  gcFIXUP2(ht->mutex, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
}

#define hash_table_val_IS_ATOMIC 0
#define hash_table_val_IS_CONST_SIZE 1


static int bucket_table_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
}

static int bucket_table_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Bucket_Table *ht = (Scheme_Bucket_Table *)p;

  gcMARK2(ht->buckets, gc);
  gcMARK2(ht->mutex, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
}

static int bucket_table_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Bucket_Table *ht = (Scheme_Bucket_Table *)p;

  gcFIXUP2(ht->buckets, gc);
  gcFIXUP2(ht->mutex, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
}

#define bucket_table_val_IS_ATOMIC 0
#define bucket_table_val_IS_CONST_SIZE 1


static int namespace_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
}

static int namespace_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Env *e = (Scheme_Env *)p;

  gcMARK2(e->module, gc);
  gcMARK2(e->module_registry, gc);
  gcMARK2(e->insp, gc);

  gcMARK2(e->rename_set, gc);
  gcMARK2(e->temp_marked_names, gc);
  gcMARK2(e->post_ex_rename_set, gc);

  gcMARK2(e->syntax, gc);
  gcMARK2(e->exp_env, gc);
  gcMARK2(e->template_env, gc);
  gcMARK2(e->label_env, gc);

  gcMARK2(e->shadowed_syntax, gc);

  gcMARK2(e->link_midx, gc);
  gcMARK2(e->require_names, gc);
  gcMARK2(e->et_require_names, gc);
  gcMARK2(e->tt_require_names, gc);
  gcMARK2(e->dt_require_names, gc);
  gcMARK2(e->other_require_names, gc);
  gcMARK2(e->did_starts, gc);
  gcMARK2(e->available_next[0], gc);
  gcMARK2(e->available_next[1], gc);

  gcMARK2(e->toplevel, gc);
  gcMARK2(e->modchain, gc);

  gcMARK2(e->modvars, gc);


  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
}

static int namespace_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Env *e = (Scheme_Env *)p;

  gcFIXUP2(e->module, gc);
  gcFIXUP2(e->module_registry, gc);
  gcFIXUP2(e->insp, gc);

  gcFIXUP2(e->rename_set, gc);
  gcFIXUP2(e->temp_marked_names, gc);
  gcFIXUP2(e->post_ex_rename_set, gc);

  gcFIXUP2(e->syntax, gc);
  gcFIXUP2(e->exp_env, gc);
  gcFIXUP2(e->template_env, gc);
  gcFIXUP2(e->label_env, gc);

  gcFIXUP2(e->shadowed_syntax, gc);

  gcFIXUP2(e->link_midx, gc);
  gcFIXUP2(e->require_names, gc);
  gcFIXUP2(e->et_require_names, gc);
  gcFIXUP2(e->tt_require_names, gc);
  gcFIXUP2(e->dt_require_names, gc);
  gcFIXUP2(e->other_require_names, gc);
  gcFIXUP2(e->did_starts, gc);
  gcFIXUP2(e->available_next[0], gc);
  gcFIXUP2(e->available_next[1], gc);

  gcFIXUP2(e->toplevel, gc);
  gcFIXUP2(e->modchain, gc);

  gcFIXUP2(e->modvars, gc);


  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
}

#define namespace_val_IS_ATOMIC 0
#define namespace_val_IS_CONST_SIZE 1


static int module_reg_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Registry));
}

static int module_reg_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Module_Registry *r = (Scheme_Module_Registry *)p;
  gcMARK2(r->loaded, gc);
  gcMARK2(r->exports, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Registry));
}

static int module_reg_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Module_Registry *r = (Scheme_Module_Registry *)p;
  gcFIXUP2(r->loaded, gc);
  gcFIXUP2(r->exports, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Registry));
}

#define module_reg_val_IS_ATOMIC 0
#define module_reg_val_IS_CONST_SIZE 1


static int random_state_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
}

static int random_state_val_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
}

static int random_state_val_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
}

#define random_state_val_IS_ATOMIC 1
#define random_state_val_IS_CONST_SIZE 1


static int compilation_top_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compilation_Top));
}

static int compilation_top_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Compilation_Top *t = (Scheme_Compilation_Top *)p;
  gcMARK2(t->code, gc);
  gcMARK2(t->prefix, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compilation_Top));
}

static int compilation_top_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Compilation_Top *t = (Scheme_Compilation_Top *)p;
  gcFIXUP2(t->code, gc);
  gcFIXUP2(t->prefix, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compilation_Top));
}

#define compilation_top_val_IS_ATOMIC 0
#define compilation_top_val_IS_CONST_SIZE 1


static int resolve_prefix_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Prefix));
}

static int resolve_prefix_val_MARK(void *p, struct NewGC *gc) {
  Resolve_Prefix *rp = (Resolve_Prefix *)p;
  gcMARK2(rp->toplevels, gc);
  gcMARK2(rp->stxes, gc);
  gcMARK2(rp->delay_info_rpair, gc);
  gcMARK2(rp->uses_unsafe, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Prefix));
}

static int resolve_prefix_val_FIXUP(void *p, struct NewGC *gc) {
  Resolve_Prefix *rp = (Resolve_Prefix *)p;
  gcFIXUP2(rp->toplevels, gc);
  gcFIXUP2(rp->stxes, gc);
  gcFIXUP2(rp->delay_info_rpair, gc);
  gcFIXUP2(rp->uses_unsafe, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Prefix));
}

#define resolve_prefix_val_IS_ATOMIC 0
#define resolve_prefix_val_IS_CONST_SIZE 1


static int comp_prefix_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Comp_Prefix));
}

static int comp_prefix_val_MARK(void *p, struct NewGC *gc) {
  Comp_Prefix *cp = (Comp_Prefix *)p;
  gcMARK2(cp->toplevels, gc);
  gcMARK2(cp->stxes, gc);
  gcMARK2(cp->uses_unsafe, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Comp_Prefix));
}

static int comp_prefix_val_FIXUP(void *p, struct NewGC *gc) {
  Comp_Prefix *cp = (Comp_Prefix *)p;
  gcFIXUP2(cp->toplevels, gc);
  gcFIXUP2(cp->stxes, gc);
  gcFIXUP2(cp->uses_unsafe, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Comp_Prefix));
}

#define comp_prefix_val_IS_ATOMIC 0
#define comp_prefix_val_IS_CONST_SIZE 1


static int svector_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int svector_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;

  gcMARK2(SCHEME_SVEC_VEC(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int svector_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Object *o = (Scheme_Object *)p;

  gcFIXUP2(SCHEME_SVEC_VEC(o), gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define svector_val_IS_ATOMIC 0
#define svector_val_IS_CONST_SIZE 1


static int stx_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
}

static int stx_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Stx *stx = (Scheme_Stx *)p;
  gcMARK2(stx->val, gc);
  gcMARK2(stx->srcloc, gc);
  gcMARK2(stx->wraps, gc);
  gcMARK2(stx->certs, gc);
  gcMARK2(stx->props, gc);
  if (!(MZ_OPT_HASH_KEY(&(stx)->iso) & STX_SUBSTX_FLAG))
    gcMARK2(stx->u.modinfo_cache, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
}

static int stx_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Stx *stx = (Scheme_Stx *)p;
  gcFIXUP2(stx->val, gc);
  gcFIXUP2(stx->srcloc, gc);
  gcFIXUP2(stx->wraps, gc);
  gcFIXUP2(stx->certs, gc);
  gcFIXUP2(stx->props, gc);
  if (!(MZ_OPT_HASH_KEY(&(stx)->iso) & STX_SUBSTX_FLAG))
    gcFIXUP2(stx->u.modinfo_cache, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
}

#define stx_val_IS_ATOMIC 0
#define stx_val_IS_CONST_SIZE 1


static int stx_off_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Offset));
}

static int stx_off_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Stx_Offset *o = (Scheme_Stx_Offset *)p;
  gcMARK2(o->src, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Offset));
}

static int stx_off_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Stx_Offset *o = (Scheme_Stx_Offset *)p;
  gcFIXUP2(o->src, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Offset));
}

#define stx_off_val_IS_ATOMIC 0
#define stx_off_val_IS_CONST_SIZE 1


static int module_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module));
}

static int module_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Module *m = (Scheme_Module *)p;
  gcMARK2(m->modname, gc);
  gcMARK2(m->modsrc, gc);

  gcMARK2(m->et_requires, gc);
  gcMARK2(m->requires, gc);
  gcMARK2(m->tt_requires, gc);
  gcMARK2(m->dt_requires, gc);
  gcMARK2(m->other_requires, gc);

  gcMARK2(m->body, gc);
  gcMARK2(m->et_body, gc);

  gcMARK2(m->me, gc);

  gcMARK2(m->provide_protects, gc);
  gcMARK2(m->indirect_provides, gc);

  gcMARK2(m->indirect_syntax_provides, gc);

  gcMARK2(m->et_provide_protects, gc);
  gcMARK2(m->et_indirect_provides, gc);

  gcMARK2(m->self_modidx, gc);

  gcMARK2(m->accessible, gc);
  gcMARK2(m->et_accessible, gc);

  gcMARK2(m->insp, gc);

  gcMARK2(m->lang_info, gc);

  gcMARK2(m->hints, gc);
  gcMARK2(m->ii_src, gc);

  gcMARK2(m->comp_prefix, gc);
  gcMARK2(m->prefix, gc);
  gcMARK2(m->dummy, gc);

  gcMARK2(m->rn_stx, gc);

  gcMARK2(m->primitive, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module));
}

static int module_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Module *m = (Scheme_Module *)p;
  gcFIXUP2(m->modname, gc);
  gcFIXUP2(m->modsrc, gc);

  gcFIXUP2(m->et_requires, gc);
  gcFIXUP2(m->requires, gc);
  gcFIXUP2(m->tt_requires, gc);
  gcFIXUP2(m->dt_requires, gc);
  gcFIXUP2(m->other_requires, gc);

  gcFIXUP2(m->body, gc);
  gcFIXUP2(m->et_body, gc);

  gcFIXUP2(m->me, gc);

  gcFIXUP2(m->provide_protects, gc);
  gcFIXUP2(m->indirect_provides, gc);

  gcFIXUP2(m->indirect_syntax_provides, gc);

  gcFIXUP2(m->et_provide_protects, gc);
  gcFIXUP2(m->et_indirect_provides, gc);

  gcFIXUP2(m->self_modidx, gc);

  gcFIXUP2(m->accessible, gc);
  gcFIXUP2(m->et_accessible, gc);

  gcFIXUP2(m->insp, gc);

  gcFIXUP2(m->lang_info, gc);

  gcFIXUP2(m->hints, gc);
  gcFIXUP2(m->ii_src, gc);

  gcFIXUP2(m->comp_prefix, gc);
  gcFIXUP2(m->prefix, gc);
  gcFIXUP2(m->dummy, gc);

  gcFIXUP2(m->rn_stx, gc);

  gcFIXUP2(m->primitive, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module));
}

#define module_val_IS_ATOMIC 0
#define module_val_IS_CONST_SIZE 1


static int module_phase_exports_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Phase_Exports));
}

static int module_phase_exports_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Module_Phase_Exports *m = (Scheme_Module_Phase_Exports *)p;

  gcMARK2(m->phase_index, gc);

  gcMARK2(m->src_modidx, gc);

  gcMARK2(m->provides, gc);
  gcMARK2(m->provide_srcs, gc);
  gcMARK2(m->provide_src_names, gc);
  gcMARK2(m->provide_nominal_srcs, gc);
  gcMARK2(m->provide_src_phases, gc);
  gcMARK2(m->provide_insps, gc);

  gcMARK2(m->kernel_exclusion, gc);
  gcMARK2(m->kernel_exclusion2, gc);

  gcMARK2(m->ht, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Phase_Exports));
}

static int module_phase_exports_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Module_Phase_Exports *m = (Scheme_Module_Phase_Exports *)p;

  gcFIXUP2(m->phase_index, gc);

  gcFIXUP2(m->src_modidx, gc);

  gcFIXUP2(m->provides, gc);
  gcFIXUP2(m->provide_srcs, gc);
  gcFIXUP2(m->provide_src_names, gc);
  gcFIXUP2(m->provide_nominal_srcs, gc);
  gcFIXUP2(m->provide_src_phases, gc);
  gcFIXUP2(m->provide_insps, gc);

  gcFIXUP2(m->kernel_exclusion, gc);
  gcFIXUP2(m->kernel_exclusion2, gc);

  gcFIXUP2(m->ht, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Phase_Exports));
}

#define module_phase_exports_val_IS_ATOMIC 0
#define module_phase_exports_val_IS_CONST_SIZE 1


static int module_exports_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Exports));
}

static int module_exports_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Module_Exports *m = (Scheme_Module_Exports *)p;

  gcMARK2(m->rt, gc);
  gcMARK2(m->et, gc);
  gcMARK2(m->dt, gc);
  gcMARK2(m->other_phases, gc);

  gcMARK2(m->src_modidx, gc);
  gcMARK2(m->modsrc, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Exports));
}

static int module_exports_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Module_Exports *m = (Scheme_Module_Exports *)p;

  gcFIXUP2(m->rt, gc);
  gcFIXUP2(m->et, gc);
  gcFIXUP2(m->dt, gc);
  gcFIXUP2(m->other_phases, gc);

  gcFIXUP2(m->src_modidx, gc);
  gcFIXUP2(m->modsrc, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Exports));
}

#define module_exports_val_IS_ATOMIC 0
#define module_exports_val_IS_CONST_SIZE 1


static int modidx_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Modidx));
}

static int modidx_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Modidx *modidx = (Scheme_Modidx *)p;

  gcMARK2(modidx->path, gc);
  gcMARK2(modidx->base, gc);
  gcMARK2(modidx->resolved, gc);
  gcMARK2(modidx->shift_cache, gc);
  gcMARK2(modidx->cache_next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Modidx));
}

static int modidx_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Modidx *modidx = (Scheme_Modidx *)p;

  gcFIXUP2(modidx->path, gc);
  gcFIXUP2(modidx->base, gc);
  gcFIXUP2(modidx->resolved, gc);
  gcFIXUP2(modidx->shift_cache, gc);
  gcFIXUP2(modidx->cache_next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Modidx));
}

#define modidx_val_IS_ATOMIC 0
#define modidx_val_IS_CONST_SIZE 1


static int guard_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
}

static int guard_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Security_Guard *g = (Scheme_Security_Guard *)p;

  gcMARK2(g->parent, gc);
  gcMARK2(g->file_proc, gc);
  gcMARK2(g->network_proc, gc);
  gcMARK2(g->link_proc, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
}

static int guard_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Security_Guard *g = (Scheme_Security_Guard *)p;

  gcFIXUP2(g->parent, gc);
  gcFIXUP2(g->file_proc, gc);
  gcFIXUP2(g->network_proc, gc);
  gcFIXUP2(g->link_proc, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
}

#define guard_val_IS_ATOMIC 0
#define guard_val_IS_CONST_SIZE 1


static int buf_holder_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
}

static int buf_holder_MARK(void *p, struct NewGC *gc) {
  Scheme_Jumpup_Buf_Holder *h = (Scheme_Jumpup_Buf_Holder *)p;
 
  MARK_jmpup(&h->buf, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
}

static int buf_holder_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Jumpup_Buf_Holder *h = (Scheme_Jumpup_Buf_Holder *)p;
 
  FIXUP_jmpup(&h->buf, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
}

#define buf_holder_IS_ATOMIC 0
#define buf_holder_IS_CONST_SIZE 1


static int mark_inspector_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
}

static int mark_inspector_MARK(void *p, struct NewGC *gc) {
  Scheme_Inspector *i = (Scheme_Inspector *)p;
  gcMARK2(i->superior, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
}

static int mark_inspector_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Inspector *i = (Scheme_Inspector *)p;
  gcFIXUP2(i->superior, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
}

#define mark_inspector_IS_ATOMIC 0
#define mark_inspector_IS_CONST_SIZE 1


static int mark_pipe_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
}

static int mark_pipe_MARK(void *p, struct NewGC *gc) {
  Scheme_Pipe *pp = (Scheme_Pipe *)p;
    
  gcMARK2(pp->buf, gc);
  gcMARK2(pp->wakeup_on_read, gc);
  gcMARK2(pp->wakeup_on_write, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
}

static int mark_pipe_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Pipe *pp = (Scheme_Pipe *)p;
    
  gcFIXUP2(pp->buf, gc);
  gcFIXUP2(pp->wakeup_on_read, gc);
  gcFIXUP2(pp->wakeup_on_write, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
}

#define mark_pipe_IS_ATOMIC 0
#define mark_pipe_IS_CONST_SIZE 1


static int mark_logger_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Logger));
}

static int mark_logger_MARK(void *p, struct NewGC *gc) {
  Scheme_Logger *l = (Scheme_Logger *)p;
  gcMARK2(l->name, gc);
  gcMARK2(l->parent, gc);
  gcMARK2(l->readers, gc);
  gcMARK2(l->timestamp, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Logger));
}

static int mark_logger_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Logger *l = (Scheme_Logger *)p;
  gcFIXUP2(l->name, gc);
  gcFIXUP2(l->parent, gc);
  gcFIXUP2(l->readers, gc);
  gcFIXUP2(l->timestamp, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Logger));
}

#define mark_logger_IS_ATOMIC 0
#define mark_logger_IS_CONST_SIZE 1


static int mark_log_reader_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Log_Reader));
}

static int mark_log_reader_MARK(void *p, struct NewGC *gc) {
  Scheme_Log_Reader *lr = (Scheme_Log_Reader *)p;
  gcMARK2(lr->sema, gc);
  gcMARK2(lr->head, gc);
  gcMARK2(lr->tail, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Log_Reader));
}

static int mark_log_reader_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Log_Reader *lr = (Scheme_Log_Reader *)p;
  gcFIXUP2(lr->sema, gc);
  gcFIXUP2(lr->head, gc);
  gcFIXUP2(lr->tail, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Log_Reader));
}

#define mark_log_reader_IS_ATOMIC 0
#define mark_log_reader_IS_CONST_SIZE 1


#endif  /* TYPE */

/**********************************************************************/

#ifdef MARKS_FOR_ENGINE_C

static int engine_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Engine));
}

static int engine_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Engine *en = (Scheme_Engine *)p;
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Engine));
}

static int engine_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Engine *en = (Scheme_Engine *)p;
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Engine));
}

#define engine_val_IS_ATOMIC 0
#define engine_val_IS_CONST_SIZE 1


#endif  /* ENGINE */

#ifdef MARKS_FOR_ENV_C

static int mark_comp_env_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Full_Comp_Env));
}

static int mark_comp_env_MARK(void *p, struct NewGC *gc) {
  Scheme_Full_Comp_Env *e = (Scheme_Full_Comp_Env *)p;

  gcMARK2(e->base.genv, gc);
  gcMARK2(e->base.insp, gc);
  gcMARK2(e->base.prefix, gc);
  gcMARK2(e->base.next, gc);
  gcMARK2(e->base.values, gc);
  gcMARK2(e->base.certs, gc);
  gcMARK2(e->base.renames, gc);
  gcMARK2(e->base.uid, gc);
  gcMARK2(e->base.uids, gc);
  gcMARK2(e->base.dup_check, gc);
  gcMARK2(e->base.intdef_name, gc);
  gcMARK2(e->base.in_modidx, gc);
  gcMARK2(e->base.skip_table, gc);
  
  gcMARK2(e->data.const_names, gc);
  gcMARK2(e->data.const_vals, gc);
  gcMARK2(e->data.const_uids, gc);
  gcMARK2(e->data.sealed, gc);
  gcMARK2(e->data.use, gc);
  gcMARK2(e->data.lifts, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Full_Comp_Env));
}

static int mark_comp_env_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Full_Comp_Env *e = (Scheme_Full_Comp_Env *)p;

  gcFIXUP2(e->base.genv, gc);
  gcFIXUP2(e->base.insp, gc);
  gcFIXUP2(e->base.prefix, gc);
  gcFIXUP2(e->base.next, gc);
  gcFIXUP2(e->base.values, gc);
  gcFIXUP2(e->base.certs, gc);
  gcFIXUP2(e->base.renames, gc);
  gcFIXUP2(e->base.uid, gc);
  gcFIXUP2(e->base.uids, gc);
  gcFIXUP2(e->base.dup_check, gc);
  gcFIXUP2(e->base.intdef_name, gc);
  gcFIXUP2(e->base.in_modidx, gc);
  gcFIXUP2(e->base.skip_table, gc);
  
  gcFIXUP2(e->data.const_names, gc);
  gcFIXUP2(e->data.const_vals, gc);
  gcFIXUP2(e->data.const_uids, gc);
  gcFIXUP2(e->data.sealed, gc);
  gcFIXUP2(e->data.use, gc);
  gcFIXUP2(e->data.lifts, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Full_Comp_Env));
}

#define mark_comp_env_IS_ATOMIC 0
#define mark_comp_env_IS_CONST_SIZE 1


static int mark_resolve_info_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Info));
}

static int mark_resolve_info_MARK(void *p, struct NewGC *gc) {
  Resolve_Info *i = (Resolve_Info *)p;
  
  gcMARK2(i->prefix, gc);
  gcMARK2(i->stx_map, gc);
  gcMARK2(i->old_pos, gc);
  gcMARK2(i->new_pos, gc);
  gcMARK2(i->old_stx_pos, gc);
  gcMARK2(i->flags, gc);
  gcMARK2(i->lifts, gc);
  gcMARK2(i->lifted, gc);
  gcMARK2(i->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Info));
}

static int mark_resolve_info_FIXUP(void *p, struct NewGC *gc) {
  Resolve_Info *i = (Resolve_Info *)p;
  
  gcFIXUP2(i->prefix, gc);
  gcFIXUP2(i->stx_map, gc);
  gcFIXUP2(i->old_pos, gc);
  gcFIXUP2(i->new_pos, gc);
  gcFIXUP2(i->old_stx_pos, gc);
  gcFIXUP2(i->flags, gc);
  gcFIXUP2(i->lifts, gc);
  gcFIXUP2(i->lifted, gc);
  gcFIXUP2(i->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Info));
}

#define mark_resolve_info_IS_ATOMIC 0
#define mark_resolve_info_IS_CONST_SIZE 1


static int mark_optimize_info_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Optimize_Info));
}

static int mark_optimize_info_MARK(void *p, struct NewGC *gc) {
  Optimize_Info *i = (Optimize_Info *)p;
  
  gcMARK2(i->stat_dists, gc);
  gcMARK2(i->sd_depths, gc);
  gcMARK2(i->next, gc);
  gcMARK2(i->use, gc);
  gcMARK2(i->consts, gc);
  gcMARK2(i->top_level_consts, gc);
  gcMARK2(i->transitive_use, gc);
  gcMARK2(i->transitive_use_len, gc);
  gcMARK2(i->context, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Optimize_Info));
}

static int mark_optimize_info_FIXUP(void *p, struct NewGC *gc) {
  Optimize_Info *i = (Optimize_Info *)p;
  
  gcFIXUP2(i->stat_dists, gc);
  gcFIXUP2(i->sd_depths, gc);
  gcFIXUP2(i->next, gc);
  gcFIXUP2(i->use, gc);
  gcFIXUP2(i->consts, gc);
  gcFIXUP2(i->top_level_consts, gc);
  gcFIXUP2(i->transitive_use, gc);
  gcFIXUP2(i->transitive_use_len, gc);
  gcFIXUP2(i->context, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Optimize_Info));
}

#define mark_optimize_info_IS_ATOMIC 0
#define mark_optimize_info_IS_CONST_SIZE 1


static int mark_sfs_info_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(SFS_Info));
}

static int mark_sfs_info_MARK(void *p, struct NewGC *gc) {
  SFS_Info *i = (SFS_Info *)p;
  
  gcMARK2(i->max_used, gc);
  gcMARK2(i->max_calls, gc);
  gcMARK2(i->saved, gc);

  return
  gcBYTES_TO_WORDS(sizeof(SFS_Info));
}

static int mark_sfs_info_FIXUP(void *p, struct NewGC *gc) {
  SFS_Info *i = (SFS_Info *)p;
  
  gcFIXUP2(i->max_used, gc);
  gcFIXUP2(i->max_calls, gc);
  gcFIXUP2(i->saved, gc);

  return
  gcBYTES_TO_WORDS(sizeof(SFS_Info));
}

#define mark_sfs_info_IS_ATOMIC 0
#define mark_sfs_info_IS_CONST_SIZE 1


static int mark_once_used_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Once_Used));
}

static int mark_once_used_MARK(void *p, struct NewGC *gc) {
  Scheme_Once_Used *o = (Scheme_Once_Used *)p;
  gcMARK2(o->expr, gc);
  gcMARK2(o->info, gc);
  gcMARK2(o->next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Once_Used));
}

static int mark_once_used_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Once_Used *o = (Scheme_Once_Used *)p;
  gcFIXUP2(o->expr, gc);
  gcFIXUP2(o->info, gc);
  gcFIXUP2(o->next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Once_Used));
}

#define mark_once_used_IS_ATOMIC 0
#define mark_once_used_IS_CONST_SIZE 1


#endif  /* ENV */

/**********************************************************************/

#ifdef MARKS_FOR_EVAL_C

static int mark_comp_info_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compile_Info));
}

static int mark_comp_info_MARK(void *p, struct NewGC *gc) {
  Scheme_Compile_Info *i = (Scheme_Compile_Info *)p;
  
  gcMARK2(i->value_name, gc);
  gcMARK2(i->certs, gc);
  gcMARK2(i->observer, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compile_Info));
}

static int mark_comp_info_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Compile_Info *i = (Scheme_Compile_Info *)p;
  
  gcFIXUP2(i->value_name, gc);
  gcFIXUP2(i->certs, gc);
  gcFIXUP2(i->observer, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compile_Info));
}

#define mark_comp_info_IS_ATOMIC 0
#define mark_comp_info_IS_CONST_SIZE 1


static int mark_saved_stack_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Saved_Stack));
}

static int mark_saved_stack_MARK(void *p, struct NewGC *gc) {
  Scheme_Saved_Stack *saved = (Scheme_Saved_Stack *)p;
  
  gcMARK2(saved->prev, gc);
  gcMARK2(saved->runstack_start, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Saved_Stack));
}

static int mark_saved_stack_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Saved_Stack *saved = (Scheme_Saved_Stack *)p;
  
  gcFIXUP2(saved->prev, gc);
  gcFIXUP2(saved->runstack_start, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Saved_Stack));
}

#define mark_saved_stack_IS_ATOMIC 0
#define mark_saved_stack_IS_CONST_SIZE 1


static int mark_validate_clearing_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Validate_Clearing));
}

static int mark_validate_clearing_MARK(void *p, struct NewGC *gc) {
  Validate_Clearing *vc = (Validate_Clearing *)p;
  
  gcMARK2(vc->stack, gc);
  gcMARK2(vc->ncstack, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Validate_Clearing));
}

static int mark_validate_clearing_FIXUP(void *p, struct NewGC *gc) {
  Validate_Clearing *vc = (Validate_Clearing *)p;
  
  gcFIXUP2(vc->stack, gc);
  gcFIXUP2(vc->ncstack, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Validate_Clearing));
}

#define mark_validate_clearing_IS_ATOMIC 0
#define mark_validate_clearing_IS_CONST_SIZE 1


#endif  /* EVAL */

/**********************************************************************/

#ifdef MARKS_FOR_FILE_C

static int mark_reply_item_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(ReplyItem));
}

static int mark_reply_item_MARK(void *p, struct NewGC *gc) {
  ReplyItem *r = (ReplyItem *)p;
  
  gcMARK2(r->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(ReplyItem));
}

static int mark_reply_item_FIXUP(void *p, struct NewGC *gc) {
  ReplyItem *r = (ReplyItem *)p;
  
  gcFIXUP2(r->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(ReplyItem));
}

#define mark_reply_item_IS_ATOMIC 0
#define mark_reply_item_IS_CONST_SIZE 1


#endif  /* FILE */

/**********************************************************************/

#ifdef MARKS_FOR_FUN_C

static int mark_closure_info_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Closure_Info));
}

static int mark_closure_info_MARK(void *p, struct NewGC *gc) {
  Closure_Info *i = (Closure_Info *)p;
  
  gcMARK2(i->local_flags, gc);
  gcMARK2(i->base_closure_map, gc);
  gcMARK2(i->flonum_map, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Closure_Info));
}

static int mark_closure_info_FIXUP(void *p, struct NewGC *gc) {
  Closure_Info *i = (Closure_Info *)p;
  
  gcFIXUP2(i->local_flags, gc);
  gcFIXUP2(i->base_closure_map, gc);
  gcFIXUP2(i->flonum_map, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Closure_Info));
}

#define mark_closure_info_IS_ATOMIC 0
#define mark_closure_info_IS_CONST_SIZE 1


static int mark_dyn_wind_cell_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind_List));
}

static int mark_dyn_wind_cell_MARK(void *p, struct NewGC *gc) {
  Scheme_Dynamic_Wind_List *l = (Scheme_Dynamic_Wind_List *)p;
  
  gcMARK2(l->dw, gc);
  gcMARK2(l->next, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind_List));
}

static int mark_dyn_wind_cell_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Dynamic_Wind_List *l = (Scheme_Dynamic_Wind_List *)p;
  
  gcFIXUP2(l->dw, gc);
  gcFIXUP2(l->next, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind_List));
}

#define mark_dyn_wind_cell_IS_ATOMIC 0
#define mark_dyn_wind_cell_IS_CONST_SIZE 1


static int mark_dyn_wind_info_SIZE(void *p, struct NewGC *gc) {
  return
   gcBYTES_TO_WORDS(sizeof(Dyn_Wind));
}

static int mark_dyn_wind_info_MARK(void *p, struct NewGC *gc) {
  Dyn_Wind *d = (Dyn_Wind *)p;
  
  gcMARK2(d->pre, gc);
  gcMARK2(d->act, gc);
  gcMARK2(d->post, gc);

  return
   gcBYTES_TO_WORDS(sizeof(Dyn_Wind));
}

static int mark_dyn_wind_info_FIXUP(void *p, struct NewGC *gc) {
  Dyn_Wind *d = (Dyn_Wind *)p;
  
  gcFIXUP2(d->pre, gc);
  gcFIXUP2(d->act, gc);
  gcFIXUP2(d->post, gc);

  return
   gcBYTES_TO_WORDS(sizeof(Dyn_Wind));
}

#define mark_dyn_wind_info_IS_ATOMIC 0
#define mark_dyn_wind_info_IS_CONST_SIZE 1


static int mark_cont_mark_chain_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Chain));
}

static int mark_cont_mark_chain_MARK(void *p, struct NewGC *gc) {
  Scheme_Cont_Mark_Chain *c = (Scheme_Cont_Mark_Chain *)p;
  
  gcMARK2(c->key, gc);
  gcMARK2(c->val, gc);
  gcMARK2(c->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Chain));
}

static int mark_cont_mark_chain_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Cont_Mark_Chain *c = (Scheme_Cont_Mark_Chain *)p;
  
  gcFIXUP2(c->key, gc);
  gcFIXUP2(c->val, gc);
  gcFIXUP2(c->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Chain));
}

#define mark_cont_mark_chain_IS_ATOMIC 0
#define mark_cont_mark_chain_IS_CONST_SIZE 1


#ifdef MZ_USE_JIT

static int mark_lightweight_cont_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Lightweight_Continuation));
}

static int mark_lightweight_cont_MARK(void *p, struct NewGC *gc) {
  Scheme_Lightweight_Continuation *lw = (Scheme_Lightweight_Continuation *)p;

  gcMARK2(lw->saved_lwc, gc);
  gcMARK2(lw->stack_slice, gc);
  gcMARK2(lw->runstack_slice, gc);
  gcMARK2(lw->cont_mark_stack_slice, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Lightweight_Continuation));
}

static int mark_lightweight_cont_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Lightweight_Continuation *lw = (Scheme_Lightweight_Continuation *)p;

  gcFIXUP2(lw->saved_lwc, gc);
  gcFIXUP2(lw->stack_slice, gc);
  gcFIXUP2(lw->runstack_slice, gc);
  gcFIXUP2(lw->cont_mark_stack_slice, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Lightweight_Continuation));
}

#define mark_lightweight_cont_IS_ATOMIC 0
#define mark_lightweight_cont_IS_CONST_SIZE 1


#endif

#endif  /* FUN */

/**********************************************************************/

#ifdef MARKS_FOR_HASH_C

static int hash_tree_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Tree));
}

static int hash_tree_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Hash_Tree *ht = (Scheme_Hash_Tree *)p;

  gcMARK2(ht->root, gc);
  gcMARK2(ht->elems_box, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Tree));
}

static int hash_tree_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Hash_Tree *ht = (Scheme_Hash_Tree *)p;

  gcFIXUP2(ht->root, gc);
  gcFIXUP2(ht->elems_box, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Tree));
}

#define hash_tree_val_IS_ATOMIC 0
#define hash_tree_val_IS_CONST_SIZE 1


static int mark_rb_node_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(RBNode));
}

static int mark_rb_node_MARK(void *p, struct NewGC *gc) {
  RBNode *rb = (RBNode *)p;

  /* Short-circuit on NULL pointers, which are especially likely */
  if (rb->left) {
    gcMARK2(rb->left, gc);
  }
  if (rb->right) {
    gcMARK2(rb->right, gc);
  }
  gcMARK2(rb->key, gc);
  gcMARK2(rb->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(RBNode));
}

static int mark_rb_node_FIXUP(void *p, struct NewGC *gc) {
  RBNode *rb = (RBNode *)p;

  /* Short-circuit on NULL pointers, which are especially likely */
  if (rb->left) {
    gcFIXUP2(rb->left, gc);
  }
  if (rb->right) {
    gcFIXUP2(rb->right, gc);
  }
  gcFIXUP2(rb->key, gc);
  gcFIXUP2(rb->val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(RBNode));
}

#define mark_rb_node_IS_ATOMIC 0
#define mark_rb_node_IS_CONST_SIZE 1


#endif  /* HASH */

/**********************************************************************/

#ifdef MARKS_FOR_PLACES_C

static int place_bi_channel_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Bi_Channel));
}

static int place_bi_channel_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Place_Bi_Channel *pbc = (Scheme_Place_Bi_Channel *)p;
  gcMARK2(pbc->sendch, gc);
  gcMARK2(pbc->recvch, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Bi_Channel));
}

static int place_bi_channel_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Place_Bi_Channel *pbc = (Scheme_Place_Bi_Channel *)p;
  gcFIXUP2(pbc->sendch, gc);
  gcFIXUP2(pbc->recvch, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Bi_Channel));
}

#define place_bi_channel_val_IS_ATOMIC 0
#define place_bi_channel_val_IS_CONST_SIZE 1


static int place_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place));
}

static int place_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Place *pr = (Scheme_Place *)p;
  gcMARK2(pr->channel, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place));
}

static int place_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Place *pr = (Scheme_Place *)p;
  gcFIXUP2(pr->channel, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place));
}

#define place_val_IS_ATOMIC 0
#define place_val_IS_CONST_SIZE 1


static int place_async_channel_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Async_Channel));
}

static int place_async_channel_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Place_Async_Channel *pac = (Scheme_Place_Async_Channel *)p;
  int i;
  gcMARK2(pac->msgs, gc);
  gcMARK2(pac->msg_memory, gc);
  for (i = pac->size; i--; )
    gcMARK2(pac->msgs[i], gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Async_Channel));
}

static int place_async_channel_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Place_Async_Channel *pac = (Scheme_Place_Async_Channel *)p;
  int i;
  gcFIXUP2(pac->msgs, gc);
  gcFIXUP2(pac->msg_memory, gc);
  for (i = pac->size; i--; )
    gcFIXUP2(pac->msgs[i], gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Async_Channel));
}

#define place_async_channel_val_IS_ATOMIC 0
#define place_async_channel_val_IS_CONST_SIZE 1


#endif  /* PLACES */

/**********************************************************************/

#ifdef MARKS_FOR_PORTFUN_C

static int mark_load_handler_data_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(LoadHandlerData));
}

static int mark_load_handler_data_MARK(void *p, struct NewGC *gc) {
  LoadHandlerData *d = (LoadHandlerData *)p;
    
  gcMARK2(d->config, gc);
  gcMARK2(d->port, gc);
  gcMARK2(d->p, gc);
  gcMARK2(d->stxsrc, gc);
  gcMARK2(d->expected_module, gc);
  gcMARK2(d->delay_load_info, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(LoadHandlerData));
}

static int mark_load_handler_data_FIXUP(void *p, struct NewGC *gc) {
  LoadHandlerData *d = (LoadHandlerData *)p;
    
  gcFIXUP2(d->config, gc);
  gcFIXUP2(d->port, gc);
  gcFIXUP2(d->p, gc);
  gcFIXUP2(d->stxsrc, gc);
  gcFIXUP2(d->expected_module, gc);
  gcFIXUP2(d->delay_load_info, gc);
  
  return
  gcBYTES_TO_WORDS(sizeof(LoadHandlerData));
}

#define mark_load_handler_data_IS_ATOMIC 0
#define mark_load_handler_data_IS_CONST_SIZE 1


static int mark_indexed_string_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indexed_String));
}

static int mark_indexed_string_MARK(void *p, struct NewGC *gc) {
  Scheme_Indexed_String *is = (Scheme_Indexed_String *)p;
    
  gcMARK2(is->string, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indexed_String));
}

static int mark_indexed_string_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Indexed_String *is = (Scheme_Indexed_String *)p;
    
  gcFIXUP2(is->string, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indexed_String));
}

#define mark_indexed_string_IS_ATOMIC 0
#define mark_indexed_string_IS_CONST_SIZE 1


static int mark_user_input_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(User_Input_Port));
}

static int mark_user_input_MARK(void *p, struct NewGC *gc) {
  User_Input_Port *uip = (User_Input_Port *)p;

  gcMARK2(uip->read_proc, gc);
  gcMARK2(uip->peek_proc, gc);
  gcMARK2(uip->progress_evt_proc, gc);
  gcMARK2(uip->peeked_read_proc, gc);
  gcMARK2(uip->location_proc, gc);
  gcMARK2(uip->count_lines_proc, gc);
  gcMARK2(uip->buffer_mode_proc, gc);
  gcMARK2(uip->close_proc, gc);
  gcMARK2(uip->reuse_str, gc);
  gcMARK2(uip->peeked, gc);
  gcMARK2(uip->prefix_pipe, gc);
  return
  gcBYTES_TO_WORDS(sizeof(User_Input_Port));
}

static int mark_user_input_FIXUP(void *p, struct NewGC *gc) {
  User_Input_Port *uip = (User_Input_Port *)p;

  gcFIXUP2(uip->read_proc, gc);
  gcFIXUP2(uip->peek_proc, gc);
  gcFIXUP2(uip->progress_evt_proc, gc);
  gcFIXUP2(uip->peeked_read_proc, gc);
  gcFIXUP2(uip->location_proc, gc);
  gcFIXUP2(uip->count_lines_proc, gc);
  gcFIXUP2(uip->buffer_mode_proc, gc);
  gcFIXUP2(uip->close_proc, gc);
  gcFIXUP2(uip->reuse_str, gc);
  gcFIXUP2(uip->peeked, gc);
  gcFIXUP2(uip->prefix_pipe, gc);
  return
  gcBYTES_TO_WORDS(sizeof(User_Input_Port));
}

#define mark_user_input_IS_ATOMIC 0
#define mark_user_input_IS_CONST_SIZE 1


static int mark_user_output_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(User_Output_Port));
}

static int mark_user_output_MARK(void *p, struct NewGC *gc) {
  User_Output_Port *uop = (User_Output_Port *)p;

  gcMARK2(uop->evt, gc);
  gcMARK2(uop->write_evt_proc, gc);
  gcMARK2(uop->write_proc, gc);
  gcMARK2(uop->write_special_evt_proc, gc);
  gcMARK2(uop->write_special_proc, gc);
  gcMARK2(uop->location_proc, gc);
  gcMARK2(uop->count_lines_proc, gc);
  gcMARK2(uop->buffer_mode_proc, gc);
  gcMARK2(uop->close_proc, gc);
  gcMARK2(uop->buffer_pipe, gc);
  return
  gcBYTES_TO_WORDS(sizeof(User_Output_Port));
}

static int mark_user_output_FIXUP(void *p, struct NewGC *gc) {
  User_Output_Port *uop = (User_Output_Port *)p;

  gcFIXUP2(uop->evt, gc);
  gcFIXUP2(uop->write_evt_proc, gc);
  gcFIXUP2(uop->write_proc, gc);
  gcFIXUP2(uop->write_special_evt_proc, gc);
  gcFIXUP2(uop->write_special_proc, gc);
  gcFIXUP2(uop->location_proc, gc);
  gcFIXUP2(uop->count_lines_proc, gc);
  gcFIXUP2(uop->buffer_mode_proc, gc);
  gcFIXUP2(uop->close_proc, gc);
  gcFIXUP2(uop->buffer_pipe, gc);
  return
  gcBYTES_TO_WORDS(sizeof(User_Output_Port));
}

#define mark_user_output_IS_ATOMIC 0
#define mark_user_output_IS_CONST_SIZE 1


#endif  /* PORTFUN */

/**********************************************************************/

#ifdef MARKS_FOR_PORT_C

#ifdef WINDOWS_PROCESSES
static int mark_thread_memory_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Memory));
}

static int mark_thread_memory_MARK(void *p, struct NewGC *gc) {
  Scheme_Thread_Memory *tm = (Scheme_Thread_Memory *)p;
  gcMARK2(tm->prev, gc);
  gcMARK2(tm->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Memory));
}

static int mark_thread_memory_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Thread_Memory *tm = (Scheme_Thread_Memory *)p;
  gcFIXUP2(tm->prev, gc);
  gcFIXUP2(tm->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Memory));
}

#define mark_thread_memory_IS_ATOMIC 0
#define mark_thread_memory_IS_CONST_SIZE 1

#endif

static int mark_input_file_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_File));
}

static int mark_input_file_MARK(void *p, struct NewGC *gc) {
  Scheme_Input_File *i = (Scheme_Input_File *)p;

  gcMARK2(i->f, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_File));
}

static int mark_input_file_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Input_File *i = (Scheme_Input_File *)p;

  gcFIXUP2(i->f, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_File));
}

#define mark_input_file_IS_ATOMIC 0
#define mark_input_file_IS_CONST_SIZE 1


static int mark_output_file_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_File));
}

static int mark_output_file_MARK(void *p, struct NewGC *gc) {
  Scheme_Output_File *o = (Scheme_Output_File *)p;

  gcMARK2(o->f, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_File));
}

static int mark_output_file_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Output_File *o = (Scheme_Output_File *)p;

  gcFIXUP2(o->f, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_File));
}

#define mark_output_file_IS_ATOMIC 0
#define mark_output_file_IS_CONST_SIZE 1


#ifdef MZ_FDS
static int mark_input_fd_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_FD));
}

static int mark_input_fd_MARK(void *p, struct NewGC *gc) {
  Scheme_FD *fd = (Scheme_FD *)p;

  gcMARK2(fd->buffer, gc);
  gcMARK2(fd->refcount, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_FD));
}

static int mark_input_fd_FIXUP(void *p, struct NewGC *gc) {
  Scheme_FD *fd = (Scheme_FD *)p;

  gcFIXUP2(fd->buffer, gc);
  gcFIXUP2(fd->refcount, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_FD));
}

#define mark_input_fd_IS_ATOMIC 0
#define mark_input_fd_IS_CONST_SIZE 1

#endif

#if defined(UNIX_PROCESSES) && !(defined(MZ_USE_PLACES) && defined(MZ_PRECISE_GC))
static int mark_system_child_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(System_Child));
}

static int mark_system_child_MARK(void *p, struct NewGC *gc) {
  System_Child *sc = (System_Child *)p;

  gcMARK2(sc->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(System_Child));
}

static int mark_system_child_FIXUP(void *p, struct NewGC *gc) {
  System_Child *sc = (System_Child *)p;

  gcFIXUP2(sc->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(System_Child));
}

#define mark_system_child_IS_ATOMIC 0
#define mark_system_child_IS_CONST_SIZE 1

#endif

#ifdef USE_OSKIT_CONSOLE
static int mark_oskit_console_input_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(osk_console_input));
}

static int mark_oskit_console_input_MARK(void *p, struct NewGC *gc) {
  osk_console_input *c = (osk_console_input *)p;
    
  gcMARK2(c->buffer, gc);
  gcMARK2(c->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(osk_console_input));
}

static int mark_oskit_console_input_FIXUP(void *p, struct NewGC *gc) {
  osk_console_input *c = (osk_console_input *)p;
    
  gcFIXUP2(c->buffer, gc);
  gcFIXUP2(c->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(osk_console_input));
}

#define mark_oskit_console_input_IS_ATOMIC 0
#define mark_oskit_console_input_IS_CONST_SIZE 1

#endif

static int mark_subprocess_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Subprocess));
}

static int mark_subprocess_MARK(void *p, struct NewGC *gc) {
#ifndef WINDOWS_PROCESSES
  Scheme_Subprocess *sp = (Scheme_Subprocess *)p;
  gcMARK2(sp->handle, gc);
  gcMARK2(sp->mref, gc);
#endif
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Subprocess));
}

static int mark_subprocess_FIXUP(void *p, struct NewGC *gc) {
#ifndef WINDOWS_PROCESSES
  Scheme_Subprocess *sp = (Scheme_Subprocess *)p;
  gcFIXUP2(sp->handle, gc);
  gcFIXUP2(sp->mref, gc);
#endif
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Subprocess));
}

#define mark_subprocess_IS_ATOMIC 0
#define mark_subprocess_IS_CONST_SIZE 1


static int mark_read_write_evt_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Read_Write_Evt));
}

static int mark_read_write_evt_MARK(void *p, struct NewGC *gc) {
  Scheme_Read_Write_Evt *rww = (Scheme_Read_Write_Evt *)p;
  gcMARK2(rww->port, gc);
  gcMARK2(rww->v, gc);
  gcMARK2(rww->str, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Read_Write_Evt));
}

static int mark_read_write_evt_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Read_Write_Evt *rww = (Scheme_Read_Write_Evt *)p;
  gcFIXUP2(rww->port, gc);
  gcFIXUP2(rww->v, gc);
  gcFIXUP2(rww->str, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Read_Write_Evt));
}

#define mark_read_write_evt_IS_ATOMIC 0
#define mark_read_write_evt_IS_CONST_SIZE 1


#endif  /* PORT */

/**********************************************************************/

#ifdef MARKS_FOR_PRINT_C

static int mark_print_params_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(PrintParams));
}

static int mark_print_params_MARK(void *p, struct NewGC *gc) {
  PrintParams *pp = (PrintParams *)p;
  gcMARK2(pp->inspector, gc);
  gcMARK2(pp->print_port, gc);
  gcMARK2(pp->print_buffer, gc);
  gcMARK2(pp->depth_delta, gc);
  gcMARK2(pp->uq_ht, gc);
  return
  gcBYTES_TO_WORDS(sizeof(PrintParams));
}

static int mark_print_params_FIXUP(void *p, struct NewGC *gc) {
  PrintParams *pp = (PrintParams *)p;
  gcFIXUP2(pp->inspector, gc);
  gcFIXUP2(pp->print_port, gc);
  gcFIXUP2(pp->print_buffer, gc);
  gcFIXUP2(pp->depth_delta, gc);
  gcFIXUP2(pp->uq_ht, gc);
  return
  gcBYTES_TO_WORDS(sizeof(PrintParams));
}

#define mark_print_params_IS_ATOMIC 0
#define mark_print_params_IS_CONST_SIZE 1


static int mark_marshal_tables_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Marshal_Tables));
}

static int mark_marshal_tables_MARK(void *p, struct NewGC *gc) {
  Scheme_Marshal_Tables *mt = (Scheme_Marshal_Tables *)p;
  gcMARK2(mt->symtab, gc);
  gcMARK2(mt->rns, gc);
  gcMARK2(mt->rn_refs, gc);
  gcMARK2(mt->st_refs, gc);
  gcMARK2(mt->st_ref_stack, gc);
  gcMARK2(mt->reverse_map, gc);
  gcMARK2(mt->same_map, gc);
  gcMARK2(mt->cert_lists, gc);
  gcMARK2(mt->shift_map, gc);
  gcMARK2(mt->top_map, gc);
  gcMARK2(mt->key_map, gc);
  gcMARK2(mt->delay_map, gc);
  gcMARK2(mt->cdata_map, gc);
  gcMARK2(mt->rn_saved, gc);
  gcMARK2(mt->shared_offsets, gc);
  gcMARK2(mt->sorted_keys, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Marshal_Tables));
}

static int mark_marshal_tables_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Marshal_Tables *mt = (Scheme_Marshal_Tables *)p;
  gcFIXUP2(mt->symtab, gc);
  gcFIXUP2(mt->rns, gc);
  gcFIXUP2(mt->rn_refs, gc);
  gcFIXUP2(mt->st_refs, gc);
  gcFIXUP2(mt->st_ref_stack, gc);
  gcFIXUP2(mt->reverse_map, gc);
  gcFIXUP2(mt->same_map, gc);
  gcFIXUP2(mt->cert_lists, gc);
  gcFIXUP2(mt->shift_map, gc);
  gcFIXUP2(mt->top_map, gc);
  gcFIXUP2(mt->key_map, gc);
  gcFIXUP2(mt->delay_map, gc);
  gcFIXUP2(mt->cdata_map, gc);
  gcFIXUP2(mt->rn_saved, gc);
  gcFIXUP2(mt->shared_offsets, gc);
  gcFIXUP2(mt->sorted_keys, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Marshal_Tables));
}

#define mark_marshal_tables_IS_ATOMIC 0
#define mark_marshal_tables_IS_CONST_SIZE 1


#endif  /* PRINT */

/**********************************************************************/

#ifdef MARKS_FOR_NETWORK_C

static int mark_listener_SIZE(void *p, struct NewGC *gc) {
  listener_t *l = (listener_t *)p;

  return
  gcBYTES_TO_WORDS(sizeof(listener_t) + ((l->count - 1) * sizeof(tcp_t)));
}

static int mark_listener_MARK(void *p, struct NewGC *gc) {
  listener_t *l = (listener_t *)p;


  gcMARK2(l->mref, gc);

  return
  gcBYTES_TO_WORDS(sizeof(listener_t) + ((l->count - 1) * sizeof(tcp_t)));
}

static int mark_listener_FIXUP(void *p, struct NewGC *gc) {
  listener_t *l = (listener_t *)p;


  gcFIXUP2(l->mref, gc);

  return
  gcBYTES_TO_WORDS(sizeof(listener_t) + ((l->count - 1) * sizeof(tcp_t)));
}

#define mark_listener_IS_ATOMIC 0
#define mark_listener_IS_CONST_SIZE 0


#ifdef USE_TCP
static int mark_tcp_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Tcp));
}

static int mark_tcp_MARK(void *p, struct NewGC *gc) {
  Scheme_Tcp *tcp = (Scheme_Tcp *)p;

  gcMARK2(tcp->b.buffer, gc);
  gcMARK2(tcp->b.out_buffer, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Tcp));
}

static int mark_tcp_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Tcp *tcp = (Scheme_Tcp *)p;

  gcFIXUP2(tcp->b.buffer, gc);
  gcFIXUP2(tcp->b.out_buffer, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Tcp));
}

#define mark_tcp_IS_ATOMIC 0
#define mark_tcp_IS_CONST_SIZE 1


# ifdef UDP_IS_SUPPORTED
static int mark_udp_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP));
}

static int mark_udp_MARK(void *p, struct NewGC *gc) {
  Scheme_UDP *udp = (Scheme_UDP *)p;

  gcMARK2(udp->previous_from_addr, gc);
  gcMARK2(udp->mref, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP));
}

static int mark_udp_FIXUP(void *p, struct NewGC *gc) {
  Scheme_UDP *udp = (Scheme_UDP *)p;

  gcFIXUP2(udp->previous_from_addr, gc);
  gcFIXUP2(udp->mref, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP));
}

#define mark_udp_IS_ATOMIC 0
#define mark_udp_IS_CONST_SIZE 1


static int mark_udp_evt_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP_Evt));
}

static int mark_udp_evt_MARK(void *p, struct NewGC *gc) {
  Scheme_UDP_Evt *uw = (Scheme_UDP_Evt *)p;

  gcMARK2(uw->udp, gc);
  gcMARK2(uw->str, gc);
  gcMARK2(uw->dest_addr, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP_Evt));
}

static int mark_udp_evt_FIXUP(void *p, struct NewGC *gc) {
  Scheme_UDP_Evt *uw = (Scheme_UDP_Evt *)p;

  gcFIXUP2(uw->udp, gc);
  gcFIXUP2(uw->str, gc);
  gcFIXUP2(uw->dest_addr, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP_Evt));
}

#define mark_udp_evt_IS_ATOMIC 0
#define mark_udp_evt_IS_CONST_SIZE 1

# endif
#endif

#endif  /* NETWORK */

/**********************************************************************/

#ifdef MARKS_FOR_THREAD_C

static int mark_parameterization_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Parameterization)
		    + ((max_configs - 1) * sizeof(Scheme_Object*))));
}

static int mark_parameterization_MARK(void *p, struct NewGC *gc) {
  Scheme_Parameterization *c = (Scheme_Parameterization *)p;
  int i;
    
  for (i = max_configs; i--; ) {
    gcMARK2(c->prims[i], gc);
  }
  gcMARK2(c->extensions, gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Parameterization)
		    + ((max_configs - 1) * sizeof(Scheme_Object*))));
}

static int mark_parameterization_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Parameterization *c = (Scheme_Parameterization *)p;
  int i;
    
  for (i = max_configs; i--; ) {
    gcFIXUP2(c->prims[i], gc);
  }
  gcFIXUP2(c->extensions, gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Parameterization)
		    + ((max_configs - 1) * sizeof(Scheme_Object*))));
}

#define mark_parameterization_IS_ATOMIC 0
#define mark_parameterization_IS_CONST_SIZE 0


static int mark_config_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Config));
}

static int mark_config_MARK(void *p, struct NewGC *gc) {
  Scheme_Config *config = (Scheme_Config *)p;
  gcMARK2(config->key, gc);
  gcMARK2(config->cell, gc);
  gcMARK2(config->next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Config));
}

static int mark_config_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Config *config = (Scheme_Config *)p;
  gcFIXUP2(config->key, gc);
  gcFIXUP2(config->cell, gc);
  gcFIXUP2(config->next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Config));
}

#define mark_config_IS_ATOMIC 0
#define mark_config_IS_CONST_SIZE 1


static int mark_will_executor_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(WillExecutor));
}

static int mark_will_executor_val_MARK(void *p, struct NewGC *gc) {
  WillExecutor *e = (WillExecutor *)p;
  
  gcMARK2(e->sema, gc);
  gcMARK2(e->first, gc);
  gcMARK2(e->last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(WillExecutor));
}

static int mark_will_executor_val_FIXUP(void *p, struct NewGC *gc) {
  WillExecutor *e = (WillExecutor *)p;
  
  gcFIXUP2(e->sema, gc);
  gcFIXUP2(e->first, gc);
  gcFIXUP2(e->last, gc);

  return
  gcBYTES_TO_WORDS(sizeof(WillExecutor));
}

#define mark_will_executor_val_IS_ATOMIC 0
#define mark_will_executor_val_IS_CONST_SIZE 1


static int mark_custodian_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian));
}

static int mark_custodian_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Custodian *m = (Scheme_Custodian *)p;
  
  gcMARK2(m->boxes, gc);
  gcMARK2(m->mrefs, gc);
  gcMARK2(m->closers, gc);
  gcMARK2(m->data, gc);

  gcMARK2(m->parent, gc);
  gcMARK2(m->sibling, gc);
  gcMARK2(m->children, gc);

  gcMARK2(m->global_next, gc);
  gcMARK2(m->global_prev, gc);

  gcMARK2(m->cust_boxes, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian));
}

static int mark_custodian_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Custodian *m = (Scheme_Custodian *)p;
  
  gcFIXUP2(m->boxes, gc);
  gcFIXUP2(m->mrefs, gc);
  gcFIXUP2(m->closers, gc);
  gcFIXUP2(m->data, gc);

  gcFIXUP2(m->parent, gc);
  gcFIXUP2(m->sibling, gc);
  gcFIXUP2(m->children, gc);

  gcFIXUP2(m->global_next, gc);
  gcFIXUP2(m->global_prev, gc);

  gcFIXUP2(m->cust_boxes, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian));
}

#define mark_custodian_val_IS_ATOMIC 0
#define mark_custodian_val_IS_CONST_SIZE 1


static int mark_custodian_box_val_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian_Box));
}

static int mark_custodian_box_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Custodian_Box *b = (Scheme_Custodian_Box *)p;
  int sd = ((Scheme_Custodian *)GC_resolve(b->cust))->shut_down;

  gcMARK2(b->cust, gc);
  if (!sd) {
    gcMARK2(b->v, gc);
  }

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian_Box));
}

static int mark_custodian_box_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Custodian_Box *b = (Scheme_Custodian_Box *)p;
  int sd = ((Scheme_Custodian *)GC_resolve(b->cust))->shut_down;

  gcFIXUP2(b->cust, gc);
  if (!sd) {
    gcFIXUP2(b->v, gc);
  }

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian_Box));
}

#define mark_custodian_box_val_IS_ATOMIC 0
#define mark_custodian_box_val_IS_CONST_SIZE 1


static int mark_thread_hop_SIZE(void *p, struct NewGC *gc) {
  return
   gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Custodian_Hop));
}

static int mark_thread_hop_MARK(void *p, struct NewGC *gc) {
  Scheme_Thread_Custodian_Hop *hop = (Scheme_Thread_Custodian_Hop *)p;

  gcMARK2(hop->p, gc);

  return
   gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Custodian_Hop));
}

static int mark_thread_hop_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Thread_Custodian_Hop *hop = (Scheme_Thread_Custodian_Hop *)p;

  gcFIXUP2(hop->p, gc);

  return
   gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Custodian_Hop));
}

#define mark_thread_hop_IS_ATOMIC 0
#define mark_thread_hop_IS_CONST_SIZE 1


static int mark_param_data_SIZE(void *p, struct NewGC *gc) {
  return
   gcBYTES_TO_WORDS(sizeof(ParamData));
}

static int mark_param_data_MARK(void *p, struct NewGC *gc) {
  ParamData *d = (ParamData *)p;

  gcMARK2(d->key, gc);
  gcMARK2(d->guard, gc);
  gcMARK2(d->extract_guard, gc);
  gcMARK2(d->defcell, gc);

  return
   gcBYTES_TO_WORDS(sizeof(ParamData));
}

static int mark_param_data_FIXUP(void *p, struct NewGC *gc) {
  ParamData *d = (ParamData *)p;

  gcFIXUP2(d->key, gc);
  gcFIXUP2(d->guard, gc);
  gcFIXUP2(d->extract_guard, gc);
  gcFIXUP2(d->defcell, gc);

  return
   gcBYTES_TO_WORDS(sizeof(ParamData));
}

#define mark_param_data_IS_ATOMIC 0
#define mark_param_data_IS_CONST_SIZE 1


static int mark_will_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(ActiveWill));
}

static int mark_will_MARK(void *p, struct NewGC *gc) {
  ActiveWill *w = (ActiveWill *)p;
  
  gcMARK2(w->o, gc);
  gcMARK2(w->proc, gc);
  gcMARK2(w->w, gc);
  gcMARK2(w->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(ActiveWill));
}

static int mark_will_FIXUP(void *p, struct NewGC *gc) {
  ActiveWill *w = (ActiveWill *)p;
  
  gcFIXUP2(w->o, gc);
  gcFIXUP2(w->proc, gc);
  gcFIXUP2(w->w, gc);
  gcFIXUP2(w->next, gc);

  return
  gcBYTES_TO_WORDS(sizeof(ActiveWill));
}

#define mark_will_IS_ATOMIC 0
#define mark_will_IS_CONST_SIZE 1


static int mark_evt_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt));
}

static int mark_evt_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt));
}

static int mark_evt_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt));
}

#define mark_evt_IS_ATOMIC 1
#define mark_evt_IS_CONST_SIZE 1


static int mark_syncing_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Syncing));
}

static int mark_syncing_MARK(void *p, struct NewGC *gc) {
  Syncing *w = (Syncing *)p;
 
  gcMARK2(w->set, gc);
  gcMARK2(w->wrapss, gc);
  gcMARK2(w->nackss, gc);
  gcMARK2(w->reposts, gc);
  gcMARK2(w->accepts, gc);
  gcMARK2(w->disable_break, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Syncing));
}

static int mark_syncing_FIXUP(void *p, struct NewGC *gc) {
  Syncing *w = (Syncing *)p;
 
  gcFIXUP2(w->set, gc);
  gcFIXUP2(w->wrapss, gc);
  gcFIXUP2(w->nackss, gc);
  gcFIXUP2(w->reposts, gc);
  gcFIXUP2(w->accepts, gc);
  gcFIXUP2(w->disable_break, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Syncing));
}

#define mark_syncing_IS_ATOMIC 0
#define mark_syncing_IS_CONST_SIZE 1


static int mark_evt_set_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt_Set));
}

static int mark_evt_set_MARK(void *p, struct NewGC *gc) {
  Evt_Set *w = (Evt_Set *)p;
 
  gcMARK2(w->ws, gc);
  gcMARK2(w->argv, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Evt_Set));
}

static int mark_evt_set_FIXUP(void *p, struct NewGC *gc) {
  Evt_Set *w = (Evt_Set *)p;
 
  gcFIXUP2(w->ws, gc);
  gcFIXUP2(w->argv, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Evt_Set));
}

#define mark_evt_set_IS_ATOMIC 0
#define mark_evt_set_IS_CONST_SIZE 1


static int mark_thread_set_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Set));
}

static int mark_thread_set_MARK(void *p, struct NewGC *gc) {
  Scheme_Thread_Set *ts = (Scheme_Thread_Set *)p;
 
  gcMARK2(ts->parent, gc);
  gcMARK2(ts->first, gc);
  gcMARK2(ts->next, gc);
  gcMARK2(ts->prev, gc);
  gcMARK2(ts->search_start, gc);
  gcMARK2(ts->current, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Set));
}

static int mark_thread_set_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Thread_Set *ts = (Scheme_Thread_Set *)p;
 
  gcFIXUP2(ts->parent, gc);
  gcFIXUP2(ts->first, gc);
  gcFIXUP2(ts->next, gc);
  gcFIXUP2(ts->prev, gc);
  gcFIXUP2(ts->search_start, gc);
  gcFIXUP2(ts->current, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Set));
}

#define mark_thread_set_IS_ATOMIC 0
#define mark_thread_set_IS_CONST_SIZE 1


static int mark_thread_cell_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Thread_Cell));
}

static int mark_thread_cell_MARK(void *p, struct NewGC *gc) {
  Thread_Cell *c = (Thread_Cell *)p;
 
  gcMARK2(c->def_val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Thread_Cell));
}

static int mark_thread_cell_FIXUP(void *p, struct NewGC *gc) {
  Thread_Cell *c = (Thread_Cell *)p;
 
  gcFIXUP2(c->def_val, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Thread_Cell));
}

#define mark_thread_cell_IS_ATOMIC 0
#define mark_thread_cell_IS_CONST_SIZE 1


static int mark_frozen_tramp_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(FrozenTramp));
}

static int mark_frozen_tramp_MARK(void *p, struct NewGC *gc) {
  FrozenTramp *f = (FrozenTramp *)p;
 
  gcMARK2(f->do_data, gc);
  gcMARK2(f->old_param, gc);
  gcMARK2(f->config, gc);
  gcMARK2(f->progress_cont, gc);

  return
  gcBYTES_TO_WORDS(sizeof(FrozenTramp));
}

static int mark_frozen_tramp_FIXUP(void *p, struct NewGC *gc) {
  FrozenTramp *f = (FrozenTramp *)p;
 
  gcFIXUP2(f->do_data, gc);
  gcFIXUP2(f->old_param, gc);
  gcFIXUP2(f->config, gc);
  gcFIXUP2(f->progress_cont, gc);

  return
  gcBYTES_TO_WORDS(sizeof(FrozenTramp));
}

#define mark_frozen_tramp_IS_ATOMIC 0
#define mark_frozen_tramp_IS_CONST_SIZE 1


#endif  /* THREAD */

/**********************************************************************/

#ifdef MARKS_FOR_SALLOC_C

static int mark_finalization_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Finalization));
}

static int mark_finalization_MARK(void *p, struct NewGC *gc) {
  Finalization *f = (Finalization *)p;
  
  gcMARK2(f->data, gc);
  gcMARK2(f->next, gc);
  gcMARK2(f->prev, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Finalization));
}

static int mark_finalization_FIXUP(void *p, struct NewGC *gc) {
  Finalization *f = (Finalization *)p;
  
  gcFIXUP2(f->data, gc);
  gcFIXUP2(f->next, gc);
  gcFIXUP2(f->prev, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Finalization));
}

#define mark_finalization_IS_ATOMIC 0
#define mark_finalization_IS_CONST_SIZE 1


static int mark_finalizations_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Finalizations));
}

static int mark_finalizations_MARK(void *p, struct NewGC *gc) {
  Finalizations *f = (Finalizations *)p;

  gcMARK2(f->scheme_first, gc);
  gcMARK2(f->scheme_last, gc);
  gcMARK2(f->prim_first, gc);
  gcMARK2(f->prim_last, gc);
  gcMARK2(f->ext_data, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Finalizations));
}

static int mark_finalizations_FIXUP(void *p, struct NewGC *gc) {
  Finalizations *f = (Finalizations *)p;

  gcFIXUP2(f->scheme_first, gc);
  gcFIXUP2(f->scheme_last, gc);
  gcFIXUP2(f->prim_first, gc);
  gcFIXUP2(f->prim_last, gc);
  gcFIXUP2(f->ext_data, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Finalizations));
}

#define mark_finalizations_IS_ATOMIC 0
#define mark_finalizations_IS_CONST_SIZE 1


#endif  /* SALLOC */

/**********************************************************************/

#ifdef MARKS_FOR_SEMA_C

static int mark_channel_syncer_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Syncer));
}

static int mark_channel_syncer_MARK(void *p, struct NewGC *gc) {
  Scheme_Channel_Syncer *w = (Scheme_Channel_Syncer *)p;

  gcMARK2(w->p, gc);
  gcMARK2(w->prev, gc);
  gcMARK2(w->next, gc);
  gcMARK2(w->syncing, gc);
  gcMARK2(w->obj, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Syncer));
}

static int mark_channel_syncer_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Channel_Syncer *w = (Scheme_Channel_Syncer *)p;

  gcFIXUP2(w->p, gc);
  gcFIXUP2(w->prev, gc);
  gcFIXUP2(w->next, gc);
  gcFIXUP2(w->syncing, gc);
  gcFIXUP2(w->obj, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Syncer));
}

#define mark_channel_syncer_IS_ATOMIC 0
#define mark_channel_syncer_IS_CONST_SIZE 1


static int mark_alarm_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Alarm));
}

static int mark_alarm_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Alarm));
}

static int mark_alarm_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Alarm));
}

#define mark_alarm_IS_ATOMIC 1
#define mark_alarm_IS_CONST_SIZE 1


#endif  /* SEMA */

/**********************************************************************/

#ifdef MARKS_FOR_STRUCT_C

#ifdef MZ_USE_PLACES
static int mark_serialized_struct_val_SIZE(void *p, struct NewGC *gc) {
  Scheme_Serialized_Structure *s = (Scheme_Serialized_Structure *)p;
  int num_slots = s->num_slots;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Serialized_Structure) 
		    + ((num_slots - 1) * sizeof(Scheme_Object *))));
}

static int mark_serialized_struct_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Serialized_Structure *s = (Scheme_Serialized_Structure *)p;
  int num_slots = s->num_slots;

  int i;

  gcMARK2(s->prefab_key, gc);
  
  for(i = num_slots; i--; )
    gcMARK2(s->slots[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Serialized_Structure) 
		    + ((num_slots - 1) * sizeof(Scheme_Object *))));
}

static int mark_serialized_struct_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Serialized_Structure *s = (Scheme_Serialized_Structure *)p;
  int num_slots = s->num_slots;

  int i;

  gcFIXUP2(s->prefab_key, gc);
  
  for(i = num_slots; i--; )
    gcFIXUP2(s->slots[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Serialized_Structure) 
		    + ((num_slots - 1) * sizeof(Scheme_Object *))));
}

#define mark_serialized_struct_val_IS_ATOMIC 0
#define mark_serialized_struct_val_IS_CONST_SIZE 0

#endif

static int mark_struct_val_SIZE(void *p, struct NewGC *gc) {
  Scheme_Structure *s = (Scheme_Structure *)p;
  int num_slots = ((Scheme_Struct_Type *)GC_resolve(s->stype))->num_slots;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Structure) 
		    + ((num_slots - 1) * sizeof(Scheme_Object *))));
}

static int mark_struct_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Structure *s = (Scheme_Structure *)p;
  int num_slots = ((Scheme_Struct_Type *)GC_resolve(s->stype))->num_slots;

  int i;

  gcMARK2( s->stype, gc);
  
  for(i = num_slots; i--; )
    gcMARK2(s->slots[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Structure) 
		    + ((num_slots - 1) * sizeof(Scheme_Object *))));
}

static int mark_struct_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Structure *s = (Scheme_Structure *)p;
  int num_slots = ((Scheme_Struct_Type *)GC_resolve(s->stype))->num_slots;

  int i;

  gcFIXUP2_TYPED_NOW(Scheme_Struct_Type *, s->stype, gc);
  
  for(i = num_slots; i--; )
    gcFIXUP2(s->slots[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Structure) 
		    + ((num_slots - 1) * sizeof(Scheme_Object *))));
}

#define mark_struct_val_IS_ATOMIC 0
#define mark_struct_val_IS_CONST_SIZE 0


static int mark_struct_type_val_SIZE(void *p, struct NewGC *gc) {
  Scheme_Struct_Type *t = (Scheme_Struct_Type *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Struct_Type)
		    + (t->name_pos * sizeof(Scheme_Struct_Type *))));
}

static int mark_struct_type_val_MARK(void *p, struct NewGC *gc) {
  Scheme_Struct_Type *t = (Scheme_Struct_Type *)p;

  int i;
  for (i = t->name_pos + 1; i--; ) {
    gcMARK2(t->parent_types[i], gc);
  }
  gcMARK2(t->name, gc);
  gcMARK2(t->inspector, gc);
  gcMARK2(t->accessor, gc);
  gcMARK2(t->mutator, gc);
  gcMARK2(t->prefab_key, gc);
  gcMARK2(t->uninit_val, gc);
  gcMARK2(t->props, gc);
  gcMARK2(t->proc_attr, gc);
  gcMARK2(t->guard, gc);
  gcMARK2(t->immutables, gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Struct_Type)
		    + (t->name_pos * sizeof(Scheme_Struct_Type *))));
}

static int mark_struct_type_val_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Struct_Type *t = (Scheme_Struct_Type *)p;

  int i;
  for (i = t->name_pos + 1; i--; ) {
    gcFIXUP2(t->parent_types[i], gc);
  }
  gcFIXUP2(t->name, gc);
  gcFIXUP2(t->inspector, gc);
  gcFIXUP2(t->accessor, gc);
  gcFIXUP2(t->mutator, gc);
  gcFIXUP2(t->prefab_key, gc);
  gcFIXUP2(t->uninit_val, gc);
  gcFIXUP2(t->props, gc);
  gcFIXUP2(t->proc_attr, gc);
  gcFIXUP2(t->guard, gc);
  gcFIXUP2(t->immutables, gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Struct_Type)
		    + (t->name_pos * sizeof(Scheme_Struct_Type *))));
}

#define mark_struct_type_val_IS_ATOMIC 0
#define mark_struct_type_val_IS_CONST_SIZE 0


static int mark_struct_proc_info_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Struct_Proc_Info));
}

static int mark_struct_proc_info_MARK(void *p, struct NewGC *gc) {
  Struct_Proc_Info *i = (Struct_Proc_Info *)p;

  gcMARK2(i->struct_type, gc);
  gcMARK2(i->func_name, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Struct_Proc_Info));
}

static int mark_struct_proc_info_FIXUP(void *p, struct NewGC *gc) {
  Struct_Proc_Info *i = (Struct_Proc_Info *)p;

  gcFIXUP2(i->struct_type, gc);
  gcFIXUP2(i->func_name, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Struct_Proc_Info));
}

#define mark_struct_proc_info_IS_ATOMIC 0
#define mark_struct_proc_info_IS_CONST_SIZE 1


static int mark_struct_property_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Struct_Property));
}

static int mark_struct_property_MARK(void *p, struct NewGC *gc) {
  Scheme_Struct_Property *i = (Scheme_Struct_Property *)p;
  gcMARK2(i->name, gc);
  gcMARK2(i->guard, gc);
  gcMARK2(i->supers, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Struct_Property));
}

static int mark_struct_property_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Struct_Property *i = (Scheme_Struct_Property *)p;
  gcFIXUP2(i->name, gc);
  gcFIXUP2(i->guard, gc);
  gcFIXUP2(i->supers, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Struct_Property));
}

#define mark_struct_property_IS_ATOMIC 0
#define mark_struct_property_IS_CONST_SIZE 1


static int mark_wrapped_evt_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Wrapped_Evt));
}

static int mark_wrapped_evt_MARK(void *p, struct NewGC *gc) {
  Wrapped_Evt *ww = (Wrapped_Evt *)p;

  gcMARK2(ww->evt, gc);
  gcMARK2(ww->wrapper, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Wrapped_Evt));
}

static int mark_wrapped_evt_FIXUP(void *p, struct NewGC *gc) {
  Wrapped_Evt *ww = (Wrapped_Evt *)p;

  gcFIXUP2(ww->evt, gc);
  gcFIXUP2(ww->wrapper, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Wrapped_Evt));
}

#define mark_wrapped_evt_IS_ATOMIC 0
#define mark_wrapped_evt_IS_CONST_SIZE 1


static int mark_nack_guard_evt_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Nack_Guard_Evt));
}

static int mark_nack_guard_evt_MARK(void *p, struct NewGC *gc) {
  Nack_Guard_Evt *nw = (Nack_Guard_Evt *)p;

  gcMARK2(nw->maker, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Nack_Guard_Evt));
}

static int mark_nack_guard_evt_FIXUP(void *p, struct NewGC *gc) {
  Nack_Guard_Evt *nw = (Nack_Guard_Evt *)p;

  gcFIXUP2(nw->maker, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Nack_Guard_Evt));
}

#define mark_nack_guard_evt_IS_ATOMIC 0
#define mark_nack_guard_evt_IS_CONST_SIZE 1


static int mark_chaperone_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Chaperone));
}

static int mark_chaperone_MARK(void *p, struct NewGC *gc) {
  Scheme_Chaperone *px = (Scheme_Chaperone *)p;

  gcMARK2(px->val, gc);
  gcMARK2(px->prev, gc);
  gcMARK2(px->props, gc);
  gcMARK2(px->redirects, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Chaperone));
}

static int mark_chaperone_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Chaperone *px = (Scheme_Chaperone *)p;

  gcFIXUP2(px->val, gc);
  gcFIXUP2(px->prev, gc);
  gcFIXUP2(px->props, gc);
  gcFIXUP2(px->redirects, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Chaperone));
}

#define mark_chaperone_IS_ATOMIC 0
#define mark_chaperone_IS_CONST_SIZE 1


#endif  /* STRUCT */

/**********************************************************************/

#ifdef MARKS_FOR_SYNTAX_C

#endif  /* SYNTAX */

/**********************************************************************/

#ifdef MARKS_FOR_READ_C

static int mark_indent_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indent));
}

static int mark_indent_MARK(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indent));
}

static int mark_indent_FIXUP(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indent));
}

#define mark_indent_IS_ATOMIC 1
#define mark_indent_IS_CONST_SIZE 1


static int mark_cport_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(CPort));
}

static int mark_cport_MARK(void *p, struct NewGC *gc) {
  CPort *cp = (CPort *)p;
  gcMARK2(cp->start, gc);
  gcMARK2(cp->orig_port, gc);
  gcMARK2(cp->ht, gc);
  gcMARK2(cp->ut, gc);
  gcMARK2(cp->symtab, gc);
  gcMARK2(cp->insp, gc);
  gcMARK2(cp->relto, gc);
  gcMARK2(cp->magic_sym, gc);
  gcMARK2(cp->magic_val, gc);
  gcMARK2(cp->shared_offsets, gc);
  gcMARK2(cp->delay_info, gc);
  return
  gcBYTES_TO_WORDS(sizeof(CPort));
}

static int mark_cport_FIXUP(void *p, struct NewGC *gc) {
  CPort *cp = (CPort *)p;
  gcFIXUP2(cp->start, gc);
  gcFIXUP2(cp->orig_port, gc);
  gcFIXUP2(cp->ht, gc);
  gcFIXUP2(cp->ut, gc);
  gcFIXUP2(cp->symtab, gc);
  gcFIXUP2(cp->insp, gc);
  gcFIXUP2(cp->relto, gc);
  gcFIXUP2(cp->magic_sym, gc);
  gcFIXUP2(cp->magic_val, gc);
  gcFIXUP2(cp->shared_offsets, gc);
  gcFIXUP2(cp->delay_info, gc);
  return
  gcBYTES_TO_WORDS(sizeof(CPort));
}

#define mark_cport_IS_ATOMIC 0
#define mark_cport_IS_CONST_SIZE 1


static int mark_readtable_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Readtable));
}

static int mark_readtable_MARK(void *p, struct NewGC *gc) {
  Readtable *t = (Readtable *)p;
  gcMARK2(t->mapping, gc);
  gcMARK2(t->fast_mapping, gc);
  gcMARK2(t->symbol_parser, gc);
  gcMARK2(t->names, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Readtable));
}

static int mark_readtable_FIXUP(void *p, struct NewGC *gc) {
  Readtable *t = (Readtable *)p;
  gcFIXUP2(t->mapping, gc);
  gcFIXUP2(t->fast_mapping, gc);
  gcFIXUP2(t->symbol_parser, gc);
  gcFIXUP2(t->names, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Readtable));
}

#define mark_readtable_IS_ATOMIC 0
#define mark_readtable_IS_CONST_SIZE 1


static int mark_read_params_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(ReadParams));
}

static int mark_read_params_MARK(void *p, struct NewGC *gc) {
  ReadParams *rp = (ReadParams *)p;
  gcMARK2(rp->table, gc);
  gcMARK2(rp->magic_sym, gc);
  gcMARK2(rp->magic_val, gc);
  gcMARK2(rp->delay_load_info, gc);
  gcMARK2(rp->read_relative_path, gc);
  return
  gcBYTES_TO_WORDS(sizeof(ReadParams));
}

static int mark_read_params_FIXUP(void *p, struct NewGC *gc) {
  ReadParams *rp = (ReadParams *)p;
  gcFIXUP2(rp->table, gc);
  gcFIXUP2(rp->magic_sym, gc);
  gcFIXUP2(rp->magic_val, gc);
  gcFIXUP2(rp->delay_load_info, gc);
  gcFIXUP2(rp->read_relative_path, gc);
  return
  gcBYTES_TO_WORDS(sizeof(ReadParams));
}

#define mark_read_params_IS_ATOMIC 0
#define mark_read_params_IS_CONST_SIZE 1


static int mark_delay_load_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Load_Delay));
}

static int mark_delay_load_MARK(void *p, struct NewGC *gc) {
  Scheme_Load_Delay *ld = (Scheme_Load_Delay *)p;
  gcMARK2(ld->path, gc);
  gcMARK2(ld->symtab, gc);
  gcMARK2(ld->shared_offsets, gc);
  gcMARK2(ld->insp, gc);
  gcMARK2(ld->relto, gc);
  gcMARK2(ld->ut, gc);
  gcMARK2(ld->current_rp, gc);
  gcMARK2(ld->cached, gc);
  gcMARK2(ld->cached_port, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Load_Delay));
}

static int mark_delay_load_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Load_Delay *ld = (Scheme_Load_Delay *)p;
  gcFIXUP2(ld->path, gc);
  gcFIXUP2(ld->symtab, gc);
  gcFIXUP2(ld->shared_offsets, gc);
  gcFIXUP2(ld->insp, gc);
  gcFIXUP2(ld->relto, gc);
  gcFIXUP2(ld->ut, gc);
  gcFIXUP2(ld->current_rp, gc);
  gcFIXUP2(ld->cached, gc);
  gcFIXUP2(ld->cached_port, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Load_Delay));
}

#define mark_delay_load_IS_ATOMIC 0
#define mark_delay_load_IS_CONST_SIZE 1


static int mark_unmarshal_tables_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Unmarshal_Tables));
}

static int mark_unmarshal_tables_MARK(void *p, struct NewGC *gc) {
  Scheme_Unmarshal_Tables *ut = (Scheme_Unmarshal_Tables *)p;
  gcMARK2(ut->rns, gc);
  gcMARK2(ut->rp, gc);
  gcMARK2(ut->decoded, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Unmarshal_Tables));
}

static int mark_unmarshal_tables_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Unmarshal_Tables *ut = (Scheme_Unmarshal_Tables *)p;
  gcFIXUP2(ut->rns, gc);
  gcFIXUP2(ut->rp, gc);
  gcFIXUP2(ut->decoded, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Unmarshal_Tables));
}

#define mark_unmarshal_tables_IS_ATOMIC 0
#define mark_unmarshal_tables_IS_CONST_SIZE 1


#endif  /* READ */

/**********************************************************************/

#ifdef MARKS_FOR_REGEXP_C

static int mark_regexp_SIZE(void *p, struct NewGC *gc) {
  regexp *r = (regexp *)p;
  return
  gcBYTES_TO_WORDS((sizeof(regexp) + r->regsize));
}

static int mark_regexp_MARK(void *p, struct NewGC *gc) {
  regexp *r = (regexp *)p;
  gcMARK2(r->source, gc);
  gcMARK2(r->regstart, gc);
  return
  gcBYTES_TO_WORDS((sizeof(regexp) + r->regsize));
}

static int mark_regexp_FIXUP(void *p, struct NewGC *gc) {
  regexp *r = (regexp *)p;
  gcFIXUP2(r->source, gc);
  gcFIXUP2(r->regstart, gc);
  return
  gcBYTES_TO_WORDS((sizeof(regexp) + r->regsize));
}

#define mark_regexp_IS_ATOMIC 0
#define mark_regexp_IS_CONST_SIZE 0


static int mark_regwork_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Regwork));
}

static int mark_regwork_MARK(void *p, struct NewGC *gc) {
  Regwork *r = (Regwork *)p;
  gcMARK2(r->str, gc);
  gcMARK2(r->instr, gc);
  gcMARK2(r->port, gc);
  gcMARK2(r->unless_evt, gc);
  gcMARK2(r->startp, gc);
  gcMARK2(r->maybep, gc);
  gcMARK2(r->endp, gc);
  gcMARK2(r->counters, gc);
  gcMARK2(r->peekskip, gc);
  gcMARK2(r->prefix, gc);
  gcMARK2(r->rewind_stack, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Regwork));
}

static int mark_regwork_FIXUP(void *p, struct NewGC *gc) {
  Regwork *r = (Regwork *)p;
  gcFIXUP2(r->str, gc);
  gcFIXUP2(r->instr, gc);
  gcFIXUP2(r->port, gc);
  gcFIXUP2(r->unless_evt, gc);
  gcFIXUP2(r->startp, gc);
  gcFIXUP2(r->maybep, gc);
  gcFIXUP2(r->endp, gc);
  gcFIXUP2(r->counters, gc);
  gcFIXUP2(r->peekskip, gc);
  gcFIXUP2(r->prefix, gc);
  gcFIXUP2(r->rewind_stack, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Regwork));
}

#define mark_regwork_IS_ATOMIC 0
#define mark_regwork_IS_CONST_SIZE 1


#endif  /* REGEXP */

/**********************************************************************/

#ifdef MARKS_FOR_STRING_C

static int mark_string_convert_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Converter));
}

static int mark_string_convert_MARK(void *p, struct NewGC *gc) {
  Scheme_Converter *c = (Scheme_Converter *)p;
  gcMARK2(c->mref, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Converter));
}

static int mark_string_convert_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Converter *c = (Scheme_Converter *)p;
  gcFIXUP2(c->mref, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Converter));
}

#define mark_string_convert_IS_ATOMIC 0
#define mark_string_convert_IS_CONST_SIZE 1


#endif  /* STRING */

/**********************************************************************/

#ifdef MARKS_FOR_STXOBJ_C

static int mark_rename_table_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Module_Renames));
}

static int mark_rename_table_MARK(void *p, struct NewGC *gc) {
  Module_Renames *rn = (Module_Renames *)p;
  gcMARK2(rn->phase, gc);
  gcMARK2(rn->ht, gc);
  gcMARK2(rn->nomarshal_ht, gc);
  gcMARK2(rn->unmarshal_info, gc);
  gcMARK2(rn->shared_pes, gc);
  gcMARK2(rn->set_identity, gc);
  gcMARK2(rn->marked_names, gc);
  gcMARK2(rn->free_id_renames, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Module_Renames));
}

static int mark_rename_table_FIXUP(void *p, struct NewGC *gc) {
  Module_Renames *rn = (Module_Renames *)p;
  gcFIXUP2(rn->phase, gc);
  gcFIXUP2(rn->ht, gc);
  gcFIXUP2(rn->nomarshal_ht, gc);
  gcFIXUP2(rn->unmarshal_info, gc);
  gcFIXUP2(rn->shared_pes, gc);
  gcFIXUP2(rn->set_identity, gc);
  gcFIXUP2(rn->marked_names, gc);
  gcFIXUP2(rn->free_id_renames, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Module_Renames));
}

#define mark_rename_table_IS_ATOMIC 0
#define mark_rename_table_IS_CONST_SIZE 1


static int mark_rename_table_set_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Module_Renames_Set));
}

static int mark_rename_table_set_MARK(void *p, struct NewGC *gc) {
  Module_Renames_Set *rns = (Module_Renames_Set *)p;
  gcMARK2(rns->et, gc);
  gcMARK2(rns->rt, gc);
  gcMARK2(rns->other_phases, gc);
  gcMARK2(rns->share_marked_names, gc);
  gcMARK2(rns->set_identity, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Module_Renames_Set));
}

static int mark_rename_table_set_FIXUP(void *p, struct NewGC *gc) {
  Module_Renames_Set *rns = (Module_Renames_Set *)p;
  gcFIXUP2(rns->et, gc);
  gcFIXUP2(rns->rt, gc);
  gcFIXUP2(rns->other_phases, gc);
  gcFIXUP2(rns->share_marked_names, gc);
  gcFIXUP2(rns->set_identity, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Module_Renames_Set));
}

#define mark_rename_table_set_IS_ATOMIC 0
#define mark_rename_table_set_IS_CONST_SIZE 1


static int mark_srcloc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
}

static int mark_srcloc_MARK(void *p, struct NewGC *gc) {
  Scheme_Stx_Srcloc *s = (Scheme_Stx_Srcloc *)p;
  gcMARK2(s->src, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
}

static int mark_srcloc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Stx_Srcloc *s = (Scheme_Stx_Srcloc *)p;
  gcFIXUP2(s->src, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
}

#define mark_srcloc_IS_ATOMIC 0
#define mark_srcloc_IS_CONST_SIZE 1


static int mark_wrapchunk_SIZE(void *p, struct NewGC *gc) {
  Wrap_Chunk *wc = (Wrap_Chunk *)p;
  return
  gcBYTES_TO_WORDS(sizeof(Wrap_Chunk) + ((wc->len - 1) * sizeof(Scheme_Object *)));
}

static int mark_wrapchunk_MARK(void *p, struct NewGC *gc) {
  Wrap_Chunk *wc = (Wrap_Chunk *)p;
  int i;
  for (i = wc->len; i--; ) {
    gcMARK2(wc->a[i], gc);
  }
  return
  gcBYTES_TO_WORDS(sizeof(Wrap_Chunk) + ((wc->len - 1) * sizeof(Scheme_Object *)));
}

static int mark_wrapchunk_FIXUP(void *p, struct NewGC *gc) {
  Wrap_Chunk *wc = (Wrap_Chunk *)p;
  int i;
  for (i = wc->len; i--; ) {
    gcFIXUP2(wc->a[i], gc);
  }
  return
  gcBYTES_TO_WORDS(sizeof(Wrap_Chunk) + ((wc->len - 1) * sizeof(Scheme_Object *)));
}

#define mark_wrapchunk_IS_ATOMIC 0
#define mark_wrapchunk_IS_CONST_SIZE 0


static int mark_cert_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cert));
}

static int mark_cert_MARK(void *p, struct NewGC *gc) {
  Scheme_Cert *c = (Scheme_Cert *)p;
  gcMARK2(c->mark, gc);
  gcMARK2(c->modidx, gc);
  gcMARK2(c->insp, gc);
  gcMARK2(c->key, gc);
  gcMARK2(c->mapped, gc);
  gcMARK2(c->next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cert));
}

static int mark_cert_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Cert *c = (Scheme_Cert *)p;
  gcFIXUP2(c->mark, gc);
  gcFIXUP2(c->modidx, gc);
  gcFIXUP2(c->insp, gc);
  gcFIXUP2(c->key, gc);
  gcFIXUP2(c->mapped, gc);
  gcFIXUP2(c->next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cert));
}

#define mark_cert_IS_ATOMIC 0
#define mark_cert_IS_CONST_SIZE 1


static int lex_rib_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Lexical_Rib));
}

static int lex_rib_MARK(void *p, struct NewGC *gc) {
  Scheme_Lexical_Rib *rib = (Scheme_Lexical_Rib *)p;
  gcMARK2(rib->rename, gc);
  gcMARK2(rib->timestamp, gc);
  gcMARK2(rib->sealed, gc);
  gcMARK2(rib->mapped_names, gc);
  gcMARK2(rib->next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Lexical_Rib));
}

static int lex_rib_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Lexical_Rib *rib = (Scheme_Lexical_Rib *)p;
  gcFIXUP2(rib->rename, gc);
  gcFIXUP2(rib->timestamp, gc);
  gcFIXUP2(rib->sealed, gc);
  gcFIXUP2(rib->mapped_names, gc);
  gcFIXUP2(rib->next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Lexical_Rib));
}

#define lex_rib_IS_ATOMIC 0
#define lex_rib_IS_CONST_SIZE 1


static int mark_free_id_info_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((8 - 1) * sizeof(Scheme_Object *))));
}

static int mark_free_id_info_MARK(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;
  int i;
  for (i = 8; i--; )
    gcMARK2(vec->els[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((8 - 1) * sizeof(Scheme_Object *))));
}

static int mark_free_id_info_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Vector *vec = (Scheme_Vector *)p;
  int i;
  for (i = 8; i--; )
    gcFIXUP2(vec->els[i], gc);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((8 - 1) * sizeof(Scheme_Object *))));
}

#define mark_free_id_info_IS_ATOMIC 0
#define mark_free_id_info_IS_CONST_SIZE 0




#endif  /* STXOBJ */

/**********************************************************************/

#ifdef MARKS_FOR_JIT_C

static int native_closure_SIZE(void *p, struct NewGC *gc) {
  Scheme_Native_Closure *c = (Scheme_Native_Closure *)p;
  int closure_size = ((Scheme_Native_Closure_Data *)GC_resolve(c->code))->closure_size;

  if (closure_size < 0) {
    closure_size = -(closure_size + 1);
  }

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Native_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

static int native_closure_MARK(void *p, struct NewGC *gc) {
  Scheme_Native_Closure *c = (Scheme_Native_Closure *)p;
  int closure_size = ((Scheme_Native_Closure_Data *)GC_resolve(c->code))->closure_size;

  if (closure_size < 0) {
    closure_size = -(closure_size + 1);
  }


  {
    int i = closure_size;
    while (i--)
      gcMARK2(c->vals[i], gc);
  }
  gcMARK2(c->code, gc);
  
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Native_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

static int native_closure_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Native_Closure *c = (Scheme_Native_Closure *)p;
  int closure_size = ((Scheme_Native_Closure_Data *)GC_resolve(c->code))->closure_size;

  if (closure_size < 0) {
    closure_size = -(closure_size + 1);
  }


  {
    int i = closure_size;
    while (i--)
      gcFIXUP2(c->vals[i], gc);
  }
  gcFIXUP2(c->code, gc);
  
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Native_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

#define native_closure_IS_ATOMIC 0
#define native_closure_IS_CONST_SIZE 0


static int mark_jit_state_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(mz_jit_state));
}

static int mark_jit_state_MARK(void *p, struct NewGC *gc) {
  mz_jit_state *j = (mz_jit_state *)p;
  gcMARK2(j->mappings, gc);
  gcMARK2(j->self_data, gc);
  return
  gcBYTES_TO_WORDS(sizeof(mz_jit_state));
}

static int mark_jit_state_FIXUP(void *p, struct NewGC *gc) {
  mz_jit_state *j = (mz_jit_state *)p;
  gcFIXUP2(j->mappings, gc);
  gcFIXUP2(j->self_data, gc);
  return
  gcBYTES_TO_WORDS(sizeof(mz_jit_state));
}

#define mark_jit_state_IS_ATOMIC 0
#define mark_jit_state_IS_CONST_SIZE 1


static int native_unclosed_proc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data));
}

static int native_unclosed_proc_MARK(void *p, struct NewGC *gc) {
  Scheme_Native_Closure_Data *d = (Scheme_Native_Closure_Data *)p;
  int i;

  gcMARK2(d->u2.name, gc);
  if (d->retained) {
    for (i = SCHEME_INT_VAL(d->retained[0]); i--; ) {
      gcMARK2(d->retained[i], gc);
    }
  }
  if (d->closure_size < 0) {
    gcMARK2(d->u.arities, gc);
  }

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data));
}

static int native_unclosed_proc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Native_Closure_Data *d = (Scheme_Native_Closure_Data *)p;
  int i;

  gcFIXUP2(d->u2.name, gc);
  if (d->retained) {
    for (i = SCHEME_INT_VAL(d->retained[0]); i--; ) {
      gcFIXUP2(d->retained[i], gc);
    }
  }
  if (d->closure_size < 0) {
    gcFIXUP2(d->u.arities, gc);
  }

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data));
}

#define native_unclosed_proc_IS_ATOMIC 0
#define native_unclosed_proc_IS_CONST_SIZE 1


static int native_unclosed_proc_plus_case_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data_Plus_Case));
}

static int native_unclosed_proc_plus_case_MARK(void *p, struct NewGC *gc) {
  Scheme_Native_Closure_Data_Plus_Case *d = (Scheme_Native_Closure_Data_Plus_Case *)p;

  native_unclosed_proc_MARK(p, gc);
  gcMARK2(d->case_lam, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data_Plus_Case));
}

static int native_unclosed_proc_plus_case_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Native_Closure_Data_Plus_Case *d = (Scheme_Native_Closure_Data_Plus_Case *)p;

  native_unclosed_proc_FIXUP(p, gc);
  gcFIXUP2(d->case_lam, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data_Plus_Case));
}

#define native_unclosed_proc_plus_case_IS_ATOMIC 0
#define native_unclosed_proc_plus_case_IS_CONST_SIZE 1


#endif  /* JIT */

/**********************************************************************/

#ifdef MARKS_FOR_FUTURE_C

#ifdef MZ_USE_FUTURES

static int future_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(future_t));
}

static int future_MARK(void *p, struct NewGC *gc) {
  future_t *f = (future_t *)p;
  gcMARK2(f->orig_lambda, gc);
  gcMARK2(f->arg_s0, gc);
  gcMARK2(f->arg_t0, gc);
  gcMARK2(f->arg_S0, gc);
  gcMARK2(f->arg_b0, gc);
  gcMARK2(f->arg_n0, gc);
  gcMARK2(f->arg_s1, gc);
  gcMARK2(f->arg_t1, gc);
  gcMARK2(f->arg_S1, gc);
  gcMARK2(f->arg_s2, gc);
  gcMARK2(f->arg_S2, gc);
  gcMARK2(f->arg_p, gc);
  gcMARK2(f->retval_s, gc);
  gcMARK2(f->retval, gc);
  gcMARK2(f->multiple_array, gc);
  gcMARK2(f->tail_rator, gc);
  gcMARK2(f->tail_rands, gc);
  gcMARK2(f->prev, gc);
  gcMARK2(f->next, gc);
  gcMARK2(f->next_waiting_atomic, gc);
  gcMARK2(f->next_waiting_lwc, gc);
  gcMARK2(f->suspended_lw, gc);
  return
  gcBYTES_TO_WORDS(sizeof(future_t));
}

static int future_FIXUP(void *p, struct NewGC *gc) {
  future_t *f = (future_t *)p;
  gcFIXUP2(f->orig_lambda, gc);
  gcFIXUP2(f->arg_s0, gc);
  gcFIXUP2(f->arg_t0, gc);
  gcFIXUP2(f->arg_S0, gc);
  gcFIXUP2(f->arg_b0, gc);
  gcFIXUP2(f->arg_n0, gc);
  gcFIXUP2(f->arg_s1, gc);
  gcFIXUP2(f->arg_t1, gc);
  gcFIXUP2(f->arg_S1, gc);
  gcFIXUP2(f->arg_s2, gc);
  gcFIXUP2(f->arg_S2, gc);
  gcFIXUP2(f->arg_p, gc);
  gcFIXUP2(f->retval_s, gc);
  gcFIXUP2(f->retval, gc);
  gcFIXUP2(f->multiple_array, gc);
  gcFIXUP2(f->tail_rator, gc);
  gcFIXUP2(f->tail_rands, gc);
  gcFIXUP2(f->prev, gc);
  gcFIXUP2(f->next, gc);
  gcFIXUP2(f->next_waiting_atomic, gc);
  gcFIXUP2(f->next_waiting_lwc, gc);
  gcFIXUP2(f->suspended_lw, gc);
  return
  gcBYTES_TO_WORDS(sizeof(future_t));
}

#define future_IS_ATOMIC 0
#define future_IS_CONST_SIZE 1


#else

static int sequential_future_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(future_t));
}

static int sequential_future_MARK(void *p, struct NewGC *gc) {
  future_t *f = (future_t *)p;
  gcMARK2(f->orig_lambda, gc);
  gcMARK2(f->running_sema, gc);
  gcMARK2(f->retval, gc);
  gcMARK2(f->multiple_array, gc);
  return
  gcBYTES_TO_WORDS(sizeof(future_t));
}

static int sequential_future_FIXUP(void *p, struct NewGC *gc) {
  future_t *f = (future_t *)p;
  gcFIXUP2(f->orig_lambda, gc);
  gcFIXUP2(f->running_sema, gc);
  gcFIXUP2(f->retval, gc);
  gcFIXUP2(f->multiple_array, gc);
  return
  gcBYTES_TO_WORDS(sizeof(future_t));
}

#define sequential_future_IS_ATOMIC 0
#define sequential_future_IS_CONST_SIZE 1


#endif

#endif  /* FUTURE */

/**********************************************************************/

#define GC_REG_TRAV(type, base) GC_register_traversers2(type, base ## _SIZE, base ## _MARK, base ## _FIXUP, base ## _IS_CONST_SIZE, base ## _IS_ATOMIC)
