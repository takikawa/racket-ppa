/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int mark_optimize_info_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Optimize_Info));
}

static int mark_optimize_info_MARK(void *p, struct NewGC *gc) {
  Optimize_Info *i = (Optimize_Info *)p;
  
  gcMARK2(i->stat_dists, gc);
  gcMARK2(i->sd_depths, gc);
  gcMARK2(i->next, gc);
  gcMARK2(i->use, gc);
  gcMARK2(i->consts, gc);
  gcMARK2(i->cp, gc);
  gcMARK2(i->top_level_consts, gc);
  gcMARK2(i->transitive_use, gc);
  gcMARK2(i->transitive_use_len, gc);
  gcMARK2(i->context, gc);
  gcMARK2(i->logger, gc);
  gcMARK2(i->types, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Optimize_Info));
}

static int mark_optimize_info_FIXUP(void *p, struct NewGC *gc) {
  Optimize_Info *i = (Optimize_Info *)p;
  
  gcFIXUP2(i->stat_dists, gc);
  gcFIXUP2(i->sd_depths, gc);
  gcFIXUP2(i->next, gc);
  gcFIXUP2(i->use, gc);
  gcFIXUP2(i->consts, gc);
  gcFIXUP2(i->cp, gc);
  gcFIXUP2(i->top_level_consts, gc);
  gcFIXUP2(i->transitive_use, gc);
  gcFIXUP2(i->transitive_use_len, gc);
  gcFIXUP2(i->context, gc);
  gcFIXUP2(i->logger, gc);
  gcFIXUP2(i->types, gc);

  return
  gcBYTES_TO_WORDS(sizeof(Optimize_Info));
}

#define mark_optimize_info_IS_ATOMIC 0
#define mark_optimize_info_IS_CONST_SIZE 1


static int mark_once_used_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Once_Used));
}

static int mark_once_used_MARK(void *p, struct NewGC *gc) {
  Scheme_Once_Used *o = (Scheme_Once_Used *)p;
  gcMARK2(o->expr, gc);
  gcMARK2(o->info, gc);
  gcMARK2(o->next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Once_Used));
}

static int mark_once_used_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Once_Used *o = (Scheme_Once_Used *)p;
  gcFIXUP2(o->expr, gc);
  gcFIXUP2(o->info, gc);
  gcFIXUP2(o->next, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Once_Used));
}

#define mark_once_used_IS_ATOMIC 0
#define mark_once_used_IS_CONST_SIZE 1


