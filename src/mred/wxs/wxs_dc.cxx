/* DO NOT EDIT THIS FILE. */
/* This file was generated by xctocc from "wxs_dc.xc". */


#if defined(_MSC_VER)
# include "wx.h"
#endif
#if defined(OS_X)
# include "common.h"
#endif

#include "wx_dccan.h"
#include "wx_dcmem.h"
#include "wx_dcps.h"
#include "wx_gdi.h"
#ifdef wx_msw
#include "wx_mf.h"
#endif
#include "wx_types.h"
#ifdef wx_mac
#include "wx_dcpr.h"
#endif
#include "wx_rgn.h"
#include "../../wxcommon/wxGLConfig.h"
#include <math.h>

#ifdef wx_msw
# define USE_GL
#endif
#ifdef wx_mac
# define USE_GL
#endif

#ifndef USE_GL
class wxGL : public wxObject {
public:
  wxGL();

  int Ok();

  void Reset(long d);
  void SwapBuffers(void);
  void ThisContextCurrent(void);
};

wxGL::wxGL()
: wxObject(WXGC_NO_CLEANUP)
{
}
int wxGL::Ok() { return 0; }
void wxGL::SwapBuffers(void) { }
void wxGL::ThisContextCurrent(void) { }
#endif




#ifdef wx_x
# define BM_SELECTED(map) ((map)->selectedTo)
#endif
#if defined(wx_mac) || defined(wx_msw)
# define BM_SELECTED(map) ((map)->selectedInto)
#endif
# define BM_IN_USE(map) ((map)->selectedIntoDC)





#include "wxscheme.h"
#include "wxs_dc.h"

#ifdef MZ_PRECISE_GC
START_XFORM_SKIP;
#endif

static Scheme_Object *textMode_wxTRANSPARENT_sym = NULL;
static Scheme_Object *textMode_wxSOLID_sym = NULL;

static void init_symset_textMode(void) {
  REMEMBER_VAR_STACK();
  wxREGGLOB(textMode_wxTRANSPARENT_sym);
  textMode_wxTRANSPARENT_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("transparent"));
  wxREGGLOB(textMode_wxSOLID_sym);
  textMode_wxSOLID_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("solid"));
}

static int unbundle_symset_textMode(Scheme_Object *v, const char *where) {
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, v);
  if (!textMode_wxSOLID_sym) WITH_VAR_STACK(init_symset_textMode());
  if (0) { }
  else if (v == textMode_wxTRANSPARENT_sym) { READY_TO_RETURN; return wxTRANSPARENT; }
  else if (v == textMode_wxSOLID_sym) { READY_TO_RETURN; return wxSOLID; }
  if (where) WITH_VAR_STACK(scheme_wrong_type(where, "textMode symbol", -1, 0, &v));
  READY_TO_RETURN;
  return 0;
}

static Scheme_Object *bundle_symset_textMode(int v) {
  if (!textMode_wxSOLID_sym) init_symset_textMode();
  switch (v) {
  case wxTRANSPARENT: return textMode_wxTRANSPARENT_sym;
  case wxSOLID: return textMode_wxSOLID_sym;
  default: return NULL;
  }
}


static Scheme_Object *bitmapDrawStyle_wxSOLID_sym = NULL;
static Scheme_Object *bitmapDrawStyle_wxSTIPPLE_sym = NULL;
static Scheme_Object *bitmapDrawStyle_wxXOR_sym = NULL;

static void init_symset_bitmapDrawStyle(void) {
  REMEMBER_VAR_STACK();
  wxREGGLOB(bitmapDrawStyle_wxSOLID_sym);
  bitmapDrawStyle_wxSOLID_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("solid"));
  wxREGGLOB(bitmapDrawStyle_wxSTIPPLE_sym);
  bitmapDrawStyle_wxSTIPPLE_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("opaque"));
  wxREGGLOB(bitmapDrawStyle_wxXOR_sym);
  bitmapDrawStyle_wxXOR_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("xor"));
}

static int unbundle_symset_bitmapDrawStyle(Scheme_Object *v, const char *where) {
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, v);
  if (!bitmapDrawStyle_wxXOR_sym) WITH_VAR_STACK(init_symset_bitmapDrawStyle());
  if (0) { }
  else if (v == bitmapDrawStyle_wxSOLID_sym) { READY_TO_RETURN; return wxSOLID; }
  else if (v == bitmapDrawStyle_wxSTIPPLE_sym) { READY_TO_RETURN; return wxSTIPPLE; }
  else if (v == bitmapDrawStyle_wxXOR_sym) { READY_TO_RETURN; return wxXOR; }
  if (where) WITH_VAR_STACK(scheme_wrong_type(where, "bitmapDrawStyle symbol", -1, 0, &v));
  READY_TO_RETURN;
  return 0;
}



static Scheme_Object *fillKind_wxODDEVEN_RULE_sym = NULL;
static Scheme_Object *fillKind_wxWINDING_RULE_sym = NULL;

static void init_symset_fillKind(void) {
  REMEMBER_VAR_STACK();
  wxREGGLOB(fillKind_wxODDEVEN_RULE_sym);
  fillKind_wxODDEVEN_RULE_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("odd-even"));
  wxREGGLOB(fillKind_wxWINDING_RULE_sym);
  fillKind_wxWINDING_RULE_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("winding"));
}

static int unbundle_symset_fillKind(Scheme_Object *v, const char *where) {
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, v);
  if (!fillKind_wxWINDING_RULE_sym) WITH_VAR_STACK(init_symset_fillKind());
  if (0) { }
  else if (v == fillKind_wxODDEVEN_RULE_sym) { READY_TO_RETURN; return wxODDEVEN_RULE; }
  else if (v == fillKind_wxWINDING_RULE_sym) { READY_TO_RETURN; return wxWINDING_RULE; }
  if (where) WITH_VAR_STACK(scheme_wrong_type(where, "fillKind symbol", -1, 0, &v));
  READY_TO_RETURN;
  return 0;
}


static Scheme_Object *smoothingMode_0_sym = NULL;
static Scheme_Object *smoothingMode_1_sym = NULL;
static Scheme_Object *smoothingMode_2_sym = NULL;

static void init_symset_smoothingMode(void) {
  REMEMBER_VAR_STACK();
  wxREGGLOB(smoothingMode_0_sym);
  smoothingMode_0_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("unsmoothed"));
  wxREGGLOB(smoothingMode_1_sym);
  smoothingMode_1_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("smoothed"));
  wxREGGLOB(smoothingMode_2_sym);
  smoothingMode_2_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("aligned"));
}

static int unbundle_symset_smoothingMode(Scheme_Object *v, const char *where) {
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, v);
  if (!smoothingMode_2_sym) WITH_VAR_STACK(init_symset_smoothingMode());
  if (0) { }
  else if (v == smoothingMode_0_sym) { READY_TO_RETURN; return 0; }
  else if (v == smoothingMode_1_sym) { READY_TO_RETURN; return 1; }
  else if (v == smoothingMode_2_sym) { READY_TO_RETURN; return 2; }
  if (where) WITH_VAR_STACK(scheme_wrong_type(where, "smoothingMode symbol", -1, 0, &v));
  READY_TO_RETURN;
  return 0;
}

static Scheme_Object *bundle_symset_smoothingMode(int v) {
  if (!smoothingMode_2_sym) init_symset_smoothingMode();
  switch (v) {
  case 0: return smoothingMode_0_sym;
  case 1: return smoothingMode_1_sym;
  case 2: return smoothingMode_2_sym;
  default: return NULL;
  }
}



static wxColour* dcGetTextBackground(wxDC *dc)
{
  wxColour *c = NULL, *bg = NULL;
  SETUP_VAR_STACK(2);
  VAR_STACK_PUSH(0, dc);
  VAR_STACK_PUSH(1, c);

  c = WITH_VAR_STACK(new wxColour());
#ifdef MZ_PRECISE_GC
  WITH_VAR_STACK(c->gcInit_wxColour());
#endif
  bg = WITH_VAR_STACK(dc->GetTextBackground());
  WITH_VAR_STACK(c->CopyFrom(bg));
  READY_TO_RETURN;
  return c;
}

static wxColour* dcGetTextForeground(wxDC *dc)
{
  wxColour *c = NULL, *fg = NULL;
  SETUP_VAR_STACK(2);
  VAR_STACK_PUSH(0, dc);
  VAR_STACK_PUSH(1, c);

  c = WITH_VAR_STACK(new wxColour());
#ifdef MZ_PRECISE_GC
  WITH_VAR_STACK(c->gcInit_wxColour());
#endif
  fg = WITH_VAR_STACK(dc->GetTextForeground());
  WITH_VAR_STACK(c->CopyFrom(fg));
  READY_TO_RETURN;
  return c;
}

static Bool DrawBitmap(wxDC *dc, wxBitmap *bm, double x, double y, int mode, wxColour *c, wxBitmap* mask)
{
  REMEMBER_VAR_STACK();
  if (bm->Ok()) {
    return WITH_REMEMBERED_STACK(dc->Blit(x, y, bm->GetWidth(), bm->GetHeight(), bm, 0, 0, mode, c, mask));
  } else
    return FALSE;
}

static Bool DrawBitmapRegion(wxDC *dc, wxBitmap *bm, double x, double y, double dx, double dy, double dw, double dh, int mode, wxColour *c, wxBitmap* mask)
{
  REMEMBER_VAR_STACK();
  if (bm->Ok()) {
    return WITH_REMEMBERED_STACK(dc->Blit(x, y, dw, dh, bm, dx, dy, mode, c, mask));
  } else
    return FALSE;
}

static void* MyTextExtent(wxDC *dc, mzchar *s, wxFont *f, Bool combine, int offset)
{
  double w, h, d, asc;
  Scheme_Object *a[4];
  void *r;
  SETUP_VAR_STACK(3);
  VAR_STACK_PUSH_ARRAY(0, a, 4);

  a[0] = a[1] = a[2] = a[3] = NULL;

  WITH_VAR_STACK(dc->GetTextExtent((char *)s, &w, &h, &d, &asc, f, combine, TRUE, offset));
    
  a[0] = WITH_VAR_STACK(scheme_make_double(w));
  a[1] = WITH_VAR_STACK(scheme_make_double(h));
  a[2] = WITH_VAR_STACK(scheme_make_double(d));
  a[3] = WITH_VAR_STACK(scheme_make_double(asc));

  r = WITH_VAR_STACK(scheme_values(4, a));

  READY_TO_RETURN;

  return r;
}

static void* MyGetSize(wxDC *dc)
{
  double w, h;
  Scheme_Object *a[2];
  void *r;
  SETUP_VAR_STACK(3);
  VAR_STACK_PUSH_ARRAY(0, a, 2);

  a[0] = a[1] = NULL;

  dc->GetSize(&w, &h); /* no GC possible */

  a[0] = WITH_VAR_STACK(scheme_make_double(w));
  a[1] = WITH_VAR_STACK(scheme_make_double(h));

  r = WITH_VAR_STACK(scheme_values(2, a));

  READY_TO_RETURN;

  return r;
}

static void* MyGetScale(wxDC *dc)
{
  double w, h;
  Scheme_Object *a[2];
  void *r;
  SETUP_VAR_STACK(3);
  VAR_STACK_PUSH_ARRAY(0, a, 2);

  a[0] = a[1] = NULL;

  dc->GetUserScale(&w, &h); /* no GC possible */

  a[0] = WITH_VAR_STACK(scheme_make_double(w));
  a[1] = WITH_VAR_STACK(scheme_make_double(h));

  r = WITH_VAR_STACK(scheme_values(2, a));

  READY_TO_RETURN;

  return r;
}

static void* MyGetOrigin(wxDC *dc)
{
  double w, h;
  Scheme_Object *a[2];
  void *r;
  SETUP_VAR_STACK(3);
  VAR_STACK_PUSH_ARRAY(0, a, 2);

  a[0] = a[1] = NULL;

  dc->GetDeviceOrigin(&w, &h); /* no GC possible */

  a[0] = WITH_VAR_STACK(scheme_make_double(w));
  a[1] = WITH_VAR_STACK(scheme_make_double(h));

  r = WITH_VAR_STACK(scheme_values(2, a));

  READY_TO_RETURN;

  return r;
}

inline static wxGL *_GetGL(wxDC *dc)
{
#ifdef USE_GL
  return dc->GetGL();
#else
  return NULL;
#endif
}

#ifdef MZ_PRECISE_GC
END_XFORM_SKIP;
#endif
static wxMemoryDC *make_memdc(void)
{
  return new wxMemoryDC(1);
}
#ifdef MZ_PRECISE_GC
START_XFORM_SKIP;
#endif

static wxMemoryDC *temp_mdc;

static wxMemoryDC *MakeDC(wxBitmap *src)
{
  wxMemoryDC *srcdc = NULL;
  SETUP_VAR_STACK(2);
  VAR_STACK_PUSH(0, src);
  VAR_STACK_PUSH(1, srcdc);

#ifdef wx_msw
  srcdc = (wxMemoryDC *)src->selectedInto;
  if (!srcdc) {
#endif
    if (!temp_mdc) {
      wxREGGLOB(temp_mdc);
      temp_mdc = WITH_VAR_STACK(make_memdc());
    }
    WITH_VAR_STACK(temp_mdc->SelectObject(src));
    srcdc = temp_mdc;
#ifdef wx_msw
  }
#endif

  READY_TO_RETURN;

  return srcdc;
}

static void UnmakeDC(wxMemoryDC *srcdc)
{
#ifdef wx_msw
  if (srcdc == temp_mdc)
#endif
    WITH_VAR_STACK(temp_mdc->SelectObject(NULL));
}

static void dcGetARGBPixels(wxMemoryDC *dc, double x, double y, int w, int h, char *s, Bool get_alpha)
{
  int i, j, p;
  unsigned char *ss = (unsigned char *)s;
  wxColour *c = NULL;
  double xs, ys, xo, yo;
  SETUP_VAR_STACK(3);
  VAR_STACK_PUSH(0, ss);
  VAR_STACK_PUSH(1, c);
  VAR_STACK_PUSH(2, dc);

  dc->GetUserScale(&xs, &ys);
  dc->GetDeviceOrigin(&xo, &yo);
  p = 0;

  if (xs == 1 && ys == 1 && xo == 0 && yo == 0
      && WITH_VAR_STACK(dc->BeginGetPixelFast((int)x, (int)y, w, h))) {
    int xi = (int)x;
    int yi = (int)y;
    int r, g, b;
    if (!get_alpha) {
      for (j = 0; j < h; j++) {
	for (i = 0; i < w; i++) {
	  WITH_VAR_STACK(dc->GetPixelFast(xi + i, yi + j, &r, &g, &b));
	  ss[p++] = 255; /* alpha */
	  ss[p++] = r;
	  ss[p++] = g;
	  ss[p++] = b;
	}
      }
    } else {
      for (j = 0; j < h; j++) {
	for (i = 0; i < w; i++) {
	  WITH_VAR_STACK(dc->GetPixelFast(xi + i, yi + j, &r, &g, &b));
	  ss[p] = 255 - ((r + g + b) / 3);
	  p += 4;
	}
      }
    }
    WITH_VAR_STACK(dc->EndGetPixelFast());
  } else {
    c = new wxColour();

    if (!get_alpha) {
      for (j = 0; j < h; j++) {
	for (i = 0; i < w; i++) {
	  WITH_VAR_STACK(dc->GetPixel(x + i, y + j, c));
	  ss[p++] = 255; /* alpha */
	  ss[p++] = c->Red();
	  ss[p++] = c->Green();
	  ss[p++] = c->Blue();
	}
      }
    } else {
      for (j = 0; j < h; j++) {
	for (i = 0; i < w; i++) {
	  WITH_VAR_STACK(dc->GetPixel(x + i, y + j, c));
	  ss[p] = 255 - ((c->Red() + c->Green() + c->Blue()) / 3);
	  p += 4;
	}
      }
    }
  }

  READY_TO_RETURN;
}

void wxGetARGBPixels(wxBitmap *src, double x, double y, int w, int h, char *s, Bool get_alpha)
{
  wxMemoryDC *srcdc;
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, srcdc);

  srcdc = WITH_VAR_STACK(MakeDC(src));
  WITH_VAR_STACK(dcGetARGBPixels(srcdc, x, y, w, h, (char *)s, get_alpha));
  WITH_VAR_STACK(UnmakeDC(srcdc));

  READY_TO_RETURN;
}

static void dcSetARGBPixels(wxMemoryDC *dc, double x, double y, int w, int h, char *s, Bool set_alpha)
{
  int i, j, p;
  unsigned char *ss = (unsigned char *)s;
  wxColour *c = NULL;
  double xs, ys, xo, yo;
  SETUP_VAR_STACK(3);
  VAR_STACK_PUSH(0, ss);
  VAR_STACK_PUSH(1, c);
  VAR_STACK_PUSH(2, dc);

  dc->GetUserScale(&xs, &ys);
  dc->GetDeviceOrigin(&xo, &yo);
  p = 0;    

  if (xs == 1 && ys == 1 && xo == 0 && yo == 0
      && WITH_VAR_STACK(dc->BeginSetPixelFast((int)x, (int)y, w, h))) {
    int xi = (int)x;
    int yi = (int)y;
    if (!set_alpha) {
      for (j = 0; j < h; j++) {
	for (i = 0; i < w; i++) {
	  WITH_VAR_STACK(dc->SetPixelFast(xi + i, yi + j, ss[p+1], ss[p+2], ss[p+3]));
	  p += 4;
	}
      }
    } else {
      for (j = 0; j < h; j++) {
	for (i = 0; i < w; i++) {
	  WITH_VAR_STACK(dc->SetPixelFast(xi + i, yi + j, 255-ss[p], 255-ss[p], 255-ss[p]));
	  p += 4;
	}
      }
    }
    WITH_VAR_STACK(dc->EndSetPixelFast());
  } else {
    c = new wxColour();
  
    if (!set_alpha) {
      for (j = 0; j < h; j++) {
	for (i = 0; i < w; i++) {
	  WITH_VAR_STACK(c->Set(ss[p+1], ss[p+2], ss[p+3]));
	  WITH_VAR_STACK(dc->SetPixel(x + i, y + j, c));
	  p += 4;
	}
      }
    } else {
      for (j = 0; j < h; j++) {
	for (i = 0; i < w; i++) {
	  WITH_VAR_STACK(c->Set(255-ss[p], 255-ss[p], 255-ss[p]));
	  WITH_VAR_STACK(dc->SetPixel(x + i, y + j, c));
	  p += 4;
	}
      }
    }
  }

  READY_TO_RETURN;
}

static wxBitmap *dc_target(Scheme_Object *obj)
{
  wxDC *dc;
  dc = (wxDC *)((Scheme_Class_Object *)obj)->primdata;
  if (dc->__type == wxTYPE_DC_MEMORY) {
    wxBitmap *bm;
    bm = ((wxMemoryDC *)dc)->GetObject();
    if (bm)
      return bm;
  }
  return (wxBitmap *)0x1; /* dont't return NULL because that matches unspecified mask */
}

static inline double approx_dist(double x, double y) 
{
  x = fabs(x);
  y = fabs(y);
  return ((x < y) ? y : x);
}

static double my_round(double f)
/* doesn't have to deal with negtive numbers */
{
  double d, frac;
  
  frac = modf(f, &d);

  if (frac >= 0.5)  
    d += 1.0;

  return d;
}

static void ScaleSection(wxMemoryDC *dest, wxBitmap *src, 
			 double tx, double ty, double ww2, double hh2,
			 double fx, double fy, double ww, double hh,
			 wxBitmap *mask)
{
  double xs, ys, r, g, b, t, dx, dy, wt, si, sj, a, span;
  int i, j, starti, endi, startj, endj, p, xi, xj, sji, sii;
  int sbmw, sbmh, w, h, w2, h2, ispan, jspan;
  unsigned char *s = NULL, *s2 = NULL;
  wxMemoryDC *srcdc = NULL;
  SETUP_VAR_STACK(6);
  VAR_STACK_PUSH(0, s);
  VAR_STACK_PUSH(1, s2);
  VAR_STACK_PUSH(2, dest);
  VAR_STACK_PUSH(3, src);
  VAR_STACK_PUSH(4, srcdc);
  VAR_STACK_PUSH(5, mask);

  if (!dest->Ok())
    WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","draw-bitmap-section-smooth"), 
				       "dc is not ok: ",
				       WITH_VAR_STACK(objscheme_bundle_wxMemoryDC(dest))));
  if (!src->Ok())
    WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","draw-bitmap-section-smooth"), 
				       "source bitmap is not ok: ", 
				       WITH_VAR_STACK(objscheme_bundle_wxBitmap(src))));
  sbmw = WITH_VAR_STACK(src->GetWidth());
  sbmh = WITH_VAR_STACK(src->GetHeight());
  if (fx > sbmw)
    WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","draw-bitmap-section-smooth"), 
				       "x offset too large for source bitmap: ", 
				       WITH_VAR_STACK(scheme_make_double(fx))));
  if (fy > sbmh)
    WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","draw-bitmap-section-smooth"), 
				       "y offset too large for source bitmap: ", 
				       WITH_VAR_STACK(scheme_make_double(fy))));
  if ((fx + ww) > sbmw)
    WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","draw-bitmap-section-smooth"), 
				       "x offset plus width too large for source bitmap: ", 
				       WITH_VAR_STACK(scheme_make_double(fx))));
  if ((fy + hh) > sbmh)
    WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","draw-bitmap-section-smooth"), 
				       "y offset plus height too large for source bitmap: ", 
				       WITH_VAR_STACK(scheme_make_double(fy))));
  
  if (mask) {
    if (!mask->Ok()) {
      WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","draw-bitmap-section-smooth"), 
					 "mask bitmap is not ok: ", 
					 WITH_VAR_STACK(objscheme_bundle_wxBitmap(mask))));
    }
    if ((WITH_VAR_STACK(mask->GetWidth()) != sbmw)
	|| (WITH_VAR_STACK(mask->GetHeight()) != sbmh))
      WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","draw-bitmap-section-smooth"), 
					 "mask bitmap does not match source bitmap dimensions: ", 
					 WITH_VAR_STACK(objscheme_bundle_wxBitmap(mask))));
  }

  w = (int)(floor(ww + fx) - floor(fx));
  h = (int)(floor(hh + fy) - floor(fy));

  w2 = (int)(floor(ww2 + tx) - floor(tx));
  h2 = (int)(floor(hh2 + ty) - floor(ty));

  xs = (double)w2 / (double)w;
  ys = (double)h2 / (double)h;

  s = (unsigned char *)WITH_VAR_STACK(scheme_malloc_atomic(w * h * 4));
  s2 = (unsigned char *)WITH_VAR_STACK(scheme_malloc_atomic(w2 * h2 * 4));

  srcdc = WITH_VAR_STACK(MakeDC(src));
  WITH_VAR_STACK(dcGetARGBPixels(srcdc, fx, fy, w, h, (char *)s, 0));
  WITH_VAR_STACK(UnmakeDC(srcdc));

  if (mask) {
    srcdc = WITH_VAR_STACK(MakeDC(mask));
    WITH_VAR_STACK(dcGetARGBPixels(srcdc, fx, fy, w, h, (char *)s, 1));
    WITH_VAR_STACK(UnmakeDC(srcdc));

    WITH_VAR_STACK(dcGetARGBPixels(dest, tx, ty, w2, h2, (char *)s2, 0));
  }

  if (w <= w2)
    ispan = 0;
  else
    ispan = (w / w2) - 1;
  if (h <= h2)
    jspan = 0;
  else
    jspan = (h / h2) - 1;
  span = (((double)ispan + (double)jspan) / 2.0) + 0.001;

  for (j = 0; j < h2; j++) {
    sj = (double)j / ys;
    sji = (int)sj;
    startj = sji - (jspan >> 1);
    if (startj < 0)
      startj = 0;
    endj = sji + (jspan - (jspan >> 1)) + (((double)sji == sj) ? 0 : 1);
    if (endj >= h)
      endj = h - 1;
    
    for (i = 0; i < w2; i++) {
      si = (double)i / xs;
      sii = (int)si;
      starti = sii - (ispan >> 1);
      if (starti < 0)
	starti = 0;
      endi = sii + (ispan - (ispan >> 1)) + (((double)sii == si) ? 0 : 1);
      if (endi >= w)
	endi = w - 1;

      r = g = b = t = a = 0.0;

      for (xj = startj; xj <= endj; xj++) {
	dy = ((xj * ys) - j);
	for (xi = starti; xi <= endi; xi++) {
	  dx = ((xi * xs) - i);
	  wt = 1 / (span + approx_dist(dx, dy));
	  p = ((xj * w) + xi) * 4;
	  a += (wt * s[p]);
	  r += (wt * s[p+1]);
	  g += (wt * s[p+2]);
	  b += (wt * s[p+3]);
	  t += wt;
	}
      }

      r /= t;
      g /= t;
      b /= t;

      p = ((j * w2) + i) * 4;

      if (mask) {
	a /= (3.0 * 255.0 * t);
	r = (r * (1 - a)) + ((double)s2[p+1] * a);
	g = (g * (1 - a)) + ((double)s2[p+2] * a);
	b = (b * (1 - a)) + ((double)s2[p+3] * a);
      }

      s2[p+1] = (int)my_round(r);
      s2[p+2] = (int)my_round(g);
      s2[p+3] = (int)my_round(b);
    }
  }

  WITH_VAR_STACK(dcSetARGBPixels(dest, tx, ty, w2, h2, (char *)s2, 0));

#ifndef SENORA_GC_NO_FREE
  GC_free(s);
  GC_free(s2);
#endif

  READY_TO_RETURN;
}

#ifdef MZ_PRECISE_GC
END_XFORM_SKIP;
#endif

static void SetPen(wxDC *dc, wxColour *c, double pw, int style)
{
  wxPenList *pl;
  wxPen *p;
  pl = wxThePenList;
  p = pl->FindOrCreatePen(c, pw, style);
  dc->SetPen(p);
}

static void SetPen(wxDC *dc, char *cname, double pw, int style)
{
  wxPenList *pl;
  wxPen *p;
  pl = wxThePenList;
  p = pl->FindOrCreatePen(cname, pw, style);
  if (p)
    dc->SetPen(p);
  else {
    scheme_arg_mismatch(METHODNAME("dc<%>", "set-pen"), "unknown color: ", scheme_make_utf8_string(cname));
  }
}

static void SetBrush(wxDC *dc, wxColour *c, int style)
{
  wxBrushList *bl;
  wxBrush *b;
  bl = wxTheBrushList;
  b = bl->FindOrCreateBrush(c, style);
  dc->SetBrush(b);
}

static void SetBrush(wxDC *dc, char *cname, int style)
{
  wxBrushList *bl;
  wxBrush *b;
  bl = wxTheBrushList;
  b = bl->FindOrCreateBrush(cname, style);
  if (b)
    dc->SetBrush(b);
  else {
    scheme_arg_mismatch(METHODNAME("dc<%>", "set-brush"), "unknown color: ", scheme_make_utf8_string(cname));
  }
}

void wxDrawTabBase(wxDC *dc, double x, double y, double w, double h, int state)
{
#ifdef wx_mac
  dc->DrawTabBase(x, y, w, h, state);
#endif
}

void wxDrawTab(wxDC *dc, char *s, double x, double y, double w, double h, int state)
{
#ifdef wx_mac
  dc->DrawTab(s, x, y, w, h, state);
#endif
}

#ifdef MZ_PRECISE_GC
START_XFORM_SKIP;
#endif


static Scheme_Object *brushStyle_wxTRANSPARENT_sym = NULL;
static Scheme_Object *brushStyle_wxSOLID_sym = NULL;
static Scheme_Object *brushStyle_wxSTIPPLE_sym = NULL;
static Scheme_Object *brushStyle_wxXOR_sym = NULL;
static Scheme_Object *brushStyle_wxCOLOR_sym = NULL;
static Scheme_Object *brushStyle_wxBDIAGONAL_HATCH_sym = NULL;
static Scheme_Object *brushStyle_wxCROSSDIAG_HATCH_sym = NULL;
static Scheme_Object *brushStyle_wxFDIAGONAL_HATCH_sym = NULL;
static Scheme_Object *brushStyle_wxCROSS_HATCH_sym = NULL;
static Scheme_Object *brushStyle_wxHORIZONTAL_HATCH_sym = NULL;
static Scheme_Object *brushStyle_wxVERTICAL_HATCH_sym = NULL;
static Scheme_Object *brushStyle_wxPANEL_PATTERN_sym = NULL;

static void init_symset_brushStyle(void) {
  REMEMBER_VAR_STACK();
  wxREGGLOB(brushStyle_wxTRANSPARENT_sym);
  brushStyle_wxTRANSPARENT_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("transparent"));
  wxREGGLOB(brushStyle_wxSOLID_sym);
  brushStyle_wxSOLID_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("solid"));
  wxREGGLOB(brushStyle_wxSTIPPLE_sym);
  brushStyle_wxSTIPPLE_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("opaque"));
  wxREGGLOB(brushStyle_wxXOR_sym);
  brushStyle_wxXOR_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("xor"));
  wxREGGLOB(brushStyle_wxCOLOR_sym);
  brushStyle_wxCOLOR_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("hilite"));
  wxREGGLOB(brushStyle_wxBDIAGONAL_HATCH_sym);
  brushStyle_wxBDIAGONAL_HATCH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("bdiagonal-hatch"));
  wxREGGLOB(brushStyle_wxCROSSDIAG_HATCH_sym);
  brushStyle_wxCROSSDIAG_HATCH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("crossdiag-hatch"));
  wxREGGLOB(brushStyle_wxFDIAGONAL_HATCH_sym);
  brushStyle_wxFDIAGONAL_HATCH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("fdiagonal-hatch"));
  wxREGGLOB(brushStyle_wxCROSS_HATCH_sym);
  brushStyle_wxCROSS_HATCH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("cross-hatch"));
  wxREGGLOB(brushStyle_wxHORIZONTAL_HATCH_sym);
  brushStyle_wxHORIZONTAL_HATCH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("horizontal-hatch"));
  wxREGGLOB(brushStyle_wxVERTICAL_HATCH_sym);
  brushStyle_wxVERTICAL_HATCH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("vertical-hatch"));
  wxREGGLOB(brushStyle_wxPANEL_PATTERN_sym);
  brushStyle_wxPANEL_PATTERN_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("panel"));
}

static int unbundle_symset_brushStyle(Scheme_Object *v, const char *where) {
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, v);
  if (!brushStyle_wxPANEL_PATTERN_sym) WITH_VAR_STACK(init_symset_brushStyle());
  if (0) { }
  else if (v == brushStyle_wxTRANSPARENT_sym) { READY_TO_RETURN; return wxTRANSPARENT; }
  else if (v == brushStyle_wxSOLID_sym) { READY_TO_RETURN; return wxSOLID; }
  else if (v == brushStyle_wxSTIPPLE_sym) { READY_TO_RETURN; return wxSTIPPLE; }
  else if (v == brushStyle_wxXOR_sym) { READY_TO_RETURN; return wxXOR; }
  else if (v == brushStyle_wxCOLOR_sym) { READY_TO_RETURN; return wxCOLOR; }
  else if (v == brushStyle_wxBDIAGONAL_HATCH_sym) { READY_TO_RETURN; return wxBDIAGONAL_HATCH; }
  else if (v == brushStyle_wxCROSSDIAG_HATCH_sym) { READY_TO_RETURN; return wxCROSSDIAG_HATCH; }
  else if (v == brushStyle_wxFDIAGONAL_HATCH_sym) { READY_TO_RETURN; return wxFDIAGONAL_HATCH; }
  else if (v == brushStyle_wxCROSS_HATCH_sym) { READY_TO_RETURN; return wxCROSS_HATCH; }
  else if (v == brushStyle_wxHORIZONTAL_HATCH_sym) { READY_TO_RETURN; return wxHORIZONTAL_HATCH; }
  else if (v == brushStyle_wxVERTICAL_HATCH_sym) { READY_TO_RETURN; return wxVERTICAL_HATCH; }
  else if (v == brushStyle_wxPANEL_PATTERN_sym) { READY_TO_RETURN; return wxPANEL_PATTERN; }
  if (where) WITH_VAR_STACK(scheme_wrong_type(where, "brushStyle symbol", -1, 0, &v));
  READY_TO_RETURN;
  return 0;
}

static Scheme_Object *bundle_symset_brushStyle(int v) {
  if (!brushStyle_wxPANEL_PATTERN_sym) init_symset_brushStyle();
  switch (v) {
  case wxTRANSPARENT: return brushStyle_wxTRANSPARENT_sym;
  case wxSOLID: return brushStyle_wxSOLID_sym;
  case wxSTIPPLE: return brushStyle_wxSTIPPLE_sym;
  case wxXOR: return brushStyle_wxXOR_sym;
  case wxCOLOR: return brushStyle_wxCOLOR_sym;
  case wxBDIAGONAL_HATCH: return brushStyle_wxBDIAGONAL_HATCH_sym;
  case wxCROSSDIAG_HATCH: return brushStyle_wxCROSSDIAG_HATCH_sym;
  case wxFDIAGONAL_HATCH: return brushStyle_wxFDIAGONAL_HATCH_sym;
  case wxCROSS_HATCH: return brushStyle_wxCROSS_HATCH_sym;
  case wxHORIZONTAL_HATCH: return brushStyle_wxHORIZONTAL_HATCH_sym;
  case wxVERTICAL_HATCH: return brushStyle_wxVERTICAL_HATCH_sym;
  case wxPANEL_PATTERN: return brushStyle_wxPANEL_PATTERN_sym;
  default: return NULL;
  }
}


static Scheme_Object *penStyle_wxTRANSPARENT_sym = NULL;
static Scheme_Object *penStyle_wxSOLID_sym = NULL;
static Scheme_Object *penStyle_wxXOR_sym = NULL;
static Scheme_Object *penStyle_wxCOLOR_sym = NULL;
static Scheme_Object *penStyle_wxDOT_sym = NULL;
static Scheme_Object *penStyle_wxLONG_DASH_sym = NULL;
static Scheme_Object *penStyle_wxSHORT_DASH_sym = NULL;
static Scheme_Object *penStyle_wxDOT_DASH_sym = NULL;
static Scheme_Object *penStyle_wxXOR_DOT_sym = NULL;
static Scheme_Object *penStyle_wxXOR_LONG_DASH_sym = NULL;
static Scheme_Object *penStyle_wxXOR_SHORT_DASH_sym = NULL;
static Scheme_Object *penStyle_wxXOR_DOT_DASH_sym = NULL;

static void init_symset_penStyle(void) {
  REMEMBER_VAR_STACK();
  wxREGGLOB(penStyle_wxTRANSPARENT_sym);
  penStyle_wxTRANSPARENT_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("transparent"));
  wxREGGLOB(penStyle_wxSOLID_sym);
  penStyle_wxSOLID_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("solid"));
  wxREGGLOB(penStyle_wxXOR_sym);
  penStyle_wxXOR_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("xor"));
  wxREGGLOB(penStyle_wxCOLOR_sym);
  penStyle_wxCOLOR_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("hilite"));
  wxREGGLOB(penStyle_wxDOT_sym);
  penStyle_wxDOT_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("dot"));
  wxREGGLOB(penStyle_wxLONG_DASH_sym);
  penStyle_wxLONG_DASH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("long-dash"));
  wxREGGLOB(penStyle_wxSHORT_DASH_sym);
  penStyle_wxSHORT_DASH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("short-dash"));
  wxREGGLOB(penStyle_wxDOT_DASH_sym);
  penStyle_wxDOT_DASH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("dot-dash"));
  wxREGGLOB(penStyle_wxXOR_DOT_sym);
  penStyle_wxXOR_DOT_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("xor-dot"));
  wxREGGLOB(penStyle_wxXOR_LONG_DASH_sym);
  penStyle_wxXOR_LONG_DASH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("xor-long-dash"));
  wxREGGLOB(penStyle_wxXOR_SHORT_DASH_sym);
  penStyle_wxXOR_SHORT_DASH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("xor-short-dash"));
  wxREGGLOB(penStyle_wxXOR_DOT_DASH_sym);
  penStyle_wxXOR_DOT_DASH_sym = WITH_REMEMBERED_STACK(scheme_intern_symbol("xor-dot-dash"));
}

static int unbundle_symset_penStyle(Scheme_Object *v, const char *where) {
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, v);
  if (!penStyle_wxXOR_DOT_DASH_sym) WITH_VAR_STACK(init_symset_penStyle());
  if (0) { }
  else if (v == penStyle_wxTRANSPARENT_sym) { READY_TO_RETURN; return wxTRANSPARENT; }
  else if (v == penStyle_wxSOLID_sym) { READY_TO_RETURN; return wxSOLID; }
  else if (v == penStyle_wxXOR_sym) { READY_TO_RETURN; return wxXOR; }
  else if (v == penStyle_wxCOLOR_sym) { READY_TO_RETURN; return wxCOLOR; }
  else if (v == penStyle_wxDOT_sym) { READY_TO_RETURN; return wxDOT; }
  else if (v == penStyle_wxLONG_DASH_sym) { READY_TO_RETURN; return wxLONG_DASH; }
  else if (v == penStyle_wxSHORT_DASH_sym) { READY_TO_RETURN; return wxSHORT_DASH; }
  else if (v == penStyle_wxDOT_DASH_sym) { READY_TO_RETURN; return wxDOT_DASH; }
  else if (v == penStyle_wxXOR_DOT_sym) { READY_TO_RETURN; return wxXOR_DOT; }
  else if (v == penStyle_wxXOR_LONG_DASH_sym) { READY_TO_RETURN; return wxXOR_LONG_DASH; }
  else if (v == penStyle_wxXOR_SHORT_DASH_sym) { READY_TO_RETURN; return wxXOR_SHORT_DASH; }
  else if (v == penStyle_wxXOR_DOT_DASH_sym) { READY_TO_RETURN; return wxXOR_DOT_DASH; }
  if (where) WITH_VAR_STACK(scheme_wrong_type(where, "penStyle symbol", -1, 0, &v));
  READY_TO_RETURN;
  return 0;
}

static Scheme_Object *bundle_symset_penStyle(int v) {
  if (!penStyle_wxXOR_DOT_DASH_sym) init_symset_penStyle();
  switch (v) {
  case wxTRANSPARENT: return penStyle_wxTRANSPARENT_sym;
  case wxSOLID: return penStyle_wxSOLID_sym;
  case wxXOR: return penStyle_wxXOR_sym;
  case wxCOLOR: return penStyle_wxCOLOR_sym;
  case wxDOT: return penStyle_wxDOT_sym;
  case wxLONG_DASH: return penStyle_wxLONG_DASH_sym;
  case wxSHORT_DASH: return penStyle_wxSHORT_DASH_sym;
  case wxDOT_DASH: return penStyle_wxDOT_DASH_sym;
  case wxXOR_DOT: return penStyle_wxXOR_DOT_sym;
  case wxXOR_LONG_DASH: return penStyle_wxXOR_LONG_DASH_sym;
  case wxXOR_SHORT_DASH: return penStyle_wxXOR_SHORT_DASH_sym;
  case wxXOR_DOT_DASH: return penStyle_wxXOR_DOT_DASH_sym;
  default: return NULL;
  }
}







#define DO_OK_CHECK(name) if (!((wxDC *)((Scheme_Class_Object *)THEOBJ)->primdata)->Ok()) WITH_VAR_STACK(scheme_arg_mismatch(name, "device context is not ok: ", THEOBJ));



extern Scheme_Object *objscheme_bundle_wxPoint(wxPoint *);
extern wxPoint *objscheme_unbundle_wxPoint(Scheme_Object *, const char *, int);

#undef l_ADDRESS
#undef l_DEREF
#undef l_TEST
#undef l_POINT
#undef l_TYPE
#undef l_LIST_ITEM_BUNDLE
#undef l_LIST_ITEM_UNBUNDLE
#undef l_MAKE_LIST
#undef l_MAKE_ARRAY
#undef l_EXTRA
#undef l_TERMINATE
#undef l_COPY
#undef l_OKTEST
#undef l_INTTYPE

#define l_ADDRESS &
#define l_DEREF *
#define l_NEWATOMIC (AtomicGC)
#define l_NULLOK 0
#define l_TEST , l_NULLOK
#define l_POINT 
#define l_EXTRA 0
#define l_TERMINATE 
#define l_COPY l_COPYDEST.x=l_COPYSRC.x; l_COPYDEST.y=l_COPYSRC.y;
#define l_OKTEST 
#define l_INTTYPE int
#define l_DIRECTMALLOC 1

#define l_TYPE wxPoint
#define l_LIST_ITEM_BUNDLE objscheme_bundle_wxPoint
#define l_LIST_ITEM_UNBUNDLE objscheme_unbundle_wxPoint
#define l_MAKE_LIST __MakewxPointList
#define l_MAKE_ARRAY __MakewxPointArray





static Scheme_Object *l_MAKE_LIST(l_TYPE l_POINT *f, l_INTTYPE c)
{
  Scheme_Object *cdr = scheme_null, *obj = NULL;
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, cdr);

  while (c--) {
    obj = WITH_VAR_STACK(l_LIST_ITEM_BUNDLE(l_ADDRESS f[c]));
    cdr = WITH_VAR_STACK(scheme_make_pair(obj, cdr));
  }
  
  READY_TO_RETURN;

  return cdr;
}

static l_TYPE l_POINT *l_MAKE_ARRAY(Scheme_Object *l, l_INTTYPE *c, char *who)
{
  Scheme_Object *orig_l = l;
  int i = 0;
  long len;
  l_TYPE l_POINT *f = NULL;

  SETUP_VAR_STACK(3);
  VAR_STACK_PUSH(0, l);
  VAR_STACK_PUSH(1, orig_l);
  VAR_STACK_PUSH(2, f);

  len = WITH_VAR_STACK(scheme_proper_list_length(l));
  if (len < 0) WITH_VAR_STACK(scheme_wrong_type(who, "proper-list", -1, 0, &l));
  if (c) *c = len;

  if (!(len + l_EXTRA)) {
    READY_TO_RETURN;
    return NULL;
  }

#if l_DIRECTMALLOC
  f = (l_TYPE l_POINT *)WITH_VAR_STACK(GC_malloc_atomic(sizeof(l_TYPE l_POINT) * (len + l_EXTRA)));
#else
  f = WITH_VAR_STACK(new l_NEWATOMIC l_TYPE l_POINT[len + l_EXTRA]);
#endif

  while (!SCHEME_NULLP(l)) {
    if (!SCHEME_LISTP(l)) {
      WITH_VAR_STACK(scheme_arg_mismatch(who, "expected a proper list: ", orig_l));
      READY_TO_RETURN;
      return NULL;
    }

#define l_COPYDEST f[i]
#define l_COPYSRC (l_DEREF WITH_VAR_STACK(l_LIST_ITEM_UNBUNDLE(SCHEME_CAR(l), who l_TEST)))

    l_COPY

    l_OKTEST

    i++;

    l = SCHEME_CDR(l);
  }
  l_TERMINATE

  READY_TO_RETURN;

  return f;
}


/* The methods are here: */













// Also in wxWindow:


#ifndef wx_mac
#define HIDETHISSTATEMENT(x) x
#else
#define HIDETHISSTATEMENT(x) 
#endif


#ifndef wx_mac
#define CHECKTHISONE(x) x
#else
#define CHECKTHISONE(x) 1
#endif













class os_wxDC : public wxDC {
 public:

  ~os_wxDC();
#ifdef MZ_PRECISE_GC
  void gcMark();
  void gcFixup();
#endif
};

#ifdef MZ_PRECISE_GC
void os_wxDC::gcMark() {
  wxDC::gcMark();
}
void os_wxDC::gcFixup() {
  wxDC::gcFixup();
}
#endif

static Scheme_Object *os_wxDC_class;
static Scheme_Object *os_wxDC_interface;

os_wxDC::~os_wxDC()
{
    objscheme_destroy(this, (Scheme_Object *) __gc_external);
}

static Scheme_Object *os_wxDCGetAlpha(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  double r;
  objscheme_check_valid(os_wxDC_class, "get-alpha in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->GetAlpha());

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(scheme_make_double(r));
}

static Scheme_Object *os_wxDCSetAlpha(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-alpha in dc<%>", n, p);
  double x0;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double_in(p[POFFSET+0], 0, 1, "set-alpha in dc<%>"));

  
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetAlpha(x0));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCGlyphAvailable(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  Bool r;
  objscheme_check_valid(os_wxDC_class, "glyph-exists? in dc<%>", n, p);
  mzchar x0;
  class wxFont* x1 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x1);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_char(p[POFFSET+0], "glyph-exists? in dc<%>"));
  if (n > (POFFSET+1)) {
    x1 = WITH_VAR_STACK(objscheme_unbundle_wxFont(p[POFFSET+1], "glyph-exists? in dc<%>", 1));
  } else
    x1 = NULL;

  DO_OK_CHECK(METHODNAME("dc<%>","glyph-exists?"))
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->GlyphAvailable(x0, x1));

  
  
  READY_TO_RETURN;
  return (r ? scheme_true : scheme_false);
}

static Scheme_Object *os_wxDCEndPage(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "end-page in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","end-page"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->EndPage());

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCEndDoc(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "end-doc in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","end-doc-line"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->EndDoc());

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCStartPage(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "start-page in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","start-page"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->StartPage());

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCStartDoc(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  Bool r;
  objscheme_check_valid(os_wxDC_class, "start-doc in dc<%>", n, p);
  string x0 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);

  
  x0 = (string)WITH_VAR_STACK(objscheme_unbundle_string(p[POFFSET+0], "start-doc in dc<%>"));

  DO_OK_CHECK(METHODNAME("dc<%>","start-doc"))
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->StartDoc(x0));

  
  
  READY_TO_RETURN;
  return (r ? scheme_true : scheme_false);
}

static Scheme_Object *os_wxDCOk(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  Bool r;
  objscheme_check_valid(os_wxDC_class, "ok? in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->Ok());

  
  
  READY_TO_RETURN;
  return (r ? scheme_true : scheme_false);
}

static Scheme_Object *os_wxDC_GetGL(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  class wxGL* r;
  objscheme_check_valid(os_wxDC_class, "get-gl-context in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  
  r = WITH_VAR_STACK(_GetGL(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)));

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(objscheme_bundle_wxGL(r));
}

static Scheme_Object *os_wxDCMyGetSize(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  void* r;
  objscheme_check_valid(os_wxDC_class, "get-size in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-size"))
  r = WITH_VAR_STACK(MyGetSize(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)));

  
  
  READY_TO_RETURN;
  return (Scheme_Object*)r;
}

static Scheme_Object *os_wxDCdcGetTextForeground(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  class wxColour* r;
  objscheme_check_valid(os_wxDC_class, "get-text-foreground in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-text-foreground"))
  r = WITH_VAR_STACK(dcGetTextForeground(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)));

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(objscheme_bundle_wxColour(r));
}

static Scheme_Object *os_wxDCdcGetTextBackground(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  class wxColour* r;
  objscheme_check_valid(os_wxDC_class, "get-text-background in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-text-background"))
  r = WITH_VAR_STACK(dcGetTextBackground(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)));

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(objscheme_bundle_wxColour(r));
}

static Scheme_Object *os_wxDCGetPen(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  class wxPen* r;
  objscheme_check_valid(os_wxDC_class, "get-pen in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-pen"))
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->GetPen());

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(objscheme_bundle_wxPen(r));
}

static Scheme_Object *os_wxDCGetFont(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  class wxFont* r;
  objscheme_check_valid(os_wxDC_class, "get-font in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-font"))
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->GetFont());

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(objscheme_bundle_wxFont(r));
}

static Scheme_Object *os_wxDCGetBrush(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  class wxBrush* r;
  objscheme_check_valid(os_wxDC_class, "get-brush in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-brush"))
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->GetBrush());

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(objscheme_bundle_wxBrush(r));
}

static Scheme_Object *os_wxDCGetBackgroundMode(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  int r;
  objscheme_check_valid(os_wxDC_class, "get-text-mode in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-text-mode"))
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->GetBackgroundMode());

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(bundle_symset_textMode(r));
}

static Scheme_Object *os_wxDCGetBackground(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  class wxColour* r;
  objscheme_check_valid(os_wxDC_class, "get-background in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-background"))
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->GetBackground());

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(objscheme_bundle_wxColour(r));
}

static Scheme_Object *os_wxDCMyGetOrigin(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  void* r;
  objscheme_check_valid(os_wxDC_class, "get-origin in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-origin"))
  r = WITH_VAR_STACK(MyGetOrigin(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)));

  
  
  READY_TO_RETURN;
  return (Scheme_Object*)r;
}

static Scheme_Object *os_wxDCMyGetScale(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  void* r;
  objscheme_check_valid(os_wxDC_class, "get-scale in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-scale"))
  r = WITH_VAR_STACK(MyGetScale(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)));

  
  
  READY_TO_RETURN;
  return (Scheme_Object*)r;
}

static Scheme_Object *os_wxDCSetDeviceOrigin(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-origin in dc<%>", n, p);
  double x0;
  double x1;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "set-origin in dc<%>"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "set-origin in dc<%>"));

  DO_OK_CHECK(METHODNAME("dc<%>","set-origin"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetDeviceOrigin(x0, x1));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCSetUserScale(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-scale in dc<%>", n, p);
  nndouble x0;
  nndouble x1;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+0], "set-scale in dc<%>"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+1], "set-scale in dc<%>"));

  DO_OK_CHECK(METHODNAME("dc<%>","set-scale"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetUserScale(x0, x1));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCSetBackgroundMode(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-text-mode in dc<%>", n, p);
  int x0;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(unbundle_symset_textMode(p[POFFSET+0], "set-text-mode in dc<%>"));

  DO_OK_CHECK(METHODNAME("dc<%>","set-text-mode"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetBackgroundMode(x0));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCTryColour(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "try-color in dc<%>", n, p);
  class wxColour* x0 INIT_NULLED_OUT;
  class wxColour* x1 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(3);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);
  VAR_STACK_PUSH(2, x1);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxColour(p[POFFSET+0], "try-color in dc<%>", 0));
  x1 = WITH_VAR_STACK(objscheme_unbundle_wxColour(p[POFFSET+1], "try-color in dc<%>", 0));

  DO_OK_CHECK(METHODNAME("dc<%>","try-color"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->TryColour(x0, x1));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawBitmap(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  Bool r;
  objscheme_check_valid(os_wxDC_class, "draw-bitmap in dc<%>", n, p);
  class wxBitmap* x0 INIT_NULLED_OUT;
  double x1;
  double x2;
  int x3;
  class wxColour* x4 INIT_NULLED_OUT;
  class wxBitmap* x5 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(4);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);
  VAR_STACK_PUSH(2, x4);
  VAR_STACK_PUSH(3, x5);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxBitmap(p[POFFSET+0], "draw-bitmap in dc<%>", 0));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-bitmap in dc<%>"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+2], "draw-bitmap in dc<%>"));
  if (n > (POFFSET+3)) {
    x3 = WITH_VAR_STACK(unbundle_symset_bitmapDrawStyle(p[POFFSET+3], "draw-bitmap in dc<%>"));
  } else
    x3 = wxSOLID;
  if (n > (POFFSET+4)) {
    x4 = WITH_VAR_STACK(objscheme_unbundle_wxColour(p[POFFSET+4], "draw-bitmap in dc<%>", 0));
  } else
    x4 = NULL;
  if (n > (POFFSET+5)) {
    x5 = WITH_VAR_STACK(objscheme_unbundle_wxBitmap(p[POFFSET+5], "draw-bitmap in dc<%>", 1));
  } else
    x5 = NULL;

  if (x5 && !(x5->Ok())) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-bitmap"), "mask bitmap is not ok: ", p[POFFSET+5]));if (x5 && ((x0->GetWidth() != x5->GetWidth()) || (x0->GetHeight() != x5->GetHeight()))) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-bitmap"), "mask bitmap size does not match bitmap to draw: ", p[POFFSET+0]));DO_OK_CHECK(METHODNAME("dc<%>","draw-bitmap"))if (WITH_VAR_STACK(dc_target(THEOBJ)) == x0) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-bitmap"), "source bitmap is the same as the destination: ", p[POFFSET+0])); if (WITH_VAR_STACK(dc_target(THEOBJ)) == x5) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-bitmap"), "mask bitmap is the same as the destination: ", p[POFFSET+5]));
  r = WITH_VAR_STACK(DrawBitmap(((wxDC *)((Scheme_Class_Object *)p[0])->primdata), x0, x1, x2, x3, x4, x5));

  
  
  READY_TO_RETURN;
  return (r ? scheme_true : scheme_false);
}

static Scheme_Object *os_wxDCDrawBitmapRegion(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  Bool r;
  objscheme_check_valid(os_wxDC_class, "draw-bitmap-section in dc<%>", n, p);
  class wxBitmap* x0 INIT_NULLED_OUT;
  double x1;
  double x2;
  double x3;
  double x4;
  nndouble x5;
  nndouble x6;
  int x7;
  class wxColour* x8 INIT_NULLED_OUT;
  class wxBitmap* x9 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(4);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);
  VAR_STACK_PUSH(2, x8);
  VAR_STACK_PUSH(3, x9);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxBitmap(p[POFFSET+0], "draw-bitmap-section in dc<%>", 0));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-bitmap-section in dc<%>"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+2], "draw-bitmap-section in dc<%>"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+3], "draw-bitmap-section in dc<%>"));
  x4 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+4], "draw-bitmap-section in dc<%>"));
  x5 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+5], "draw-bitmap-section in dc<%>"));
  x6 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+6], "draw-bitmap-section in dc<%>"));
  if (n > (POFFSET+7)) {
    x7 = WITH_VAR_STACK(unbundle_symset_bitmapDrawStyle(p[POFFSET+7], "draw-bitmap-section in dc<%>"));
  } else
    x7 = wxSOLID;
  if (n > (POFFSET+8)) {
    x8 = WITH_VAR_STACK(objscheme_unbundle_wxColour(p[POFFSET+8], "draw-bitmap-section in dc<%>", 0));
  } else
    x8 = NULL;
  if (n > (POFFSET+9)) {
    x9 = WITH_VAR_STACK(objscheme_unbundle_wxBitmap(p[POFFSET+9], "draw-bitmap-section in dc<%>", 1));
  } else
    x9 = NULL;

  if (x9 && !(x9->Ok())) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-bitmap-section"), "mask bitmap is not ok: ", p[POFFSET+9]));if (x9 && ((x0->GetWidth() != x9->GetWidth()) || (x0->GetHeight() != x9->GetHeight()))) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-bitmap-section"), "mask bitmap size does not match bitmap to draw: ", p[POFFSET+0]));DO_OK_CHECK(METHODNAME("dc<%>","draw-bitmap-section"))if (WITH_VAR_STACK(dc_target(THEOBJ)) == x0) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-bitmap-section"), "source bitmap is the same as the destination: ", p[POFFSET+0])); if (WITH_VAR_STACK(dc_target(THEOBJ)) == x9) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-bitmap-section"), "mask bitmap is the same as the destination: ", p[POFFSET+9]));
  r = WITH_VAR_STACK(DrawBitmapRegion(((wxDC *)((Scheme_Class_Object *)p[0])->primdata), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9));

  
  
  READY_TO_RETURN;
  return (r ? scheme_true : scheme_false);
}

static Scheme_Object *os_wxDCGetCharWidth(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  double r;
  objscheme_check_valid(os_wxDC_class, "get-char-width in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-char-width"))
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->GetCharWidth());

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(scheme_make_double(r));
}

static Scheme_Object *os_wxDCGetCharHeight(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  double r;
  objscheme_check_valid(os_wxDC_class, "get-char-height in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","get-char-height"))
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->GetCharHeight());

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(scheme_make_double(r));
}

static Scheme_Object *os_wxDCMyTextExtent(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  void* r;
  objscheme_check_valid(os_wxDC_class, "get-text-extent in dc<%>", n, p);
  mzstring x0 INIT_NULLED_OUT;
  class wxFont* x1 INIT_NULLED_OUT;
  Bool x2;
  nnint x3;

  SETUP_VAR_STACK_REMEMBERED(3);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);
  VAR_STACK_PUSH(2, x1);

  
  x0 = (mzstring)WITH_VAR_STACK(objscheme_unbundle_mzstring(p[POFFSET+0], "get-text-extent in dc<%>"));
  if (n > (POFFSET+1)) {
    x1 = WITH_VAR_STACK(objscheme_unbundle_wxFont(p[POFFSET+1], "get-text-extent in dc<%>", 1));
  } else
    x1 = NULL;
  if (n > (POFFSET+2)) {
    x2 = WITH_VAR_STACK(objscheme_unbundle_bool(p[POFFSET+2], "get-text-extent in dc<%>"));
  } else
    x2 = FALSE;
  if (n > (POFFSET+3)) {
    x3 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_integer(p[POFFSET+3], "get-text-extent in dc<%>"));
  } else
    x3 = 0;

  if (x3 > SCHEME_CHAR_STRLEN_VAL(p[POFFSET+0])) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","get-text-extent"), "string index too large: ", p[POFFSET+3]));DO_OK_CHECK(METHODNAME("dc<%>","get-text-extent"))
  r = WITH_VAR_STACK(MyTextExtent(((wxDC *)((Scheme_Class_Object *)p[0])->primdata), x0, x1, x2, x3));

  
  
  READY_TO_RETURN;
  return (Scheme_Object*)r;
}

static Scheme_Object *os_wxDCGetAntiAlias(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  int r;
  objscheme_check_valid(os_wxDC_class, "get-smoothing in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->GetAntiAlias());

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(bundle_symset_smoothingMode(r));
}

static Scheme_Object *os_wxDCSetAntiAlias(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-smoothing in dc<%>", n, p);
  int x0;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(unbundle_symset_smoothingMode(p[POFFSET+0], "set-smoothing in dc<%>"));

  
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetAntiAlias(x0));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCSetTextForeground(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-text-foreground in dc<%>", n, p);
  class wxColour* x0 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxColour(p[POFFSET+0], "set-text-foreground in dc<%>", 0));

  DO_OK_CHECK(METHODNAME("dc<%>","set-text-foreground"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetTextForeground(x0));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCSetTextBackground(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-text-background in dc<%>", n, p);
  class wxColour* x0 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxColour(p[POFFSET+0], "set-text-background in dc<%>", 0));

  DO_OK_CHECK(METHODNAME("dc<%>","set-text-background"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetTextBackground(x0));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCSetBrush(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  SETUP_PRE_VAR_STACK(1);
  PRE_VAR_STACK_PUSH(0, p);
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-brush in dc<%>", n, p);
  if ((n >= (POFFSET+1)) && WITH_REMEMBERED_STACK(objscheme_istype_wxBrush(p[POFFSET+0], NULL, 0))) {
    class wxBrush* x0 INIT_NULLED_OUT;

    SETUP_VAR_STACK_PRE_REMEMBERED(2);
    VAR_STACK_PUSH(0, p);
    VAR_STACK_PUSH(1, x0);

    
    if (n != (POFFSET+1)) 
      WITH_VAR_STACK(scheme_wrong_count_m("set-brush in dc<%> (brush% case)", POFFSET+1, POFFSET+1, n, p, 1));
    x0 = WITH_VAR_STACK(objscheme_unbundle_wxBrush(p[POFFSET+0], "set-brush in dc<%> (brush% case)", 0));

    DO_OK_CHECK(METHODNAME("dc<%>","set-brush"))
    WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetBrush(x0));

    
    
    READY_TO_PRE_RETURN;
  } else if ((n >= (POFFSET+1)) && WITH_REMEMBERED_STACK(objscheme_istype_wxColour(p[POFFSET+0], NULL, 0))) {
    class wxColour* x0 INIT_NULLED_OUT;
    int x1;

    SETUP_VAR_STACK_PRE_REMEMBERED(2);
    VAR_STACK_PUSH(0, p);
    VAR_STACK_PUSH(1, x0);

    
    if (n != (POFFSET+2)) 
      WITH_VAR_STACK(scheme_wrong_count_m("set-brush in dc<%> (color% case)", POFFSET+2, POFFSET+2, n, p, 1));
    x0 = WITH_VAR_STACK(objscheme_unbundle_wxColour(p[POFFSET+0], "set-brush in dc<%> (color% case)", 0));
    x1 = WITH_VAR_STACK(unbundle_symset_brushStyle(p[POFFSET+1], "set-brush in dc<%> (color% case)"));

    DO_OK_CHECK(METHODNAME("dc<%>","set-brush"))
    WITH_VAR_STACK(SetBrush(((wxDC *)((Scheme_Class_Object *)p[0])->primdata), x0, x1));

    
    
    READY_TO_PRE_RETURN;
  } else  {
    string x0 INIT_NULLED_OUT;
    int x1;

    SETUP_VAR_STACK_PRE_REMEMBERED(2);
    VAR_STACK_PUSH(0, p);
    VAR_STACK_PUSH(1, x0);

    
    if (n != (POFFSET+2)) 
      WITH_VAR_STACK(scheme_wrong_count_m("set-brush in dc<%> (color name case)", POFFSET+2, POFFSET+2, n, p, 1));
    x0 = (string)WITH_VAR_STACK(objscheme_unbundle_string(p[POFFSET+0], "set-brush in dc<%> (color name case)"));
    x1 = WITH_VAR_STACK(unbundle_symset_brushStyle(p[POFFSET+1], "set-brush in dc<%> (color name case)"));

    DO_OK_CHECK(METHODNAME("dc<%>","set-brush"))
    WITH_VAR_STACK(SetBrush(((wxDC *)((Scheme_Class_Object *)p[0])->primdata), x0, x1));

    
    
    READY_TO_PRE_RETURN;
  }

  return scheme_void;
}

static Scheme_Object *os_wxDCSetPen(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  SETUP_PRE_VAR_STACK(1);
  PRE_VAR_STACK_PUSH(0, p);
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-pen in dc<%>", n, p);
  if ((n >= (POFFSET+1)) && WITH_REMEMBERED_STACK(objscheme_istype_wxPen(p[POFFSET+0], NULL, 0))) {
    class wxPen* x0 INIT_NULLED_OUT;

    SETUP_VAR_STACK_PRE_REMEMBERED(2);
    VAR_STACK_PUSH(0, p);
    VAR_STACK_PUSH(1, x0);

    
    if (n != (POFFSET+1)) 
      WITH_VAR_STACK(scheme_wrong_count_m("set-pen in dc<%> (pen% case)", POFFSET+1, POFFSET+1, n, p, 1));
    x0 = WITH_VAR_STACK(objscheme_unbundle_wxPen(p[POFFSET+0], "set-pen in dc<%> (pen% case)", 0));

    DO_OK_CHECK(METHODNAME("dc<%>","set-pen"))
    WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetPen(x0));

    
    
    READY_TO_PRE_RETURN;
  } else if ((n >= (POFFSET+1)) && WITH_REMEMBERED_STACK(objscheme_istype_wxColour(p[POFFSET+0], NULL, 0))) {
    class wxColour* x0 INIT_NULLED_OUT;
    double x1;
    int x2;

    SETUP_VAR_STACK_PRE_REMEMBERED(2);
    VAR_STACK_PUSH(0, p);
    VAR_STACK_PUSH(1, x0);

    
    if (n != (POFFSET+3)) 
      WITH_VAR_STACK(scheme_wrong_count_m("set-pen in dc<%> (color% case)", POFFSET+3, POFFSET+3, n, p, 1));
    x0 = WITH_VAR_STACK(objscheme_unbundle_wxColour(p[POFFSET+0], "set-pen in dc<%> (color% case)", 0));
    x1 = WITH_VAR_STACK(objscheme_unbundle_double_in(p[POFFSET+1], 0, 255, "set-pen in dc<%> (color% case)"));
    x2 = WITH_VAR_STACK(unbundle_symset_penStyle(p[POFFSET+2], "set-pen in dc<%> (color% case)"));

    DO_OK_CHECK(METHODNAME("dc<%>","set-pen"))
    WITH_VAR_STACK(SetPen(((wxDC *)((Scheme_Class_Object *)p[0])->primdata), x0, x1, x2));

    
    
    READY_TO_PRE_RETURN;
  } else  {
    string x0 INIT_NULLED_OUT;
    double x1;
    int x2;

    SETUP_VAR_STACK_PRE_REMEMBERED(2);
    VAR_STACK_PUSH(0, p);
    VAR_STACK_PUSH(1, x0);

    
    if (n != (POFFSET+3)) 
      WITH_VAR_STACK(scheme_wrong_count_m("set-pen in dc<%> (color name case)", POFFSET+3, POFFSET+3, n, p, 1));
    x0 = (string)WITH_VAR_STACK(objscheme_unbundle_string(p[POFFSET+0], "set-pen in dc<%> (color name case)"));
    x1 = WITH_VAR_STACK(objscheme_unbundle_double_in(p[POFFSET+1], 0, 255, "set-pen in dc<%> (color name case)"));
    x2 = WITH_VAR_STACK(unbundle_symset_penStyle(p[POFFSET+2], "set-pen in dc<%> (color name case)"));

    DO_OK_CHECK(METHODNAME("dc<%>","set-pen"))
    WITH_VAR_STACK(SetPen(((wxDC *)((Scheme_Class_Object *)p[0])->primdata), x0, x1, x2));

    
    
    READY_TO_PRE_RETURN;
  }

  return scheme_void;
}

static Scheme_Object *os_wxDCSetFont(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-font in dc<%>", n, p);
  class wxFont* x0 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxFont(p[POFFSET+0], "set-font in dc<%>", 0));

  DO_OK_CHECK(METHODNAME("dc<%>","set-font"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetFont(x0));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCSetBackground(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-background in dc<%>", n, p);
  class wxColour* x0 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxColour(p[POFFSET+0], "set-background in dc<%>", 0));

  DO_OK_CHECK(METHODNAME("dc<%>","set-background"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetBackground(x0));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCGetClippingRegion(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  class wxRegion* r;
  objscheme_check_valid(os_wxDC_class, "get-clipping-region in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","set-clipping-region"))
  r = WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->GetClippingRegion());

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(objscheme_bundle_wxRegion(r));
}

static Scheme_Object *os_wxDCSetClippingRegion(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-clipping-region in dc<%>", n, p);
  class wxRegion* x0 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxRegion(p[POFFSET+0], "set-clipping-region in dc<%>", 1));

  if (x0 && (x0->GetDC() != ((wxDC *)((Scheme_Class_Object *)THEOBJ)->primdata))) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","set-clipping-region"), "provided a different dc's region: ", p[POFFSET+0]));
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetClippingRegion(x0));

  DO_OK_CHECK(METHODNAME("dc<%>","set-clipping-region"))
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCSetClippingRect(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "set-clipping-rect in dc<%>", n, p);
  double x0;
  double x1;
  nndouble x2;
  nndouble x3;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "set-clipping-rect in dc<%>"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "set-clipping-rect in dc<%>"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+2], "set-clipping-rect in dc<%>"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+3], "set-clipping-rect in dc<%>"));

  if (x2 < 0) x2 = 0;if (x3 < 0) x3 = 0;DO_OK_CHECK(METHODNAME("dc<%>","set-clipping-rec"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->SetClippingRect(x0, x1, x2, x3));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawPolygon(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "draw-polygon in dc<%>", n, p);
  int x0;
  class wxPoint* x1 INIT_NULLED_OUT;
  double x2;
  double x3;
  int x4;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x1);

  
  x1 = NULL;
  if (n > (POFFSET+1)) {
    x2 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-polygon in dc<%>"));
  } else
    x2 = 0;
  if (n > (POFFSET+2)) {
    x3 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+2], "draw-polygon in dc<%>"));
  } else
    x3 = 0;
  if (n > (POFFSET+3)) {
    x4 = WITH_VAR_STACK(unbundle_symset_fillKind(p[POFFSET+3], "draw-polygon in dc<%>"));
  } else
    x4 = wxODDEVEN_RULE;

  x1 = WITH_VAR_STACK(__MakewxPointArray((0+POFFSET < n) ? p[POFFSET+0] : scheme_null, &x0, METHODNAME("dc<%>","draw-polygon")));DO_OK_CHECK(METHODNAME("dc<%>","draw-polygon"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->DrawPolygon(x0, x1, x2, x3, x4));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawLines(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "draw-lines in dc<%>", n, p);
  int x0;
  class wxPoint* x1 INIT_NULLED_OUT;
  double x2;
  double x3;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x1);

  
  x1 = NULL;
  if (n > (POFFSET+1)) {
    x2 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-lines in dc<%>"));
  } else
    x2 = 0;
  if (n > (POFFSET+2)) {
    x3 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+2], "draw-lines in dc<%>"));
  } else
    x3 = 0;

  x1 = WITH_VAR_STACK(__MakewxPointArray((0+POFFSET < n) ? p[POFFSET+0] : scheme_null, &x0, METHODNAME("dc<%>","draw-lines")));DO_OK_CHECK(METHODNAME("dc<%>","draw-lines"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->DrawLines(x0, x1, x2, x3));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawPath(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "draw-path in dc<%>", n, p);
  class wxPath* x0 INIT_NULLED_OUT;
  double x1;
  double x2;
  int x3;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxPath(p[POFFSET+0], "draw-path in dc<%>", 0));
  if (n > (POFFSET+1)) {
    x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-path in dc<%>"));
  } else
    x1 = 0.0;
  if (n > (POFFSET+2)) {
    x2 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+2], "draw-path in dc<%>"));
  } else
    x2 = 0.0;
  if (n > (POFFSET+3)) {
    x3 = WITH_VAR_STACK(unbundle_symset_fillKind(p[POFFSET+3], "draw-path in dc<%>"));
  } else
    x3 = wxODDEVEN_RULE;

  DO_OK_CHECK(METHODNAME("dc<%>","draw-path"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->DrawPath(x0, x1, x2, x3));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawEllipse(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "draw-ellipse in dc<%>", n, p);
  double x0;
  double x1;
  nndouble x2;
  nndouble x3;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "draw-ellipse in dc<%>"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-ellipse in dc<%>"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+2], "draw-ellipse in dc<%>"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+3], "draw-ellipse in dc<%>"));

  if (x2 <= 0) { READY_TO_RETURN; return scheme_void; }if (x3 <= 0) { READY_TO_RETURN; return scheme_void; }DO_OK_CHECK(METHODNAME("dc<%>","draw-ellipse"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->DrawEllipse(x0, x1, x2, x3));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawArc(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "draw-arc in dc<%>", n, p);
  double x0;
  double x1;
  nndouble x2;
  nndouble x3;
  double x4;
  double x5;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "draw-arc in dc<%>"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-arc in dc<%>"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+2], "draw-arc in dc<%>"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+3], "draw-arc in dc<%>"));
  x4 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+4], "draw-arc in dc<%>"));
  x5 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+5], "draw-arc in dc<%>"));

  DO_OK_CHECK(METHODNAME("dc<%>","draw-arc"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->DrawArc(x0, x1, x2, x3, x4, x5));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawText(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "draw-text in dc<%>", n, p);
  mzxstring x0 INIT_NULLED_OUT;
  double x1;
  double x2;
  Bool x3;
  Bool x4;
  nnint x5;
  double x6;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);

  
  x0 = (mzxstring)WITH_VAR_STACK(objscheme_unbundle_mzxstring(p[POFFSET+0], "draw-text in dc<%>"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-text in dc<%>"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+2], "draw-text in dc<%>"));
  if (n > (POFFSET+3)) {
    x3 = WITH_VAR_STACK(objscheme_unbundle_bool(p[POFFSET+3], "draw-text in dc<%>"));
  } else
    x3 = FALSE;
  if (n > (POFFSET+4)) {
    x5 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_integer(p[POFFSET+4], "draw-text in dc<%>"));
  } else
    x5 = 0;
  if (n > (POFFSET+5)) {
    x6 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+5], "draw-text in dc<%>"));
  } else
    x6 = 0.0;

  if (x5 > SCHEME_CHAR_STRLEN_VAL(p[POFFSET+0])) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-text"), "string index too large: ", p[POFFSET+5]));DO_OK_CHECK(METHODNAME("dc<%>","draw-text"))x4 = TRUE;
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->DrawText(x0, x1, x2, x3, x4, x5, x6));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawSpline(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "draw-spline in dc<%>", n, p);
  double x0;
  double x1;
  double x2;
  double x3;
  double x4;
  double x5;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "draw-spline in dc<%>"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-spline in dc<%>"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+2], "draw-spline in dc<%>"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+3], "draw-spline in dc<%>"));
  x4 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+4], "draw-spline in dc<%>"));
  x5 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+5], "draw-spline in dc<%>"));

  DO_OK_CHECK(METHODNAME("dc<%>","draw-spline"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->DrawSpline(x0, x1, x2, x3, x4, x5));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawRoundedRectangle(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "draw-rounded-rectangle in dc<%>", n, p);
  double x0;
  double x1;
  nndouble x2;
  nndouble x3;
  double x4;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "draw-rounded-rectangle in dc<%>"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-rounded-rectangle in dc<%>"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+2], "draw-rounded-rectangle in dc<%>"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+3], "draw-rounded-rectangle in dc<%>"));
  if (n > (POFFSET+4)) {
    x4 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+4], "draw-rounded-rectangle in dc<%>"));
  } else
    x4 = -0.25;

  if (x2 <= 0) { READY_TO_RETURN; return scheme_void; }if (x3 <= 0) { READY_TO_RETURN; return scheme_void; }{ if (x4 < -0.5)  WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-rounded-rectangle"), "radius must be no less than -0.5: ", p[POFFSET+4])); if (x4 > 0) { if (2 * x4 > x2) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-rounded-rectangle"), "radius is more than half the width: ", p[POFFSET+4])); if (2 * x4 > x3) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("dc<%>","draw-rounded-rectangle"), "radius is more than half the height: ", p[POFFSET+4])); } }DO_OK_CHECK(METHODNAME("dc<%>","draw-rounded-rectangle"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->DrawRoundedRectangle(x0, x1, x2, x3, x4));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawRectangle(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "draw-rectangle in dc<%>", n, p);
  double x0;
  double x1;
  nndouble x2;
  nndouble x3;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "draw-rectangle in dc<%>"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-rectangle in dc<%>"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+2], "draw-rectangle in dc<%>"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+3], "draw-rectangle in dc<%>"));

  if (x2 <= 0) { READY_TO_RETURN; return scheme_void; }if (x3 <= 0) { READY_TO_RETURN; return scheme_void; }DO_OK_CHECK(METHODNAME("dc<%>","draw-rectangle"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->DrawRectangle(x0, x1, x2, x3));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawPoint(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "draw-point in dc<%>", n, p);
  double x0;
  double x1;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "draw-point in dc<%>"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-point in dc<%>"));

  DO_OK_CHECK(METHODNAME("dc<%>","draw-point"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->DrawPoint(x0, x1));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCDrawLine(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "draw-line in dc<%>", n, p);
  double x0;
  double x1;
  double x2;
  double x3;

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "draw-line in dc<%>"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-line in dc<%>"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+2], "draw-line in dc<%>"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+3], "draw-line in dc<%>"));

  DO_OK_CHECK(METHODNAME("dc<%>","draw-line"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->DrawLine(x0, x1, x2, x3));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxDCClear(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxDC_class, "clear in dc<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  DO_OK_CHECK(METHODNAME("dc<%>","clear"))
  WITH_VAR_STACK(((wxDC *)((Scheme_Class_Object *)p[0])->primdata)->Clear());

  
  
  READY_TO_RETURN;
  return scheme_void;
}

void objscheme_setup_wxDC(Scheme_Env *env)
{
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, env);

  wxREGGLOB(os_wxDC_class);
  wxREGGLOB(os_wxDC_interface);

  os_wxDC_class = WITH_VAR_STACK(objscheme_def_prim_class(env, "dc%", "object%", NULL, 51));

  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-alpha" " method", (Scheme_Method_Prim *)os_wxDCGetAlpha, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-alpha" " method", (Scheme_Method_Prim *)os_wxDCSetAlpha, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "glyph-exists?" " method", (Scheme_Method_Prim *)os_wxDCGlyphAvailable, 1, 2));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "end-page" " method", (Scheme_Method_Prim *)os_wxDCEndPage, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "end-doc" " method", (Scheme_Method_Prim *)os_wxDCEndDoc, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "start-page" " method", (Scheme_Method_Prim *)os_wxDCStartPage, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "start-doc" " method", (Scheme_Method_Prim *)os_wxDCStartDoc, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "ok?" " method", (Scheme_Method_Prim *)os_wxDCOk, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-gl-context" " method", (Scheme_Method_Prim *)os_wxDC_GetGL, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-size" " method", (Scheme_Method_Prim *)os_wxDCMyGetSize, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-text-foreground" " method", (Scheme_Method_Prim *)os_wxDCdcGetTextForeground, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-text-background" " method", (Scheme_Method_Prim *)os_wxDCdcGetTextBackground, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-pen" " method", (Scheme_Method_Prim *)os_wxDCGetPen, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-font" " method", (Scheme_Method_Prim *)os_wxDCGetFont, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-brush" " method", (Scheme_Method_Prim *)os_wxDCGetBrush, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-text-mode" " method", (Scheme_Method_Prim *)os_wxDCGetBackgroundMode, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-background" " method", (Scheme_Method_Prim *)os_wxDCGetBackground, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-origin" " method", (Scheme_Method_Prim *)os_wxDCMyGetOrigin, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-scale" " method", (Scheme_Method_Prim *)os_wxDCMyGetScale, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-origin" " method", (Scheme_Method_Prim *)os_wxDCSetDeviceOrigin, 2, 2));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-scale" " method", (Scheme_Method_Prim *)os_wxDCSetUserScale, 2, 2));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-text-mode" " method", (Scheme_Method_Prim *)os_wxDCSetBackgroundMode, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "try-color" " method", (Scheme_Method_Prim *)os_wxDCTryColour, 2, 2));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-bitmap" " method", (Scheme_Method_Prim *)os_wxDCDrawBitmap, 3, 6));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-bitmap-section" " method", (Scheme_Method_Prim *)os_wxDCDrawBitmapRegion, 7, 10));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-char-width" " method", (Scheme_Method_Prim *)os_wxDCGetCharWidth, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-char-height" " method", (Scheme_Method_Prim *)os_wxDCGetCharHeight, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-text-extent" " method", (Scheme_Method_Prim *)os_wxDCMyTextExtent, 1, 4));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-smoothing" " method", (Scheme_Method_Prim *)os_wxDCGetAntiAlias, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-smoothing" " method", (Scheme_Method_Prim *)os_wxDCSetAntiAlias, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-text-foreground" " method", (Scheme_Method_Prim *)os_wxDCSetTextForeground, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-text-background" " method", (Scheme_Method_Prim *)os_wxDCSetTextBackground, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-brush" " method", (Scheme_Method_Prim *)os_wxDCSetBrush, 1, 2));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-pen" " method", (Scheme_Method_Prim *)os_wxDCSetPen, 1, 3));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-font" " method", (Scheme_Method_Prim *)os_wxDCSetFont, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-background" " method", (Scheme_Method_Prim *)os_wxDCSetBackground, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "get-clipping-region" " method", (Scheme_Method_Prim *)os_wxDCGetClippingRegion, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-clipping-region" " method", (Scheme_Method_Prim *)os_wxDCSetClippingRegion, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "set-clipping-rect" " method", (Scheme_Method_Prim *)os_wxDCSetClippingRect, 4, 4));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-polygon" " method", (Scheme_Method_Prim *)os_wxDCDrawPolygon, 1, 4));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-lines" " method", (Scheme_Method_Prim *)os_wxDCDrawLines, 1, 3));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-path" " method", (Scheme_Method_Prim *)os_wxDCDrawPath, 1, 4));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-ellipse" " method", (Scheme_Method_Prim *)os_wxDCDrawEllipse, 4, 4));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-arc" " method", (Scheme_Method_Prim *)os_wxDCDrawArc, 6, 6));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-text" " method", (Scheme_Method_Prim *)os_wxDCDrawText, 3, 6));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-spline" " method", (Scheme_Method_Prim *)os_wxDCDrawSpline, 6, 6));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-rounded-rectangle" " method", (Scheme_Method_Prim *)os_wxDCDrawRoundedRectangle, 4, 5));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-rectangle" " method", (Scheme_Method_Prim *)os_wxDCDrawRectangle, 4, 4));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-point" " method", (Scheme_Method_Prim *)os_wxDCDrawPoint, 2, 2));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "draw-line" " method", (Scheme_Method_Prim *)os_wxDCDrawLine, 4, 4));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxDC_class, "clear" " method", (Scheme_Method_Prim *)os_wxDCClear, 0, 0));


  WITH_VAR_STACK(scheme_made_class(os_wxDC_class));

  os_wxDC_interface = WITH_VAR_STACK(scheme_class_to_interface(os_wxDC_class, "dc" "<%>"));

  WITH_VAR_STACK(objscheme_add_global_interface(os_wxDC_interface, "dc" "<%>", env));
  WITH_VAR_STACK(objscheme_install_bundler((Objscheme_Bundler)objscheme_bundle_wxDC, wxTYPE_DC));

  READY_TO_RETURN;
}

int objscheme_istype_wxDC(Scheme_Object *obj, const char *stop, int nullOK)
{
  REMEMBER_VAR_STACK();
  if (nullOK && XC_SCHEME_NULLP(obj)) return 1;
  if (objscheme_is_a(obj,  os_wxDC_class))
    return 1;
  else {
    if (!stop)
       return 0;
    WITH_REMEMBERED_STACK(scheme_wrong_type(stop, nullOK ? "dc% object or " XC_NULL_STR: "dc% object", -1, 0, &obj));
    return 0;
  }
}

Scheme_Object *objscheme_bundle_wxDC(class wxDC *realobj)
{
  Scheme_Class_Object *obj INIT_NULLED_OUT;
  Scheme_Object *sobj INIT_NULLED_OUT;

  if (!realobj) return XC_SCHEME_NULL;

  if (realobj->__gc_external)
    return (Scheme_Object *)realobj->__gc_external;

  SETUP_VAR_STACK(2);
  VAR_STACK_PUSH(0, obj);
  VAR_STACK_PUSH(1, realobj);

  if ((realobj->__type != wxTYPE_DC) && (sobj = WITH_VAR_STACK(objscheme_bundle_by_type(realobj, realobj->__type))))
    { READY_TO_RETURN; return sobj; }
  obj = (Scheme_Class_Object *)WITH_VAR_STACK(scheme_make_uninited_object(os_wxDC_class));

  obj->primdata = realobj;
  WITH_VAR_STACK(objscheme_register_primpointer(obj, &obj->primdata));
  obj->primflag = 0;

  realobj->__gc_external = (void *)obj;
  READY_TO_RETURN;
  return (Scheme_Object *)obj;
}

class wxDC *objscheme_unbundle_wxDC(Scheme_Object *obj, const char *where, int nullOK)
{
  if (nullOK && XC_SCHEME_NULLP(obj)) return NULL;

  REMEMBER_VAR_STACK();

  (void)objscheme_istype_wxDC(obj, where, nullOK);
  Scheme_Class_Object *o = (Scheme_Class_Object *)obj;
  WITH_REMEMBERED_STACK(objscheme_check_valid(NULL, NULL, 0, &obj));
  if (o->primflag)
    return (os_wxDC *)o->primdata;
  else
    return (wxDC *)o->primdata;
}




static Scheme_Object *wxDCGlobalwxDrawTab(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  class wxDC* x0 INIT_NULLED_OUT;
  string x1 INIT_NULLED_OUT;
  double x2;
  double x3;
  double x4;
  double x5;
  int x6;

  SETUP_VAR_STACK_REMEMBERED(3);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);
  VAR_STACK_PUSH(2, x1);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxDC(p[0+0], "draw-tab in dc%", 0));
  x1 = (string)WITH_VAR_STACK(objscheme_unbundle_string(p[0+1], "draw-tab in dc%"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_double(p[0+2], "draw-tab in dc%"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_double(p[0+3], "draw-tab in dc%"));
  x4 = WITH_VAR_STACK(objscheme_unbundle_double(p[0+4], "draw-tab in dc%"));
  x5 = WITH_VAR_STACK(objscheme_unbundle_double(p[0+5], "draw-tab in dc%"));
  x6 = WITH_VAR_STACK(objscheme_unbundle_integer(p[0+6], "draw-tab in dc%"));

  
  WITH_VAR_STACK(wxDrawTab(x0, x1, x2, x3, x4, x5, x6));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *wxDCGlobalwxDrawTabBase(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  class wxDC* x0 INIT_NULLED_OUT;
  double x1;
  double x2;
  double x3;
  double x4;
  int x5;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxDC(p[0+0], "draw-tab-base in dc%", 0));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[0+1], "draw-tab-base in dc%"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_double(p[0+2], "draw-tab-base in dc%"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_double(p[0+3], "draw-tab-base in dc%"));
  x4 = WITH_VAR_STACK(objscheme_unbundle_double(p[0+4], "draw-tab-base in dc%"));
  x5 = WITH_VAR_STACK(objscheme_unbundle_integer(p[0+5], "draw-tab-base in dc%"));

  
  WITH_VAR_STACK(wxDrawTabBase(x0, x1, x2, x3, x4, x5));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

void objscheme_setup_wxDCGlobal(Scheme_Env *env)
{
  Scheme_Object *functmp INIT_NULLED_OUT;
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, env);
  functmp = WITH_VAR_STACK(scheme_make_prim_w_arity((Scheme_Prim *)wxDCGlobalwxDrawTab, "draw-tab", 7, 7));
  WITH_VAR_STACK(scheme_install_xc_global("draw-tab", functmp, env));
  functmp = WITH_VAR_STACK(scheme_make_prim_w_arity((Scheme_Prim *)wxDCGlobalwxDrawTabBase, "draw-tab-base", 6, 6));
  WITH_VAR_STACK(scheme_install_xc_global("draw-tab-base", functmp, env));
  READY_TO_RETURN;
}










class os_wxMemoryDC : public wxMemoryDC {
 public:

  os_wxMemoryDC CONSTRUCTOR_ARGS(());
  ~os_wxMemoryDC();
#ifdef MZ_PRECISE_GC
  void gcMark();
  void gcFixup();
#endif
};

#ifdef MZ_PRECISE_GC
void os_wxMemoryDC::gcMark() {
  wxMemoryDC::gcMark();
}
void os_wxMemoryDC::gcFixup() {
  wxMemoryDC::gcFixup();
}
#endif

static Scheme_Object *os_wxMemoryDC_class;

os_wxMemoryDC::os_wxMemoryDC CONSTRUCTOR_ARGS(())
CONSTRUCTOR_INIT(: wxMemoryDC())
{
}

os_wxMemoryDC::~os_wxMemoryDC()
{
    objscheme_destroy(this, (Scheme_Object *) __gc_external);
}

static Scheme_Object *os_wxMemoryDCGetObject(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  class wxBitmap* r;
  objscheme_check_valid(os_wxMemoryDC_class, "get-bitmap in bitmap-dc%", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  
  r = WITH_VAR_STACK(((wxMemoryDC *)((Scheme_Class_Object *)p[0])->primdata)->GetObject());

  
  
  READY_TO_RETURN;
  return WITH_REMEMBERED_STACK(objscheme_bundle_wxBitmap(r));
}

static Scheme_Object *os_wxMemoryDCSelectObject(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxMemoryDC_class, "set-bitmap in bitmap-dc%", n, p);
  class wxBitmap* x0 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxBitmap(p[POFFSET+0], "set-bitmap in bitmap-dc%", 1));

  if (x0) { if (!x0->Ok()) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","set-bitmap"), "bad bitmap: ", p[POFFSET+0])); if (BM_SELECTED(x0)) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","set-bitmap"), "bitmap is already installed into a bitmap-dc%: ", p[POFFSET+0])); if (BM_IN_USE(x0)) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","set-bitmap"), "bitmap is currently installed as a control label or pen/brush stipple: ", p[POFFSET+0])); }
  WITH_VAR_STACK(((wxMemoryDC *)((Scheme_Class_Object *)p[0])->primdata)->SelectObject(x0));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxMemoryDCScaleSection(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxMemoryDC_class, "draw-bitmap-section-smooth in bitmap-dc%", n, p);
  class wxBitmap* x0 INIT_NULLED_OUT;
  double x1;
  double x2;
  nndouble x3;
  nndouble x4;
  double x5;
  double x6;
  nndouble x7;
  nndouble x8;
  class wxBitmap* x9 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(3);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);
  VAR_STACK_PUSH(2, x9);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_wxBitmap(p[POFFSET+0], "draw-bitmap-section-smooth in bitmap-dc%", 0));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "draw-bitmap-section-smooth in bitmap-dc%"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+2], "draw-bitmap-section-smooth in bitmap-dc%"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+3], "draw-bitmap-section-smooth in bitmap-dc%"));
  x4 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+4], "draw-bitmap-section-smooth in bitmap-dc%"));
  x5 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+5], "draw-bitmap-section-smooth in bitmap-dc%"));
  x6 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+6], "draw-bitmap-section-smooth in bitmap-dc%"));
  x7 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+7], "draw-bitmap-section-smooth in bitmap-dc%"));
  x8 = WITH_VAR_STACK(objscheme_unbundle_nonnegative_double(p[POFFSET+8], "draw-bitmap-section-smooth in bitmap-dc%"));
  if (n > (POFFSET+9)) {
    x9 = WITH_VAR_STACK(objscheme_unbundle_wxBitmap(p[POFFSET+9], "draw-bitmap-section-smooth in bitmap-dc%", 1));
  } else
    x9 = NULL;

  
  WITH_VAR_STACK(ScaleSection(((wxMemoryDC *)((Scheme_Class_Object *)p[0])->primdata), x0, x1, x2, x3, x4, x5, x6, x7, x8, x9));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxMemoryDCdcSetARGBPixels(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxMemoryDC_class, "set-argb-pixels in bitmap-dc%", n, p);
  double x0;
  double x1;
  int x2;
  int x3;
  bstring x4 INIT_NULLED_OUT;
  Bool x5;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x4);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "set-argb-pixels in bitmap-dc%"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "set-argb-pixels in bitmap-dc%"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_integer_in(p[POFFSET+2], 0, 10000, "set-argb-pixels in bitmap-dc%"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_integer_in(p[POFFSET+3], 0, 10000, "set-argb-pixels in bitmap-dc%"));
  x4 = (bstring)WITH_VAR_STACK(objscheme_unbundle_bstring(p[POFFSET+4], "set-argb-pixels in bitmap-dc%"));
  if (n > (POFFSET+5)) {
    x5 = WITH_VAR_STACK(objscheme_unbundle_bool(p[POFFSET+5], "set-argb-pixels in bitmap-dc%"));
  } else
    x5 = FALSE;

  DO_OK_CHECK(METHODNAME("bitmap-dc%","set-argb-pixels"))if (SCHEME_BYTE_STRTAG_VAL(p[4+POFFSET]) < (x2 * x3 * 4)) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","set-argb-pixels"), "byte string too short: ", p[4+POFFSET]));
  WITH_VAR_STACK(dcSetARGBPixels(((wxMemoryDC *)((Scheme_Class_Object *)p[0])->primdata), x0, x1, x2, x3, x4, x5));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxMemoryDCdcGetARGBPixels(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxMemoryDC_class, "get-argb-pixels in bitmap-dc%", n, p);
  double x0;
  double x1;
  int x2;
  int x3;
  wbstring x4 INIT_NULLED_OUT;
  Bool x5;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x4);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "get-argb-pixels in bitmap-dc%"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "get-argb-pixels in bitmap-dc%"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_integer_in(p[POFFSET+2], 0, 10000, "get-argb-pixels in bitmap-dc%"));
  x3 = WITH_VAR_STACK(objscheme_unbundle_integer_in(p[POFFSET+3], 0, 10000, "get-argb-pixels in bitmap-dc%"));
  x4 = (wbstring)WITH_VAR_STACK(objscheme_unbundle_mutable_bstring(p[POFFSET+4], "get-argb-pixels in bitmap-dc%"));
  if (n > (POFFSET+5)) {
    x5 = WITH_VAR_STACK(objscheme_unbundle_bool(p[POFFSET+5], "get-argb-pixels in bitmap-dc%"));
  } else
    x5 = FALSE;

  DO_OK_CHECK(METHODNAME("bitmap-dc%","get-argb-pixels"))if (SCHEME_BYTE_STRTAG_VAL(p[4+POFFSET]) < (x2 * x3 * 4)) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("bitmap-dc%","get-argb-pixels"), "byte string too short: ", p[4+POFFSET]));
  WITH_VAR_STACK(dcGetARGBPixels(((wxMemoryDC *)((Scheme_Class_Object *)p[0])->primdata), x0, x1, x2, x3, x4, x5));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxMemoryDCSetPixel(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxMemoryDC_class, "set-pixel in bitmap-dc%", n, p);
  double x0;
  double x1;
  class wxColour* x2 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x2);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "set-pixel in bitmap-dc%"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "set-pixel in bitmap-dc%"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_wxColour(p[POFFSET+2], "set-pixel in bitmap-dc%", 0));

  DO_OK_CHECK(METHODNAME("bitmap-dc%","set-pixel"))
  WITH_VAR_STACK(((wxMemoryDC *)((Scheme_Class_Object *)p[0])->primdata)->SetPixel(x0, x1, x2));

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxMemoryDCGetPixel(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  Bool r;
  objscheme_check_valid(os_wxMemoryDC_class, "get-pixel in bitmap-dc%", n, p);
  double x0;
  double x1;
  class wxColour* x2 INIT_NULLED_OUT;

  SETUP_VAR_STACK_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x2);

  
  x0 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+0], "get-pixel in bitmap-dc%"));
  x1 = WITH_VAR_STACK(objscheme_unbundle_double(p[POFFSET+1], "get-pixel in bitmap-dc%"));
  x2 = WITH_VAR_STACK(objscheme_unbundle_wxColour(p[POFFSET+2], "get-pixel in bitmap-dc%", 0));

  DO_OK_CHECK(METHODNAME("bitmap-dc%","get-pixel"))
  r = WITH_VAR_STACK(((wxMemoryDC *)((Scheme_Class_Object *)p[0])->primdata)->GetPixel(x0, x1, x2));

  
  
  READY_TO_RETURN;
  return (r ? scheme_true : scheme_false);
}

static Scheme_Object *os_wxMemoryDC_ConstructScheme(int n,  Scheme_Object *p[])
{
  SETUP_PRE_VAR_STACK(1);
  PRE_VAR_STACK_PUSH(0, p);
  os_wxMemoryDC *realobj INIT_NULLED_OUT;
  REMEMBER_VAR_STACK();

  SETUP_VAR_STACK_PRE_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, realobj);

  
  if (n != (POFFSET+0)) 
    WITH_VAR_STACK(scheme_wrong_count_m("initialization in bitmap-dc%", POFFSET+0, POFFSET+0, n, p, 1));

  
  realobj = WITH_VAR_STACK(new os_wxMemoryDC CONSTRUCTOR_ARGS(()));
#ifdef MZ_PRECISE_GC
  WITH_VAR_STACK(realobj->gcInit_wxMemoryDC());
#endif
  realobj->__gc_external = (void *)p[0];
  
  
  READY_TO_RETURN;
  ((Scheme_Class_Object *)p[0])->primdata = realobj;
  ((Scheme_Class_Object *)p[0])->primflag = 1;
  WITH_REMEMBERED_STACK(objscheme_register_primpointer(p[0], &((Scheme_Class_Object *)p[0])->primdata));
  return scheme_void;
}

void objscheme_setup_wxMemoryDC(Scheme_Env *env)
{
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, env);

  wxREGGLOB(os_wxMemoryDC_class);

  os_wxMemoryDC_class = WITH_VAR_STACK(objscheme_def_prim_class(env, "bitmap-dc%", "dc%", (Scheme_Method_Prim *)os_wxMemoryDC_ConstructScheme, 7));

  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxMemoryDC_class, "get-bitmap" " method", (Scheme_Method_Prim *)os_wxMemoryDCGetObject, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxMemoryDC_class, "set-bitmap" " method", (Scheme_Method_Prim *)os_wxMemoryDCSelectObject, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxMemoryDC_class, "draw-bitmap-section-smooth" " method", (Scheme_Method_Prim *)os_wxMemoryDCScaleSection, 9, 10));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxMemoryDC_class, "set-argb-pixels" " method", (Scheme_Method_Prim *)os_wxMemoryDCdcSetARGBPixels, 5, 6));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxMemoryDC_class, "get-argb-pixels" " method", (Scheme_Method_Prim *)os_wxMemoryDCdcGetARGBPixels, 5, 6));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxMemoryDC_class, "set-pixel" " method", (Scheme_Method_Prim *)os_wxMemoryDCSetPixel, 3, 3));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxMemoryDC_class, "get-pixel" " method", (Scheme_Method_Prim *)os_wxMemoryDCGetPixel, 3, 3));


  WITH_VAR_STACK(scheme_made_class(os_wxMemoryDC_class));

  WITH_VAR_STACK(objscheme_install_bundler((Objscheme_Bundler)objscheme_bundle_wxMemoryDC, wxTYPE_DC_MEMORY));

  READY_TO_RETURN;
}

int objscheme_istype_wxMemoryDC(Scheme_Object *obj, const char *stop, int nullOK)
{
  REMEMBER_VAR_STACK();
  if (nullOK && XC_SCHEME_NULLP(obj)) return 1;
  if (objscheme_is_a(obj,  os_wxMemoryDC_class))
    return 1;
  else {
    if (!stop)
       return 0;
    WITH_REMEMBERED_STACK(scheme_wrong_type(stop, nullOK ? "bitmap-dc% object or " XC_NULL_STR: "bitmap-dc% object", -1, 0, &obj));
    return 0;
  }
}

Scheme_Object *objscheme_bundle_wxMemoryDC(class wxMemoryDC *realobj)
{
  Scheme_Class_Object *obj INIT_NULLED_OUT;
  Scheme_Object *sobj INIT_NULLED_OUT;

  if (!realobj) return XC_SCHEME_NULL;

  if (realobj->__gc_external)
    return (Scheme_Object *)realobj->__gc_external;

  SETUP_VAR_STACK(2);
  VAR_STACK_PUSH(0, obj);
  VAR_STACK_PUSH(1, realobj);

  if ((realobj->__type != wxTYPE_DC_MEMORY) && (sobj = WITH_VAR_STACK(objscheme_bundle_by_type(realobj, realobj->__type))))
    { READY_TO_RETURN; return sobj; }
  obj = (Scheme_Class_Object *)WITH_VAR_STACK(scheme_make_uninited_object(os_wxMemoryDC_class));

  obj->primdata = realobj;
  WITH_VAR_STACK(objscheme_register_primpointer(obj, &obj->primdata));
  obj->primflag = 0;

  realobj->__gc_external = (void *)obj;
  READY_TO_RETURN;
  return (Scheme_Object *)obj;
}

class wxMemoryDC *objscheme_unbundle_wxMemoryDC(Scheme_Object *obj, const char *where, int nullOK)
{
  if (nullOK && XC_SCHEME_NULLP(obj)) return NULL;

  REMEMBER_VAR_STACK();

  (void)objscheme_istype_wxMemoryDC(obj, where, nullOK);
  Scheme_Class_Object *o = (Scheme_Class_Object *)obj;
  WITH_REMEMBERED_STACK(objscheme_check_valid(NULL, NULL, 0, &obj));
  if (o->primflag)
    return (os_wxMemoryDC *)o->primdata;
  else
    return (wxMemoryDC *)o->primdata;
}







class os_wxPostScriptDC : public wxPostScriptDC {
 public:

  os_wxPostScriptDC CONSTRUCTOR_ARGS((Bool x0 = TRUE, class wxWindow* x1 = NULL, Bool x2 = FALSE, Bool x3 = TRUE));
  ~os_wxPostScriptDC();
#ifdef MZ_PRECISE_GC
  void gcMark();
  void gcFixup();
#endif
};

#ifdef MZ_PRECISE_GC
void os_wxPostScriptDC::gcMark() {
  wxPostScriptDC::gcMark();
}
void os_wxPostScriptDC::gcFixup() {
  wxPostScriptDC::gcFixup();
}
#endif

static Scheme_Object *os_wxPostScriptDC_class;

os_wxPostScriptDC::os_wxPostScriptDC CONSTRUCTOR_ARGS((Bool x0, class wxWindow* x1, Bool x2, Bool x3))
CONSTRUCTOR_INIT(: wxPostScriptDC(x0, x1, x2, x3))
{
}

os_wxPostScriptDC::~os_wxPostScriptDC()
{
    objscheme_destroy(this, (Scheme_Object *) __gc_external);
}

static Scheme_Object *os_wxPostScriptDC_ConstructScheme(int n,  Scheme_Object *p[])
{
  SETUP_PRE_VAR_STACK(1);
  PRE_VAR_STACK_PUSH(0, p);
  os_wxPostScriptDC *realobj INIT_NULLED_OUT;
  REMEMBER_VAR_STACK();
  Bool x0;
  class wxWindow* x1 INIT_NULLED_OUT;
  Bool x2;
  Bool x3;

  SETUP_VAR_STACK_PRE_REMEMBERED(3);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, realobj);
  VAR_STACK_PUSH(2, x1);

  
  if ((n > (POFFSET+4))) 
    WITH_VAR_STACK(scheme_wrong_count_m("initialization in post-script-dc%", POFFSET+POFFSET, POFFSET+4, n, p, 1));
  if (n > (POFFSET+0)) {
    x0 = WITH_VAR_STACK(objscheme_unbundle_bool(p[POFFSET+0], "initialization in post-script-dc%"));
  } else
    x0 = TRUE;
  if (n > (POFFSET+1)) {
    x1 = WITH_VAR_STACK(objscheme_unbundle_wxWindow(p[POFFSET+1], "initialization in post-script-dc%", 1));
  } else
    x1 = NULL;
  if (n > (POFFSET+2)) {
    x2 = WITH_VAR_STACK(objscheme_unbundle_bool(p[POFFSET+2], "initialization in post-script-dc%"));
  } else
    x2 = FALSE;
  if (n > (POFFSET+3)) {
    x3 = WITH_VAR_STACK(objscheme_unbundle_bool(p[POFFSET+3], "initialization in post-script-dc%"));
  } else
    x3 = TRUE;

  if (x1 && !wxSubType(((wxObject *)x1)->__type, wxTYPE_FRAME) && !wxSubType(((wxObject *)x1)->__type, wxTYPE_DIALOG_BOX)) scheme_wrong_type(METHODNAME("post-script-dc%","initialization"), "frame or dialog box", POFFSET+1, n, p);
  realobj = WITH_VAR_STACK(new os_wxPostScriptDC CONSTRUCTOR_ARGS((x0, x1, x2, x3)));
#ifdef MZ_PRECISE_GC
  WITH_VAR_STACK(realobj->gcInit_wxPostScriptDC(x0, x1, x2, x3));
#endif
  realobj->__gc_external = (void *)p[0];
  
  
  READY_TO_RETURN;
  ((Scheme_Class_Object *)p[0])->primdata = realobj;
  ((Scheme_Class_Object *)p[0])->primflag = 1;
  WITH_REMEMBERED_STACK(objscheme_register_primpointer(p[0], &((Scheme_Class_Object *)p[0])->primdata));
  return scheme_void;
}

void objscheme_setup_wxPostScriptDC(Scheme_Env *env)
{
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, env);

  wxREGGLOB(os_wxPostScriptDC_class);

  os_wxPostScriptDC_class = WITH_VAR_STACK(objscheme_def_prim_class(env, "post-script-dc%", "dc%", (Scheme_Method_Prim *)os_wxPostScriptDC_ConstructScheme, 0));



  WITH_VAR_STACK(scheme_made_class(os_wxPostScriptDC_class));

  WITH_VAR_STACK(objscheme_install_bundler((Objscheme_Bundler)objscheme_bundle_wxPostScriptDC, wxTYPE_DC_POSTSCRIPT));

  READY_TO_RETURN;
}

int objscheme_istype_wxPostScriptDC(Scheme_Object *obj, const char *stop, int nullOK)
{
  REMEMBER_VAR_STACK();
  if (nullOK && XC_SCHEME_NULLP(obj)) return 1;
  if (objscheme_is_a(obj,  os_wxPostScriptDC_class))
    return 1;
  else {
    if (!stop)
       return 0;
    WITH_REMEMBERED_STACK(scheme_wrong_type(stop, nullOK ? "post-script-dc% object or " XC_NULL_STR: "post-script-dc% object", -1, 0, &obj));
    return 0;
  }
}

Scheme_Object *objscheme_bundle_wxPostScriptDC(class wxPostScriptDC *realobj)
{
  Scheme_Class_Object *obj INIT_NULLED_OUT;
  Scheme_Object *sobj INIT_NULLED_OUT;

  if (!realobj) return XC_SCHEME_NULL;

  if (realobj->__gc_external)
    return (Scheme_Object *)realobj->__gc_external;

  SETUP_VAR_STACK(2);
  VAR_STACK_PUSH(0, obj);
  VAR_STACK_PUSH(1, realobj);

  if ((realobj->__type != wxTYPE_DC_POSTSCRIPT) && (sobj = WITH_VAR_STACK(objscheme_bundle_by_type(realobj, realobj->__type))))
    { READY_TO_RETURN; return sobj; }
  obj = (Scheme_Class_Object *)WITH_VAR_STACK(scheme_make_uninited_object(os_wxPostScriptDC_class));

  obj->primdata = realobj;
  WITH_VAR_STACK(objscheme_register_primpointer(obj, &obj->primdata));
  obj->primflag = 0;

  realobj->__gc_external = (void *)obj;
  READY_TO_RETURN;
  return (Scheme_Object *)obj;
}

class wxPostScriptDC *objscheme_unbundle_wxPostScriptDC(Scheme_Object *obj, const char *where, int nullOK)
{
  if (nullOK && XC_SCHEME_NULLP(obj)) return NULL;

  REMEMBER_VAR_STACK();

  (void)objscheme_istype_wxPostScriptDC(obj, where, nullOK);
  Scheme_Class_Object *o = (Scheme_Class_Object *)obj;
  WITH_REMEMBERED_STACK(objscheme_check_valid(NULL, NULL, 0, &obj));
  if (o->primflag)
    return (os_wxPostScriptDC *)o->primdata;
  else
    return (wxPostScriptDC *)o->primdata;
}


#ifdef MZ_PRECISE_GC
END_XFORM_SKIP;
#endif

#ifdef wx_x

class basePrinterDC : public wxObject
{
public:
  basePrinterDC(wxWindow *w);
};

basePrinterDC::basePrinterDC(wxWindow *)
{
  scheme_raise_exn(MZEXN_FAIL_UNSUPPORTED,
		   "%s", 
		   METHODNAME("printer-dc%","initialization")": not supported for X Windows");
}

#else

class basePrinterDC : public wxPrinterDC
{
public:
  basePrinterDC(wxWindow *w);
};

basePrinterDC::basePrinterDC(wxWindow *w) 
: wxPrinterDC( )
{
}

#endif

#ifdef MZ_PRECISE_GC
START_XFORM_SKIP;
#endif




class os_basePrinterDC : public basePrinterDC {
 public:

  os_basePrinterDC CONSTRUCTOR_ARGS((class wxWindow* x0 = NULL));
  ~os_basePrinterDC();
#ifdef MZ_PRECISE_GC
  void gcMark();
  void gcFixup();
#endif
};

#ifdef MZ_PRECISE_GC
void os_basePrinterDC::gcMark() {
  basePrinterDC::gcMark();
}
void os_basePrinterDC::gcFixup() {
  basePrinterDC::gcFixup();
}
#endif

static Scheme_Object *os_basePrinterDC_class;

os_basePrinterDC::os_basePrinterDC CONSTRUCTOR_ARGS((class wxWindow* x0))
CONSTRUCTOR_INIT(: basePrinterDC(x0))
{
}

os_basePrinterDC::~os_basePrinterDC()
{
    objscheme_destroy(this, (Scheme_Object *) __gc_external);
}

static Scheme_Object *os_basePrinterDC_ConstructScheme(int n,  Scheme_Object *p[])
{
  SETUP_PRE_VAR_STACK(1);
  PRE_VAR_STACK_PUSH(0, p);
  os_basePrinterDC *realobj INIT_NULLED_OUT;
  REMEMBER_VAR_STACK();
  class wxWindow* x0 INIT_NULLED_OUT;

  SETUP_VAR_STACK_PRE_REMEMBERED(3);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, realobj);
  VAR_STACK_PUSH(2, x0);

  
  if ((n > (POFFSET+1))) 
    WITH_VAR_STACK(scheme_wrong_count_m("initialization in printer-dc%", POFFSET+POFFSET, POFFSET+1, n, p, 1));
  if (n > (POFFSET+0)) {
    x0 = WITH_VAR_STACK(objscheme_unbundle_wxWindow(p[POFFSET+0], "initialization in printer-dc%", 1));
  } else
    x0 = NULL;

  if (x0 && !wxSubType(((wxObject *)x0)->__type, wxTYPE_FRAME) && !wxSubType(((wxObject *)x0)->__type, wxTYPE_DIALOG_BOX)) scheme_wrong_type(METHODNAME("printer-dc%","initialization"), "frame or dialog box", POFFSET+0, n, p);
  realobj = WITH_VAR_STACK(new os_basePrinterDC CONSTRUCTOR_ARGS((x0)));
#ifdef MZ_PRECISE_GC
  WITH_VAR_STACK(realobj->gcInit_basePrinterDC(x0));
#endif
  realobj->__gc_external = (void *)p[0];
  
  
  READY_TO_RETURN;
  ((Scheme_Class_Object *)p[0])->primdata = realobj;
  ((Scheme_Class_Object *)p[0])->primflag = 1;
  WITH_REMEMBERED_STACK(objscheme_register_primpointer(p[0], &((Scheme_Class_Object *)p[0])->primdata));
  return scheme_void;
}

void objscheme_setup_basePrinterDC(Scheme_Env *env)
{
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, env);

  wxREGGLOB(os_basePrinterDC_class);

  os_basePrinterDC_class = WITH_VAR_STACK(objscheme_def_prim_class(env, "printer-dc%", "dc%", (Scheme_Method_Prim *)os_basePrinterDC_ConstructScheme, 0));



  WITH_VAR_STACK(scheme_made_class(os_basePrinterDC_class));

  WITH_VAR_STACK(objscheme_install_bundler((Objscheme_Bundler)objscheme_bundle_basePrinterDC, wxTYPE_DC_PRINTER));

  READY_TO_RETURN;
}

int objscheme_istype_basePrinterDC(Scheme_Object *obj, const char *stop, int nullOK)
{
  REMEMBER_VAR_STACK();
  if (nullOK && XC_SCHEME_NULLP(obj)) return 1;
  if (objscheme_is_a(obj,  os_basePrinterDC_class))
    return 1;
  else {
    if (!stop)
       return 0;
    WITH_REMEMBERED_STACK(scheme_wrong_type(stop, nullOK ? "printer-dc% object or " XC_NULL_STR: "printer-dc% object", -1, 0, &obj));
    return 0;
  }
}

Scheme_Object *objscheme_bundle_basePrinterDC(class basePrinterDC *realobj)
{
  Scheme_Class_Object *obj INIT_NULLED_OUT;
  Scheme_Object *sobj INIT_NULLED_OUT;

  if (!realobj) return XC_SCHEME_NULL;

  if (realobj->__gc_external)
    return (Scheme_Object *)realobj->__gc_external;

  SETUP_VAR_STACK(2);
  VAR_STACK_PUSH(0, obj);
  VAR_STACK_PUSH(1, realobj);

  if ((realobj->__type != wxTYPE_DC_PRINTER) && (sobj = WITH_VAR_STACK(objscheme_bundle_by_type(realobj, realobj->__type))))
    { READY_TO_RETURN; return sobj; }
  obj = (Scheme_Class_Object *)WITH_VAR_STACK(scheme_make_uninited_object(os_basePrinterDC_class));

  obj->primdata = realobj;
  WITH_VAR_STACK(objscheme_register_primpointer(obj, &obj->primdata));
  obj->primflag = 0;

  realobj->__gc_external = (void *)obj;
  READY_TO_RETURN;
  return (Scheme_Object *)obj;
}

class basePrinterDC *objscheme_unbundle_basePrinterDC(Scheme_Object *obj, const char *where, int nullOK)
{
  if (nullOK && XC_SCHEME_NULLP(obj)) return NULL;

  REMEMBER_VAR_STACK();

  (void)objscheme_istype_basePrinterDC(obj, where, nullOK);
  Scheme_Class_Object *o = (Scheme_Class_Object *)obj;
  WITH_REMEMBERED_STACK(objscheme_check_valid(NULL, NULL, 0, &obj));
  if (o->primflag)
    return (os_basePrinterDC *)o->primdata;
  else
    return (basePrinterDC *)o->primdata;
}



#ifdef USE_GL
extern void *wxWithGLContext(wxGL *gl, void *thunk, void *alt_waitable, int eb);
#endif

static void *WithContext(wxGL *gl, void *thunk, void *alt_waitable, int eb)
{
#ifdef USE_GL
  return wxWithGLContext(gl, thunk, alt_waitable, eb);
#else
  return (void *)scheme_false;
#endif
}





class os_wxGL : public wxGL {
 public:

  ~os_wxGL();
#ifdef MZ_PRECISE_GC
  void gcMark();
  void gcFixup();
#endif
};

#ifdef MZ_PRECISE_GC
void os_wxGL::gcMark() {
  wxGL::gcMark();
}
void os_wxGL::gcFixup() {
  wxGL::gcFixup();
}
#endif

static Scheme_Object *os_wxGL_class;
static Scheme_Object *os_wxGL_interface;

os_wxGL::~os_wxGL()
{
    objscheme_destroy(this, (Scheme_Object *) __gc_external);
}

static Scheme_Object *os_wxGLWithContext(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  void* r;
  objscheme_check_valid(os_wxGL_class, "call-as-current in gl-context<%>", n, p);
  void* x0 INIT_NULLED_OUT;
  void* x1 INIT_NULLED_OUT;
  Bool x2;

  SETUP_VAR_STACK_REMEMBERED(3);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, x0);
  VAR_STACK_PUSH(2, x1);

  
  x0 = (void*)p[POFFSET+0];
  if (n > (POFFSET+1)) {
    x1 = (void*)p[POFFSET+1];
  } else
    x1 = NULL;
  if (n > (POFFSET+2)) {
    x2 = WITH_VAR_STACK(objscheme_unbundle_bool(p[POFFSET+2], "call-as-current in gl-context<%>"));
  } else
    x2 = 0;

  if (!((wxGL *)((Scheme_Class_Object *)THEOBJ)->primdata)->Ok()) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("gl-context<%>","swap-buffers"), "GL context is not ok: ", THEOBJ));
  r = WITH_VAR_STACK(WithContext(((wxGL *)((Scheme_Class_Object *)p[0])->primdata), x0, x1, x2));

  
  
  READY_TO_RETURN;
  return (Scheme_Object*)r;
}

static Scheme_Object *os_wxGLSwapBuffers(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  objscheme_check_valid(os_wxGL_class, "swap-buffers in gl-context<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  if (!((wxGL *)((Scheme_Class_Object *)THEOBJ)->primdata)->Ok()) WITH_VAR_STACK(scheme_arg_mismatch(METHODNAME("gl-context<%>","swap-buffers"), "GL context is not ok: ", THEOBJ));
  WITH_VAR_STACK(((wxGL *)((Scheme_Class_Object *)p[0])->primdata)->SwapBuffers());

  
  
  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxGLOk(int n,  Scheme_Object *p[])
{
  WXS_USE_ARGUMENT(n) WXS_USE_ARGUMENT(p)
  REMEMBER_VAR_STACK();
  Bool r;
  objscheme_check_valid(os_wxGL_class, "ok? in gl-context<%>", n, p);

  SETUP_VAR_STACK_REMEMBERED(1);
  VAR_STACK_PUSH(0, p);

  

  
  r = WITH_VAR_STACK(((wxGL *)((Scheme_Class_Object *)p[0])->primdata)->Ok());

  
  
  READY_TO_RETURN;
  return (r ? scheme_true : scheme_false);
}

void objscheme_setup_wxGL(Scheme_Env *env)
{
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, env);

  wxREGGLOB(os_wxGL_class);
  wxREGGLOB(os_wxGL_interface);

  os_wxGL_class = WITH_VAR_STACK(objscheme_def_prim_class(env, "gl-context%", "object%", NULL, 3));

  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGL_class, "call-as-current" " method", (Scheme_Method_Prim *)os_wxGLWithContext, 1, 3));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGL_class, "swap-buffers" " method", (Scheme_Method_Prim *)os_wxGLSwapBuffers, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGL_class, "ok?" " method", (Scheme_Method_Prim *)os_wxGLOk, 0, 0));


  WITH_VAR_STACK(scheme_made_class(os_wxGL_class));

  os_wxGL_interface = WITH_VAR_STACK(scheme_class_to_interface(os_wxGL_class, "gl-context" "<%>"));

  WITH_VAR_STACK(objscheme_add_global_interface(os_wxGL_interface, "gl-context" "<%>", env));

  READY_TO_RETURN;
}

int objscheme_istype_wxGL(Scheme_Object *obj, const char *stop, int nullOK)
{
  REMEMBER_VAR_STACK();
  if (nullOK && XC_SCHEME_NULLP(obj)) return 1;
  if (objscheme_is_a(obj,  os_wxGL_class))
    return 1;
  else {
    if (!stop)
       return 0;
    WITH_REMEMBERED_STACK(scheme_wrong_type(stop, nullOK ? "gl-context% object or " XC_NULL_STR: "gl-context% object", -1, 0, &obj));
    return 0;
  }
}

Scheme_Object *objscheme_bundle_wxGL(class wxGL *realobj)
{
  Scheme_Class_Object *obj INIT_NULLED_OUT;
  Scheme_Object *sobj INIT_NULLED_OUT;

  if (!realobj) return XC_SCHEME_NULL;

  if (realobj->__gc_external)
    return (Scheme_Object *)realobj->__gc_external;

  SETUP_VAR_STACK(2);
  VAR_STACK_PUSH(0, obj);
  VAR_STACK_PUSH(1, realobj);

  if ((sobj = WITH_VAR_STACK(objscheme_bundle_by_type(realobj, realobj->__type))))
    { READY_TO_RETURN; return sobj; }
  obj = (Scheme_Class_Object *)WITH_VAR_STACK(scheme_make_uninited_object(os_wxGL_class));

  obj->primdata = realobj;
  WITH_VAR_STACK(objscheme_register_primpointer(obj, &obj->primdata));
  obj->primflag = 0;

  realobj->__gc_external = (void *)obj;
  READY_TO_RETURN;
  return (Scheme_Object *)obj;
}

class wxGL *objscheme_unbundle_wxGL(Scheme_Object *obj, const char *where, int nullOK)
{
  if (nullOK && XC_SCHEME_NULLP(obj)) return NULL;

  REMEMBER_VAR_STACK();

  (void)objscheme_istype_wxGL(obj, where, nullOK);
  Scheme_Class_Object *o = (Scheme_Class_Object *)obj;
  WITH_REMEMBERED_STACK(objscheme_check_valid(NULL, NULL, 0, &obj));
  if (o->primflag)
    return (os_wxGL *)o->primdata;
  else
    return (wxGL *)o->primdata;
}






class os_wxGLConfig : public wxGLConfig {
 public:

  os_wxGLConfig CONSTRUCTOR_ARGS(());
  ~os_wxGLConfig();
#ifdef MZ_PRECISE_GC
  void gcMark();
  void gcFixup();
#endif
};

#ifdef MZ_PRECISE_GC
void os_wxGLConfig::gcMark() {
  wxGLConfig::gcMark();
}
void os_wxGLConfig::gcFixup() {
  wxGLConfig::gcFixup();
}
#endif

static Scheme_Object *os_wxGLConfig_class;

os_wxGLConfig::os_wxGLConfig CONSTRUCTOR_ARGS(())
CONSTRUCTOR_INIT(: wxGLConfig())
{
}

os_wxGLConfig::~os_wxGLConfig()
{
    objscheme_destroy(this, (Scheme_Object *) __gc_external);
}

static Scheme_Object *objscheme_wxGLConfig_GetdoubleBuffered(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj INIT_NULLED_OUT;
  Bool v;
  REMEMBER_VAR_STACK();

  objscheme_check_valid(os_wxGLConfig_class, "get-double-buffered in gl-config%", n, p);
  if (n > POFFSET) WITH_REMEMBERED_STACK(scheme_wrong_count_m("get-double-buffered in gl-config%", POFFSET, POFFSET, n, p, 1));
  cobj = (Scheme_Class_Object *)p[0];
  if (cobj->primflag)
    v = ((os_wxGLConfig *)cobj->primdata)->wxGLConfig::doubleBuffered;
  else
    v = ((wxGLConfig *)cobj->primdata)->doubleBuffered;

  return (v ? scheme_true : scheme_false);
}

static Scheme_Object *objscheme_wxGLConfig_SetdoubleBuffered(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj = (Scheme_Class_Object *)p[0];
  Bool v;
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, cobj);

  WITH_VAR_STACK(objscheme_check_valid(os_wxGLConfig_class, "set-double-buffered in gl-config%", n, p));
  if (n != (POFFSET+1)) WITH_VAR_STACK(scheme_wrong_count_m("set-double-buffered in gl-config%", POFFSET+1, POFFSET+1, n, p, 1));

  v = WITH_VAR_STACK(objscheme_unbundle_bool(p[POFFSET], "set-double-buffered in gl-config%"));
  ((wxGLConfig *)cobj->primdata)->doubleBuffered = v;

  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *objscheme_wxGLConfig_Getstereo(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj INIT_NULLED_OUT;
  Bool v;
  REMEMBER_VAR_STACK();

  objscheme_check_valid(os_wxGLConfig_class, "get-stereo in gl-config%", n, p);
  if (n > POFFSET) WITH_REMEMBERED_STACK(scheme_wrong_count_m("get-stereo in gl-config%", POFFSET, POFFSET, n, p, 1));
  cobj = (Scheme_Class_Object *)p[0];
  if (cobj->primflag)
    v = ((os_wxGLConfig *)cobj->primdata)->wxGLConfig::stereo;
  else
    v = ((wxGLConfig *)cobj->primdata)->stereo;

  return (v ? scheme_true : scheme_false);
}

static Scheme_Object *objscheme_wxGLConfig_Setstereo(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj = (Scheme_Class_Object *)p[0];
  Bool v;
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, cobj);

  WITH_VAR_STACK(objscheme_check_valid(os_wxGLConfig_class, "set-stereo in gl-config%", n, p));
  if (n != (POFFSET+1)) WITH_VAR_STACK(scheme_wrong_count_m("set-stereo in gl-config%", POFFSET+1, POFFSET+1, n, p, 1));

  v = WITH_VAR_STACK(objscheme_unbundle_bool(p[POFFSET], "set-stereo in gl-config%"));
  ((wxGLConfig *)cobj->primdata)->stereo = v;

  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *objscheme_wxGLConfig_Getstencil(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj INIT_NULLED_OUT;
  int v;
  REMEMBER_VAR_STACK();

  objscheme_check_valid(os_wxGLConfig_class, "get-stencil-size in gl-config%", n, p);
  if (n > POFFSET) WITH_REMEMBERED_STACK(scheme_wrong_count_m("get-stencil-size in gl-config%", POFFSET, POFFSET, n, p, 1));
  cobj = (Scheme_Class_Object *)p[0];
  if (cobj->primflag)
    v = ((os_wxGLConfig *)cobj->primdata)->wxGLConfig::stencil;
  else
    v = ((wxGLConfig *)cobj->primdata)->stencil;

  return scheme_make_integer(v);
}

static Scheme_Object *objscheme_wxGLConfig_Setstencil(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj = (Scheme_Class_Object *)p[0];
  int v;
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, cobj);

  WITH_VAR_STACK(objscheme_check_valid(os_wxGLConfig_class, "set-stencil-size in gl-config%", n, p));
  if (n != (POFFSET+1)) WITH_VAR_STACK(scheme_wrong_count_m("set-stencil-size in gl-config%", POFFSET+1, POFFSET+1, n, p, 1));

  v = WITH_VAR_STACK(objscheme_unbundle_integer_in(p[POFFSET], 0, 256, "set-stencil-size in gl-config%"));
  ((wxGLConfig *)cobj->primdata)->stencil = v;

  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *objscheme_wxGLConfig_Getaccum(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj INIT_NULLED_OUT;
  int v;
  REMEMBER_VAR_STACK();

  objscheme_check_valid(os_wxGLConfig_class, "get-accum-size in gl-config%", n, p);
  if (n > POFFSET) WITH_REMEMBERED_STACK(scheme_wrong_count_m("get-accum-size in gl-config%", POFFSET, POFFSET, n, p, 1));
  cobj = (Scheme_Class_Object *)p[0];
  if (cobj->primflag)
    v = ((os_wxGLConfig *)cobj->primdata)->wxGLConfig::accum;
  else
    v = ((wxGLConfig *)cobj->primdata)->accum;

  return scheme_make_integer(v);
}

static Scheme_Object *objscheme_wxGLConfig_Setaccum(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj = (Scheme_Class_Object *)p[0];
  int v;
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, cobj);

  WITH_VAR_STACK(objscheme_check_valid(os_wxGLConfig_class, "set-accum-size in gl-config%", n, p));
  if (n != (POFFSET+1)) WITH_VAR_STACK(scheme_wrong_count_m("set-accum-size in gl-config%", POFFSET+1, POFFSET+1, n, p, 1));

  v = WITH_VAR_STACK(objscheme_unbundle_integer_in(p[POFFSET], 0, 256, "set-accum-size in gl-config%"));
  ((wxGLConfig *)cobj->primdata)->accum = v;

  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *objscheme_wxGLConfig_Getdepth(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj INIT_NULLED_OUT;
  int v;
  REMEMBER_VAR_STACK();

  objscheme_check_valid(os_wxGLConfig_class, "get-depth-size in gl-config%", n, p);
  if (n > POFFSET) WITH_REMEMBERED_STACK(scheme_wrong_count_m("get-depth-size in gl-config%", POFFSET, POFFSET, n, p, 1));
  cobj = (Scheme_Class_Object *)p[0];
  if (cobj->primflag)
    v = ((os_wxGLConfig *)cobj->primdata)->wxGLConfig::depth;
  else
    v = ((wxGLConfig *)cobj->primdata)->depth;

  return scheme_make_integer(v);
}

static Scheme_Object *objscheme_wxGLConfig_Setdepth(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj = (Scheme_Class_Object *)p[0];
  int v;
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, cobj);

  WITH_VAR_STACK(objscheme_check_valid(os_wxGLConfig_class, "set-depth-size in gl-config%", n, p));
  if (n != (POFFSET+1)) WITH_VAR_STACK(scheme_wrong_count_m("set-depth-size in gl-config%", POFFSET+1, POFFSET+1, n, p, 1));

  v = WITH_VAR_STACK(objscheme_unbundle_integer_in(p[POFFSET], 0, 256, "set-depth-size in gl-config%"));
  ((wxGLConfig *)cobj->primdata)->depth = v;

  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *objscheme_wxGLConfig_Getmultisample(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj INIT_NULLED_OUT;
  int v;
  REMEMBER_VAR_STACK();

  objscheme_check_valid(os_wxGLConfig_class, "get-multisample-size in gl-config%", n, p);
  if (n > POFFSET) WITH_REMEMBERED_STACK(scheme_wrong_count_m("get-multisample-size in gl-config%", POFFSET, POFFSET, n, p, 1));
  cobj = (Scheme_Class_Object *)p[0];
  if (cobj->primflag)
    v = ((os_wxGLConfig *)cobj->primdata)->wxGLConfig::multisample;
  else
    v = ((wxGLConfig *)cobj->primdata)->multisample;

  return scheme_make_integer(v);
}

static Scheme_Object *objscheme_wxGLConfig_Setmultisample(int n,  Scheme_Object *p[])
{
  Scheme_Class_Object *cobj = (Scheme_Class_Object *)p[0];
  int v;
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, cobj);

  WITH_VAR_STACK(objscheme_check_valid(os_wxGLConfig_class, "set-multisample-size in gl-config%", n, p));
  if (n != (POFFSET+1)) WITH_VAR_STACK(scheme_wrong_count_m("set-multisample-size in gl-config%", POFFSET+1, POFFSET+1, n, p, 1));

  v = WITH_VAR_STACK(objscheme_unbundle_integer_in(p[POFFSET], 0, 256, "set-multisample-size in gl-config%"));
  ((wxGLConfig *)cobj->primdata)->multisample = v;

  READY_TO_RETURN;
  return scheme_void;
}

static Scheme_Object *os_wxGLConfig_ConstructScheme(int n,  Scheme_Object *p[])
{
  SETUP_PRE_VAR_STACK(1);
  PRE_VAR_STACK_PUSH(0, p);
  os_wxGLConfig *realobj INIT_NULLED_OUT;
  REMEMBER_VAR_STACK();

  SETUP_VAR_STACK_PRE_REMEMBERED(2);
  VAR_STACK_PUSH(0, p);
  VAR_STACK_PUSH(1, realobj);

  
  if (n != (POFFSET+0)) 
    WITH_VAR_STACK(scheme_wrong_count_m("initialization in gl-config%", POFFSET+0, POFFSET+0, n, p, 1));

  
  realobj = WITH_VAR_STACK(new os_wxGLConfig CONSTRUCTOR_ARGS(()));
#ifdef MZ_PRECISE_GC
  WITH_VAR_STACK(realobj->gcInit_wxGLConfig());
#endif
  realobj->__gc_external = (void *)p[0];
  
  
  READY_TO_RETURN;
  ((Scheme_Class_Object *)p[0])->primdata = realobj;
  ((Scheme_Class_Object *)p[0])->primflag = 1;
  WITH_REMEMBERED_STACK(objscheme_register_primpointer(p[0], &((Scheme_Class_Object *)p[0])->primdata));
  return scheme_void;
}

void objscheme_setup_wxGLConfig(Scheme_Env *env)
{
  SETUP_VAR_STACK(1);
  VAR_STACK_PUSH(0, env);

  wxREGGLOB(os_wxGLConfig_class);

  os_wxGLConfig_class = WITH_VAR_STACK(objscheme_def_prim_class(env, "gl-config%", "object%", (Scheme_Method_Prim *)os_wxGLConfig_ConstructScheme, 12));


  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"get-double-buffered" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_GetdoubleBuffered, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"set-double-buffered" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_SetdoubleBuffered, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"get-stereo" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_Getstereo, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"set-stereo" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_Setstereo, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"get-stencil-size" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_Getstencil, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"set-stencil-size" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_Setstencil, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"get-accum-size" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_Getaccum, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"set-accum-size" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_Setaccum, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"get-depth-size" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_Getdepth, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"set-depth-size" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_Setdepth, 1, 1));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"get-multisample-size" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_Getmultisample, 0, 0));
  WITH_VAR_STACK(scheme_add_method_w_arity(os_wxGLConfig_class,"set-multisample-size" " method", (Scheme_Method_Prim *)objscheme_wxGLConfig_Setmultisample, 1, 1));

  WITH_VAR_STACK(scheme_made_class(os_wxGLConfig_class));


  READY_TO_RETURN;
}

int objscheme_istype_wxGLConfig(Scheme_Object *obj, const char *stop, int nullOK)
{
  REMEMBER_VAR_STACK();
  if (nullOK && XC_SCHEME_NULLP(obj)) return 1;
  if (objscheme_is_a(obj,  os_wxGLConfig_class))
    return 1;
  else {
    if (!stop)
       return 0;
    WITH_REMEMBERED_STACK(scheme_wrong_type(stop, nullOK ? "gl-config% object or " XC_NULL_STR: "gl-config% object", -1, 0, &obj));
    return 0;
  }
}

Scheme_Object *objscheme_bundle_wxGLConfig(class wxGLConfig *realobj)
{
  Scheme_Class_Object *obj INIT_NULLED_OUT;
  Scheme_Object *sobj INIT_NULLED_OUT;

  if (!realobj) return XC_SCHEME_NULL;

  if (realobj->__gc_external)
    return (Scheme_Object *)realobj->__gc_external;

  SETUP_VAR_STACK(2);
  VAR_STACK_PUSH(0, obj);
  VAR_STACK_PUSH(1, realobj);

  if ((sobj = WITH_VAR_STACK(objscheme_bundle_by_type(realobj, realobj->__type))))
    { READY_TO_RETURN; return sobj; }
  obj = (Scheme_Class_Object *)WITH_VAR_STACK(scheme_make_uninited_object(os_wxGLConfig_class));

  obj->primdata = realobj;
  WITH_VAR_STACK(objscheme_register_primpointer(obj, &obj->primdata));
  obj->primflag = 0;

  realobj->__gc_external = (void *)obj;
  READY_TO_RETURN;
  return (Scheme_Object *)obj;
}

class wxGLConfig *objscheme_unbundle_wxGLConfig(Scheme_Object *obj, const char *where, int nullOK)
{
  if (nullOK && XC_SCHEME_NULLP(obj)) return NULL;

  REMEMBER_VAR_STACK();

  (void)objscheme_istype_wxGLConfig(obj, where, nullOK);
  Scheme_Class_Object *o = (Scheme_Class_Object *)obj;
  WITH_REMEMBERED_STACK(objscheme_check_valid(NULL, NULL, 0, &obj));
  if (o->primflag)
    return (os_wxGLConfig *)o->primdata;
  else
    return (wxGLConfig *)o->primdata;
}



