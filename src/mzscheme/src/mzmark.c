/* >>>> Generated by mkmark.ss from mzmarksrc.c <<<< */

#ifdef MARKS_FOR_TYPE_C

static int variable_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
}

static int variable_obj_MARK(void *p) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcMARK(b->key);
  gcMARK(b->val);
  gcMARK(((Scheme_Bucket_With_Home *)b)->home);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
}

static int variable_obj_FIXUP(void *p) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcFIXUP(b->key);
  gcFIXUP(b->val);
  gcFIXUP(((Scheme_Bucket_With_Home *)b)->home);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_With_Home));
}

#define variable_obj_IS_ATOMIC 0
#define variable_obj_IS_CONST_SIZE 1


static int module_var_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Module_Variable));
}

static int module_var_MARK(void *p) {
  Module_Variable *mv = (Module_Variable *)p;

  gcMARK(mv->modidx);
  gcMARK(mv->sym);
  gcMARK(mv->insp);

  return
  gcBYTES_TO_WORDS(sizeof(Module_Variable));
}

static int module_var_FIXUP(void *p) {
  Module_Variable *mv = (Module_Variable *)p;

  gcFIXUP(mv->modidx);
  gcFIXUP(mv->sym);
  gcFIXUP(mv->insp);

  return
  gcBYTES_TO_WORDS(sizeof(Module_Variable));
}

#define module_var_IS_ATOMIC 0
#define module_var_IS_CONST_SIZE 1


static int bucket_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
}

static int bucket_obj_MARK(void *p) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcMARK(b->key);
  gcMARK(b->val);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
}

static int bucket_obj_FIXUP(void *p) {
  Scheme_Bucket *b = (Scheme_Bucket *)p;

  gcFIXUP(b->key);
  gcFIXUP(b->val);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket));
}

#define bucket_obj_IS_ATOMIC 0
#define bucket_obj_IS_CONST_SIZE 1


static int local_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
}

static int local_obj_MARK(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
}

static int local_obj_FIXUP(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Local));
}

#define local_obj_IS_ATOMIC 1
#define local_obj_IS_CONST_SIZE 1


static int toplevel_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
}

static int toplevel_obj_MARK(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
}

static int toplevel_obj_FIXUP(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Toplevel));
}

#define toplevel_obj_IS_ATOMIC 1
#define toplevel_obj_IS_CONST_SIZE 1


static int quotesyntax_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Quote_Syntax));
}

static int quotesyntax_obj_MARK(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Quote_Syntax));
}

static int quotesyntax_obj_FIXUP(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Quote_Syntax));
}

#define quotesyntax_obj_IS_ATOMIC 1
#define quotesyntax_obj_IS_CONST_SIZE 1


static int cpointer_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int cpointer_obj_MARK(void *p) {
  gcMARK(SCHEME_CPTR_VAL((Scheme_Object *)p));
  gcMARK(SCHEME_CPTR_TYPE((Scheme_Object *)p));
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int cpointer_obj_FIXUP(void *p) {
  gcFIXUP(SCHEME_CPTR_VAL((Scheme_Object *)p));
  gcFIXUP(SCHEME_CPTR_TYPE((Scheme_Object *)p));
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define cpointer_obj_IS_ATOMIC 0
#define cpointer_obj_IS_CONST_SIZE 1


static int second_of_cons_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int second_of_cons_MARK(void *p) {
  gcMARK(SCHEME_PTR2_VAL((Scheme_Object *)p));
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int second_of_cons_FIXUP(void *p) {
  gcFIXUP(SCHEME_PTR2_VAL((Scheme_Object *)p));
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define second_of_cons_IS_ATOMIC 0
#define second_of_cons_IS_CONST_SIZE 1


static int twoptr_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int twoptr_obj_MARK(void *p) {
  gcMARK(SCHEME_PTR1_VAL((Scheme_Object *)p));
  gcMARK(SCHEME_PTR2_VAL((Scheme_Object *)p));
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int twoptr_obj_FIXUP(void *p) {
  gcFIXUP(SCHEME_PTR1_VAL((Scheme_Object *)p));
  gcFIXUP(SCHEME_PTR2_VAL((Scheme_Object *)p));
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define twoptr_obj_IS_ATOMIC 0
#define twoptr_obj_IS_CONST_SIZE 1


static int iptr_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int iptr_obj_MARK(void *p) {
  gcMARK(SCHEME_IPTR_VAL((Scheme_Object *)p));
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int iptr_obj_FIXUP(void *p) {
  gcFIXUP(SCHEME_IPTR_VAL((Scheme_Object *)p));
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define iptr_obj_IS_ATOMIC 0
#define iptr_obj_IS_CONST_SIZE 1


static int small_object_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int small_object_MARK(void *p) {
  gcMARK(((Scheme_Small_Object *)p)->u.ptr_value);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int small_object_FIXUP(void *p) {
  gcFIXUP(((Scheme_Small_Object *)p)->u.ptr_value);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

#define small_object_IS_ATOMIC 0
#define small_object_IS_CONST_SIZE 1


static int app_rec_SIZE(void *p) {
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + (r->num_args * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
}

static int app_rec_MARK(void *p) {
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  int i = r->num_args + 1;
  while (i--) 
    gcMARK(r->args[i]);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + (r->num_args * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
}

static int app_rec_FIXUP(void *p) {
  Scheme_App_Rec *r = (Scheme_App_Rec *)p;

  int i = r->num_args + 1;
  while (i--) 
    gcFIXUP(r->args[i]);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_App_Rec) 
		    + (r->num_args * sizeof(Scheme_Object *))
		    + ((r->num_args + 1) * sizeof(char))));
}

#define app_rec_IS_ATOMIC 0
#define app_rec_IS_CONST_SIZE 0


static int app2_rec_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
}

static int app2_rec_MARK(void *p) {
  Scheme_App2_Rec *r = (Scheme_App2_Rec *)p;
  gcMARK(r->rator);
  gcMARK(r->rand);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
}

static int app2_rec_FIXUP(void *p) {
  Scheme_App2_Rec *r = (Scheme_App2_Rec *)p;
  gcFIXUP(r->rator);
  gcFIXUP(r->rand);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App2_Rec));
}

#define app2_rec_IS_ATOMIC 0
#define app2_rec_IS_CONST_SIZE 1


static int app3_rec_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
}

static int app3_rec_MARK(void *p) {
  Scheme_App3_Rec *r = (Scheme_App3_Rec *)p;
  gcMARK(r->rator);
  gcMARK(r->rand1);
  gcMARK(r->rand2);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
}

static int app3_rec_FIXUP(void *p) {
  Scheme_App3_Rec *r = (Scheme_App3_Rec *)p;
  gcFIXUP(r->rator);
  gcFIXUP(r->rand1);
  gcFIXUP(r->rand2);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_App3_Rec));
}

#define app3_rec_IS_ATOMIC 0
#define app3_rec_IS_CONST_SIZE 1


static int seq_rec_SIZE(void *p) {
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - 1) * sizeof(Scheme_Object *))));
}

static int seq_rec_MARK(void *p) {
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  int i = s->count;
  while (i--)
    gcMARK(s->array[i]);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - 1) * sizeof(Scheme_Object *))));
}

static int seq_rec_FIXUP(void *p) {
  Scheme_Sequence *s = (Scheme_Sequence *)p;

  int i = s->count;
  while (i--)
    gcFIXUP(s->array[i]);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Sequence)
		    + ((s->count - 1) * sizeof(Scheme_Object *))));
}

#define seq_rec_IS_ATOMIC 0
#define seq_rec_IS_CONST_SIZE 0


static int branch_rec_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
}

static int branch_rec_MARK(void *p) {
  Scheme_Branch_Rec *b = (Scheme_Branch_Rec *)p;
  
  gcMARK(b->test);
  gcMARK(b->tbranch);
  gcMARK(b->fbranch);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
}

static int branch_rec_FIXUP(void *p) {
  Scheme_Branch_Rec *b = (Scheme_Branch_Rec *)p;
  
  gcFIXUP(b->test);
  gcFIXUP(b->tbranch);
  gcFIXUP(b->fbranch);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Branch_Rec));
}

#define branch_rec_IS_ATOMIC 0
#define branch_rec_IS_CONST_SIZE 1


static int unclosed_proc_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Closure_Data));
}

static int unclosed_proc_MARK(void *p) {
  Scheme_Closure_Data *d = (Scheme_Closure_Data *)p;

  gcMARK(d->name);
  gcMARK(d->code);
  gcMARK(d->closure_map);
#ifdef MZ_USE_JIT
  gcMARK(d->native_code);
  gcMARK(d->context);
#endif

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Closure_Data));
}

static int unclosed_proc_FIXUP(void *p) {
  Scheme_Closure_Data *d = (Scheme_Closure_Data *)p;

  gcFIXUP(d->name);
  gcFIXUP(d->code);
  gcFIXUP(d->closure_map);
#ifdef MZ_USE_JIT
  gcFIXUP(d->native_code);
  gcFIXUP(d->context);
#endif

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Closure_Data));
}

#define unclosed_proc_IS_ATOMIC 0
#define unclosed_proc_IS_CONST_SIZE 1


static int let_value_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
}

static int let_value_MARK(void *p) {
  Scheme_Let_Value *l = (Scheme_Let_Value *)p;
  
  gcMARK(l->value);
  gcMARK(l->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
}

static int let_value_FIXUP(void *p) {
  Scheme_Let_Value *l = (Scheme_Let_Value *)p;
  
  gcFIXUP(l->value);
  gcFIXUP(l->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Value));
}

#define let_value_IS_ATOMIC 0
#define let_value_IS_CONST_SIZE 1


static int let_void_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
}

static int let_void_MARK(void *p) {
  Scheme_Let_Void *l = (Scheme_Let_Void *)p;

  gcMARK(l->body);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
}

static int let_void_FIXUP(void *p) {
  Scheme_Let_Void *l = (Scheme_Let_Void *)p;

  gcFIXUP(l->body);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Void));
}

#define let_void_IS_ATOMIC 0
#define let_void_IS_CONST_SIZE 1


static int letrec_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
}

static int letrec_MARK(void *p) {
  Scheme_Letrec *l = (Scheme_Letrec *)p;
  
  gcMARK(l->procs);
  gcMARK(l->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
}

static int letrec_FIXUP(void *p) {
  Scheme_Letrec *l = (Scheme_Letrec *)p;
  
  gcFIXUP(l->procs);
  gcFIXUP(l->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Letrec));
}

#define letrec_IS_ATOMIC 0
#define letrec_IS_CONST_SIZE 1


static int let_one_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
}

static int let_one_MARK(void *p) {
  Scheme_Let_One *l = (Scheme_Let_One *)p;
  
  gcMARK(l->value);
  gcMARK(l->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
}

static int let_one_FIXUP(void *p) {
  Scheme_Let_One *l = (Scheme_Let_One *)p;
  
  gcFIXUP(l->value);
  gcFIXUP(l->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_One));
}

#define let_one_IS_ATOMIC 0
#define let_one_IS_CONST_SIZE 1


static int with_cont_mark_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
}

static int with_cont_mark_MARK(void *p) {
  Scheme_With_Continuation_Mark *w = (Scheme_With_Continuation_Mark *)p;

  gcMARK(w->key);
  gcMARK(w->val);
  gcMARK(w->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
}

static int with_cont_mark_FIXUP(void *p) {
  Scheme_With_Continuation_Mark *w = (Scheme_With_Continuation_Mark *)p;

  gcFIXUP(w->key);
  gcFIXUP(w->val);
  gcFIXUP(w->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_With_Continuation_Mark));
}

#define with_cont_mark_IS_ATOMIC 0
#define with_cont_mark_IS_CONST_SIZE 1


static int comp_let_value_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compiled_Let_Value));
}

static int comp_let_value_MARK(void *p) {
  Scheme_Compiled_Let_Value *c = (Scheme_Compiled_Let_Value *)p;

  gcMARK(c->flags);
  gcMARK(c->value);
  gcMARK(c->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compiled_Let_Value));
}

static int comp_let_value_FIXUP(void *p) {
  Scheme_Compiled_Let_Value *c = (Scheme_Compiled_Let_Value *)p;

  gcFIXUP(c->flags);
  gcFIXUP(c->value);
  gcFIXUP(c->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compiled_Let_Value));
}

#define comp_let_value_IS_ATOMIC 0
#define comp_let_value_IS_CONST_SIZE 1


static int let_header_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Header));
}

static int let_header_MARK(void *p) {
  Scheme_Let_Header *h = (Scheme_Let_Header *)p;
  
  gcMARK(h->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Header));
}

static int let_header_FIXUP(void *p) {
  Scheme_Let_Header *h = (Scheme_Let_Header *)p;
  
  gcFIXUP(h->body);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Let_Header));
}

#define let_header_IS_ATOMIC 0
#define let_header_IS_CONST_SIZE 1


static int prim_proc_SIZE(void *p) {
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  return
  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - 1)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
}

static int prim_proc_MARK(void *p) {
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  gcMARK(prim->name);
  if (prim->mina < 0) {
    gcMARK(prim->mu.cases);
  }
  if (prim->pp.flags & SCHEME_PRIM_IS_CLOSURE) {
    Scheme_Primitive_Closure *cc = (Scheme_Primitive_Closure *)prim;
    int i;
    for (i = cc->count; i--; ) {
      gcMARK(cc->val[i]);
    }
  }  
  
  return
  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - 1)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
}

static int prim_proc_FIXUP(void *p) {
  Scheme_Primitive_Proc *prim = (Scheme_Primitive_Proc *)p;

  gcFIXUP(prim->name);
  if (prim->mina < 0) {
    gcFIXUP(prim->mu.cases);
  }
  if (prim->pp.flags & SCHEME_PRIM_IS_CLOSURE) {
    Scheme_Primitive_Closure *cc = (Scheme_Primitive_Closure *)prim;
    int i;
    for (i = cc->count; i--; ) {
      gcFIXUP(cc->val[i]);
    }
  }  
  
  return
  ((prim->pp.flags & SCHEME_PRIM_IS_CLOSURE)
   ? (gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Closure))
      + ((Scheme_Primitive_Closure *)prim)->count - 1)
   : ((prim->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Prim_W_Result_Arity))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Primitive_Proc))));
}

#define prim_proc_IS_ATOMIC 0
#define prim_proc_IS_CONST_SIZE 0


static int closed_prim_proc_SIZE(void *p) {
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  return
  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
}

static int closed_prim_proc_MARK(void *p) {
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  gcMARK(c->name);
  gcMARK(SCHEME_CLSD_PRIM_DATA(c));
  if (c->mina == -2) {
    gcMARK(((Scheme_Closed_Case_Primitive_Proc *)c)->cases);
  }
  
  return
  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
}

static int closed_prim_proc_FIXUP(void *p) {
  Scheme_Closed_Primitive_Proc *c = (Scheme_Closed_Primitive_Proc *)p;

  gcFIXUP(c->name);
  gcFIXUP(SCHEME_CLSD_PRIM_DATA(c));
  if (c->mina == -2) {
    gcFIXUP(((Scheme_Closed_Case_Primitive_Proc *)c)->cases);
  }
  
  return
  ((c->pp.flags & SCHEME_PRIM_IS_MULTI_RESULT)
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Prim_W_Result_Arity))
   : ((c->mina == -2)
      ? gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Case_Primitive_Proc))
      : gcBYTES_TO_WORDS(sizeof(Scheme_Closed_Primitive_Proc))));
}

#define closed_prim_proc_IS_ATOMIC 0
#define closed_prim_proc_IS_CONST_SIZE 0


static int scm_closure_SIZE(void *p) {
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = ((Scheme_Closure_Data *)GC_resolve(c->code))->closure_size;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

static int scm_closure_MARK(void *p) {
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = ((Scheme_Closure_Data *)GC_resolve(c->code))->closure_size;


  int i = closure_size;
  while (i--)
    gcMARK(c->vals[i]);
  gcMARK(c->code);
  
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

static int scm_closure_FIXUP(void *p) {
  Scheme_Closure *c = (Scheme_Closure *)p;
  int closure_size = ((Scheme_Closure_Data *)GC_resolve(c->code))->closure_size;


  int i = closure_size;
  while (i--)
    gcFIXUP(c->vals[i]);
  gcFIXUP(c->code);
  
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

#define scm_closure_IS_ATOMIC 0
#define scm_closure_IS_CONST_SIZE 0


static int case_closure_SIZE(void *p) {
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - 1) * sizeof(Scheme_Object *))));
}

static int case_closure_MARK(void *p) {
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  int i;
  
  for (i = c->count; i--; )
    gcMARK(c->array[i]);
  gcMARK(c->name);
#ifdef MZ_USE_JIT
  gcMARK(c->native_code);
#endif

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - 1) * sizeof(Scheme_Object *))));
}

static int case_closure_FIXUP(void *p) {
  Scheme_Case_Lambda *c = (Scheme_Case_Lambda *)p;

  int i;
  
  for (i = c->count; i--; )
    gcFIXUP(c->array[i]);
  gcFIXUP(c->name);
#ifdef MZ_USE_JIT
  gcFIXUP(c->native_code);
#endif

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Case_Lambda)
		    + ((c->count - 1) * sizeof(Scheme_Object *))));
}

#define case_closure_IS_ATOMIC 0
#define case_closure_IS_CONST_SIZE 0


static int cont_proc_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
}

static int cont_proc_MARK(void *p) {
  Scheme_Cont *c = (Scheme_Cont *)p;
  
  gcMARK(c->dw);
  gcMARK(c->common);
  gcMARK(c->ok);
  gcMARK(c->save_overflow);
  gcMARK(c->runstack_copied);
  gcMARK(c->runstack_owner);
  gcMARK(c->cont_mark_stack_copied);
  gcMARK(c->cont_mark_stack_owner);
  gcMARK(c->orig_mark_segments);
  gcMARK(c->init_config);
  gcMARK(c->init_break_cell);
#ifdef MZ_USE_JIT
  gcMARK(c->native_trace);
#endif

  MARK_jmpup(&c->buf);
  MARK_cjs(&c->cjs);
  MARK_stack_state(&c->ss);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
}

static int cont_proc_FIXUP(void *p) {
  Scheme_Cont *c = (Scheme_Cont *)p;
  
  gcFIXUP(c->dw);
  gcFIXUP(c->common);
  gcFIXUP(c->ok);
  gcFIXUP(c->save_overflow);
  gcFIXUP(c->runstack_copied);
  gcFIXUP(c->runstack_owner);
  gcFIXUP(c->cont_mark_stack_copied);
  gcFIXUP(c->cont_mark_stack_owner);
  gcFIXUP(c->orig_mark_segments);
  gcFIXUP(c->init_config);
  gcFIXUP(c->init_break_cell);
#ifdef MZ_USE_JIT
  gcFIXUP(c->native_trace);
#endif

  FIXUP_jmpup(&c->buf);
  FIXUP_cjs(&c->cjs);
  FIXUP_stack_state(&c->ss);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont));
}

#define cont_proc_IS_ATOMIC 0
#define cont_proc_IS_CONST_SIZE 1


static int mark_dyn_wind_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
}

static int mark_dyn_wind_MARK(void *p) {
  Scheme_Dynamic_Wind *dw = (Scheme_Dynamic_Wind *)p;
  
  gcMARK(dw->data);
  gcMARK(dw->cont);
  gcMARK(dw->prev);
    
  MARK_stack_state(&dw->envss);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
}

static int mark_dyn_wind_FIXUP(void *p) {
  Scheme_Dynamic_Wind *dw = (Scheme_Dynamic_Wind *)p;
  
  gcFIXUP(dw->data);
  gcFIXUP(dw->cont);
  gcFIXUP(dw->prev);
    
  FIXUP_stack_state(&dw->envss);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind));
}

#define mark_dyn_wind_IS_ATOMIC 0
#define mark_dyn_wind_IS_CONST_SIZE 1


static int mark_overflow_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
}

static int mark_overflow_MARK(void *p) {
  Scheme_Overflow *o = (Scheme_Overflow *)p;

  gcMARK(o->prev);
  MARK_jmpup(&o->cont);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
}

static int mark_overflow_FIXUP(void *p) {
  Scheme_Overflow *o = (Scheme_Overflow *)p;

  gcFIXUP(o->prev);
  FIXUP_jmpup(&o->cont);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Overflow));
}

#define mark_overflow_IS_ATOMIC 0
#define mark_overflow_IS_CONST_SIZE 1


static int escaping_cont_proc_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
}

static int escaping_cont_proc_MARK(void *p) {
  Scheme_Escaping_Cont *c = (Scheme_Escaping_Cont *)p;

  gcMARK(c->mark_key);
  gcMARK(c->marks_prefix);
#ifdef MZ_USE_JIT
  gcMARK(c->native_trace);
#endif

  MARK_cjs(&c->cjs);
  MARK_stack_state(&c->envss);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
}

static int escaping_cont_proc_FIXUP(void *p) {
  Scheme_Escaping_Cont *c = (Scheme_Escaping_Cont *)p;

  gcFIXUP(c->mark_key);
  gcFIXUP(c->marks_prefix);
#ifdef MZ_USE_JIT
  gcFIXUP(c->native_trace);
#endif

  FIXUP_cjs(&c->cjs);
  FIXUP_stack_state(&c->envss);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Escaping_Cont));
}

#define escaping_cont_proc_IS_ATOMIC 0
#define escaping_cont_proc_IS_CONST_SIZE 1


static int char_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int char_obj_MARK(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

static int char_obj_FIXUP(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Small_Object));
}

#define char_obj_IS_ATOMIC 1
#define char_obj_IS_CONST_SIZE 1


static int bignum_obj_SIZE(void *p) {
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  return
  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
}

static int bignum_obj_MARK(void *p) {
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  if (!SCHEME_BIGINLINE(b)) {
    gcMARK(b->digits);
  } else {
    
  }

  return
  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
}

static int bignum_obj_FIXUP(void *p) {
  Scheme_Bignum *b = (Scheme_Bignum *)p;

  if (!SCHEME_BIGINLINE(b)) {
    gcFIXUP(b->digits);
  } else {
    b->digits = ((Small_Bignum *)GC_fixup_self(b))->v;
  }

  return
  ((!SCHEME_BIGINLINE(b))
   ? gcBYTES_TO_WORDS(sizeof(Scheme_Bignum))
   : gcBYTES_TO_WORDS(sizeof(Small_Bignum)));
}

#define bignum_obj_IS_ATOMIC 0
#define bignum_obj_IS_CONST_SIZE 0


static int rational_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
}

static int rational_obj_MARK(void *p) {
  Scheme_Rational *r = (Scheme_Rational *)p;
  
  gcMARK(r->num);
  gcMARK(r->denom);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
}

static int rational_obj_FIXUP(void *p) {
  Scheme_Rational *r = (Scheme_Rational *)p;
  
  gcFIXUP(r->num);
  gcFIXUP(r->denom);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Rational));
}

#define rational_obj_IS_ATOMIC 0
#define rational_obj_IS_CONST_SIZE 1


static int float_obj_SIZE(void *p) {
  return
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
}

static int float_obj_MARK(void *p) {
  return
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
}

static int float_obj_FIXUP(void *p) {
  return
#ifdef MZ_USE_SINGLE_FLOATS
  gcBYTES_TO_WORDS(sizeof(Scheme_Float));
#else
  0;
#endif
}

#define float_obj_IS_ATOMIC 1
#define float_obj_IS_CONST_SIZE 0


static int double_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
}

static int double_obj_MARK(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
}

static int double_obj_FIXUP(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Double));
}

#define double_obj_IS_ATOMIC 1
#define double_obj_IS_CONST_SIZE 1


static int complex_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
}

static int complex_obj_MARK(void *p) {
  Scheme_Complex *c = (Scheme_Complex *)p;
  
  gcMARK(c->r);
  gcMARK(c->i);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
}

static int complex_obj_FIXUP(void *p) {
  Scheme_Complex *c = (Scheme_Complex *)p;
  
  gcFIXUP(c->r);
  gcFIXUP(c->i);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Complex));
}

#define complex_obj_IS_ATOMIC 0
#define complex_obj_IS_CONST_SIZE 1


static int string_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int string_obj_MARK(void *p) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcMARK(SCHEME_CHAR_STR_VAL(o));

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int string_obj_FIXUP(void *p) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcFIXUP(SCHEME_CHAR_STR_VAL(o));

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define string_obj_IS_ATOMIC 0
#define string_obj_IS_CONST_SIZE 1


static int bstring_obj_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int bstring_obj_MARK(void *p) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcMARK(SCHEME_BYTE_STR_VAL(o));

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int bstring_obj_FIXUP(void *p) {
  Scheme_Object *o = (Scheme_Object *)p;
  gcFIXUP(SCHEME_BYTE_STR_VAL(o));

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define bstring_obj_IS_ATOMIC 0
#define bstring_obj_IS_CONST_SIZE 1


static int symbol_obj_SIZE(void *p) {
  Scheme_Symbol *s = (Scheme_Symbol *)p;

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + s->len - 3);
}

static int symbol_obj_MARK(void *p) {
  Scheme_Symbol *s = (Scheme_Symbol *)p;

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + s->len - 3);
}

static int symbol_obj_FIXUP(void *p) {
  Scheme_Symbol *s = (Scheme_Symbol *)p;

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Symbol) + s->len - 3);
}

#define symbol_obj_IS_ATOMIC 1
#define symbol_obj_IS_CONST_SIZE 0


static int cons_cell_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int cons_cell_MARK(void *p) {
  Scheme_Object *o = (Scheme_Object *)p;
  
  gcMARK(SCHEME_CAR(o));
  gcMARK(SCHEME_CDR(o));

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int cons_cell_FIXUP(void *p) {
  Scheme_Object *o = (Scheme_Object *)p;
  
  gcFIXUP(SCHEME_CAR(o));
  gcFIXUP(SCHEME_CDR(o));

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define cons_cell_IS_ATOMIC 0
#define cons_cell_IS_CONST_SIZE 1


static int vector_obj_SIZE(void *p) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - 1) * sizeof(Scheme_Object *))));
}

static int vector_obj_MARK(void *p) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  int i;
  for (i = vec->size; i--; )
    gcMARK(vec->els[i]);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - 1) * sizeof(Scheme_Object *))));
}

static int vector_obj_FIXUP(void *p) {
  Scheme_Vector *vec = (Scheme_Vector *)p;

  int i;
  for (i = vec->size; i--; )
    gcFIXUP(vec->els[i]);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Vector) 
		    + ((vec->size - 1) * sizeof(Scheme_Object *))));
}

#define vector_obj_IS_ATOMIC 0
#define vector_obj_IS_CONST_SIZE 0


static int input_port_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
}

static int input_port_MARK(void *p) {
  Scheme_Input_Port *ip = (Scheme_Input_Port *)p;
  
  gcMARK(ip->sub_type);
  gcMARK(ip->port_data);
  gcMARK(ip->name);
  gcMARK(ip->peeked_read);
  gcMARK(ip->peeked_write);
  gcMARK(ip->read_handler);
  gcMARK(ip->mref);
  gcMARK(ip->output_half);
  gcMARK(ip->special);
  gcMARK(ip->ungotten_special);
  gcMARK(ip->progress_evt);
  gcMARK(ip->input_lock);
  gcMARK(ip->input_giveup);
  gcMARK(ip->input_extras);
  gcMARK(ip->input_extras_ready);
  gcMARK(ip->unless);
  gcMARK(ip->unless_cache);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
}

static int input_port_FIXUP(void *p) {
  Scheme_Input_Port *ip = (Scheme_Input_Port *)p;
  
  gcFIXUP(ip->sub_type);
  gcFIXUP(ip->port_data);
  gcFIXUP(ip->name);
  gcFIXUP(ip->peeked_read);
  gcFIXUP(ip->peeked_write);
  gcFIXUP(ip->read_handler);
  gcFIXUP(ip->mref);
  gcFIXUP(ip->output_half);
  gcFIXUP(ip->special);
  gcFIXUP(ip->ungotten_special);
  gcFIXUP(ip->progress_evt);
  gcFIXUP(ip->input_lock);
  gcFIXUP(ip->input_giveup);
  gcFIXUP(ip->input_extras);
  gcFIXUP(ip->input_extras_ready);
  gcFIXUP(ip->unless);
  gcFIXUP(ip->unless_cache);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_Port));
}

#define input_port_IS_ATOMIC 0
#define input_port_IS_CONST_SIZE 1


static int output_port_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
}

static int output_port_MARK(void *p) {
  Scheme_Output_Port *op = (Scheme_Output_Port *)p;

  gcMARK(op->sub_type);
  gcMARK(op->port_data);
  gcMARK(op->name);
  gcMARK(op->display_handler);
  gcMARK(op->write_handler);
  gcMARK(op->print_handler);
  gcMARK(op->mref);
  gcMARK(op->input_half);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
}

static int output_port_FIXUP(void *p) {
  Scheme_Output_Port *op = (Scheme_Output_Port *)p;

  gcFIXUP(op->sub_type);
  gcFIXUP(op->port_data);
  gcFIXUP(op->name);
  gcFIXUP(op->display_handler);
  gcFIXUP(op->write_handler);
  gcFIXUP(op->print_handler);
  gcFIXUP(op->mref);
  gcFIXUP(op->input_half);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_Port));
}

#define output_port_IS_ATOMIC 0
#define output_port_IS_CONST_SIZE 1



static int syntax_compiler_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int syntax_compiler_MARK(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int syntax_compiler_FIXUP(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define syntax_compiler_IS_ATOMIC 1
#define syntax_compiler_IS_CONST_SIZE 1


static int thread_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
}

static int thread_val_MARK(void *p) {
  Scheme_Thread *pr = (Scheme_Thread *)p;
  
  gcMARK(pr->next);
  gcMARK(pr->prev);

  gcMARK(pr->t_set_parent);
  gcMARK(pr->t_set_next);
  gcMARK(pr->t_set_prev);

  MARK_cjs(&pr->cjs);

  gcMARK(pr->current_escape_cont_key);

  gcMARK(pr->cell_values);
  gcMARK(pr->init_config);
  gcMARK(pr->init_break_cell);

  {
    Scheme_Object **rs = pr->runstack_start;
    gcMARK( pr->runstack_start);
    pr->runstack = pr->runstack_start + (pr->runstack - rs);
  }
  gcMARK(pr->runstack_saved);
  gcMARK(pr->runstack_owner);
  gcMARK(pr->runstack_swapped);
  pr->spare_runstack = NULL; /* just in case */
  
  gcMARK(pr->cont_mark_stack_segments);
  gcMARK(pr->cont_mark_stack_owner);
  gcMARK(pr->cont_mark_stack_swapped);
  
  MARK_jmpup(&pr->jmpup_buf);
  
  gcMARK(pr->cc_ok);
  gcMARK(pr->dw);
  
  gcMARK(pr->nester);
  gcMARK(pr->nestee);
  
  gcMARK(pr->blocker);
  gcMARK(pr->overflow);
  
  gcMARK(pr->current_local_env);
  gcMARK(pr->current_local_mark);
  gcMARK(pr->current_local_name);
  gcMARK(pr->current_local_certs);
  gcMARK(pr->current_local_modidx);
  gcMARK(pr->current_local_menv);
  
  gcMARK(pr->overflow_reply);

  gcMARK(pr->values_buffer);

  gcMARK(pr->tail_buffer);
  
  gcMARK(pr->ku.k.p1);
  gcMARK(pr->ku.k.p2);
  gcMARK(pr->ku.k.p3);
  gcMARK(pr->ku.k.p4);
  gcMARK(pr->ku.k.p5);
  
  gcMARK(pr->list_stack);
  
  gcMARK(pr->rn_memory);
  
  gcMARK(pr->kill_data);
  gcMARK(pr->private_kill_data);
  gcMARK(pr->private_kill_next);
  
  gcMARK(pr->user_tls);
  
  gcMARK(pr->mr_hop);
  gcMARK(pr->mref);
  gcMARK(pr->extra_mrefs);

  gcMARK(pr->name);

  gcMARK(pr->transitive_resumes);

  gcMARK(pr->suspended_box);
  gcMARK(pr->resumed_box);
  gcMARK(pr->dead_box);
  gcMARK(pr->running_box);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
}

static int thread_val_FIXUP(void *p) {
  Scheme_Thread *pr = (Scheme_Thread *)p;
  
  gcFIXUP(pr->next);
  gcFIXUP(pr->prev);

  gcFIXUP(pr->t_set_parent);
  gcFIXUP(pr->t_set_next);
  gcFIXUP(pr->t_set_prev);

  FIXUP_cjs(&pr->cjs);

  gcFIXUP(pr->current_escape_cont_key);

  gcFIXUP(pr->cell_values);
  gcFIXUP(pr->init_config);
  gcFIXUP(pr->init_break_cell);

  {
    Scheme_Object **rs = pr->runstack_start;
    gcFIXUP_TYPED_NOW(Scheme_Object **, pr->runstack_start);
    pr->runstack = pr->runstack_start + (pr->runstack - rs);
  }
  gcFIXUP(pr->runstack_saved);
  gcFIXUP(pr->runstack_owner);
  gcFIXUP(pr->runstack_swapped);
  pr->spare_runstack = NULL; /* just in case */
  
  gcFIXUP(pr->cont_mark_stack_segments);
  gcFIXUP(pr->cont_mark_stack_owner);
  gcFIXUP(pr->cont_mark_stack_swapped);
  
  FIXUP_jmpup(&pr->jmpup_buf);
  
  gcFIXUP(pr->cc_ok);
  gcFIXUP(pr->dw);
  
  gcFIXUP(pr->nester);
  gcFIXUP(pr->nestee);
  
  gcFIXUP(pr->blocker);
  gcFIXUP(pr->overflow);
  
  gcFIXUP(pr->current_local_env);
  gcFIXUP(pr->current_local_mark);
  gcFIXUP(pr->current_local_name);
  gcFIXUP(pr->current_local_certs);
  gcFIXUP(pr->current_local_modidx);
  gcFIXUP(pr->current_local_menv);
  
  gcFIXUP(pr->overflow_reply);

  gcFIXUP(pr->values_buffer);

  gcFIXUP(pr->tail_buffer);
  
  gcFIXUP(pr->ku.k.p1);
  gcFIXUP(pr->ku.k.p2);
  gcFIXUP(pr->ku.k.p3);
  gcFIXUP(pr->ku.k.p4);
  gcFIXUP(pr->ku.k.p5);
  
  gcFIXUP(pr->list_stack);
  
  gcFIXUP(pr->rn_memory);
  
  gcFIXUP(pr->kill_data);
  gcFIXUP(pr->private_kill_data);
  gcFIXUP(pr->private_kill_next);
  
  gcFIXUP(pr->user_tls);
  
  gcFIXUP(pr->mr_hop);
  gcFIXUP(pr->mref);
  gcFIXUP(pr->extra_mrefs);

  gcFIXUP(pr->name);

  gcFIXUP(pr->transitive_resumes);

  gcFIXUP(pr->suspended_box);
  gcFIXUP(pr->resumed_box);
  gcFIXUP(pr->dead_box);
  gcFIXUP(pr->running_box);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread));
}

#define thread_val_IS_ATOMIC 0
#define thread_val_IS_CONST_SIZE 1


static int cont_mark_set_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
}

static int cont_mark_set_val_MARK(void *p) {
  Scheme_Cont_Mark_Set *s = (Scheme_Cont_Mark_Set *)p;
  gcMARK(s->chain);
  gcMARK(s->native_stack_trace);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
}

static int cont_mark_set_val_FIXUP(void *p) {
  Scheme_Cont_Mark_Set *s = (Scheme_Cont_Mark_Set *)p;
  gcFIXUP(s->chain);
  gcFIXUP(s->native_stack_trace);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Set));
}

#define cont_mark_set_val_IS_ATOMIC 0
#define cont_mark_set_val_IS_CONST_SIZE 1


static int sema_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
}

static int sema_val_MARK(void *p) {
  Scheme_Sema *s = (Scheme_Sema *)p;

  gcMARK(s->first);
  gcMARK(s->last);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
}

static int sema_val_FIXUP(void *p) {
  Scheme_Sema *s = (Scheme_Sema *)p;

  gcFIXUP(s->first);
  gcFIXUP(s->last);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Sema));
}

#define sema_val_IS_ATOMIC 0
#define sema_val_IS_CONST_SIZE 1


static int channel_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
}

static int channel_val_MARK(void *p) {
  Scheme_Channel *s = (Scheme_Channel *)p;

  gcMARK(s->get_first);
  gcMARK(s->get_last);
  gcMARK(s->put_first);
  gcMARK(s->put_last);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
}

static int channel_val_FIXUP(void *p) {
  Scheme_Channel *s = (Scheme_Channel *)p;

  gcFIXUP(s->get_first);
  gcFIXUP(s->get_last);
  gcFIXUP(s->put_first);
  gcFIXUP(s->put_last);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel));
}

#define channel_val_IS_ATOMIC 0
#define channel_val_IS_CONST_SIZE 1


static int channel_put_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
}

static int channel_put_val_MARK(void *p) {
  Scheme_Channel_Put *s = (Scheme_Channel_Put *)p;

  gcMARK(s->ch);
  gcMARK(s->val);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
}

static int channel_put_val_FIXUP(void *p) {
  Scheme_Channel_Put *s = (Scheme_Channel_Put *)p;

  gcFIXUP(s->ch);
  gcFIXUP(s->val);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Put));
}

#define channel_put_val_IS_ATOMIC 0
#define channel_put_val_IS_CONST_SIZE 1


static int hash_table_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
}

static int hash_table_val_MARK(void *p) {
  Scheme_Hash_Table *ht = (Scheme_Hash_Table *)p;

  gcMARK(ht->keys);
  gcMARK(ht->vals);
  gcMARK(ht->mutex);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
}

static int hash_table_val_FIXUP(void *p) {
  Scheme_Hash_Table *ht = (Scheme_Hash_Table *)p;

  gcFIXUP(ht->keys);
  gcFIXUP(ht->vals);
  gcFIXUP(ht->mutex);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Hash_Table));
}

#define hash_table_val_IS_ATOMIC 0
#define hash_table_val_IS_CONST_SIZE 1


static int bucket_table_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
}

static int bucket_table_val_MARK(void *p) {
  Scheme_Bucket_Table *ht = (Scheme_Bucket_Table *)p;

  gcMARK(ht->buckets);
  gcMARK(ht->mutex);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
}

static int bucket_table_val_FIXUP(void *p) {
  Scheme_Bucket_Table *ht = (Scheme_Bucket_Table *)p;

  gcFIXUP(ht->buckets);
  gcFIXUP(ht->mutex);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Bucket_Table));
}

#define bucket_table_val_IS_ATOMIC 0
#define bucket_table_val_IS_CONST_SIZE 1


static int namespace_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
}

static int namespace_val_MARK(void *p) {
  Scheme_Env *e = (Scheme_Env *)p;

  gcMARK(e->module);
  gcMARK(e->module_registry);
  gcMARK(e->export_registry);
  gcMARK(e->insp);

  gcMARK(e->rename);
  gcMARK(e->et_rename);
  gcMARK(e->tt_rename);

  gcMARK(e->syntax);
  gcMARK(e->exp_env);
  gcMARK(e->template_env);

  gcMARK(e->shadowed_syntax);

  gcMARK(e->link_midx);
  gcMARK(e->require_names);
  gcMARK(e->et_require_names);
  gcMARK(e->tt_require_names);

  gcMARK(e->toplevel);
  gcMARK(e->modchain);

  gcMARK(e->modvars);

  gcMARK(e->marked_names);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
}

static int namespace_val_FIXUP(void *p) {
  Scheme_Env *e = (Scheme_Env *)p;

  gcFIXUP(e->module);
  gcFIXUP(e->module_registry);
  gcFIXUP(e->export_registry);
  gcFIXUP(e->insp);

  gcFIXUP(e->rename);
  gcFIXUP(e->et_rename);
  gcFIXUP(e->tt_rename);

  gcFIXUP(e->syntax);
  gcFIXUP(e->exp_env);
  gcFIXUP(e->template_env);

  gcFIXUP(e->shadowed_syntax);

  gcFIXUP(e->link_midx);
  gcFIXUP(e->require_names);
  gcFIXUP(e->et_require_names);
  gcFIXUP(e->tt_require_names);

  gcFIXUP(e->toplevel);
  gcFIXUP(e->modchain);

  gcFIXUP(e->modvars);

  gcFIXUP(e->marked_names);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Env));
}

#define namespace_val_IS_ATOMIC 0
#define namespace_val_IS_CONST_SIZE 1


static int random_state_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
}

static int random_state_val_MARK(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
}

static int random_state_val_FIXUP(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Random_State));
}

#define random_state_val_IS_ATOMIC 1
#define random_state_val_IS_CONST_SIZE 1


static int compilation_top_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compilation_Top));
}

static int compilation_top_val_MARK(void *p) {
  Scheme_Compilation_Top *t = (Scheme_Compilation_Top *)p;
  gcMARK(t->code);
  gcMARK(t->prefix);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compilation_Top));
}

static int compilation_top_val_FIXUP(void *p) {
  Scheme_Compilation_Top *t = (Scheme_Compilation_Top *)p;
  gcFIXUP(t->code);
  gcFIXUP(t->prefix);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compilation_Top));
}

#define compilation_top_val_IS_ATOMIC 0
#define compilation_top_val_IS_CONST_SIZE 1


static int resolve_prefix_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Prefix));
}

static int resolve_prefix_val_MARK(void *p) {
  Resolve_Prefix *rp = (Resolve_Prefix *)p;
  gcMARK(rp->toplevels);
  gcMARK(rp->stxes);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Prefix));
}

static int resolve_prefix_val_FIXUP(void *p) {
  Resolve_Prefix *rp = (Resolve_Prefix *)p;
  gcFIXUP(rp->toplevels);
  gcFIXUP(rp->stxes);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Prefix));
}

#define resolve_prefix_val_IS_ATOMIC 0
#define resolve_prefix_val_IS_CONST_SIZE 1


static int comp_prefix_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Comp_Prefix));
}

static int comp_prefix_val_MARK(void *p) {
  Comp_Prefix *cp = (Comp_Prefix *)p;
  gcMARK(cp->toplevels);
  gcMARK(cp->stxes);

  return
  gcBYTES_TO_WORDS(sizeof(Comp_Prefix));
}

static int comp_prefix_val_FIXUP(void *p) {
  Comp_Prefix *cp = (Comp_Prefix *)p;
  gcFIXUP(cp->toplevels);
  gcFIXUP(cp->stxes);

  return
  gcBYTES_TO_WORDS(sizeof(Comp_Prefix));
}

#define comp_prefix_val_IS_ATOMIC 0
#define comp_prefix_val_IS_CONST_SIZE 1


static int svector_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int svector_val_MARK(void *p) {
  Scheme_Object *o = (Scheme_Object *)p;

  gcMARK(SCHEME_SVEC_VEC(o));

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

static int svector_val_FIXUP(void *p) {
  Scheme_Object *o = (Scheme_Object *)p;

  gcFIXUP(SCHEME_SVEC_VEC(o));

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Simple_Object));
}

#define svector_val_IS_ATOMIC 0
#define svector_val_IS_CONST_SIZE 1


static int stx_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
}

static int stx_val_MARK(void *p) {
  Scheme_Stx *stx = (Scheme_Stx *)p;
  gcMARK(stx->val);
  gcMARK(stx->srcloc);
  gcMARK(stx->wraps);
  gcMARK(stx->certs);
  gcMARK(stx->props);
  if (!(MZ_OPT_HASH_KEY(&(stx)->iso) & STX_SUBSTX_FLAG))
    gcMARK(stx->u.modinfo_cache);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
}

static int stx_val_FIXUP(void *p) {
  Scheme_Stx *stx = (Scheme_Stx *)p;
  gcFIXUP(stx->val);
  gcFIXUP(stx->srcloc);
  gcFIXUP(stx->wraps);
  gcFIXUP(stx->certs);
  gcFIXUP(stx->props);
  if (!(MZ_OPT_HASH_KEY(&(stx)->iso) & STX_SUBSTX_FLAG))
    gcFIXUP(stx->u.modinfo_cache);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx));
}

#define stx_val_IS_ATOMIC 0
#define stx_val_IS_CONST_SIZE 1


static int stx_off_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Offset));
}

static int stx_off_val_MARK(void *p) {
  Scheme_Stx_Offset *o = (Scheme_Stx_Offset *)p;
  gcMARK(o->src);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Offset));
}

static int stx_off_val_FIXUP(void *p) {
  Scheme_Stx_Offset *o = (Scheme_Stx_Offset *)p;
  gcFIXUP(o->src);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Offset));
}

#define stx_off_val_IS_ATOMIC 0
#define stx_off_val_IS_CONST_SIZE 1


static int module_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module));
}

static int module_val_MARK(void *p) {
  Scheme_Module *m = (Scheme_Module *)p;
  gcMARK(m->modname);

  gcMARK(m->et_requires);
  gcMARK(m->tt_requires);
  gcMARK(m->requires);

  gcMARK(m->body);
  gcMARK(m->et_body);

  gcMARK(m->me);

  gcMARK(m->provide_protects);
  gcMARK(m->indirect_provides);
  gcMARK(m->self_modidx);

  gcMARK(m->accessible);
  gcMARK(m->insp);

  gcMARK(m->hints);

  gcMARK(m->comp_prefix);
  gcMARK(m->prefix);
  gcMARK(m->dummy);

  gcMARK(m->rn_stx);
  gcMARK(m->et_rn_stx);
  gcMARK(m->tt_rn_stx);

  gcMARK(m->primitive);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module));
}

static int module_val_FIXUP(void *p) {
  Scheme_Module *m = (Scheme_Module *)p;
  gcFIXUP(m->modname);

  gcFIXUP(m->et_requires);
  gcFIXUP(m->tt_requires);
  gcFIXUP(m->requires);

  gcFIXUP(m->body);
  gcFIXUP(m->et_body);

  gcFIXUP(m->me);

  gcFIXUP(m->provide_protects);
  gcFIXUP(m->indirect_provides);
  gcFIXUP(m->self_modidx);

  gcFIXUP(m->accessible);
  gcFIXUP(m->insp);

  gcFIXUP(m->hints);

  gcFIXUP(m->comp_prefix);
  gcFIXUP(m->prefix);
  gcFIXUP(m->dummy);

  gcFIXUP(m->rn_stx);
  gcFIXUP(m->et_rn_stx);
  gcFIXUP(m->tt_rn_stx);

  gcFIXUP(m->primitive);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module));
}

#define module_val_IS_ATOMIC 0
#define module_val_IS_CONST_SIZE 1


static int module_exports_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Exports));
}

static int module_exports_val_MARK(void *p) {
  Scheme_Module_Exports *m = (Scheme_Module_Exports *)p;

  gcMARK(m->provides);
  gcMARK(m->provide_srcs);
  gcMARK(m->provide_src_names);

  gcMARK(m->kernel_exclusion);

  gcMARK(m->src_modidx);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Exports));
}

static int module_exports_val_FIXUP(void *p) {
  Scheme_Module_Exports *m = (Scheme_Module_Exports *)p;

  gcFIXUP(m->provides);
  gcFIXUP(m->provide_srcs);
  gcFIXUP(m->provide_src_names);

  gcFIXUP(m->kernel_exclusion);

  gcFIXUP(m->src_modidx);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Module_Exports));
}

#define module_exports_val_IS_ATOMIC 0
#define module_exports_val_IS_CONST_SIZE 1


static int modidx_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Modidx));
}

static int modidx_val_MARK(void *p) {
  Scheme_Modidx *modidx = (Scheme_Modidx *)p;

  gcMARK(modidx->path);
  gcMARK(modidx->base);
  gcMARK(modidx->resolved);
  gcMARK(modidx->shift_cache);
  gcMARK(modidx->cache_next);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Modidx));
}

static int modidx_val_FIXUP(void *p) {
  Scheme_Modidx *modidx = (Scheme_Modidx *)p;

  gcFIXUP(modidx->path);
  gcFIXUP(modidx->base);
  gcFIXUP(modidx->resolved);
  gcFIXUP(modidx->shift_cache);
  gcFIXUP(modidx->cache_next);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Modidx));
}

#define modidx_val_IS_ATOMIC 0
#define modidx_val_IS_CONST_SIZE 1


static int guard_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
}

static int guard_val_MARK(void *p) {
  Scheme_Security_Guard *g = (Scheme_Security_Guard *)p;

  gcMARK(g->parent);
  gcMARK(g->file_proc);
  gcMARK(g->network_proc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
}

static int guard_val_FIXUP(void *p) {
  Scheme_Security_Guard *g = (Scheme_Security_Guard *)p;

  gcFIXUP(g->parent);
  gcFIXUP(g->file_proc);
  gcFIXUP(g->network_proc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Security_Guard));
}

#define guard_val_IS_ATOMIC 0
#define guard_val_IS_CONST_SIZE 1


static int buf_holder_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
}

static int buf_holder_MARK(void *p) {
  Scheme_Jumpup_Buf_Holder *h = (Scheme_Jumpup_Buf_Holder *)p;
 
  MARK_jmpup(&h->buf);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
}

static int buf_holder_FIXUP(void *p) {
  Scheme_Jumpup_Buf_Holder *h = (Scheme_Jumpup_Buf_Holder *)p;
 
  FIXUP_jmpup(&h->buf);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Jumpup_Buf_Holder));
}

#define buf_holder_IS_ATOMIC 0
#define buf_holder_IS_CONST_SIZE 1


static int mark_inspector_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
}

static int mark_inspector_MARK(void *p) {
  Scheme_Inspector *i = (Scheme_Inspector *)p;
  gcMARK(i->superior);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
}

static int mark_inspector_FIXUP(void *p) {
  Scheme_Inspector *i = (Scheme_Inspector *)p;
  gcFIXUP(i->superior);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Inspector));
}

#define mark_inspector_IS_ATOMIC 0
#define mark_inspector_IS_CONST_SIZE 1


static int mark_pipe_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
}

static int mark_pipe_MARK(void *p) {
  Scheme_Pipe *pp = (Scheme_Pipe *)p;
    
  gcMARK(pp->buf);
  gcMARK(pp->wakeup_on_read);
  gcMARK(pp->wakeup_on_write);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
}

static int mark_pipe_FIXUP(void *p) {
  Scheme_Pipe *pp = (Scheme_Pipe *)p;
    
  gcFIXUP(pp->buf);
  gcFIXUP(pp->wakeup_on_read);
  gcFIXUP(pp->wakeup_on_write);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Pipe));
}

#define mark_pipe_IS_ATOMIC 0
#define mark_pipe_IS_CONST_SIZE 1


#endif  /* TYPE */

/**********************************************************************/

#ifdef MARKS_FOR_ENV_C

static int mark_comp_env_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Full_Comp_Env));
}

static int mark_comp_env_MARK(void *p) {
  Scheme_Full_Comp_Env *e = (Scheme_Full_Comp_Env *)p;

  gcMARK(e->base.genv);
  gcMARK(e->base.insp);
  gcMARK(e->base.prefix);
  gcMARK(e->base.next);
  gcMARK(e->base.values);
  gcMARK(e->base.certs);
  gcMARK(e->base.renames);
  gcMARK(e->base.uid);
  gcMARK(e->base.uids);
  gcMARK(e->base.dup_check);
  gcMARK(e->base.intdef_name);
  gcMARK(e->base.in_modidx);
  gcMARK(e->base.skip_table);
  
  gcMARK(e->data.const_names);
  gcMARK(e->data.const_vals);
  gcMARK(e->data.const_uids);
  gcMARK(e->data.use);
  gcMARK(e->data.lifts);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Full_Comp_Env));
}

static int mark_comp_env_FIXUP(void *p) {
  Scheme_Full_Comp_Env *e = (Scheme_Full_Comp_Env *)p;

  gcFIXUP(e->base.genv);
  gcFIXUP(e->base.insp);
  gcFIXUP(e->base.prefix);
  gcFIXUP(e->base.next);
  gcFIXUP(e->base.values);
  gcFIXUP(e->base.certs);
  gcFIXUP(e->base.renames);
  gcFIXUP(e->base.uid);
  gcFIXUP(e->base.uids);
  gcFIXUP(e->base.dup_check);
  gcFIXUP(e->base.intdef_name);
  gcFIXUP(e->base.in_modidx);
  gcFIXUP(e->base.skip_table);
  
  gcFIXUP(e->data.const_names);
  gcFIXUP(e->data.const_vals);
  gcFIXUP(e->data.const_uids);
  gcFIXUP(e->data.use);
  gcFIXUP(e->data.lifts);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Full_Comp_Env));
}

#define mark_comp_env_IS_ATOMIC 0
#define mark_comp_env_IS_CONST_SIZE 1


static int mark_resolve_info_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Info));
}

static int mark_resolve_info_MARK(void *p) {
  Resolve_Info *i = (Resolve_Info *)p;
  
  gcMARK(i->prefix);
  gcMARK(i->old_pos);
  gcMARK(i->new_pos);
  gcMARK(i->old_stx_pos);
  gcMARK(i->flags);
  gcMARK(i->next);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Info));
}

static int mark_resolve_info_FIXUP(void *p) {
  Resolve_Info *i = (Resolve_Info *)p;
  
  gcFIXUP(i->prefix);
  gcFIXUP(i->old_pos);
  gcFIXUP(i->new_pos);
  gcFIXUP(i->old_stx_pos);
  gcFIXUP(i->flags);
  gcFIXUP(i->next);

  return
  gcBYTES_TO_WORDS(sizeof(Resolve_Info));
}

#define mark_resolve_info_IS_ATOMIC 0
#define mark_resolve_info_IS_CONST_SIZE 1


static int mark_optimize_info_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Optimize_Info));
}

static int mark_optimize_info_MARK(void *p) {
  Optimize_Info *i = (Optimize_Info *)p;
  
  gcMARK(i->stat_dists);
  gcMARK(i->sd_depths);
  gcMARK(i->next);
  gcMARK(i->use);
  gcMARK(i->consts);
  gcMARK(i->top_level_consts);

  return
  gcBYTES_TO_WORDS(sizeof(Optimize_Info));
}

static int mark_optimize_info_FIXUP(void *p) {
  Optimize_Info *i = (Optimize_Info *)p;
  
  gcFIXUP(i->stat_dists);
  gcFIXUP(i->sd_depths);
  gcFIXUP(i->next);
  gcFIXUP(i->use);
  gcFIXUP(i->consts);
  gcFIXUP(i->top_level_consts);

  return
  gcBYTES_TO_WORDS(sizeof(Optimize_Info));
}

#define mark_optimize_info_IS_ATOMIC 0
#define mark_optimize_info_IS_CONST_SIZE 1



#endif  /* ENV */

/**********************************************************************/

#ifdef MARKS_FOR_EVAL_C

static int mark_comp_info_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compile_Info));
}

static int mark_comp_info_MARK(void *p) {
  Scheme_Compile_Info *i = (Scheme_Compile_Info *)p;
  
  gcMARK(i->value_name);
  gcMARK(i->certs);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compile_Info));
}

static int mark_comp_info_FIXUP(void *p) {
  Scheme_Compile_Info *i = (Scheme_Compile_Info *)p;
  
  gcFIXUP(i->value_name);
  gcFIXUP(i->certs);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Compile_Info));
}

#define mark_comp_info_IS_ATOMIC 0
#define mark_comp_info_IS_CONST_SIZE 1


static int mark_saved_stack_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Saved_Stack));
}

static int mark_saved_stack_MARK(void *p) {
  Scheme_Saved_Stack *saved = (Scheme_Saved_Stack *) p;
  Scheme_Object **old = saved->runstack_start;
  
  gcMARK(saved->prev);
  gcMARK( saved->runstack_start);
  saved->runstack = saved->runstack_start + (saved->runstack - old);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Saved_Stack));
}

static int mark_saved_stack_FIXUP(void *p) {
  Scheme_Saved_Stack *saved = (Scheme_Saved_Stack *) p;
  Scheme_Object **old = saved->runstack_start;
  
  gcFIXUP(saved->prev);
  gcFIXUP_TYPED_NOW(Scheme_Object **, saved->runstack_start);
  saved->runstack = saved->runstack_start + (saved->runstack - old);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Saved_Stack));
}

#define mark_saved_stack_IS_ATOMIC 0
#define mark_saved_stack_IS_CONST_SIZE 1


#endif  /* EVAL */

/**********************************************************************/

#ifdef MARKS_FOR_FILE_C

static int mark_reply_item_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(ReplyItem));
}

static int mark_reply_item_MARK(void *p) {
  ReplyItem *r = (ReplyItem *)p;
  
  gcMARK(r->next);

  return
  gcBYTES_TO_WORDS(sizeof(ReplyItem));
}

static int mark_reply_item_FIXUP(void *p) {
  ReplyItem *r = (ReplyItem *)p;
  
  gcFIXUP(r->next);

  return
  gcBYTES_TO_WORDS(sizeof(ReplyItem));
}

#define mark_reply_item_IS_ATOMIC 0
#define mark_reply_item_IS_CONST_SIZE 1


#endif  /* FILE */

/**********************************************************************/

#ifdef MARKS_FOR_FUN_C

static int mark_closure_info_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Closure_Info));
}

static int mark_closure_info_MARK(void *p) {
  Closure_Info *i = (Closure_Info *)p;
  
  gcMARK(i->local_flags);
  gcMARK(i->base_closure_map);

  return
  gcBYTES_TO_WORDS(sizeof(Closure_Info));
}

static int mark_closure_info_FIXUP(void *p) {
  Closure_Info *i = (Closure_Info *)p;
  
  gcFIXUP(i->local_flags);
  gcFIXUP(i->base_closure_map);

  return
  gcBYTES_TO_WORDS(sizeof(Closure_Info));
}

#define mark_closure_info_IS_ATOMIC 0
#define mark_closure_info_IS_CONST_SIZE 1


static int mark_dyn_wind_cell_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind_List));
}

static int mark_dyn_wind_cell_MARK(void *p) {
  Scheme_Dynamic_Wind_List *l = (Scheme_Dynamic_Wind_List *)p;
  
  gcMARK(l->dw);
  gcMARK(l->next);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind_List));
}

static int mark_dyn_wind_cell_FIXUP(void *p) {
  Scheme_Dynamic_Wind_List *l = (Scheme_Dynamic_Wind_List *)p;
  
  gcFIXUP(l->dw);
  gcFIXUP(l->next);
  
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Dynamic_Wind_List));
}

#define mark_dyn_wind_cell_IS_ATOMIC 0
#define mark_dyn_wind_cell_IS_CONST_SIZE 1


static int mark_dyn_wind_info_SIZE(void *p) {
  return
   gcBYTES_TO_WORDS(sizeof(Dyn_Wind));
}

static int mark_dyn_wind_info_MARK(void *p) {
  Dyn_Wind *d = (Dyn_Wind *)p;
  
  gcMARK(d->pre);
  gcMARK(d->act);
  gcMARK(d->post);

  return
   gcBYTES_TO_WORDS(sizeof(Dyn_Wind));
}

static int mark_dyn_wind_info_FIXUP(void *p) {
  Dyn_Wind *d = (Dyn_Wind *)p;
  
  gcFIXUP(d->pre);
  gcFIXUP(d->act);
  gcFIXUP(d->post);

  return
   gcBYTES_TO_WORDS(sizeof(Dyn_Wind));
}

#define mark_dyn_wind_info_IS_ATOMIC 0
#define mark_dyn_wind_info_IS_CONST_SIZE 1


static int mark_cont_mark_chain_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Chain));
}

static int mark_cont_mark_chain_MARK(void *p) {
  Scheme_Cont_Mark_Chain *c = (Scheme_Cont_Mark_Chain *)p;
  
  gcMARK(c->key);
  gcMARK(c->val);
  gcMARK(c->next);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Chain));
}

static int mark_cont_mark_chain_FIXUP(void *p) {
  Scheme_Cont_Mark_Chain *c = (Scheme_Cont_Mark_Chain *)p;
  
  gcFIXUP(c->key);
  gcFIXUP(c->val);
  gcFIXUP(c->next);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cont_Mark_Chain));
}

#define mark_cont_mark_chain_IS_ATOMIC 0
#define mark_cont_mark_chain_IS_CONST_SIZE 1


#endif  /* FUN */

/**********************************************************************/

#ifdef MARKS_FOR_PORTFUN_C

static int mark_load_handler_data_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(LoadHandlerData));
}

static int mark_load_handler_data_MARK(void *p) {
  LoadHandlerData *d = (LoadHandlerData *)p;
    
  gcMARK(d->config);
  gcMARK(d->port);
  gcMARK(d->p);
  gcMARK(d->stxsrc);
  gcMARK(d->expected_module);
  
  return
  gcBYTES_TO_WORDS(sizeof(LoadHandlerData));
}

static int mark_load_handler_data_FIXUP(void *p) {
  LoadHandlerData *d = (LoadHandlerData *)p;
    
  gcFIXUP(d->config);
  gcFIXUP(d->port);
  gcFIXUP(d->p);
  gcFIXUP(d->stxsrc);
  gcFIXUP(d->expected_module);
  
  return
  gcBYTES_TO_WORDS(sizeof(LoadHandlerData));
}

#define mark_load_handler_data_IS_ATOMIC 0
#define mark_load_handler_data_IS_CONST_SIZE 1


static int mark_indexed_string_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indexed_String));
}

static int mark_indexed_string_MARK(void *p) {
  Scheme_Indexed_String *is = (Scheme_Indexed_String *)p;
    
  gcMARK(is->string);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indexed_String));
}

static int mark_indexed_string_FIXUP(void *p) {
  Scheme_Indexed_String *is = (Scheme_Indexed_String *)p;
    
  gcFIXUP(is->string);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indexed_String));
}

#define mark_indexed_string_IS_ATOMIC 0
#define mark_indexed_string_IS_CONST_SIZE 1


static int mark_user_input_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(User_Input_Port));
}

static int mark_user_input_MARK(void *p) {
  User_Input_Port *uip = (User_Input_Port *)p;

  gcMARK(uip->read_proc);
  gcMARK(uip->peek_proc);
  gcMARK(uip->progress_evt_proc);
  gcMARK(uip->peeked_read_proc);
  gcMARK(uip->location_proc);
  gcMARK(uip->count_lines_proc);
  gcMARK(uip->buffer_mode_proc);
  gcMARK(uip->close_proc);
  gcMARK(uip->reuse_str);
  gcMARK(uip->peeked);
  return
  gcBYTES_TO_WORDS(sizeof(User_Input_Port));
}

static int mark_user_input_FIXUP(void *p) {
  User_Input_Port *uip = (User_Input_Port *)p;

  gcFIXUP(uip->read_proc);
  gcFIXUP(uip->peek_proc);
  gcFIXUP(uip->progress_evt_proc);
  gcFIXUP(uip->peeked_read_proc);
  gcFIXUP(uip->location_proc);
  gcFIXUP(uip->count_lines_proc);
  gcFIXUP(uip->buffer_mode_proc);
  gcFIXUP(uip->close_proc);
  gcFIXUP(uip->reuse_str);
  gcFIXUP(uip->peeked);
  return
  gcBYTES_TO_WORDS(sizeof(User_Input_Port));
}

#define mark_user_input_IS_ATOMIC 0
#define mark_user_input_IS_CONST_SIZE 1


static int mark_user_output_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(User_Output_Port));
}

static int mark_user_output_MARK(void *p) {
  User_Output_Port *uop = (User_Output_Port *)p;

  gcMARK(uop->evt);
  gcMARK(uop->write_evt_proc);
  gcMARK(uop->write_proc);
  gcMARK(uop->write_special_evt_proc);
  gcMARK(uop->write_special_proc);
  gcMARK(uop->location_proc);
  gcMARK(uop->count_lines_proc);
  gcMARK(uop->buffer_mode_proc);
  gcMARK(uop->close_proc);
  return
  gcBYTES_TO_WORDS(sizeof(User_Output_Port));
}

static int mark_user_output_FIXUP(void *p) {
  User_Output_Port *uop = (User_Output_Port *)p;

  gcFIXUP(uop->evt);
  gcFIXUP(uop->write_evt_proc);
  gcFIXUP(uop->write_proc);
  gcFIXUP(uop->write_special_evt_proc);
  gcFIXUP(uop->write_special_proc);
  gcFIXUP(uop->location_proc);
  gcFIXUP(uop->count_lines_proc);
  gcFIXUP(uop->buffer_mode_proc);
  gcFIXUP(uop->close_proc);
  return
  gcBYTES_TO_WORDS(sizeof(User_Output_Port));
}

#define mark_user_output_IS_ATOMIC 0
#define mark_user_output_IS_CONST_SIZE 1


#endif  /* PORTFUN */

/**********************************************************************/

#ifdef MARKS_FOR_PORT_C

#ifdef WINDOWS_PROCESSES
static int mark_thread_memory_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Memory));
}

static int mark_thread_memory_MARK(void *p) {
  Scheme_Thread_Memory *tm = (Scheme_Thread_Memory *)p;
  gcMARK(tm->prev);
  gcMARK(tm->next);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Memory));
}

static int mark_thread_memory_FIXUP(void *p) {
  Scheme_Thread_Memory *tm = (Scheme_Thread_Memory *)p;
  gcFIXUP(tm->prev);
  gcFIXUP(tm->next);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Memory));
}

#define mark_thread_memory_IS_ATOMIC 0
#define mark_thread_memory_IS_CONST_SIZE 1

#endif

static int mark_input_file_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_File));
}

static int mark_input_file_MARK(void *p) {
  Scheme_Input_File *i = (Scheme_Input_File *)p;

  gcMARK(i->f);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_File));
}

static int mark_input_file_FIXUP(void *p) {
  Scheme_Input_File *i = (Scheme_Input_File *)p;

  gcFIXUP(i->f);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Input_File));
}

#define mark_input_file_IS_ATOMIC 0
#define mark_input_file_IS_CONST_SIZE 1


#if defined(WIN32_FD_HANDLES)
static int mark_tcp_select_info_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Tcp_Select_Info));
}

static int mark_tcp_select_info_MARK(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Tcp_Select_Info));
}

static int mark_tcp_select_info_FIXUP(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Tcp_Select_Info));
}

#define mark_tcp_select_info_IS_ATOMIC 1
#define mark_tcp_select_info_IS_CONST_SIZE 1

#endif

static int mark_output_file_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_File));
}

static int mark_output_file_MARK(void *p) {
  Scheme_Output_File *o = (Scheme_Output_File *)p;

  gcMARK(o->f);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_File));
}

static int mark_output_file_FIXUP(void *p) {
  Scheme_Output_File *o = (Scheme_Output_File *)p;

  gcFIXUP(o->f);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Output_File));
}

#define mark_output_file_IS_ATOMIC 0
#define mark_output_file_IS_CONST_SIZE 1


#ifdef MZ_FDS
static int mark_input_fd_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_FD));
}

static int mark_input_fd_MARK(void *p) {
  Scheme_FD *fd = (Scheme_FD *)p;

  gcMARK(fd->buffer);
  gcMARK(fd->refcount);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_FD));
}

static int mark_input_fd_FIXUP(void *p) {
  Scheme_FD *fd = (Scheme_FD *)p;

  gcFIXUP(fd->buffer);
  gcFIXUP(fd->refcount);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_FD));
}

#define mark_input_fd_IS_ATOMIC 0
#define mark_input_fd_IS_CONST_SIZE 1

#endif

#if defined(UNIX_PROCESSES)
static int mark_system_child_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(System_Child));
}

static int mark_system_child_MARK(void *p) {
  System_Child *sc = (System_Child *)p;

  gcMARK(sc->next);

  return
  gcBYTES_TO_WORDS(sizeof(System_Child));
}

static int mark_system_child_FIXUP(void *p) {
  System_Child *sc = (System_Child *)p;

  gcFIXUP(sc->next);

  return
  gcBYTES_TO_WORDS(sizeof(System_Child));
}

#define mark_system_child_IS_ATOMIC 0
#define mark_system_child_IS_CONST_SIZE 1

#endif

#ifdef USE_OSKIT_CONSOLE
static int mark_oskit_console_input_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(osk_console_input));
}

static int mark_oskit_console_input_MARK(void *p) {
  osk_console_input *c = (osk_console_input *)p;
    
  gcMARK(c->buffer);
  gcMARK(c->next);

  return
  gcBYTES_TO_WORDS(sizeof(osk_console_input));
}

static int mark_oskit_console_input_FIXUP(void *p) {
  osk_console_input *c = (osk_console_input *)p;
    
  gcFIXUP(c->buffer);
  gcFIXUP(c->next);

  return
  gcBYTES_TO_WORDS(sizeof(osk_console_input));
}

#define mark_oskit_console_input_IS_ATOMIC 0
#define mark_oskit_console_input_IS_CONST_SIZE 1

#endif

static int mark_subprocess_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Subprocess));
}

static int mark_subprocess_MARK(void *p) {
#ifndef WINDOWS_PROCESSES
  Scheme_Subprocess *sp = (Scheme_Subprocess *)p;
  gcMARK(sp->handle);
#endif
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Subprocess));
}

static int mark_subprocess_FIXUP(void *p) {
#ifndef WINDOWS_PROCESSES
  Scheme_Subprocess *sp = (Scheme_Subprocess *)p;
  gcFIXUP(sp->handle);
#endif
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Subprocess));
}

#define mark_subprocess_IS_ATOMIC 0
#define mark_subprocess_IS_CONST_SIZE 1


static int mark_read_write_evt_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Read_Write_Evt));
}

static int mark_read_write_evt_MARK(void *p) {
  Scheme_Read_Write_Evt *rww = (Scheme_Read_Write_Evt *)p;
  gcMARK(rww->port);
  gcMARK(rww->v);
  gcMARK(rww->str);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Read_Write_Evt));
}

static int mark_read_write_evt_FIXUP(void *p) {
  Scheme_Read_Write_Evt *rww = (Scheme_Read_Write_Evt *)p;
  gcFIXUP(rww->port);
  gcFIXUP(rww->v);
  gcFIXUP(rww->str);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Read_Write_Evt));
}

#define mark_read_write_evt_IS_ATOMIC 0
#define mark_read_write_evt_IS_CONST_SIZE 1


#endif  /* PORT */

/**********************************************************************/

#ifdef MARKS_FOR_PRINT_C

static int mark_print_params_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(PrintParams));
}

static int mark_print_params_MARK(void *p) {
  PrintParams *pp = (PrintParams *)p;
  gcMARK(pp->inspector);
  gcMARK(pp->print_port);
  gcMARK(pp->print_buffer);
  return
  gcBYTES_TO_WORDS(sizeof(PrintParams));
}

static int mark_print_params_FIXUP(void *p) {
  PrintParams *pp = (PrintParams *)p;
  gcFIXUP(pp->inspector);
  gcFIXUP(pp->print_port);
  gcFIXUP(pp->print_buffer);
  return
  gcBYTES_TO_WORDS(sizeof(PrintParams));
}

#define mark_print_params_IS_ATOMIC 0
#define mark_print_params_IS_CONST_SIZE 1


#endif  /* PRINT */

/**********************************************************************/

#ifdef MARKS_FOR_NETWORK_C

static int mark_listener_SIZE(void *p) {
  listener_t *l = (listener_t *)p;

  return
  gcBYTES_TO_WORDS(sizeof(listener_t) + ((l->count - 1) * sizeof(tcp_t)));
}

static int mark_listener_MARK(void *p) {
  listener_t *l = (listener_t *)p;


  gcMARK(l->mref);

  return
  gcBYTES_TO_WORDS(sizeof(listener_t) + ((l->count - 1) * sizeof(tcp_t)));
}

static int mark_listener_FIXUP(void *p) {
  listener_t *l = (listener_t *)p;


  gcFIXUP(l->mref);

  return
  gcBYTES_TO_WORDS(sizeof(listener_t) + ((l->count - 1) * sizeof(tcp_t)));
}

#define mark_listener_IS_ATOMIC 0
#define mark_listener_IS_CONST_SIZE 0


#ifdef USE_TCP
static int mark_tcp_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Tcp));
}

static int mark_tcp_MARK(void *p) {
  Scheme_Tcp *tcp = (Scheme_Tcp *)p;

  gcMARK(tcp->b.buffer);
  gcMARK(tcp->b.out_buffer);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Tcp));
}

static int mark_tcp_FIXUP(void *p) {
  Scheme_Tcp *tcp = (Scheme_Tcp *)p;

  gcFIXUP(tcp->b.buffer);
  gcFIXUP(tcp->b.out_buffer);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Tcp));
}

#define mark_tcp_IS_ATOMIC 0
#define mark_tcp_IS_CONST_SIZE 1


# ifdef UDP_IS_SUPPORTED
static int mark_udp_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP));
}

static int mark_udp_MARK(void *p) {
  Scheme_UDP *udp = (Scheme_UDP *)p;

  gcMARK(udp->previous_from_addr);
  gcMARK(udp->mref);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP));
}

static int mark_udp_FIXUP(void *p) {
  Scheme_UDP *udp = (Scheme_UDP *)p;

  gcFIXUP(udp->previous_from_addr);
  gcFIXUP(udp->mref);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP));
}

#define mark_udp_IS_ATOMIC 0
#define mark_udp_IS_CONST_SIZE 1


static int mark_udp_evt_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP_Evt));
}

static int mark_udp_evt_MARK(void *p) {
  Scheme_UDP_Evt *uw = (Scheme_UDP_Evt *)p;

  gcMARK(uw->udp);
  gcMARK(uw->str);
  gcMARK(uw->dest_addr);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP_Evt));
}

static int mark_udp_evt_FIXUP(void *p) {
  Scheme_UDP_Evt *uw = (Scheme_UDP_Evt *)p;

  gcFIXUP(uw->udp);
  gcFIXUP(uw->str);
  gcFIXUP(uw->dest_addr);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_UDP_Evt));
}

#define mark_udp_evt_IS_ATOMIC 0
#define mark_udp_evt_IS_CONST_SIZE 1

# endif
#endif

#endif  /* NETWORK */

/**********************************************************************/

#ifdef MARKS_FOR_THREAD_C

static int mark_parameterization_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Parameterization)
		    + ((max_configs - 1) * sizeof(Scheme_Object*))));
}

static int mark_parameterization_MARK(void *p) {
  Scheme_Parameterization *c = (Scheme_Parameterization *)p;
  int i;
    
  for (i = max_configs; i--; ) {
    gcMARK(c->prims[i]);
  }
  gcMARK(c->extensions);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Parameterization)
		    + ((max_configs - 1) * sizeof(Scheme_Object*))));
}

static int mark_parameterization_FIXUP(void *p) {
  Scheme_Parameterization *c = (Scheme_Parameterization *)p;
  int i;
    
  for (i = max_configs; i--; ) {
    gcFIXUP(c->prims[i]);
  }
  gcFIXUP(c->extensions);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Parameterization)
		    + ((max_configs - 1) * sizeof(Scheme_Object*))));
}

#define mark_parameterization_IS_ATOMIC 0
#define mark_parameterization_IS_CONST_SIZE 0


static int mark_config_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Config));
}

static int mark_config_MARK(void *p) {
  Scheme_Config *config = (Scheme_Config *)p;
  gcMARK(config->key);
  gcMARK(config->cell);
  gcMARK(config->next);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Config));
}

static int mark_config_FIXUP(void *p) {
  Scheme_Config *config = (Scheme_Config *)p;
  gcFIXUP(config->key);
  gcFIXUP(config->cell);
  gcFIXUP(config->next);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Config));
}

#define mark_config_IS_ATOMIC 0
#define mark_config_IS_CONST_SIZE 1


static int mark_will_executor_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(WillExecutor));
}

static int mark_will_executor_val_MARK(void *p) {
  WillExecutor *e = (WillExecutor *)p;
  
  gcMARK(e->sema);
  gcMARK(e->first);
  gcMARK(e->last);

  return
  gcBYTES_TO_WORDS(sizeof(WillExecutor));
}

static int mark_will_executor_val_FIXUP(void *p) {
  WillExecutor *e = (WillExecutor *)p;
  
  gcFIXUP(e->sema);
  gcFIXUP(e->first);
  gcFIXUP(e->last);

  return
  gcBYTES_TO_WORDS(sizeof(WillExecutor));
}

#define mark_will_executor_val_IS_ATOMIC 0
#define mark_will_executor_val_IS_CONST_SIZE 1


static int mark_custodian_val_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian));
}

static int mark_custodian_val_MARK(void *p) {
  Scheme_Custodian *m = (Scheme_Custodian *)p;
  
  gcMARK(m->boxes);
  gcMARK(m->mrefs);
  gcMARK(m->closers);
  gcMARK(m->data);

  gcMARK(m->parent);
  gcMARK(m->sibling);
  gcMARK(m->children);

  gcMARK(m->global_next);
  gcMARK(m->global_prev);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian));
}

static int mark_custodian_val_FIXUP(void *p) {
  Scheme_Custodian *m = (Scheme_Custodian *)p;
  
  gcFIXUP(m->boxes);
  gcFIXUP(m->mrefs);
  gcFIXUP(m->closers);
  gcFIXUP(m->data);

  gcFIXUP(m->parent);
  gcFIXUP(m->sibling);
  gcFIXUP(m->children);

  gcFIXUP(m->global_next);
  gcFIXUP(m->global_prev);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Custodian));
}

#define mark_custodian_val_IS_ATOMIC 0
#define mark_custodian_val_IS_CONST_SIZE 1


static int mark_thread_hop_SIZE(void *p) {
  return
   gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Custodian_Hop));
}

static int mark_thread_hop_MARK(void *p) {
  Scheme_Thread_Custodian_Hop *hop = (Scheme_Thread_Custodian_Hop *)p;

  gcMARK(hop->p);

  return
   gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Custodian_Hop));
}

static int mark_thread_hop_FIXUP(void *p) {
  Scheme_Thread_Custodian_Hop *hop = (Scheme_Thread_Custodian_Hop *)p;

  gcFIXUP(hop->p);

  return
   gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Custodian_Hop));
}

#define mark_thread_hop_IS_ATOMIC 0
#define mark_thread_hop_IS_CONST_SIZE 1


static int mark_namespace_option_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_NSO));
}

static int mark_namespace_option_MARK(void *p) {
  Scheme_NSO *o = (Scheme_NSO *)p;

  gcMARK(o->key);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_NSO));
}

static int mark_namespace_option_FIXUP(void *p) {
  Scheme_NSO *o = (Scheme_NSO *)p;

  gcFIXUP(o->key);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_NSO));
}

#define mark_namespace_option_IS_ATOMIC 0
#define mark_namespace_option_IS_CONST_SIZE 1


static int mark_param_data_SIZE(void *p) {
  return
   gcBYTES_TO_WORDS(sizeof(ParamData));
}

static int mark_param_data_MARK(void *p) {
  ParamData *d = (ParamData *)p;

  gcMARK(d->key);
  gcMARK(d->guard);
  gcMARK(d->defcell);

  return
   gcBYTES_TO_WORDS(sizeof(ParamData));
}

static int mark_param_data_FIXUP(void *p) {
  ParamData *d = (ParamData *)p;

  gcFIXUP(d->key);
  gcFIXUP(d->guard);
  gcFIXUP(d->defcell);

  return
   gcBYTES_TO_WORDS(sizeof(ParamData));
}

#define mark_param_data_IS_ATOMIC 0
#define mark_param_data_IS_CONST_SIZE 1


static int mark_will_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(ActiveWill));
}

static int mark_will_MARK(void *p) {
  ActiveWill *w = (ActiveWill *)p;
  
  gcMARK(w->o);
  gcMARK(w->proc);
  gcMARK(w->w);
  gcMARK(w->next);

  return
  gcBYTES_TO_WORDS(sizeof(ActiveWill));
}

static int mark_will_FIXUP(void *p) {
  ActiveWill *w = (ActiveWill *)p;
  
  gcFIXUP(w->o);
  gcFIXUP(w->proc);
  gcFIXUP(w->w);
  gcFIXUP(w->next);

  return
  gcBYTES_TO_WORDS(sizeof(ActiveWill));
}

#define mark_will_IS_ATOMIC 0
#define mark_will_IS_CONST_SIZE 1


static int mark_will_registration_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(WillRegistration));
}

static int mark_will_registration_MARK(void *p) {
  WillRegistration *r = (WillRegistration *)p;
 
  gcMARK(r->proc);
  gcMARK(r->w);

  return
  gcBYTES_TO_WORDS(sizeof(WillRegistration));
}

static int mark_will_registration_FIXUP(void *p) {
  WillRegistration *r = (WillRegistration *)p;
 
  gcFIXUP(r->proc);
  gcFIXUP(r->w);

  return
  gcBYTES_TO_WORDS(sizeof(WillRegistration));
}

#define mark_will_registration_IS_ATOMIC 0
#define mark_will_registration_IS_CONST_SIZE 1


static int mark_evt_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt));
}

static int mark_evt_MARK(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt));
}

static int mark_evt_FIXUP(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt));
}

#define mark_evt_IS_ATOMIC 1
#define mark_evt_IS_CONST_SIZE 1


static int mark_syncing_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Syncing));
}

static int mark_syncing_MARK(void *p) {
  Syncing *w = (Syncing *)p;
 
  gcMARK(w->set);
  gcMARK(w->wrapss);
  gcMARK(w->nackss);
  gcMARK(w->reposts);
  gcMARK(w->disable_break);

  return
  gcBYTES_TO_WORDS(sizeof(Syncing));
}

static int mark_syncing_FIXUP(void *p) {
  Syncing *w = (Syncing *)p;
 
  gcFIXUP(w->set);
  gcFIXUP(w->wrapss);
  gcFIXUP(w->nackss);
  gcFIXUP(w->reposts);
  gcFIXUP(w->disable_break);

  return
  gcBYTES_TO_WORDS(sizeof(Syncing));
}

#define mark_syncing_IS_ATOMIC 0
#define mark_syncing_IS_CONST_SIZE 1


static int mark_evt_set_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Evt_Set));
}

static int mark_evt_set_MARK(void *p) {
  Evt_Set *w = (Evt_Set *)p;
 
  gcMARK(w->ws);
  gcMARK(w->argv);

  return
  gcBYTES_TO_WORDS(sizeof(Evt_Set));
}

static int mark_evt_set_FIXUP(void *p) {
  Evt_Set *w = (Evt_Set *)p;
 
  gcFIXUP(w->ws);
  gcFIXUP(w->argv);

  return
  gcBYTES_TO_WORDS(sizeof(Evt_Set));
}

#define mark_evt_set_IS_ATOMIC 0
#define mark_evt_set_IS_CONST_SIZE 1


static int mark_thread_set_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Set));
}

static int mark_thread_set_MARK(void *p) {
  Scheme_Thread_Set *ts = (Scheme_Thread_Set *)p;
 
  gcMARK(ts->parent);
  gcMARK(ts->first);
  gcMARK(ts->next);
  gcMARK(ts->prev);
  gcMARK(ts->search_start);
  gcMARK(ts->current);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Set));
}

static int mark_thread_set_FIXUP(void *p) {
  Scheme_Thread_Set *ts = (Scheme_Thread_Set *)p;
 
  gcFIXUP(ts->parent);
  gcFIXUP(ts->first);
  gcFIXUP(ts->next);
  gcFIXUP(ts->prev);
  gcFIXUP(ts->search_start);
  gcFIXUP(ts->current);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Thread_Set));
}

#define mark_thread_set_IS_ATOMIC 0
#define mark_thread_set_IS_CONST_SIZE 1


static int mark_thread_cell_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Thread_Cell));
}

static int mark_thread_cell_MARK(void *p) {
  Thread_Cell *c = (Thread_Cell *)p;
 
  gcMARK(c->def_val);

  return
  gcBYTES_TO_WORDS(sizeof(Thread_Cell));
}

static int mark_thread_cell_FIXUP(void *p) {
  Thread_Cell *c = (Thread_Cell *)p;
 
  gcFIXUP(c->def_val);

  return
  gcBYTES_TO_WORDS(sizeof(Thread_Cell));
}

#define mark_thread_cell_IS_ATOMIC 0
#define mark_thread_cell_IS_CONST_SIZE 1


#endif  /* THREAD */

/**********************************************************************/

#ifdef MARKS_FOR_SALLOC_C

static int mark_finalization_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Finalization));
}

static int mark_finalization_MARK(void *p) {
  Finalization *f = (Finalization *)p;
  
  gcMARK(f->data);
  gcMARK(f->next);
  gcMARK(f->prev);

  return
  gcBYTES_TO_WORDS(sizeof(Finalization));
}

static int mark_finalization_FIXUP(void *p) {
  Finalization *f = (Finalization *)p;
  
  gcFIXUP(f->data);
  gcFIXUP(f->next);
  gcFIXUP(f->prev);

  return
  gcBYTES_TO_WORDS(sizeof(Finalization));
}

#define mark_finalization_IS_ATOMIC 0
#define mark_finalization_IS_CONST_SIZE 1


static int mark_finalizations_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Finalizations));
}

static int mark_finalizations_MARK(void *p) {
  Finalizations *f = (Finalizations *)p;

  gcMARK(f->scheme_first);
  gcMARK(f->scheme_last);
  gcMARK(f->prim_first);
  gcMARK(f->prim_last);
  gcMARK(f->ext_data);

  return
  gcBYTES_TO_WORDS(sizeof(Finalizations));
}

static int mark_finalizations_FIXUP(void *p) {
  Finalizations *f = (Finalizations *)p;

  gcFIXUP(f->scheme_first);
  gcFIXUP(f->scheme_last);
  gcFIXUP(f->prim_first);
  gcFIXUP(f->prim_last);
  gcFIXUP(f->ext_data);

  return
  gcBYTES_TO_WORDS(sizeof(Finalizations));
}

#define mark_finalizations_IS_ATOMIC 0
#define mark_finalizations_IS_CONST_SIZE 1


#endif  /* SALLOC */

/**********************************************************************/

#ifdef MARKS_FOR_SEMA_C

static int mark_channel_syncer_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Syncer));
}

static int mark_channel_syncer_MARK(void *p) {
  Scheme_Channel_Syncer *w = (Scheme_Channel_Syncer *)p;

  gcMARK(w->p);
  gcMARK(w->prev);
  gcMARK(w->next);
  gcMARK(w->syncing);
  gcMARK(w->obj);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Syncer));
}

static int mark_channel_syncer_FIXUP(void *p) {
  Scheme_Channel_Syncer *w = (Scheme_Channel_Syncer *)p;

  gcFIXUP(w->p);
  gcFIXUP(w->prev);
  gcFIXUP(w->next);
  gcFIXUP(w->syncing);
  gcFIXUP(w->obj);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Channel_Syncer));
}

#define mark_channel_syncer_IS_ATOMIC 0
#define mark_channel_syncer_IS_CONST_SIZE 1


static int mark_alarm_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Alarm));
}

static int mark_alarm_MARK(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Alarm));
}

static int mark_alarm_FIXUP(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Alarm));
}

#define mark_alarm_IS_ATOMIC 1
#define mark_alarm_IS_CONST_SIZE 1


#endif  /* SEMA */

/**********************************************************************/

#ifdef MARKS_FOR_STRUCT_C

static int mark_struct_val_SIZE(void *p) {
  Scheme_Structure *s = (Scheme_Structure *)p;
  int num_slots = ((Scheme_Struct_Type *)GC_resolve(s->stype))->num_slots;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Structure) 
		    + ((num_slots - 1) * sizeof(Scheme_Object *))));
}

static int mark_struct_val_MARK(void *p) {
  Scheme_Structure *s = (Scheme_Structure *)p;
  int num_slots = ((Scheme_Struct_Type *)GC_resolve(s->stype))->num_slots;

  int i;

  gcMARK( s->stype);
  
  for(i = num_slots; i--; )
    gcMARK(s->slots[i]);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Structure) 
		    + ((num_slots - 1) * sizeof(Scheme_Object *))));
}

static int mark_struct_val_FIXUP(void *p) {
  Scheme_Structure *s = (Scheme_Structure *)p;
  int num_slots = ((Scheme_Struct_Type *)GC_resolve(s->stype))->num_slots;

  int i;

  gcFIXUP_TYPED_NOW(Scheme_Struct_Type *, s->stype);
  
  for(i = num_slots; i--; )
    gcFIXUP(s->slots[i]);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Structure) 
		    + ((num_slots - 1) * sizeof(Scheme_Object *))));
}

#define mark_struct_val_IS_ATOMIC 0
#define mark_struct_val_IS_CONST_SIZE 0


static int mark_struct_type_val_SIZE(void *p) {
  Scheme_Struct_Type *t = (Scheme_Struct_Type *)p;

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Struct_Type)
		    + (t->name_pos * sizeof(Scheme_Struct_Type *))));
}

static int mark_struct_type_val_MARK(void *p) {
  Scheme_Struct_Type *t = (Scheme_Struct_Type *)p;

  int i;
  for (i = t->name_pos + 1; i--; ) {
    gcMARK(t->parent_types[i]);
  }
  gcMARK(t->name);
  gcMARK(t->inspector);
  gcMARK(t->accessor);
  gcMARK(t->mutator);
  gcMARK(t->uninit_val);
  gcMARK(t->props);
  gcMARK(t->proc_attr);
  gcMARK(t->guard);
  gcMARK(t->immutables);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Struct_Type)
		    + (t->name_pos * sizeof(Scheme_Struct_Type *))));
}

static int mark_struct_type_val_FIXUP(void *p) {
  Scheme_Struct_Type *t = (Scheme_Struct_Type *)p;

  int i;
  for (i = t->name_pos + 1; i--; ) {
    gcFIXUP(t->parent_types[i]);
  }
  gcFIXUP(t->name);
  gcFIXUP(t->inspector);
  gcFIXUP(t->accessor);
  gcFIXUP(t->mutator);
  gcFIXUP(t->uninit_val);
  gcFIXUP(t->props);
  gcFIXUP(t->proc_attr);
  gcFIXUP(t->guard);
  gcFIXUP(t->immutables);

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Struct_Type)
		    + (t->name_pos * sizeof(Scheme_Struct_Type *))));
}

#define mark_struct_type_val_IS_ATOMIC 0
#define mark_struct_type_val_IS_CONST_SIZE 0


static int mark_struct_proc_info_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Struct_Proc_Info));
}

static int mark_struct_proc_info_MARK(void *p) {
  Struct_Proc_Info *i = (Struct_Proc_Info *)p;

  gcMARK(i->struct_type);
  gcMARK(i->func_name);

  return
  gcBYTES_TO_WORDS(sizeof(Struct_Proc_Info));
}

static int mark_struct_proc_info_FIXUP(void *p) {
  Struct_Proc_Info *i = (Struct_Proc_Info *)p;

  gcFIXUP(i->struct_type);
  gcFIXUP(i->func_name);

  return
  gcBYTES_TO_WORDS(sizeof(Struct_Proc_Info));
}

#define mark_struct_proc_info_IS_ATOMIC 0
#define mark_struct_proc_info_IS_CONST_SIZE 1


static int mark_struct_property_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Struct_Property));
}

static int mark_struct_property_MARK(void *p) {
  Scheme_Struct_Property *i = (Scheme_Struct_Property *)p;
  gcMARK(i->name);
  gcMARK(i->guard);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Struct_Property));
}

static int mark_struct_property_FIXUP(void *p) {
  Scheme_Struct_Property *i = (Scheme_Struct_Property *)p;
  gcFIXUP(i->name);
  gcFIXUP(i->guard);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Struct_Property));
}

#define mark_struct_property_IS_ATOMIC 0
#define mark_struct_property_IS_CONST_SIZE 1


static int mark_wrapped_evt_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Wrapped_Evt));
}

static int mark_wrapped_evt_MARK(void *p) {
  Wrapped_Evt *ww = (Wrapped_Evt *)p;

  gcMARK(ww->evt);
  gcMARK(ww->wrapper);

  return
  gcBYTES_TO_WORDS(sizeof(Wrapped_Evt));
}

static int mark_wrapped_evt_FIXUP(void *p) {
  Wrapped_Evt *ww = (Wrapped_Evt *)p;

  gcFIXUP(ww->evt);
  gcFIXUP(ww->wrapper);

  return
  gcBYTES_TO_WORDS(sizeof(Wrapped_Evt));
}

#define mark_wrapped_evt_IS_ATOMIC 0
#define mark_wrapped_evt_IS_CONST_SIZE 1


static int mark_nack_guard_evt_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Nack_Guard_Evt));
}

static int mark_nack_guard_evt_MARK(void *p) {
  Nack_Guard_Evt *nw = (Nack_Guard_Evt *)p;

  gcMARK(nw->maker);

  return
  gcBYTES_TO_WORDS(sizeof(Nack_Guard_Evt));
}

static int mark_nack_guard_evt_FIXUP(void *p) {
  Nack_Guard_Evt *nw = (Nack_Guard_Evt *)p;

  gcFIXUP(nw->maker);

  return
  gcBYTES_TO_WORDS(sizeof(Nack_Guard_Evt));
}

#define mark_nack_guard_evt_IS_ATOMIC 0
#define mark_nack_guard_evt_IS_CONST_SIZE 1


#endif  /* STRUCT */

/**********************************************************************/

#ifdef MARKS_FOR_SYNTAX_C

#endif  /* SYNTAX */

/**********************************************************************/

#ifdef MARKS_FOR_READ_C

static int mark_indent_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indent));
}

static int mark_indent_MARK(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indent));
}

static int mark_indent_FIXUP(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Indent));
}

#define mark_indent_IS_ATOMIC 1
#define mark_indent_IS_CONST_SIZE 1


static int mark_cport_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(CPort));
}

static int mark_cport_MARK(void *p) {
  CPort *cp = (CPort *)p;
  gcMARK(cp->start);
  gcMARK(cp->orig_port);
  gcMARK(cp->ht);
  gcMARK(cp->symtab);
  gcMARK(cp->insp);
  gcMARK(cp->magic_sym);
  gcMARK(cp->magic_val);
  return
  gcBYTES_TO_WORDS(sizeof(CPort));
}

static int mark_cport_FIXUP(void *p) {
  CPort *cp = (CPort *)p;
  gcFIXUP(cp->start);
  gcFIXUP(cp->orig_port);
  gcFIXUP(cp->ht);
  gcFIXUP(cp->symtab);
  gcFIXUP(cp->insp);
  gcFIXUP(cp->magic_sym);
  gcFIXUP(cp->magic_val);
  return
  gcBYTES_TO_WORDS(sizeof(CPort));
}

#define mark_cport_IS_ATOMIC 0
#define mark_cport_IS_CONST_SIZE 1


static int mark_readtable_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Readtable));
}

static int mark_readtable_MARK(void *p) {
  Readtable *t = (Readtable *)p;
  gcMARK(t->mapping);
  gcMARK(t->fast_mapping);
  gcMARK(t->symbol_parser);
  return
  gcBYTES_TO_WORDS(sizeof(Readtable));
}

static int mark_readtable_FIXUP(void *p) {
  Readtable *t = (Readtable *)p;
  gcFIXUP(t->mapping);
  gcFIXUP(t->fast_mapping);
  gcFIXUP(t->symbol_parser);
  return
  gcBYTES_TO_WORDS(sizeof(Readtable));
}

#define mark_readtable_IS_ATOMIC 0
#define mark_readtable_IS_CONST_SIZE 1


static int mark_read_params_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(ReadParams));
}

static int mark_read_params_MARK(void *p) {
  ReadParams *rp = (ReadParams *)p;
  gcMARK(rp->table);
  gcMARK(rp->magic_sym);
  gcMARK(rp->magic_val);
  return
  gcBYTES_TO_WORDS(sizeof(ReadParams));
}

static int mark_read_params_FIXUP(void *p) {
  ReadParams *rp = (ReadParams *)p;
  gcFIXUP(rp->table);
  gcFIXUP(rp->magic_sym);
  gcFIXUP(rp->magic_val);
  return
  gcBYTES_TO_WORDS(sizeof(ReadParams));
}

#define mark_read_params_IS_ATOMIC 0
#define mark_read_params_IS_CONST_SIZE 1


#endif  /* READ */

/**********************************************************************/

#ifdef MARKS_FOR_REGEXP_C

static int mark_regexp_SIZE(void *p) {
  regexp *r = (regexp *)p;
  return
  gcBYTES_TO_WORDS((sizeof(regexp) + r->regsize));
}

static int mark_regexp_MARK(void *p) {
  regexp *r = (regexp *)p;
  gcMARK(r->source);
  return
  gcBYTES_TO_WORDS((sizeof(regexp) + r->regsize));
}

static int mark_regexp_FIXUP(void *p) {
  regexp *r = (regexp *)p;
  gcFIXUP(r->source);
  return
  gcBYTES_TO_WORDS((sizeof(regexp) + r->regsize));
}

#define mark_regexp_IS_ATOMIC 0
#define mark_regexp_IS_CONST_SIZE 0


static int mark_regwork_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Regwork));
}

static int mark_regwork_MARK(void *p) {
  Regwork *r = (Regwork *)p;
  gcMARK(r->str);
  gcMARK(r->instr);
  gcMARK(r->port);
  gcMARK(r->unless_evt);
  gcMARK(r->startp);
  gcMARK(r->endp);
  gcMARK(r->peekskip);
  return
  gcBYTES_TO_WORDS(sizeof(Regwork));
}

static int mark_regwork_FIXUP(void *p) {
  Regwork *r = (Regwork *)p;
  gcFIXUP(r->str);
  gcFIXUP(r->instr);
  gcFIXUP(r->port);
  gcFIXUP(r->unless_evt);
  gcFIXUP(r->startp);
  gcFIXUP(r->endp);
  gcFIXUP(r->peekskip);
  return
  gcBYTES_TO_WORDS(sizeof(Regwork));
}

#define mark_regwork_IS_ATOMIC 0
#define mark_regwork_IS_CONST_SIZE 1


#endif  /* REGEXP */

/**********************************************************************/

#ifdef MARKS_FOR_STRING_C

static int mark_string_convert_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Converter));
}

static int mark_string_convert_MARK(void *p) {
  Scheme_Converter *c = (Scheme_Converter *)p;
  gcMARK(c->mref);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Converter));
}

static int mark_string_convert_FIXUP(void *p) {
  Scheme_Converter *c = (Scheme_Converter *)p;
  gcFIXUP(c->mref);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Converter));
}

#define mark_string_convert_IS_ATOMIC 0
#define mark_string_convert_IS_CONST_SIZE 1


#endif  /* STRING */

/**********************************************************************/

#ifdef MARKS_FOR_STXOBJ_C

static int mark_rename_table_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Module_Renames));
}

static int mark_rename_table_MARK(void *p) {
  Module_Renames *rn = (Module_Renames *)p;
  gcMARK(rn->ht);
  gcMARK(rn->nomarshal_ht);
  gcMARK(rn->unmarshal_info);
  gcMARK(rn->plus_kernel_nominal_source);
  gcMARK(rn->marked_names);
  return
  gcBYTES_TO_WORDS(sizeof(Module_Renames));
}

static int mark_rename_table_FIXUP(void *p) {
  Module_Renames *rn = (Module_Renames *)p;
  gcFIXUP(rn->ht);
  gcFIXUP(rn->nomarshal_ht);
  gcFIXUP(rn->unmarshal_info);
  gcFIXUP(rn->plus_kernel_nominal_source);
  gcFIXUP(rn->marked_names);
  return
  gcBYTES_TO_WORDS(sizeof(Module_Renames));
}

#define mark_rename_table_IS_ATOMIC 0
#define mark_rename_table_IS_CONST_SIZE 1


static int mark_srcloc_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
}

static int mark_srcloc_MARK(void *p) {
  Scheme_Stx_Srcloc *s = (Scheme_Stx_Srcloc *)p;
  gcMARK(s->src);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
}

static int mark_srcloc_FIXUP(void *p) {
  Scheme_Stx_Srcloc *s = (Scheme_Stx_Srcloc *)p;
  gcFIXUP(s->src);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
}

#define mark_srcloc_IS_ATOMIC 0
#define mark_srcloc_IS_CONST_SIZE 1


static int mark_wrapchunk_SIZE(void *p) {
  Wrap_Chunk *wc = (Wrap_Chunk *)p;
  return
  gcBYTES_TO_WORDS(sizeof(Wrap_Chunk) + ((wc->len - 1) * sizeof(Scheme_Object *)));
}

static int mark_wrapchunk_MARK(void *p) {
  Wrap_Chunk *wc = (Wrap_Chunk *)p;
  int i;
  for (i = wc->len; i--; ) {
    gcMARK(wc->a[i]);
  }
  return
  gcBYTES_TO_WORDS(sizeof(Wrap_Chunk) + ((wc->len - 1) * sizeof(Scheme_Object *)));
}

static int mark_wrapchunk_FIXUP(void *p) {
  Wrap_Chunk *wc = (Wrap_Chunk *)p;
  int i;
  for (i = wc->len; i--; ) {
    gcFIXUP(wc->a[i]);
  }
  return
  gcBYTES_TO_WORDS(sizeof(Wrap_Chunk) + ((wc->len - 1) * sizeof(Scheme_Object *)));
}

#define mark_wrapchunk_IS_ATOMIC 0
#define mark_wrapchunk_IS_CONST_SIZE 0


static int mark_cert_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cert));
}

static int mark_cert_MARK(void *p) {
  Scheme_Cert *c = (Scheme_Cert *)p;
  gcMARK(c->mark);
  gcMARK(c->modidx);
  gcMARK(c->insp);
  gcMARK(c->key);
  gcMARK(c->mapped);
  gcMARK(c->next);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cert));
}

static int mark_cert_FIXUP(void *p) {
  Scheme_Cert *c = (Scheme_Cert *)p;
  gcFIXUP(c->mark);
  gcFIXUP(c->modidx);
  gcFIXUP(c->insp);
  gcFIXUP(c->key);
  gcFIXUP(c->mapped);
  gcFIXUP(c->next);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Cert));
}

#define mark_cert_IS_ATOMIC 0
#define mark_cert_IS_CONST_SIZE 1


static int lex_rib_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Lexical_Rib));
}

static int lex_rib_MARK(void *p) {
  Scheme_Lexical_Rib *rib = (Scheme_Lexical_Rib *)p;
  gcMARK(rib->rename);
  gcMARK(rib->next);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Lexical_Rib));
}

static int lex_rib_FIXUP(void *p) {
  Scheme_Lexical_Rib *rib = (Scheme_Lexical_Rib *)p;
  gcFIXUP(rib->rename);
  gcFIXUP(rib->next);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Lexical_Rib));
}

#define lex_rib_IS_ATOMIC 0
#define lex_rib_IS_CONST_SIZE 1


#endif  /* STXOBJ */

/**********************************************************************/

#ifdef MARKS_FOR_JIT_C

static int native_closure_SIZE(void *p) {
  Scheme_Native_Closure *c = (Scheme_Native_Closure *)p;
  int closure_size = ((Scheme_Native_Closure_Data *)GC_resolve(c->code))->closure_size;

  if (closure_size < 0) {
    closure_size = -(closure_size + 1);
  }

  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Native_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

static int native_closure_MARK(void *p) {
  Scheme_Native_Closure *c = (Scheme_Native_Closure *)p;
  int closure_size = ((Scheme_Native_Closure_Data *)GC_resolve(c->code))->closure_size;

  if (closure_size < 0) {
    closure_size = -(closure_size + 1);
  }


  {
    int i = closure_size;
    while (i--)
      gcMARK(c->vals[i]);
  }
  gcMARK(c->code);
  
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Native_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

static int native_closure_FIXUP(void *p) {
  Scheme_Native_Closure *c = (Scheme_Native_Closure *)p;
  int closure_size = ((Scheme_Native_Closure_Data *)GC_resolve(c->code))->closure_size;

  if (closure_size < 0) {
    closure_size = -(closure_size + 1);
  }


  {
    int i = closure_size;
    while (i--)
      gcFIXUP(c->vals[i]);
  }
  gcFIXUP(c->code);
  
  return
  gcBYTES_TO_WORDS((sizeof(Scheme_Native_Closure)
		    + (closure_size - 1) * sizeof(Scheme_Object *)));
}

#define native_closure_IS_ATOMIC 0
#define native_closure_IS_CONST_SIZE 0


static int mark_jit_state_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(mz_jit_state));
}

static int mark_jit_state_MARK(void *p) {
  mz_jit_state *j = (mz_jit_state *)p;
  gcMARK(j->mappings);
  return
  gcBYTES_TO_WORDS(sizeof(mz_jit_state));
}

static int mark_jit_state_FIXUP(void *p) {
  mz_jit_state *j = (mz_jit_state *)p;
  gcFIXUP(j->mappings);
  return
  gcBYTES_TO_WORDS(sizeof(mz_jit_state));
}

#define mark_jit_state_IS_ATOMIC 0
#define mark_jit_state_IS_CONST_SIZE 1


static int native_unclosed_proc_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data));
}

static int native_unclosed_proc_MARK(void *p) {
  Scheme_Native_Closure_Data *d = (Scheme_Native_Closure_Data *)p;
  int i;

  gcMARK(d->u2.name);
  for (i = d->retain_count; i--; ) {
    gcMARK(d->retained[i]);
  }
  if (d->closure_size < 0) {
    gcMARK(d->u.arities);
  }

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data));
}

static int native_unclosed_proc_FIXUP(void *p) {
  Scheme_Native_Closure_Data *d = (Scheme_Native_Closure_Data *)p;
  int i;

  gcFIXUP(d->u2.name);
  for (i = d->retain_count; i--; ) {
    gcFIXUP(d->retained[i]);
  }
  if (d->closure_size < 0) {
    gcFIXUP(d->u.arities);
  }

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data));
}

#define native_unclosed_proc_IS_ATOMIC 0
#define native_unclosed_proc_IS_CONST_SIZE 1


static int native_unclosed_proc_plus_case_SIZE(void *p) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data_Plus_Case));
}

static int native_unclosed_proc_plus_case_MARK(void *p) {
  Scheme_Native_Closure_Data_Plus_Case *d = (Scheme_Native_Closure_Data_Plus_Case *)p;

  native_unclosed_proc_MARK(p);
  gcMARK(d->case_lam);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data_Plus_Case));
}

static int native_unclosed_proc_plus_case_FIXUP(void *p) {
  Scheme_Native_Closure_Data_Plus_Case *d = (Scheme_Native_Closure_Data_Plus_Case *)p;

  native_unclosed_proc_FIXUP(p);
  gcFIXUP(d->case_lam);

  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Native_Closure_Data_Plus_Case));
}

#define native_unclosed_proc_plus_case_IS_ATOMIC 0
#define native_unclosed_proc_plus_case_IS_CONST_SIZE 1


#endif  /* JIT */

/**********************************************************************/

#define GC_REG_TRAV(type, base) GC_register_traversers(type, base ## _SIZE, base ## _MARK, base ## _FIXUP, base ## _IS_CONST_SIZE, base ## _IS_ATOMIC)
