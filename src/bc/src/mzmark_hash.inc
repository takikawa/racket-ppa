/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int hash_tree_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  Scheme_Hash_Tree *ht = (Scheme_Hash_Tree *)p;
  int popcount = hamt_popcount(ht->bitmap);
  gcBYTES_TO_WORDS(HASH_TREE_RECORD_SIZE(SCHEME_HASHTR_KIND(ht), popcount));
#else
  return 0;
#endif
}

static int hash_tree_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Hash_Tree *ht = (Scheme_Hash_Tree *)p;
  int popcount = hamt_popcount(ht->bitmap);
  int i;
  for (i = ((SCHEME_HASHTR_FLAGS(ht) & HASHTR_HAS_VAL) ? 2 : 1) * popcount; i--; ) {
    gcMARK2(ht->els[i], gc);
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(HASH_TREE_RECORD_SIZE(SCHEME_HASHTR_KIND(ht), popcount));
# endif
#endif
}

static int hash_tree_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Hash_Tree *ht = (Scheme_Hash_Tree *)p;
  int popcount = hamt_popcount(ht->bitmap);
  int i;
  for (i = ((SCHEME_HASHTR_FLAGS(ht) & HASHTR_HAS_VAL) ? 2 : 1) * popcount; i--; ) {
    gcFIXUP2(ht->els[i], gc);
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(HASH_TREE_RECORD_SIZE(SCHEME_HASHTR_KIND(ht), popcount));
# endif
#endif
}

#define hash_tree_val_IS_ATOMIC 0
#define hash_tree_val_IS_CONST_SIZE 0


