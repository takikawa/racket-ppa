/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int place_bi_channel_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Bi_Channel));
#else
  return 0;
#endif
}

static int place_bi_channel_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Place_Bi_Channel *pbc = (Scheme_Place_Bi_Channel *)p;
  gcMARK2(pbc->link, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Bi_Channel));
# endif
#endif
}

static int place_bi_channel_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Place_Bi_Channel *pbc = (Scheme_Place_Bi_Channel *)p;
  gcFIXUP2(pbc->link, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Bi_Channel));
# endif
#endif
}

#define place_bi_channel_val_IS_ATOMIC 0
#define place_bi_channel_val_IS_CONST_SIZE 1


static int place_object_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Object));
#else
  return 0;
#endif
}

static int place_object_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Object));
# endif
#endif
}

static int place_object_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Object));
# endif
#endif
}

#define place_object_val_IS_ATOMIC 1
#define place_object_val_IS_CONST_SIZE 1


static int place_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Place));
#else
  return 0;
#endif
}

static int place_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Place *pr = (Scheme_Place *)p;
  gcMARK2(pr->channel, gc);
  gcMARK2(pr->mref, gc);
  gcMARK2(pr->pumper_threads, gc);
  gcMARK2(pr->place_obj, gc);
  gcMARK2(pr->prev, gc);
  gcMARK2(pr->next, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place));
# endif
#endif
}

static int place_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Place *pr = (Scheme_Place *)p;
  gcFIXUP2(pr->channel, gc);
  gcFIXUP2(pr->mref, gc);
  gcFIXUP2(pr->pumper_threads, gc);
  gcFIXUP2(pr->place_obj, gc);
  gcFIXUP2(pr->prev, gc);
  gcFIXUP2(pr->next, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place));
# endif
#endif
}

#define place_val_IS_ATOMIC 0
#define place_val_IS_CONST_SIZE 1


static int place_async_channel_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Async_Channel));
#else
  return 0;
#endif
}

static int place_async_channel_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Place_Async_Channel *pac = (Scheme_Place_Async_Channel *)p;
  Scheme_Object *pr;
  int i, j, sz;
  gcMARK2(pac->msgs, gc);
  gcMARK2(pac->msg_memory, gc);
  gcMARK2(pac->msg_chains, gc);
  gcMARK2(pac->wakeup_signal, gc);

  /* mark master-allocated objects within each messages; the
     raw pairs that form the list are embedded in each message block */
  j = pac->out;
  sz = pac->size;
  for (i = pac->count; i--; ) {
    pr = pac->msg_chains[j];
    while (pr) {
      gcMARK2(SCHEME_CAR(pr), gc);
      pr = SCHEME_CDR(pr);
    }
    j = ((j + 1) % sz);
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Async_Channel));
# endif
#endif
}

static int place_async_channel_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Place_Async_Channel *pac = (Scheme_Place_Async_Channel *)p;
  Scheme_Object *pr;
  int i, j, sz;
  gcFIXUP2(pac->msgs, gc);
  gcFIXUP2(pac->msg_memory, gc);
  gcFIXUP2(pac->msg_chains, gc);
  gcFIXUP2(pac->wakeup_signal, gc);

  /* mark master-allocated objects within each messages; the
     raw pairs that form the list are embedded in each message block */
  j = pac->out;
  sz = pac->size;
  for (i = pac->count; i--; ) {
    pr = pac->msg_chains[j];
    while (pr) {
      gcFIXUP2(SCHEME_CAR(pr), gc);
      pr = SCHEME_CDR(pr);
    }
    j = ((j + 1) % sz);
  }

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Place_Async_Channel));
# endif
#endif
}

#define place_async_channel_val_IS_ATOMIC 0
#define place_async_channel_val_IS_CONST_SIZE 1


static int serialized_file_fd_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Serialized_File_FD));
#else
  return 0;
#endif
}

static int serialized_file_fd_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Serialized_File_FD *ffd = (Scheme_Serialized_File_FD *) p;
  gcMARK2(ffd->name, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Serialized_File_FD));
# endif
#endif
}

static int serialized_file_fd_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Serialized_File_FD *ffd = (Scheme_Serialized_File_FD *) p;
  gcFIXUP2(ffd->name, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Serialized_File_FD));
# endif
#endif
}

#define serialized_file_fd_val_IS_ATOMIC 0
#define serialized_file_fd_val_IS_CONST_SIZE 1


static int serialized_socket_fd_val_SIZE(void *p, struct NewGC *gc) {
#ifndef GC_NO_SIZE_NEEDED_FROM_PROCS
  gcBYTES_TO_WORDS(sizeof(Scheme_Serialized_Socket_FD));
#else
  return 0;
#endif
}

static int serialized_socket_fd_val_MARK(void *p, struct NewGC *gc) {
#ifndef GC_NO_MARK_PROCEDURE_NEEDED
  Scheme_Serialized_Socket_FD *sfd = (Scheme_Serialized_Socket_FD *) p;
  gcMARK2(sfd->name, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Serialized_Socket_FD));
# endif
#endif
}

static int serialized_socket_fd_val_FIXUP(void *p, struct NewGC *gc) {
#ifndef GC_NO_FIXUP_PROCEDURE_NEEDED
  Scheme_Serialized_Socket_FD *sfd = (Scheme_Serialized_Socket_FD *) p;
  gcFIXUP2(sfd->name, gc);

# ifdef GC_NO_SIZE_NEEDED_FROM_PROCS
  return 0;
# else
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Serialized_Socket_FD));
# endif
#endif
}

#define serialized_socket_fd_val_IS_ATOMIC 0
#define serialized_socket_fd_val_IS_CONST_SIZE 1


