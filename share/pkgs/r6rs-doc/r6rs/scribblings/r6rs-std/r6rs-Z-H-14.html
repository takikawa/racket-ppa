<!doctype html public "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!--

Generated from r6rs.tex by tex2page, v 20070803
(running on MzScheme 371, unix), 
(c) Dorai Sitaram, 
http://www.ccs.neu.edu/~dorai/tex2page/tex2page-doc.html

-->
<head>
<title>
Revised^6 Report on the Algorithmic Language Scheme
</title>
<link rel="stylesheet" type="text/css" href="r6rs-Z-S.css" title=default>
<meta name=robots content="index,follow">
</head>
<body>
<div id=slidecontent>
<div align=right class=navigation>[Go to <span><a href="r6rs.html">first</a>, <a href="r6rs-Z-H-13.html">previous</a></span><span>, <a href="r6rs-Z-H-15.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="r6rs-Z-H-2.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="r6rs-Z-H-21.html#node_index_start">index</a></span>]</div>
<p></p>
<a name="node_chap_11"></a>
<h1 class=chapter>
<div class=chapterheading><a href="r6rs-Z-H-2.html#node_toc_node_chap_11">Chapter 11</a></div><br>
<a href="r6rs-Z-H-2.html#node_toc_node_chap_11">Base library</a></h1>
<p></p>
<p>
This chapter describes Scheme&#8217;s <tt>(rnrs base (6))</tt><a name="node_idx_324"></a>library, which exports many of
the procedure and syntax bindings that are traditionally associated
with Scheme.</p>
<p>
Section&nbsp;<a href="#node_sec_11.20">11.20</a> defines the rules that identify
tail calls and tail contexts in constructs from the <tt>(rnrs base (6))</tt>
library.</p>
<p>
</p>
<a name="node_sec_11.1"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.1">11.1&nbsp;&nbsp;Base types</a></h2>
<p></p>
<p>
No object satisfies more than one of the following predicates:</p>
<p>
</p>

<tt>boolean?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pair?<br>
symbol?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number?<br>
char?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string?<br>
vector?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;procedure?<br>
null?<p></tt></p>
<p>
These predicates define the base types <em>boolean</em>, <em>pair</em>, <em>symbol</em>, <em>number</em>, <em>char</em> (or <em>character</em>), <em>string</em>, <em>vector</em>, and <em>procedure</em>.  Moreover, the empty list is a special
object of its own type.
<a name="node_idx_326"></a><a name="node_idx_328"></a><a name="node_idx_330"></a><a name="node_idx_332"></a><a name="node_idx_334"></a><a name="node_idx_336"></a><a name="node_idx_338"></a><a name="node_idx_340"></a><a name="node_idx_342"></a><a name="node_idx_344"></a><a name="node_idx_346"></a></p>
<p>
Note that, although there is a separate boolean type, any Scheme value
can be used as a boolean value for the purpose of a conditional test;
see section&nbsp;<a href="r6rs-Z-H-8.html#node_sec_5.7">5.7</a>.</p>
<p>
</p>
<a name="node_sec_11.2"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.2">11.2&nbsp;&nbsp;Definitions</a></h2>
<p></p>
<p>
Definitions<a name="node_idx_348"></a>may appear within a
&lt;top-level body&gt; (section&nbsp;<a href="r6rs-Z-H-11.html#node_sec_8.1">8.1</a>),
at the top of a &lt;library body&gt; (section&nbsp;<a href="r6rs-Z-H-10.html#node_sec_7.1">7.1</a>),
or at the top of a &lt;body&gt; (section&nbsp;<a href="#node_sec_11.3">11.3</a>).</p>
<p>
A &lt;definition&gt; may be a variable definition
(section&nbsp;<a href="#node_sec_11.2.1">11.2.1</a>) or
keyword definition
(section&nbsp;<a href="#node_sec_11.2.1">11.2.1</a>).
Macro uses that expand into definitions or groups of
definitions (packaged in a <tt>begin</tt>, <tt>let-syntax</tt>, or
<tt>letrec-syntax</tt> form; see section&nbsp;<a href="#node_sec_11.4.7">11.4.7</a>) may also appear
wherever other definitions may appear.</p>
<p>
</p>
<a name="node_sec_11.2.1"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.2.1">11.2.1&nbsp;&nbsp;Variable definitions</a></h3>
<p></p>
<p>
The <tt>define</tt> form described in this section is a
&lt;definition&gt;<a name="node_idx_350"></a>used to create variable bindings
and may appear anywhere other definitions may appear.</p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_352"></a>define<i> &lt;variable&gt; &lt;expression&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>

<div align=left><tt>(<a name="node_idx_354"></a>define<i> &lt;variable&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>

<div align=left><tt>(define (&lt;variable&gt; &lt;formals&gt;) &lt;body&gt;)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>

<div align=left><tt>(define (&lt;variable&gt; . &lt;formal&gt;) &lt;body&gt;)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
The first from of <tt>define</tt> binds &lt;variable&gt; to a new
location before assigning the value of &lt;expression&gt; to it.
</p>

<tt>(define&nbsp;add3<br>
&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;3)))<br>
(add3&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;6<br>
(define&nbsp;first&nbsp;car)<br>
(first&nbsp;&#8217;(1&nbsp;2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;1<p></tt>
The continuation of &lt;expression&gt; should not be invoked more than
once.</p>
<p>
<em>Implementation responsibilities: </em>Implementations should detect that the
continuation of &lt;expression&gt; is invoked more than once.
If the implementation detects this, it must raise an
exception with condition type <tt>&amp;assertion</tt>.</p>
<p>
The second form of <tt>define</tt> is equivalent to
</p>

<tt>(define&nbsp;&lt;variable&gt;&nbsp;&lt;unspecified&gt;)<p></tt>
where &lt;unspecified&gt; is a side-effect-free expression returning
an unspecified value.</p>
<p>
In the third form of <tt>define</tt>, &lt;formals&gt; must be either a
sequence of zero or more variables, or a sequence of one or more
variables followed by a dot <tt>.</tt> and another variable (as
in a lambda expression, see section&nbsp;<a href="#node_sec_11.4.2">11.4.2</a>).  This form is equivalent to
</p>

<tt>(define&nbsp;&lt;variable&gt;<br>
&nbsp;&nbsp;(lambda&nbsp;(&lt;formals&gt;)&nbsp;&lt;body&gt;)).<p></tt></p>
<p>
In the fourth form of <tt>define</tt>, 
&lt;formal&gt; must be a single
variable.  This form is equivalent to
</p>

<tt>(define&nbsp;&lt;variable&gt;<br>
&nbsp;&nbsp;(lambda&nbsp;&lt;formal&gt;&nbsp;&lt;body&gt;)).<p></tt>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.2.2"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.2.2">11.2.2&nbsp;&nbsp;Syntax definitions</a></h3>
<p></p>
<p>
The <tt>define-syntax</tt> form described in this section is a
&lt;definition&gt;<a name="node_idx_356"></a>used to create keyword bindings
and may appear anywhere other definitions may appear.</p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_358"></a>define-syntax<i> &lt;keyword&gt; &lt;expression&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
Binds &lt;keyword&gt; to the value of
&lt;expression&gt;, which must evaluate, at macro-expansion
time, to a transformer.  Macro transformers can be created using the
<tt>syntax-rules</tt> and <tt>identifier-syntax</tt> forms described in
section&nbsp;<a href="#node_sec_11.19">11.19</a>.  See library
section&nbsp;on &#8220;Transformers&#8221; for a more
complete description of transformers.</p>
<p>
Keyword bindings established by <tt>define-syntax</tt> are visible
throughout the body in which they appear, except where shadowed by
other bindings, and nowhere else, just like variable bindings established
by <tt>define</tt>.
All bindings established by a set of definitions, whether
keyword or variable definitions, are visible within the definitions
themselves.</p>
<p>
<em>Implementation responsibilities: </em>The implementation should detect if the value of
&lt;expression&gt; cannot possibly be a transformer.</p>
<p>
Example:</p>
<p>
</p>

<tt>(let&nbsp;()<br>
&nbsp;&nbsp;(define&nbsp;even?<br>
&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(or&nbsp;(=&nbsp;x&nbsp;0)&nbsp;(odd?&nbsp;(-&nbsp;x&nbsp;1)))))<br>
&nbsp;&nbsp;(define-syntax&nbsp;odd?<br>
&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((odd?&nbsp;&nbsp;x)&nbsp;(not&nbsp;(even?&nbsp;x)))))<br>
&nbsp;&nbsp;(even?&nbsp;10))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<tt>#t</tt><p></tt></p>
<p>
An implication of the left-to-right processing order
(section&nbsp;<a href="r6rs-Z-H-13.html#node_chap_10">10</a>) is that one definition can
affect whether a subsequent form is also a definition.  </p>
<p>
Example:</p>
<p>
</p>

<tt>(let&nbsp;()<br>
&nbsp;&nbsp;(define-syntax&nbsp;bind-to-zero<br>
&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((bind-to-zero&nbsp;id)&nbsp;(define&nbsp;id&nbsp;0))))<br>
&nbsp;&nbsp;(bind-to-zero&nbsp;x)<br>
&nbsp;&nbsp;x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0<p></tt></p>
<p>
The behavior is unaffected by any binding for
<tt>bind-to-zero</tt> that might appear outside of the <tt>let</tt>
expression.
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.3"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.3">11.3&nbsp;&nbsp;Bodies</a></h2>
<p></p>
<p>
<a name="node_idx_360"></a>The &lt;body&gt; of a <tt>lambda</tt>, <tt>let</tt>, <tt>let*</tt>,
<tt>let-values</tt>, <tt>let*-values</tt>, <tt>letrec</tt>, or <tt>letrec*</tt>
expression, or that of a definition with a body
consists of zero or more definitions followed by one or more
expressions.</p>
<p>
<tt>&lt;definition&gt; <tt>...</tt> &lt;expression<sub>1</sub>&gt; &lt;expression<sub>2</sub>&gt; <tt>...</tt></tt></p>
<p>
Each identifier defined by a
definition is local to the &lt;body&gt;.  That is, the identifier is
bound, and the region of the binding is the
entire &lt;body&gt; (see section&nbsp;<a href="r6rs-Z-H-8.html#node_sec_5.2">5.2</a>).</p>
<p>
Example:
</p>

<tt>(let&nbsp;((x&nbsp;5))<br>
&nbsp;&nbsp;(define&nbsp;foo&nbsp;(lambda&nbsp;(y)&nbsp;(bar&nbsp;x&nbsp;y)))<br>
&nbsp;&nbsp;(define&nbsp;bar&nbsp;(lambda&nbsp;(a&nbsp;b)&nbsp;(+&nbsp;(*&nbsp;a&nbsp;b)&nbsp;a)))<br>
&nbsp;&nbsp;(foo&nbsp;(+&nbsp;x&nbsp;3)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;45<p></tt>
When <tt>begin</tt>, <tt>let-syntax</tt>, or <tt>letrec-syntax</tt> forms
occur in a body prior to the first
expression, they are spliced into the body; see section&nbsp;<a href="#node_sec_11.4.7">11.4.7</a>.
Some or all of the body, including portions wrapped in <tt>begin</tt>,
<tt>let-syntax</tt>, or <tt>letrec-syntax</tt>
forms, may be specified by a macro use
(see section&nbsp;<a href="r6rs-Z-H-12.html#node_sec_9.2">9.2</a>).</p>
<p>
An expanded &lt;body&gt; (see chapter&nbsp;<a href="r6rs-Z-H-13.html#node_chap_10">10</a>)
containing variable definitions can
always be converted into an equivalent <tt>letrec*</tt>
expression.  For example, the <tt>let</tt> expression in the above
example is equivalent to</p>
<p>
</p>

<tt>(let&nbsp;((x&nbsp;5))<br>
&nbsp;&nbsp;(letrec*&nbsp;((foo&nbsp;(lambda&nbsp;(y)&nbsp;(bar&nbsp;x&nbsp;y)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bar&nbsp;(lambda&nbsp;(a&nbsp;b)&nbsp;(+&nbsp;(*&nbsp;a&nbsp;b)&nbsp;a))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(foo&nbsp;(+&nbsp;x&nbsp;3))))<p></tt></p>
<p>
</p>
<a name="node_sec_11.4"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.4">11.4&nbsp;&nbsp;Expressions</a></h2>
<p></p>
<p>
The entries in this section describe the expressions of the <tt>(rnrs base (6))</tt>
library, which may occur in the position of the &lt;expression&gt;
syntactic variable in addition to the primitive
expression types as described in
section&nbsp;<a href="r6rs-Z-H-12.html#node_sec_9.1">9.1</a>.</p>
<p>
</p>
<a name="node_sec_11.4.1"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.4.1">11.4.1&nbsp;&nbsp;Quotation</a></h3>
<p><div style="height: -9.0pt"></div>
<p style="margin-top: 0pt; margin-bottom: 0pt"></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_362"></a>quote<i> &lt;datum&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>&lt;Datum&gt; should be a syntactic datum.</p>
<p>
<em>Semantics: </em><tt>(quote &lt;datum&gt;)</tt> evaluates to the datum value
represented by &lt;datum&gt;
(see
section&nbsp;<a href="r6rs-Z-H-7.html#node_sec_4.3">4.3</a>).  This notation is used to include
constants.</p>
<p>
</p>

<tt>(quote&nbsp;a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;a<br>
(quote&nbsp;<tt>#</tt>(a&nbsp;b&nbsp;c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;#(a&nbsp;b&nbsp;c)<br>
(quote&nbsp;(+&nbsp;1&nbsp;2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(+&nbsp;1&nbsp;2)<p></tt></p>
<p>
As noted in section&nbsp;<a href="r6rs-Z-H-7.html#node_sec_4.3.5">4.3.5</a>, <tt>(quote &lt;datum&gt;)</tt>
may be abbreviated as <tt>&#8217;</tt>&lt;datum&gt;:</p>
<p>
</p>

<tt>&#8217;&quot;abc&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&quot;abc&quot;<br>
&#8217;145932&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;145932<br>
&#8217;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;a<br>
&#8217;#(a&nbsp;b&nbsp;c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;#(a&nbsp;b&nbsp;c)<br>
&#8217;()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;()<br>
&#8217;(+&nbsp;1&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(+&nbsp;1&nbsp;2)<br>
&#8217;(quote&nbsp;a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(quote&nbsp;a)<br>
&#8217;&#8217;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(quote&nbsp;a)<p></tt></p>
<p>
As noted in section&nbsp;<a href="r6rs-Z-H-8.html#node_sec_5.10">5.10</a>, constants are immutable.</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
Different constants that are the value of a <tt>quote</tt> expression may
share the same locations.
</blockquote>
<p></p>
<p>
</p>
<a name="node_sec_11.4.2"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.4.2">11.4.2&nbsp;&nbsp;Procedures</a></h3>
<p><div style="height: -9.0pt"></div>
<p style="margin-top: 0pt; margin-bottom: 0pt"></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_364"></a>lambda<i> &lt;formals&gt; &lt;body&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>&lt;Formals&gt; must be a formal parameter list as described below,
and &lt;body&gt; must be as described in section&nbsp;<a href="#node_sec_11.3">11.3</a>.</p>
<p>
<em>Semantics: </em>A <tt>lambda</tt> expression evaluates to a procedure.  The environment in
effect when the <tt>lambda</tt> expression is evaluated is remembered as part of the
procedure.  When the procedure is later called with some 
arguments, the environment in which the <tt>lambda</tt> expression was evaluated is
extended by binding the variables in the parameter list to
fresh locations, and the resulting argument values are stored
in those locations.  Then, the expressions in the body of the <tt>lambda</tt> expression
(which may contain definitions and thus represent a <tt>letrec*</tt> form, see section&nbsp;<a href="#node_sec_11.3">11.3</a>) are evaluated
sequentially in the extended environment.
The results of the last expression in the body are returned as
the results of the procedure call.</p>
<p>
</p>

<tt>(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<em>a&nbsp;procedure</em><br>
((lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;x))&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;8<br>
<br>
((lambda&nbsp;(x)<br>
&nbsp;&nbsp;&nbsp;(define&nbsp;(p&nbsp;y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;y&nbsp;1))<br>
&nbsp;&nbsp;&nbsp;(+&nbsp;(p&nbsp;x)&nbsp;x))<br>
&nbsp;5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;11<br>
<br>
(define&nbsp;reverse-subtract<br>
&nbsp;&nbsp;(lambda&nbsp;(x&nbsp;y)&nbsp;(-&nbsp;y&nbsp;x)))<br>
(reverse-subtract&nbsp;7&nbsp;10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;3<br>
<br>
(define&nbsp;add4<br>
&nbsp;&nbsp;(let&nbsp;((x&nbsp;4))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y)&nbsp;(+&nbsp;x&nbsp;y))))<br>
(add4&nbsp;6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;10<p></tt></p>
<p>
&lt;Formals&gt; must have one of the following forms:</p>
<p>
</p>
<ul>
<li><p><tt>(&lt;variable<sub>1</sub>&gt; <tt>...</tt>)</tt>:
The procedure takes a fixed number of arguments; when the procedure is
called, the arguments are stored in the bindings of the
corresponding variables.</p>
<p>
</p>
<li><p>&lt;variable&gt;:
The procedure takes any number of arguments; when the procedure is
called, the sequence of arguments is converted into a newly
allocated list, and the list is stored in the binding of the
&lt;variable&gt;.</p>
<p>
</p>
<li><p><tt>(&lt;variable<sub>1</sub>&gt; <tt>...</tt> &lt;variable<sub><em>n</em></sub>&gt; <strong>.</strong>
&lt;variable<sub><em>n</em>+1</sub>&gt;)</tt>:
If a period <tt>.</tt> precedes the last variable, then
the procedure takes <em>n</em> or more arguments, where <em>n</em> is the
number of parameters before the period (there must
be at least one).
The value stored in the binding of the last variable is a
newly allocated
list of the arguments left over after all the other 
arguments have been matched up against the other parameters.
</p>
</ul><p></p>
<p>
</p>

<tt>((lambda&nbsp;x&nbsp;x)&nbsp;3&nbsp;4&nbsp;5&nbsp;6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(3&nbsp;4&nbsp;5&nbsp;6)<br>
((lambda&nbsp;(x&nbsp;y&nbsp;.&nbsp;z)&nbsp;z)<br>
&nbsp;3&nbsp;4&nbsp;5&nbsp;6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(5&nbsp;6)<p></tt></p>
<p>
Any &lt;variable&gt; must not appear more than once in
&lt;formals&gt;.
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.4.3"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.4.3">11.4.3&nbsp;&nbsp;Conditionals</a></h3>
<p><div style="height: -9.0pt"></div>
<p style="margin-top: 0pt; margin-bottom: 0pt"></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_366"></a>if<i> &lt;test&gt; &lt;consequent&gt; &lt;alternate&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>

<div align=left><tt>(<a name="node_idx_368"></a>if<i> &lt;test&gt; &lt;consequent&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
  <p>
<em>Syntax: </em>&lt;Test&gt;, &lt;consequent&gt;, and &lt;alternate&gt; must be 
expressions.</p>
<p>
<em>Semantics: </em>An <tt>if</tt> expression is evaluated as follows: first,
&lt;test&gt; is evaluated.  If it yields a true value<a name="node_idx_370"></a>(see
section&nbsp;<a href="r6rs-Z-H-8.html#node_sec_5.7">5.7</a>), then &lt;consequent&gt; is evaluated and
its values are returned.  Otherwise &lt;alternate&gt; is evaluated and its
values are returned.  If &lt;test&gt; yields <tt>#f</tt> and no
&lt;alternate&gt; is specified, then the result of the expression is unspecified.</p>
<p>
</p>

<tt>(if&nbsp;(&gt;&nbsp;3&nbsp;2)&nbsp;&#8217;yes&nbsp;&#8217;no)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;yes<br>
(if&nbsp;(&gt;&nbsp;2&nbsp;3)&nbsp;&#8217;yes&nbsp;&#8217;no)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;no<br>
(if&nbsp;(&gt;&nbsp;3&nbsp;2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;(-&nbsp;3&nbsp;2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;3&nbsp;2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;1<br>
(if&nbsp;#f&nbsp;#f)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<em>unspecified</em><p></tt></p>
<p>
The &lt;consequent&gt; and &lt;alternate&gt; expressions are in
tail context if the <tt>if</tt> expression itself is; see
section&nbsp;<a href="#node_sec_11.20">11.20</a>.
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.4.4"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.4.4">11.4.4&nbsp;&nbsp;Assignments</a></h3>
<p><div style="height: -9.0pt"></div>
<p style="margin-top: 0pt; margin-bottom: 0pt"></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_372"></a>set!<i> &lt;variable&gt; &lt;expression&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
&lt;Expression&gt; is evaluated, and the resulting value is stored in
the location to which &lt;variable&gt; is bound.  &lt;Variable&gt; must
be bound either in some region<a name="node_idx_374"></a>enclosing the <tt>set!</tt> expression
or at the top level.  The result of the <tt>set!</tt>
expression is unspecified.</p>
<p>
</p>

<tt>(let&nbsp;((x&nbsp;2))<br>
&nbsp;&nbsp;(+&nbsp;x&nbsp;1)<br>
&nbsp;&nbsp;(set!&nbsp;x&nbsp;4)<br>
&nbsp;&nbsp;(+&nbsp;x&nbsp;1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;5<p></tt></p>
<p>
It is a syntax violation if &lt;variable&gt; refers to an
immutable binding.</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
The identifier <tt>set!</tt> is exported with level 1 as well.  See
section&nbsp;<a href="#node_sec_11.19">11.19</a>.
</blockquote>
<p></p>
<p>
</p>
<a name="node_sec_11.4.5"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.4.5">11.4.5&nbsp;&nbsp;Derived conditionals</a></h3>
<p><div style="height: -9.0pt"></div>
<p style="margin-top: 0pt; margin-bottom: 0pt"></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_376"></a>cond<i> &lt;cond clause<sub>1</sub>&gt; &lt;cond clause<sub>2</sub>&gt; <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>

<a name="node_idx_378"></a><div align=left><tt>=&gt;</tt>&nbsp;&nbsp;&nbsp;&nbsp;auxiliary syntax&nbsp;</div>

<a name="node_idx_380"></a><div align=left><tt>else</tt>&nbsp;&nbsp;&nbsp;&nbsp;auxiliary syntax&nbsp;</div>
<p>
<em>Syntax: </em>Each &lt;cond clause&gt; must be of the form
</p>

<tt>(&lt;test&gt;&nbsp;&lt;expression<sub>1</sub>&gt;&nbsp;<tt>...</tt>)<p></tt>
where &lt;test&gt; is an expression.  Alternatively, a &lt;cond clause&gt; may be
of the form
</p>

<tt>(&lt;test&gt;&nbsp;=&gt;&nbsp;&lt;expression&gt;)<p></tt>
The last &lt;cond clause&gt; may be
an &#8220;<tt>else</tt> clause&#8221;, which has the form
</p>

<tt>(else&nbsp;&lt;expression<sub>1</sub>&gt;&nbsp;&lt;expression<sub>2</sub>&gt;&nbsp;<tt>...</tt>).<p></tt></p>
<p>
<em>Semantics: </em>A <tt>cond</tt> expression is evaluated by evaluating the &lt;test&gt;
expressions of successive &lt;cond clause&gt;s in order until one of them
evaluates to a true value<a name="node_idx_382"></a>(see
section&nbsp;<a href="r6rs-Z-H-8.html#node_sec_5.7">5.7</a>).  When a &lt;test&gt; evaluates to a true
value, then the remaining &lt;expression&gt;s in its &lt;cond clause&gt; are
evaluated in order, and the results of the last &lt;expression&gt; in the
&lt;cond clause&gt; are returned as the results of the entire <tt>cond</tt>
expression.  If the selected &lt;cond clause&gt; contains only the
&lt;test&gt; and no &lt;expression&gt;s, then the value of the
&lt;test&gt; is returned as the result.  If the selected &lt;cond clause&gt; uses the
<tt>=&gt;</tt> alternate form, then the &lt;expression&gt; is evaluated.
Its value must be a procedure.  This procedure should accept one argument; it is
called on the value of the &lt;test&gt; and the values returned by this
procedure are returned by the <tt>cond</tt> expression.
If all &lt;test&gt;s evaluate
to <tt>#f</tt>, and there is no <tt>else</tt> clause, then 
the conditional expression returns unspecified values; if there is an <tt>else</tt>
clause, then its &lt;expression&gt;s are evaluated, and the values of
the last one are returned.</p>
<p>
</p>

<tt>(cond&nbsp;((&gt;&nbsp;3&nbsp;2)&nbsp;&#8217;greater)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;3&nbsp;2)&nbsp;&#8217;less))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;greater<br>
<br>
(cond&nbsp;((&gt;&nbsp;3&nbsp;3)&nbsp;&#8217;greater)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;3&nbsp;3)&nbsp;&#8217;less)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;&#8217;equal))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;equal<br>
<br>
(cond&nbsp;(&#8217;(1&nbsp;2&nbsp;3)&nbsp;=&gt;&nbsp;cadr)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;<tt>#f</tt>))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;2<p></tt></p>
<p>
For a &lt;cond clause&gt; of one of the following forms
</p>

<tt>(&lt;test&gt;&nbsp;&lt;expression<sub>1</sub>&gt;&nbsp;<tt>...</tt>)<br>
(else&nbsp;&lt;expression<sub>1</sub>&gt;&nbsp;&lt;expression<sub>2</sub>&gt;&nbsp;<tt>...</tt>)<p></tt>
the last &lt;expression&gt; is in tail context if the <tt>cond</tt> form
itself is.  For a &lt;cond clause&gt; of the form
</p>

<tt>(&lt;test&gt;&nbsp;=&gt;&nbsp;&lt;expression&gt;)<p></tt>
the (implied) call to the procedure that results from the evaluation
of &lt;expression&gt; is in a tail context if the <tt>cond</tt> form
itself is. See section&nbsp;<a href="#node_sec_11.20">11.20</a>.</p>
<p>
A sample definition of <tt>cond</tt> in terms of simpler forms is in
appendix&nbsp;<a href="r6rs-Z-H-16.html#node_chap_B">B</a>.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_384"></a>case<i> &lt;key&gt; &lt;case clause<sub>1</sub>&gt; &lt;case clause<sub>2</sub>&gt; <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>&lt;Key&gt; must be an expression.  Each &lt;case clause&gt; must have one of
the following forms:
</p>

<tt>((&lt;datum<sub>1</sub>&gt;&nbsp;<tt>...</tt>)&nbsp;&lt;expression<sub>1</sub>&gt;&nbsp;&lt;expression<sub>2</sub>&gt;&nbsp;<tt>...</tt>)<br>
(else&nbsp;&lt;expression<sub>1</sub>&gt;&nbsp;&lt;expression<sub>2</sub>&gt;&nbsp;<tt>...</tt>)<p></tt>
<a name="node_idx_386"></a>The second form, which specifies an &#8220;<tt>else</tt> clause&#8221;,
may only appear as the last &lt;case clause&gt;.
Each &lt;datum&gt; is an external representation of some object.
The data represented by the &lt;datum&gt;s need not be distinct.</p>
<p>
<em>Semantics: </em>A <tt>case</tt> expression is evaluated as follows.  &lt;Key&gt; is
evaluated and its result is compared using <tt>eqv?</tt> (see
section&nbsp;<a href="#node_sec_11.5">11.5</a>) against the data
represented by the &lt;datum&gt;s of each &lt;case clause&gt; in turn, proceeding
in order from left to right through the set of clauses.  If the
result of evaluating &lt;key&gt; is equivalent to a datum of a &lt;case clause&gt;, the
corresponding &lt;expression&gt;s are evaluated from left
to right and the results of the last expression in the &lt;case clause&gt; are
returned as the results of the <tt>case</tt> expression.  Otherwise, the
comparison process continues.  If the result of
evaluating &lt;key&gt; is different from every datum in each set, then if
there is an <tt>else</tt> clause its expressions are evaluated and the
results of the last are the results of the <tt>case</tt> expression;
otherwise the <tt>case</tt> expression returns unspecified values.</p>
<p>
</p>

<tt>(case&nbsp;(*&nbsp;2&nbsp;3)<br>
&nbsp;&nbsp;((2&nbsp;3&nbsp;5&nbsp;7)&nbsp;&#8217;prime)<br>
&nbsp;&nbsp;((1&nbsp;4&nbsp;6&nbsp;8&nbsp;9)&nbsp;&#8217;composite))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;composite<br>
(case&nbsp;(car&nbsp;&#8217;(c&nbsp;d))<br>
&nbsp;&nbsp;((a)&nbsp;&#8217;a)<br>
&nbsp;&nbsp;((b)&nbsp;&#8217;b))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<em>unspecified</em><br>
(case&nbsp;(car&nbsp;&#8217;(c&nbsp;d))<br>
&nbsp;&nbsp;((a&nbsp;e&nbsp;i&nbsp;o&nbsp;u)&nbsp;&#8217;vowel)<br>
&nbsp;&nbsp;((w&nbsp;y)&nbsp;&#8217;semivowel)<br>
&nbsp;&nbsp;(else&nbsp;&#8217;consonant))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;consonant<p></tt></p>
<p>
The last &lt;expression&gt; of a &lt;case clause&gt; is in tail
context if the <tt>case</tt> expression itself is; see
section&nbsp;<a href="#node_sec_11.20">11.20</a>.</p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_388"></a>and<i> &lt;test<sub>1</sub>&gt; <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>The &lt;test&gt;s must be expressions.</p>
<p>
<em>Semantics: </em>If there are no &lt;test&gt;s, <tt>#t</tt> is returned.
Otherwise, the &lt;test&gt; expressions are evaluated from left to
right until a &lt;test&gt; returns <tt>#f</tt> or the last
&lt;test&gt; is reached.  In the former case, the <tt>and</tt> expression
returns <tt>#f</tt> without evaluating the remaining expressions.
In the latter case, the last expression is evaluated and its values
are returned.</p>
<p>
</p>

<tt>(and&nbsp;(=&nbsp;2&nbsp;2)&nbsp;(&gt;&nbsp;2&nbsp;1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(and&nbsp;(=&nbsp;2&nbsp;2)&nbsp;(&lt;&nbsp;2&nbsp;1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(and&nbsp;1&nbsp;2&nbsp;&#8217;c&nbsp;&#8217;(f&nbsp;g))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(f&nbsp;g)<br>
(and)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><p></tt></p>
<p>
The <tt>and</tt> keyword could be defined in terms of <tt>if</tt> using <tt>syntax-rules</tt> (see section&nbsp;<a href="#node_sec_11.19">11.19</a>) as follows:</p>
<p>
</p>

<tt>(define-syntax&nbsp;<tt>and</tt><br>
&nbsp;&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;((and)&nbsp;<tt>#t</tt>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;test)&nbsp;test)<br>
&nbsp;&nbsp;&nbsp;&nbsp;((and&nbsp;test1&nbsp;test2&nbsp;...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;test1&nbsp;(and&nbsp;test2&nbsp;...)&nbsp;<tt>#f</tt>))))<p></tt></p>
<p>
The last &lt;test&gt; expression is in tail context if the <tt>and</tt>
expression itself is; see section&nbsp;<a href="#node_sec_11.20">11.20</a>.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_390"></a>or<i> &lt;test<sub>1</sub>&gt; <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>The &lt;test&gt;s must be expressions.</p>
<p>
<em>Semantics: </em>If there are no &lt;test&gt;s, <tt>#f</tt> is returned.
Otherwise, the &lt;test&gt; expressions are evaluated from left to
right until a &lt;test&gt; returns a true value <i>val</i>
(see section&nbsp;<a href="r6rs-Z-H-8.html#node_sec_5.7">5.7</a>) or the last
&lt;test&gt; is reached.  In the former case, the <tt>or</tt> expression
returns <i>val</i> without evaluating the remaining expressions.
In the latter case, the last expression is evaluated and its values
are returned.</p>
<p>
</p>

<tt>(or&nbsp;(=&nbsp;2&nbsp;2)&nbsp;(&gt;&nbsp;2&nbsp;1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(or&nbsp;(=&nbsp;2&nbsp;2)&nbsp;(&lt;&nbsp;2&nbsp;1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(or&nbsp;<tt>#f</tt>&nbsp;<tt>#f</tt>&nbsp;<tt>#f</tt>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(or&nbsp;&#8217;(b&nbsp;c)&nbsp;(/&nbsp;3&nbsp;0))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(b&nbsp;c)<p></tt></p>
<p>
The <tt>or</tt> keyword could be defined in terms of <tt>if</tt> using <tt>syntax-rules</tt> (see section&nbsp;<a href="#node_sec_11.19">11.19</a>) as follows:</p>
<p>
</p>

<tt>(define-syntax&nbsp;<tt>or</tt><br>
&nbsp;&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;((or)&nbsp;<tt>#f</tt>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;((or&nbsp;test)&nbsp;test)<br>
&nbsp;&nbsp;&nbsp;&nbsp;((or&nbsp;test1&nbsp;test2&nbsp;...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((x&nbsp;test1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;x&nbsp;x&nbsp;(or&nbsp;test2&nbsp;...))))))<p></tt></p>
<p>
The last &lt;test&gt; expression is in tail context if the <tt>or</tt>
expression itself is; see section&nbsp;<a href="#node_sec_11.20">11.20</a>.
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.4.6"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.4.6">11.4.6&nbsp;&nbsp;Binding constructs</a></h3>
<p>The binding constructs described in this section
create local bindings for variables that are visible only in a
delimited region.  The syntax of the 
constructs
<tt>let</tt>, <tt>let*</tt>, <tt>letrec</tt>, and <tt>letrec*</tt>
is identical, but they differ in the regions<a name="node_idx_392"></a>(see section&nbsp;<a href="r6rs-Z-H-8.html#node_sec_5.2">5.2</a>) they establish
for their variable bindings and in the order in which the values for
the bindings are computed.  In a <tt>let</tt> expression, the initial
values are computed before any of the variables become bound; in a
<tt>let*</tt> expression, the bindings and evaluations are performed
sequentially.  In a <tt>letrec</tt> or <tt>letrec*</tt>
expression, all the bindings are in
effect while their initial values are being computed, thus allowing
mutually recursive definitions.  In a <tt>letrec</tt> expression, the
initial values are computed before being assigned to the variables;
in a <tt>letrec*</tt>, the evaluations and assignments are performed
sequentially.</p>
<p>
In addition, the binding constructs <tt>let-values</tt> and <tt>let*-values</tt> generalize <tt>let</tt> and <tt>let*</tt> to allow multiple
variables to be bound to the results of expressions that evaluate to
multiple values.
They are analogous to <tt>let</tt> and <tt>let*</tt> in the
way they establish regions: in a <tt>let-values</tt> expression, the
initial values are computed before any of the variables become bound;
in a <tt>let*-values</tt> expression, the bindings are performed
sequentially. </p>
<p>
Sample definitions of all the binding forms of this section in terms
of simpler forms are in appendix&nbsp;<a href="r6rs-Z-H-16.html#node_chap_B">B</a>.</p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_394"></a>let<i> &lt;bindings&gt; &lt;body&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>&lt;Bindings&gt; must have the form
</p>

<tt>((&lt;variable<sub>1</sub>&gt;&nbsp;&lt;init<sub>1</sub>&gt;)&nbsp;<tt>...</tt>),<p></tt>
where each &lt;init&gt; is an expression, and &lt;body&gt; 
is as described in section&nbsp;<a href="#node_sec_11.3">11.3</a>.  
Any variable must not appear more than once in the &lt;variable&gt;s.</p>
<p>
<em>Semantics: </em>The &lt;init&gt;s are evaluated in the current environment (in some
unspecified order), the &lt;variable&gt;s are bound to fresh locations
holding the results, the &lt;body&gt; is evaluated in the extended
environment, and the values of the last expression of &lt;body&gt;
are returned.  Each binding of a &lt;variable&gt; has &lt;body&gt; as its
region.<a name="node_idx_396"></a></p>
<p>
</p>

<tt>(let&nbsp;((x&nbsp;2)&nbsp;(y&nbsp;3))<br>
&nbsp;&nbsp;(*&nbsp;x&nbsp;y))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;6<br>
<br>
(let&nbsp;((x&nbsp;2)&nbsp;(y&nbsp;3))<br>
&nbsp;&nbsp;(let&nbsp;((x&nbsp;7)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(z&nbsp;(+&nbsp;x&nbsp;y)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;z&nbsp;x)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;35<p></tt></p>
<p>
See also named <tt>let</tt>, section <a href="#node_sec_11.16">11.16</a>.</p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_398"></a>let*<i> &lt;bindings&gt; &lt;body&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>&lt;Bindings&gt; must have the form
</p>

<tt>((&lt;variable<sub>1</sub>&gt;&nbsp;&lt;init<sub>1</sub>&gt;)&nbsp;<tt>...</tt>),<p></tt>
where each &lt;init&gt; is an expression, and &lt;body&gt; 
is as described in section&nbsp;<a href="#node_sec_11.3">11.3</a>.</p>
<p>
<em>Semantics: </em>The <tt>let*</tt> form is similar to <tt>let</tt>, but the &lt;init&gt;s are
evaluated and bindings created sequentially from left to right, with
the region<a name="node_idx_400"></a>of each binding including the bindings to
its right as well as &lt;body&gt;.  Thus the second &lt;init&gt; is evaluated
in an environment in which the first binding is visible and initialized,
and so on.</p>
<p>
</p>

<tt>(let&nbsp;((x&nbsp;2)&nbsp;(y&nbsp;3))<br>
&nbsp;&nbsp;(let*&nbsp;((x&nbsp;7)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(z&nbsp;(+&nbsp;x&nbsp;y)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;z&nbsp;x)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;70<p></tt></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
While the variables bound by a <tt>let</tt> expression must be distinct,
the variables bound by a <tt>let*</tt> expression need not be distinct.
</blockquote>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_402"></a>letrec<i> &lt;bindings&gt; &lt;body&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>&lt;Bindings&gt; must have the form
</p>

<tt>((&lt;variable<sub>1</sub>&gt;&nbsp;&lt;init<sub>1</sub>&gt;)&nbsp;<tt>...</tt>),<p></tt>
where each &lt;init&gt; is an expression, and &lt;body&gt; 
is as described in section&nbsp;<a href="#node_sec_11.3">11.3</a>.  Any
variable must not appear more than once in the
&lt;variable&gt;s.</p>
<p>
<em>Semantics: </em>The &lt;variable&gt;s are bound to fresh locations, the &lt;init&gt;s
are evaluated in the resulting environment (in
some unspecified order), each &lt;variable&gt; is assigned to the result
of the corresponding &lt;init&gt;, the &lt;body&gt; is evaluated in the
resulting environment, and the values of the last expression in
&lt;body&gt; are returned.  Each binding of a &lt;variable&gt; has the
entire <tt>letrec</tt> expression as its region<a name="node_idx_404"></a>, making it possible to
define mutually recursive procedures.</p>
<p>
</p>

<tt>(letrec&nbsp;((even?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>#t</tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(odd?&nbsp;(-&nbsp;n&nbsp;1)))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(odd?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>#f</tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(even?&nbsp;(-&nbsp;n&nbsp;1))))))<br>
&nbsp;&nbsp;(even?&nbsp;88))&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><p></tt></p>
<p>
It should be possible
to evaluate each &lt;init&gt; without assigning or referring to the
value of any &lt;variable&gt;.  In the most
common uses of <tt>letrec</tt>, all the &lt;init&gt;s are <tt>lambda</tt> expressions
and the restriction is satisfied automatically.
Another restriction is that the continuation of each &lt;init&gt; should not be invoked
more than once.</p>
<p>
<em>Implementation responsibilities: </em>Implementations must detect references to a &lt;variable&gt; during the
evaluation of the &lt;init&gt; expressions (using one particular
evaluation order and order of evaluating the &lt;init&gt; expressions).
If an implementation detects such a violation of the
restriction, it must raise an exception with condition type
<tt>&amp;assertion</tt>.
Implementations may or may not detect that the continuation of each
&lt;init&gt; is invoked more than once.  However, if the
implementation detects this, it must raise an exception with condition
type <tt>&amp;assertion</tt>.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_406"></a>letrec*<i> &lt;bindings&gt; &lt;body&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>&lt;Bindings&gt; must have the form
</p>

<tt>((&lt;variable<sub>1</sub>&gt;&nbsp;&lt;init<sub>1</sub>&gt;)&nbsp;<tt>...</tt>),<p></tt>
where each &lt;init&gt; is an expression, and &lt;body&gt; 
is as described in section&nbsp;<a href="#node_sec_11.3">11.3</a>. 
Any variable must not appear more than once in the
&lt;variable&gt;s.</p>
<p>
<em>Semantics: </em>The &lt;variable&gt;s are bound to fresh locations,
each &lt;variable&gt; is assigned in left-to-right order to the
result of evaluating the corresponding &lt;init&gt;, the &lt;body&gt; is
evaluated in the resulting environment, and the values of the last
expression in &lt;body&gt; are returned. 
Despite the left-to-right evaluation and assignment order, each binding of
a &lt;variable&gt; has the entire <tt>letrec*</tt> expression as its
region<a name="node_idx_408"></a>, making it possible to define mutually recursive
procedures.</p>
<p>
</p>

<tt>(letrec*&nbsp;((p<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;1&nbsp;(q&nbsp;(-&nbsp;x&nbsp;1)))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(q<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;1&nbsp;(p&nbsp;(-&nbsp;y&nbsp;1))))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(x&nbsp;(p&nbsp;5))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(y&nbsp;x))<br>
&nbsp;&nbsp;y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;5<p></tt></p>
<p>
It must be possible
to evaluate each &lt;init&gt; without assigning or referring to the value
of the corresponding &lt;variable&gt; or the &lt;variable&gt; of any of
the bindings that follow it in &lt;bindings&gt;.
Another restriction is that the continuation of each &lt;init&gt; should not be invoked
more than once.</p>
<p>
<em>Implementation responsibilities: </em>Implementations must, during the evaluation of an
&lt;init&gt; expression, detect references to the
value of the corresponding &lt;variable&gt; or the &lt;variable&gt; of
any of the bindings that follow it in &lt;bindings&gt;.
If an implementation detects such a
violation of the restriction, it must raise an exception with
condition type <tt>&amp;assertion</tt>.  Implementations may or may not
detect that the continuation of each &lt;init&gt; is invoked more than
once.  However, if the implementation detects this, it must raise an
exception with condition type <tt>&amp;assertion</tt>.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_410"></a>let-values<i> &lt;mv-bindings&gt; &lt;body&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>&lt;Mv-bindings&gt; must have the form
</p>

<tt>((&lt;formals<sub>1</sub>&gt;&nbsp;&lt;init<sub>1</sub>&gt;)&nbsp;<tt>...</tt>),<p></tt>
where each &lt;init&gt; is an expression, and &lt;body&gt; 
is as described in section&nbsp;<a href="#node_sec_11.3">11.3</a>.  
Any variable must not appear more
than once in the set of &lt;formals&gt;.</p>
<p>
<em>Semantics: </em>The &lt;init&gt;s are evaluated in the current environment
(in some unspecified order), and the variables occurring in the
&lt;formals&gt; are bound to fresh locations containing the values
returned by the &lt;init&gt;s, where the &lt;formals&gt; are matched
to the return values in the same way that the &lt;formals&gt; in a
<tt>lambda</tt> expression are matched to the arguments in a procedure call.
Then, the &lt;body&gt; is evaluated in the extended environment, and the
values of the last expression of &lt;body&gt; are returned.
Each binding of a variable has &lt;body&gt; as its
region.<a name="node_idx_412"></a>If the &lt;formals&gt; do not match, an exception with condition type
<tt>&amp;assertion</tt> is raised.</p>
<p>
</p>

<tt>(let-values&nbsp;(((a&nbsp;b)&nbsp;(values&nbsp;1&nbsp;2))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((c&nbsp;d)&nbsp;(values&nbsp;3&nbsp;4)))<br>
&nbsp;&nbsp;(list&nbsp;a&nbsp;b&nbsp;c&nbsp;d))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;(1&nbsp;2&nbsp;3&nbsp;4)<br>
<br>
(let-values&nbsp;(((a&nbsp;b&nbsp;.&nbsp;c)&nbsp;(values&nbsp;1&nbsp;2&nbsp;3&nbsp;4)))<br>
&nbsp;&nbsp;(list&nbsp;a&nbsp;b&nbsp;c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;(1&nbsp;2&nbsp;(3&nbsp;4))<br>
<br>
(let&nbsp;((a&nbsp;&#8217;a)&nbsp;(b&nbsp;&#8217;b)&nbsp;(x&nbsp;&#8217;x)&nbsp;(y&nbsp;&#8217;y))<br>
&nbsp;&nbsp;(let-values&nbsp;(((a&nbsp;b)&nbsp;(values&nbsp;x&nbsp;y))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((x&nbsp;y)&nbsp;(values&nbsp;a&nbsp;b)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;a&nbsp;b&nbsp;x&nbsp;y)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;(x&nbsp;y&nbsp;a&nbsp;b)<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_414"></a>let*-values<i> &lt;mv-bindings&gt; &lt;body&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>&lt;Mv-bindings&gt; must have the form
</p>

<tt>((&lt;formals<sub>1</sub>&gt;&nbsp;&lt;init<sub>1</sub>&gt;)&nbsp;<tt>...</tt>),<p></tt>
where each &lt;init&gt; is an expression, and &lt;body&gt; 
is as described in section&nbsp;<a href="#node_sec_11.3">11.3</a>.
In each &lt;formals&gt;, any variable must not appear more than once.</p>
<p>
<em>Semantics: </em>The <tt>let*-values</tt> form is similar to <tt>let-values</tt>, but the &lt;init&gt;s are
evaluated and bindings created sequentially from left to right, with
the region<a name="node_idx_416"></a>of the bindings of each &lt;formals&gt; including
the bindings to its right as well as &lt;body&gt;. 
Thus the second &lt;init&gt; is evaluated in an environment in which the
bindings of the first &lt;formals&gt; is visible and initialized, and so
on.</p>
<p>
</p>

<tt>(let&nbsp;((a&nbsp;&#8217;a)&nbsp;(b&nbsp;&#8217;b)&nbsp;(x&nbsp;&#8217;x)&nbsp;(y&nbsp;&#8217;y))<br>
&nbsp;&nbsp;(let*-values&nbsp;(((a&nbsp;b)&nbsp;(values&nbsp;x&nbsp;y))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((x&nbsp;y)&nbsp;(values&nbsp;a&nbsp;b)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;a&nbsp;b&nbsp;x&nbsp;y)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;(x&nbsp;y&nbsp;x&nbsp;y)<p></tt></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
While all of the variables bound by a <tt>let-values</tt> expression
must be distinct, the variables bound by different &lt;formals&gt; of a
<tt>let*-values</tt> expression need not be distinct.
</blockquote><p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.4.7"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.4.7">11.4.7&nbsp;&nbsp;Sequencing</a></h3>
<p><div style="height: -9.0pt"></div>
<p style="margin-top: 0pt; margin-bottom: 0pt"></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_418"></a>begin<i> &lt;form&gt; <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>

<div align=left><tt>(<a name="node_idx_420"></a>begin<i> &lt;expression&gt; &lt;expression&gt; <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
The &lt;begin&gt; keyword has two different roles, depending on its
context:
</p>
<ul>
<li><p>It may appear as a form in a &lt;body&gt; (see
section&nbsp;<a href="#node_sec_11.3">11.3</a>), &lt;library body&gt; (see
section&nbsp;<a href="r6rs-Z-H-10.html#node_sec_7.1">7.1</a>), or &lt;top-level body&gt; (see
chapter&nbsp;<a href="r6rs-Z-H-11.html#node_chap_8">8</a>), or directly nested in a <tt>begin</tt>
form that appears in a body.  In this case, the <tt>begin</tt> form
must have the shape specified in the first header line.  This use of
<tt>begin</tt> acts as a <a name="node_idx_422"></a><em>splicing</em> form&#8212;the forms inside
the &lt;body&gt; are spliced into the surrounding body, as if the
<tt>begin</tt> wrapper were not actually present.</p>
<p>
A <tt>begin</tt> form in a &lt;body&gt; or &lt;library body&gt; must
be non-empty if it appears after the first &lt;expression&gt;
within the body.
</p>
<li><p>It may appear as an ordinary expression and must have the shape
specified in the second header line.  In this case, the
&lt;expression&gt;s are evaluated sequentially from left to right,
and the values of the last &lt;expression&gt; are returned.
This expression type is used to sequence side effects such as
assignments or input
and output.
</p>
</ul><p></p>
<p>
</p>

<tt>(define&nbsp;x&nbsp;0)<br>
<br>
(begin&nbsp;(set!&nbsp;x&nbsp;5)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;x&nbsp;1))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;6<br>
<br>
(begin&nbsp;(display&nbsp;&quot;4&nbsp;plus&nbsp;1&nbsp;equals&nbsp;&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display&nbsp;(+&nbsp;4&nbsp;1)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
&nbsp;<em>&nbsp;and&nbsp;prints</em>&nbsp;&nbsp;4&nbsp;plus&nbsp;1&nbsp;equals&nbsp;5<p></tt>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.5"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.5">11.5&nbsp;&nbsp;Equivalence predicates</a></h2>
<p></p>
<p>
A <a name="node_idx_424"></a><em>predicate</em> is a procedure that always returns a boolean
value (<tt>#t</tt> or <tt>#f</tt>).  An <a name="node_idx_426"></a><em>equivalence predicate</em> is
the computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, <tt>eq?</tt> is the finest or most
discriminating, and <tt>equal?</tt> is the coarsest.  The <tt>eqv?</tt> predicate is
slightly less discriminating than <tt>eq?</tt>.  </p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_428"></a>eqv?<i> <i>obj<sub>1</sub></i> <i>obj<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <tt>eqv?</tt> procedure defines a useful equivalence relation on objects.
Briefly, it returns <tt>#t</tt> if <i>obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> should
normally be regarded as the same object and <tt>#f</tt> otherwise.  This relation is left slightly
open to interpretation, but the following partial specification of
<tt>eqv?</tt> must hold for all implementations.</p>
<p>
The <tt>eqv?</tt> procedure returns <tt>#t</tt> if one of the following holds:</p>
<p>
</p>
<ul>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are both booleans and are the same
according to the <tt>boolean=?</tt> procedure (section&nbsp;<a href="#node_sec_11.8">11.8</a>).</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are both symbols and are the same
according to the <tt>symbol=?</tt> procedure (section&nbsp;<a href="#node_sec_11.10">11.10</a>).</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are both exact<a name="node_idx_430"></a>number objects
and are numerically equal (see <tt>=</tt>, 
section&nbsp;<a href="#node_sec_11.7">11.7</a>).</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are both inexact<a name="node_idx_432"></a>number objects, are numerically
equal (see <tt>=</tt>, section&nbsp;<a href="#node_sec_11.7">11.7</a>), and
yield the same results (in the sense of <tt>eqv?</tt>) when passed
as arguments to any other procedure that can be defined
as a finite composition of Scheme&#8217;s standard arithmetic
procedures.</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are both characters and are the same
character according to the <tt>char=?</tt> procedure
(section&nbsp;<a href="#node_sec_11.11">11.11</a>).</p>
<p>
</p>
<li><p>Both <i>obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are the empty list.</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are objects such as pairs, vectors, bytevectors
(library chapter&nbsp;on &#8220;Bytevectors&#8221;),
strings, hashtables, records (library
chapter&nbsp;on &#8220;Records&#8221;), ports (library
section&nbsp;on &#8220;Port I/O&#8221;), or hashtables
(library chapter&nbsp;on &#8220;Hash tables&#8221;) that
refer to the same locations in the store (section&nbsp;<a href="r6rs-Z-H-8.html#node_sec_5.10">5.10</a>).</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are record-type descriptors that are
specified to be <tt>eqv?</tt> in library
section&nbsp;on &#8220;Procedural layer&#8221;.
</p>
</ul><p></p>
<p>
The <tt>eqv?</tt> procedure returns <tt>#f</tt> if one of the following holds:</p>
<p>
</p>
<ul>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are of different types
(section&nbsp;<a href="#node_sec_11.1">11.1</a>).</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are booleans for which the <tt>boolean=?</tt> procedure returns <tt>#f</tt>.</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are symbols for which the <tt>symbol=?</tt> procedure returns <tt>#f</tt>.</p>
<p>
</p>
<li><p>One of <i>obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> is an exact number object but the other is
an inexact number object.</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are rational number objects for which the <tt>=</tt> procedure
returns <tt>#f</tt>.</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> yield different results (in the sense of
<tt>eqv?</tt>) when passed as arguments to any other procedure
that can be defined as a finite composition of Scheme&#8217;s
standard arithmetic procedures.</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are characters for which the <tt>char=?</tt>
procedure returns <tt>#f</tt>.</p>
<p>
</p>
<li><p>One of <i>obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> is the empty list, but the other is not.</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are objects such as pairs, vectors,
bytevectors (library
chapter&nbsp;on &#8220;Bytevectors&#8221;), strings,
records (library
chapter&nbsp;on &#8220;Records&#8221;), ports (library
section&nbsp;on &#8220;Port I/O&#8221;), or hashtables
(library chapter&nbsp;on &#8220;Hashtables&#8221;) that
refer to distinct locations.</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are pairs, vectors, strings, or
records, or hashtables, where the applying the same accessor (i.e.
  <tt>car</tt>, <tt>cdr</tt>, <tt>vector-ref</tt>, <tt>string-ref</tt>, or record
accessors) to both yields results for which <tt>eqv?</tt> returns
<tt>#f</tt>.</p>
<p>
</p>
<li><p><i>Obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> are procedures that would behave differently
(return different values or have different side effects) for some arguments.</p>
<p>
</p>
</ul><p></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
The <tt>eqv?</tt> procedure returning <tt>#t</tt> when <i>obj<sub>1</sub></i> and
<i>obj<sub>2</sub></i> are number objects does not imply that <tt>=</tt> would also
return <tt>#t</tt> when called with <i>obj<sub>1</sub></i> and <i>obj<sub>2</sub></i> as
arguments.
</blockquote><p>
</p>

<tt>(eqv?&nbsp;&#8217;a&nbsp;&#8217;a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(eqv?&nbsp;&#8217;a&nbsp;&#8217;b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(eqv?&nbsp;2&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(eqv?&nbsp;&#8217;()&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(eqv?&nbsp;100000000&nbsp;100000000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(eqv?&nbsp;(cons&nbsp;1&nbsp;2)&nbsp;(cons&nbsp;1&nbsp;2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(eqv?&nbsp;(lambda&nbsp;()&nbsp;1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(eqv?&nbsp;#f&nbsp;&#8217;nil)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><p></tt></p>
<p>
The following examples illustrate cases in which the above rules do
not fully specify the behavior of <tt>eqv?</tt>.  All that can be said
about such cases is that the value returned by <tt>eqv?</tt> must be a
boolean.</p>
<p>
</p>

<tt>(let&nbsp;((p&nbsp;(lambda&nbsp;(x)&nbsp;x)))<br>
&nbsp;&nbsp;(eqv?&nbsp;p&nbsp;p))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eqv?&nbsp;&quot;&quot;&nbsp;&quot;&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eqv?&nbsp;&#8217;#()&nbsp;&#8217;#())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eqv?&nbsp;(lambda&nbsp;(x)&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(x)&nbsp;x))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eqv?&nbsp;(lambda&nbsp;(x)&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y)&nbsp;y))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eqv?&nbsp;+nan.0&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<i>unspecified</i><p></tt></p>
<p>
The next set of examples shows the use of <tt>eqv?</tt> with procedures
that have local state.  Calls to <tt>gen-counter</tt> must return a
distinct procedure every time, since each procedure has its own
internal counter.  Calls to <tt>gen-loser</tt> return procedures that
behave equivalently when called.  However, <tt>eqv?</tt> may
not detect this equivalence.</p>
<p>
</p>

<tt>(define&nbsp;gen-counter<br>
&nbsp;&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((n&nbsp;0))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;n&nbsp;(+&nbsp;n&nbsp;1))&nbsp;n))))<br>
(let&nbsp;((g&nbsp;(gen-counter)))<br>
&nbsp;&nbsp;(eqv?&nbsp;g&nbsp;g))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eqv?&nbsp;(gen-counter)&nbsp;(gen-counter))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(define&nbsp;gen-loser<br>
&nbsp;&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((n&nbsp;0))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(set!&nbsp;n&nbsp;(+&nbsp;n&nbsp;1))&nbsp;27))))<br>
(let&nbsp;((g&nbsp;(gen-loser)))<br>
&nbsp;&nbsp;(eqv?&nbsp;g&nbsp;g))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eqv?&nbsp;(gen-loser)&nbsp;(gen-loser))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
<br>
(letrec&nbsp;((f&nbsp;(lambda&nbsp;()&nbsp;(if&nbsp;(eqv?&nbsp;f&nbsp;g)&nbsp;&#8217;both&nbsp;&#8217;f)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(g&nbsp;(lambda&nbsp;()&nbsp;(if&nbsp;(eqv?&nbsp;f&nbsp;g)&nbsp;&#8217;both&nbsp;&#8217;g))))<br>
&nbsp;&nbsp;(eqv?&nbsp;f&nbsp;g))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
<br>
(letrec&nbsp;((f&nbsp;(lambda&nbsp;()&nbsp;(if&nbsp;(eqv?&nbsp;f&nbsp;g)&nbsp;&#8217;f&nbsp;&#8217;both)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(g&nbsp;(lambda&nbsp;()&nbsp;(if&nbsp;(eqv?&nbsp;f&nbsp;g)&nbsp;&#8217;g&nbsp;&#8217;both))))<br>
&nbsp;&nbsp;(eqv?&nbsp;f&nbsp;g))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><p></tt></p>
<p>
Implementations may
share structure between constants where appropriate.
Furthermore, a constant may be copied at any time by the implementation so
as to exist simultaneously in different sets of locations, as noted in
section&nbsp;<a href="#node_sec_11.4.1">11.4.1</a>.
Thus the value of <tt>eqv?</tt> on constants is sometimes
implementation-dependent.</p>
<p>
</p>

<tt>(eqv?&nbsp;&#8217;(a)&nbsp;&#8217;(a))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eqv?&nbsp;&quot;a&quot;&nbsp;&quot;a&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eqv?&nbsp;&#8217;(b)&nbsp;(cdr&nbsp;&#8217;(a&nbsp;b)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(let&nbsp;((x&nbsp;&#8217;(a)))<br>
&nbsp;&nbsp;(eqv?&nbsp;x&nbsp;x))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_434"></a>eq?<i> <i>obj<sub>1</sub></i> <i>obj<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <tt>eq?</tt> predicate is similar to <tt>eqv?</tt> except that in some cases it is
capable of discerning distinctions finer than those detectable by
<tt>eqv?</tt>.</p>
<p>
The <tt>eq?</tt> and <tt>eqv?</tt> predicates are guaranteed to have the
same behavior on symbols, booleans, the empty list, pairs, procedures,
non-empty strings, bytevectors, and vectors, and records.  The
behavior of <tt>eq?</tt> on number objects and characters is
implementation-dependent, but it always returns either <tt>#t</tt> or
<tt>#f</tt>, and returns <tt>#t</tt> only when <tt>eqv?</tt> would also
return <tt>#t</tt>.  The <tt>eq?</tt> predicate may also behave differently
from <tt>eqv?</tt> on empty vectors, empty bytevectors, and empty strings.</p>
<p>
</p>

<tt>(eq?&nbsp;&#8217;a&nbsp;&#8217;a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(eq?&nbsp;&#8217;(a)&nbsp;&#8217;(a))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eq?&nbsp;(list&nbsp;&#8217;a)&nbsp;(list&nbsp;&#8217;a))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(eq?&nbsp;&quot;a&quot;&nbsp;&quot;a&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eq?&nbsp;&quot;&quot;&nbsp;&quot;&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eq?&nbsp;&#8217;()&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(eq?&nbsp;2&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eq?&nbsp;#<tt>\</tt>A&nbsp;#<tt>\</tt>A)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(eq?&nbsp;car&nbsp;car)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(let&nbsp;((n&nbsp;(+&nbsp;2&nbsp;3)))<br>
&nbsp;&nbsp;(eq?&nbsp;n&nbsp;n))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(let&nbsp;((x&nbsp;&#8217;(a)))<br>
&nbsp;&nbsp;(eq?&nbsp;x&nbsp;x))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(let&nbsp;((x&nbsp;&#8217;#()))<br>
&nbsp;&nbsp;(eq?&nbsp;x&nbsp;x))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(let&nbsp;((p&nbsp;(lambda&nbsp;(x)&nbsp;x)))<br>
&nbsp;&nbsp;(eq?&nbsp;p&nbsp;p))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><p></tt></p>
<p>
</p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_436"></a>equal?<i> <i>obj<sub>1</sub></i> <i>obj<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <tt>equal?</tt>  predicate returns <tt>#t</tt> if and only if the
(possibly infinite) unfoldings of its arguments into regular trees are
equal as ordered trees.</p>
<p>
The <tt>equal?</tt> predicate treats pairs and vectors
as nodes with outgoing edges, uses <tt>string=?</tt> to compare strings, uses <tt>bytevector=?</tt> to compare bytevectors (see library chapter&nbsp;on &#8220;Bytevectors&#8221;),
and uses <tt>eqv?</tt> to compare other nodes.</p>
<p>
</p>

<tt>(equal?&nbsp;&#8217;a&nbsp;&#8217;a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(equal?&nbsp;&#8217;(a)&nbsp;&#8217;(a))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(equal?&nbsp;&#8217;(a&nbsp;(b)&nbsp;c)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8217;(a&nbsp;(b)&nbsp;c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(equal?&nbsp;&quot;abc&quot;&nbsp;&quot;abc&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(equal?&nbsp;2&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(equal?&nbsp;(make-vector&nbsp;5&nbsp;&#8217;a)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-vector&nbsp;5&nbsp;&#8217;a))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(equal?&nbsp;&#8217;#vu8(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(u8-list-&gt;bytevector<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8217;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(equal?&nbsp;(lambda&nbsp;(x)&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(y)&nbsp;y))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
<br>
(let*&nbsp;((x&nbsp;(list&nbsp;&#8217;a))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(y&nbsp;(list&nbsp;&#8217;a))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(z&nbsp;(list&nbsp;x&nbsp;y)))<br>
&nbsp;&nbsp;(list&nbsp;(equal?&nbsp;z&nbsp;(list&nbsp;y&nbsp;x))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(equal?&nbsp;z&nbsp;(list&nbsp;x&nbsp;x))))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(<tt>#t</tt>&nbsp;<tt>#t</tt>)<p></tt></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
The <tt>equal?</tt> procedure must always terminate, even if its
arguments contain cycles.
</blockquote><p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.6"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.6">11.6&nbsp;&nbsp;Procedure predicate</a></h2>
<p></p>
<p></p>
<div align=left><tt>(<a name="node_idx_438"></a>procedure?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is a procedure, otherwise returns <tt>#f</tt>.</p>
<p>
</p>

<tt>(procedure?&nbsp;car)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(procedure?&nbsp;&#8217;car)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(procedure?&nbsp;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;x)))&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(procedure?&nbsp;&#8217;(lambda&nbsp;(x)&nbsp;(*&nbsp;x&nbsp;x)))&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.7"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.7">11.7&nbsp;&nbsp;Arithmetic</a></h2>
<p></p>
<p>
The procedures described here implement arithmetic that is
generic over
the numerical tower described in chapter&nbsp;<a href="r6rs-Z-H-6.html#node_chap_3">3</a>.
The generic procedures described in this section
accept both exact and inexact number objects as arguments,
performing coercions and selecting the appropriate operations
as determined by the numeric subtypes of their arguments.</p>
<p>
Library chapter&nbsp;on &#8220;Arithmetic&#8221; describes
libraries that define other numerical procedures.</p>
<p>
</p>
<a name="node_sec_11.7.1"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.7.1">11.7.1&nbsp;&nbsp;Propagation of exactness and inexactness</a></h3>
<p></p>
<p>
The procedures listed below must return the mathematically correct exact result
provided all their arguments are exact:</p>
<p>
</p>

<tt>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>
max&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abs<br>
numerator&nbsp;&nbsp;&nbsp;&nbsp;denominator&nbsp;&nbsp;gcd<br>
lcm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;floor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ceiling<br>
truncate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;round&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rationalize<br>
real-part&nbsp;&nbsp;&nbsp;&nbsp;imag-part&nbsp;&nbsp;&nbsp;&nbsp;make-rectangular<p></tt></p>
<p>
The procedures listed below must return the correct exact result
provided all their arguments are exact, and no divisors are zero:</p>
<p>
</p>

<tt>/<br>
div&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mod&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div-and-mod<br>
div0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mod0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div0-and-mod0<p></tt></p>
<p>
Moreover, the procedure <tt>expt</tt> must return the correct exact
result provided its first argument is an exact real number object and
its second argument is an exact integer object.</p>
<p>
The general rule is that the generic operations return the correct
exact result when all of their arguments are exact and the result is
mathematically well-defined, but return an inexact result when any
argument is inexact.  Exceptions to this rule include
<tt>sqrt</tt>, <tt>exp</tt>, <tt>log</tt>,
<tt>sin</tt>, <tt>cos</tt>, <tt>tan</tt>,
<tt>asin</tt>, <tt>acos</tt>, <tt>atan</tt>,
<tt>expt</tt>, <tt>make-polar</tt>, <tt>magnitude</tt>, and <tt>angle</tt>, which
may (but are not required to) return inexact results even when
given exact arguments, as indicated in the specification of these
procedures.</p>
<p>
One general exception to the rule above is that an implementation may
return an exact result despite inexact arguments if that exact result
would be the correct result for all possible substitutions of exact
arguments for the inexact ones.  An example is <tt>(* 1.0 0)</tt> which
may return either <tt>0</tt> (exact) or <tt>0.0</tt> (inexact).</p>
<p>
</p>
<a name="node_sec_11.7.2"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.7.2">11.7.2&nbsp;&nbsp;Representability of infinities and NaNs</a></h3>
<p></p>
<p>
The specification of the numerical operations is written as though
infinities and NaNs are representable, and specifies many operations
with respect to these number objects in ways that are consistent with the
IEEE-754 standard for binary floating-point arithmetic.  
An implementation of Scheme may or may not represent infinities and
NaNs; however,
an implementation must raise a continuable exception with
condition type <tt>&amp;no-infinities</tt> or <tt>&amp;no-nans</tt> (respectively;
see library section&nbsp;on &#8220;Flonums&#8221;)
whenever it is unable to represent an infinity or NaN as specified. 
In this case, the continuation of the exception
handler is the continuation that otherwise would have received
the infinity or NaN value.  This requirement also applies to
conversions between number objects and external representations, including
the reading of program source code.</p>
<p>
</p>
<a name="node_sec_11.7.3"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.7.3">11.7.3&nbsp;&nbsp;Semantics of common operations</a></h3>
<p>Some operations are the semantic basis for several arithmetic
procedures.  The behavior of these operations is described in this
section for later reference.</p>
<p>
</p>
<a name="node_sec_11.7.3.1"></a>
<h4 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.7.3.1">11.7.3.1&nbsp;&nbsp;Integer division</a></h4>
<p></p>
<p>
Scheme&#8217;s operations for performing integer
division rely on mathematical operations <em>d</em><em>i</em><em>v</em>,
<em>m</em><em>o</em><em>d</em>, <em>d</em><em>i</em><em>v</em><sub>0</sub>, and
<em>m</em><em>o</em><em>d</em><sub>0</sub>, that are defined as follows:</p>
<p>
<em>d</em><em>i</em><em>v</em>, <em>m</em><em>o</em><em>d</em>, <em>d</em><em>i</em><em>v</em><sub>0</sub>, and <em>m</em><em>o</em><em>d</em><sub>0</sub>
each accept two real numbers <em>x</em><sub>1</sub> and <em>x</em><sub>2</sub> as operands, where
<em>x</em><sub>2</sub> must be nonzero.</p>
<p>
<em>d</em><em>i</em><em>v</em> returns an integer, and <em>m</em><em>o</em><em>d</em> returns a real.
Their results are specified by
</p>
<a name="node_eqn_Temp_17"></a>
<div align=left><table width=100%>
<tr><td align=right>
<em>x</em><sub>1</sub>&nbsp;<em>d</em><em>i</em><em>v</em>&nbsp;<em>x</em><sub>2</sub> </td><td align=center width=2%> = </td><td> <em>n</em><sub><em>d</em></sub></td></tr>
<tr><td align=right><em>x</em><sub>1</sub>&nbsp;<em>m</em><em>o</em><em>d</em>&nbsp;<em>x</em><sub>2</sub> </td><td align=center width=2%> = </td><td> <em>x</em><sub><em>m</em></sub>
</td></tr>
</table></div><p>*
where
</p>
<div align=left><img src="r6rs-Z-G-2.gif" border="0" alt="[r6rs-Z-G-2.gif]"></div><p>
Examples:
</p>
<a name="node_eqn_Temp_18"></a>
<div align=left><table width=100%>
<tr><td align=right>
123&nbsp;<em>d</em><em>i</em><em>v</em>&nbsp;10    </td><td align=center width=2%> = </td><td>  12</td></tr>
<tr><td align=right>123&nbsp;<em>m</em><em>o</em><em>d</em>&nbsp;10    </td><td align=center width=2%> = </td><td>  3</td></tr>
<tr><td align=right>123&nbsp;<em>d</em><em>i</em><em>v</em>&nbsp; <tt>-</tt> 10   </td><td align=center width=2%> = </td><td>   <tt>-</tt> 12</td></tr>
<tr><td align=right>123&nbsp;<em>m</em><em>o</em><em>d</em>&nbsp; <tt>-</tt> 10   </td><td align=center width=2%> = </td><td>  3</td></tr>
<tr><td align=right> <tt>-</tt> 123&nbsp;<em>d</em><em>i</em><em>v</em>&nbsp;10    </td><td align=center width=2%> = </td><td>   <tt>-</tt> 13</td></tr>
<tr><td align=right> <tt>-</tt> 123&nbsp;<em>m</em><em>o</em><em>d</em>&nbsp;10    </td><td align=center width=2%> = </td><td>  7</td></tr>
<tr><td align=right> <tt>-</tt> 123&nbsp;<em>d</em><em>i</em><em>v</em>&nbsp; <tt>-</tt> 10   </td><td align=center width=2%> = </td><td>  13</td></tr>
<tr><td align=right> <tt>-</tt> 123&nbsp;<em>m</em><em>o</em><em>d</em>&nbsp; <tt>-</tt> 10   </td><td align=center width=2%> = </td><td>  7
</td></tr>
</table></div><p>*
<em>d</em><em>i</em><em>v</em><sub>0</sub> and <em>m</em><em>o</em><em>d</em><sub>0</sub> are like <em>d</em><em>i</em><em>v</em> and
<em>m</em><em>o</em><em>d</em>, except the result of <em>m</em><em>o</em><em>d</em><sub>0</sub> lies within a
half-open interval centered on zero.  The results are specified by
</p>
<a name="node_eqn_Temp_19"></a>
<div align=left><table width=100%>
<tr><td align=right>
<em>x</em><sub>1</sub>&nbsp;<em>d</em><em>i</em><em>v</em><sub>0</sub>&nbsp;<em>x</em><sub>2</sub> </td><td align=center width=2%> = </td><td> <em>n</em><sub><em>d</em></sub></td></tr>
<tr><td align=right><em>x</em><sub>1</sub>&nbsp;<em>m</em><em>o</em><em>d</em><sub>0</sub>&nbsp;<em>x</em><sub>2</sub> </td><td align=center width=2%> = </td><td> <em>x</em><sub><em>m</em></sub>
</td></tr>
</table></div><p>*
where:
</p>
<div align=left><img src="r6rs-Z-G-3.gif" border="0" alt="[r6rs-Z-G-3.gif]"></div><p>
Examples:
</p>
<a name="node_eqn_Temp_20"></a>
<div align=left><table width=100%>
<tr><td align=right>
123&nbsp;<em>d</em><em>i</em><em>v</em><sub>0</sub>&nbsp;10    </td><td align=center width=2%> = </td><td>  12</td></tr>
<tr><td align=right>123&nbsp;<em>m</em><em>o</em><em>d</em><sub>0</sub>&nbsp;10    </td><td align=center width=2%> = </td><td>  3</td></tr>
<tr><td align=right>123&nbsp;<em>d</em><em>i</em><em>v</em><sub>0</sub>&nbsp; <tt>-</tt> 10   </td><td align=center width=2%> = </td><td>   <tt>-</tt> 12</td></tr>
<tr><td align=right>123&nbsp;<em>m</em><em>o</em><em>d</em><sub>0</sub>&nbsp; <tt>-</tt> 10   </td><td align=center width=2%> = </td><td>  3</td></tr>
<tr><td align=right> <tt>-</tt> 123&nbsp;<em>d</em><em>i</em><em>v</em><sub>0</sub>&nbsp;10    </td><td align=center width=2%> = </td><td>   <tt>-</tt> 12</td></tr>
<tr><td align=right> <tt>-</tt> 123&nbsp;<em>m</em><em>o</em><em>d</em><sub>0</sub>&nbsp;10    </td><td align=center width=2%> = </td><td>   <tt>-</tt> 3</td></tr>
<tr><td align=right> <tt>-</tt> 123&nbsp;<em>d</em><em>i</em><em>v</em><sub>0</sub>&nbsp; <tt>-</tt> 10   </td><td align=center width=2%> = </td><td>  12</td></tr>
<tr><td align=right> <tt>-</tt> 123&nbsp;<em>m</em><em>o</em><em>d</em><sub>0</sub>&nbsp; <tt>-</tt> 10   </td><td align=center width=2%> = </td><td>   <tt>-</tt> 3
</td></tr>
</table></div><p>*</p>
<p>
</p>
<a name="node_sec_11.7.3.2"></a>
<h4 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.7.3.2">11.7.3.2&nbsp;&nbsp;Transcendental functions</a></h4>
<p></p>
<p>
In general, the transcendental functions log, sin<sup><tt>-</tt>1</sup>
(arcsine), cos<sup><tt>-</tt>1</sup> (arccosine), and tan<sup><tt>-</tt>1</sup> are multiply
defined.  The value of log <em>z</em> is defined to be the one whose
imaginary part lies in the range from  <tt>-</tt> <img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"> (inclusive if  <tt>-</tt> 0.0 is
distinguished, exclusive otherwise) to <img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"> (inclusive).  log 0 is
undefined.</p>
<p>
The value of log <em>z</em> for non-real <em>z</em> is defined in terms of log on real numbers as </p>
<p>
</p>
<div align=left><img src="r6rs-Z-G-4.gif" border="0" alt="[r6rs-Z-G-4.gif]"></div><p>
where <em>a</em><em>n</em><em>g</em><em>l</em><em>e</em>&nbsp;<em>z</em> is the angle of <em>z</em>  =  <em>a</em> &middot;  <em>e</em><sup><em>i</em><em>b</em></sup> specified
as:
</p>
<div class=mathdisplay align=left><table><tr><td><em>a</em><em>n</em><em>g</em><em>l</em><em>e</em>&nbsp;<em>z</em>  =  <em>b</em> + 2<img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"> <em>n</em></td></tr></table></div>
<p class=noindent>
with  <tt>-</tt> <img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"> &le; <em>a</em><em>n</em><em>g</em><em>l</em><em>e</em>&nbsp;<em>z</em>&le; <img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"> and <em>a</em><em>n</em><em>g</em><em>l</em><em>e</em>&nbsp;<em>z</em>  = 
<em>b</em> + 2<img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"> <em>n</em> for some integer <em>n</em>.</p>
<p>
With the one-argument version of log defined this way, the values
of the two-argument-version of log, sin<sup><tt>-</tt>1</sup> <em>z</em>, cos<sup><tt>-</tt>1</sup> <em>z</em>,
tan<sup><tt>-</tt>1</sup> <em>z</em>, and the two-argument version of tan<sup><tt>-</tt>1</sup> are
according to the following formul&aelig;:
</p>
<a name="node_eqn_Temp_21"></a>
<div align=left><table width=100%>
<tr><td align=right>
log <em>z</em>&nbsp;<em>b</em> </td><td align=center width=2%> = </td><td> (log <em>z</em>/log <em>b</em>)</td></tr>
<tr><td align=right>sin<sup><tt>-</tt>1</sup> <em>z</em> </td><td align=center width=2%> = </td><td>  <tt>-</tt> <em>i</em> log (<em>i</em> <em>z</em>  +  (1  <tt>-</tt>  <em>z</em><sup>2</sup>)<sup>1/2</sup>)</td></tr>
<tr><td align=right>cos<sup><tt>-</tt>1</sup> <em>z</em> </td><td align=center width=2%> = </td><td> <img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"> / 2  <tt>-</tt>  sin<sup><tt>-</tt>1</sup> <em>z</em></td></tr>
<tr><td align=right>tan<sup><tt>-</tt>1</sup> <em>z</em> </td><td align=center width=2%> = </td><td> (log (1  +  <em>i</em> <em>z</em>)  <tt>-</tt>  log (1  <tt>-</tt>  <em>i</em> <em>z</em>)) / (2 <em>i</em>)</td></tr>
<tr><td align=right>tan<sup><tt>-</tt>1</sup> <em>x</em>&nbsp;<em>y</em> </td><td align=center width=2%> = </td><td> <em>a</em><em>n</em><em>g</em><em>l</em><em>e</em>(<em>x</em> +  <em>y</em><em>i</em>)
</td></tr>
</table></div><p>*</p>
<p>
The range of tan<sup><tt>-</tt>1</sup> <em>x</em>&nbsp;<em>y</em> is as in the following table. The
asterisk (*) indicates that the entry applies to implementations that
distinguish minus zero.</p>
<p>
</p>
<div align=center><table><tr><td>

<table border=0><tr><td valign=top ></td><td valign=top ><em>y</em> condition </td><td valign=top ><em>x</em> condition </td><td valign=top >range of result <em>r</em></td></tr>
<tr><td valign=top ></td><td valign=top ><em>y</em>  =  0.0 </td><td valign=top ><em>x</em> &gt; 0.0 </td><td valign=top >0.0</td></tr>
<tr><td valign=top >&lowast; </td><td valign=top ><em>y</em>  =   + 0.0  </td><td valign=top ><em>x</em> &gt; 0.0 </td><td valign=top > + 0.0</td></tr>
<tr><td valign=top >&lowast; </td><td valign=top ><em>y</em>  =   <tt>-</tt> 0.0 </td><td valign=top ><em>x</em> &gt; 0.0 </td><td valign=top > <tt>-</tt> 0.0</td></tr>
<tr><td valign=top ></td><td valign=top ><em>y</em> &gt; 0.0 </td><td valign=top ><em>x</em> &gt; 0.0 </td><td valign=top >0.0 &lt; <em>r</em> &lt; (<img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]">/2)</td></tr>
<tr><td valign=top ></td><td valign=top ><em>y</em> &gt; 0.0 </td><td valign=top ><em>x</em>  =  0.0 </td><td valign=top >(<img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]">/2)</td></tr>
<tr><td valign=top ></td><td valign=top ><em>y</em> &gt; 0.0 </td><td valign=top ><em>x</em> &lt; 0.0 </td><td valign=top >(<img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]">/2) &lt; <em>r</em> &lt; <img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"></td></tr>
<tr><td valign=top ></td><td valign=top ><em>y</em>  =  0.0 </td><td valign=top ><em>x</em> &lt; 0 </td><td valign=top ><img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"></td></tr>
<tr><td valign=top >&lowast; </td><td valign=top ><em>y</em>  =   + 0.0 </td><td valign=top ><em>x</em> &lt; 0.0 </td><td valign=top ><img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"></td></tr>
<tr><td valign=top >&lowast; </td><td valign=top ><em>y</em>  =   <tt>-</tt> 0.0 </td><td valign=top ><em>x</em> &lt; 0.0 </td><td valign=top > <tt>-</tt> <img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"></td></tr>
<tr><td valign=top ></td><td valign=top ><em>y</em> &lt; 0.0 </td><td valign=top ><em>x</em> &lt; 0.0 </td><td valign=top > <tt>-</tt> <img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]">&lt; <em>r</em>&lt;  <tt>-</tt> (<img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]">/2)</td></tr>
<tr><td valign=top ></td><td valign=top ><em>y</em> &lt; 0.0 </td><td valign=top ><em>x</em>  =  0.0 </td><td valign=top > <tt>-</tt> (<img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]">/2)</td></tr>
<tr><td valign=top ></td><td valign=top ><em>y</em> &lt; 0.0 </td><td valign=top ><em>x</em> &gt; 0.0 </td><td valign=top > <tt>-</tt> (<img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]">/2) &lt; <em>r</em>&lt; 0.0</td></tr>
<tr><td valign=top ></td><td valign=top ><em>y</em>  =  0.0 </td><td valign=top ><em>x</em>  =  0.0 </td><td valign=top >undefined</td></tr>
<tr><td valign=top >&lowast;</td><td valign=top ><em>y</em>  =   + 0.0 </td><td valign=top ><em>x</em>  =   + 0.0 </td><td valign=top > + 0.0</td></tr>
<tr><td valign=top >&lowast;</td><td valign=top ><em>y</em>  =   <tt>-</tt> 0.0 </td><td valign=top ><em>x</em>  =   + 0.0</td><td valign=top > <tt>-</tt> 0.0</td></tr>
<tr><td valign=top >&lowast;</td><td valign=top ><em>y</em>  =   + 0.0 </td><td valign=top ><em>x</em>  =   <tt>-</tt> 0.0 </td><td valign=top ><img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"></td></tr>
<tr><td valign=top >&lowast;</td><td valign=top ><em>y</em>  =   <tt>-</tt> 0.0 </td><td valign=top ><em>x</em>  =   <tt>-</tt> 0.0 </td><td valign=top > <tt>-</tt> <img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"></td></tr>
<tr><td valign=top >&lowast;</td><td valign=top ><em>y</em>  =   + 0.0 </td><td valign=top ><em>x</em>  =  0 </td><td valign=top >(<img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]">/2)</td></tr>
<tr><td valign=top >&lowast;</td><td valign=top ><em>y</em>  =   <tt>-</tt> 0.0 </td><td valign=top ><em>x</em>  =  0    </td><td valign=top > <tt>-</tt> (<img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]">/2)
</td></tr></table>
</td></tr></table></div>
<p>
</p>
<a name="node_sec_11.7.4"></a>
<h3 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.7.4">11.7.4&nbsp;&nbsp;Numerical operations</a></h3>
<p></p>
<a name="node_sec_11.7.4.1"></a>
<h4 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.7.4.1">11.7.4.1&nbsp;&nbsp;Numerical type predicates</a></h4>
<p></p>
<p></p>
<div align=left><tt>(<a name="node_idx_440"></a>number?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_442"></a>complex?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_444"></a>real?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_446"></a>rational?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_448"></a>integer?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These numerical type predicates can be applied to any kind of
argument.  They return <tt>#t</tt> if the object is a number object
of the named type, and <tt>#f</tt> otherwise.
In general, if a type predicate is true of a number object then all higher
type predicates are also true of that number object.  Consequently, if a type
predicate is false of a number object, then all lower type predicates are
also false of that number object.</p>
<p>
If <i>z</i> is a complex number object, then <tt>(real? <i>z</i>)</tt> is true if
and only if <tt>(zero? (imag-part <i>z</i>))</tt> and <tt>(exact?
(imag-part <i>z</i>))</tt> are both true.</p>
<p>
If <i>x</i> is a real number object, then <tt>(rational? <i>x</i>)</tt> is true if
and only if there exist exact integer objects <i>k<sub>1</sub></i> and <i>k<sub>2</sub></i> such that
<tt>(= <i>x</i> (/ <i>k<sub>1</sub></i> <i>k<sub>2</sub></i>))</tt> and <tt>(= (numerator
<i>x</i>) <i>k<sub>1</sub></i>)</tt> and <tt>(= (denominator <i>x</i>) <i>k<sub>2</sub></i>)</tt> are
all true.  Thus infinities and NaNs are not rational number objects.</p>
<p>
If <i>q</i> is a rational number objects, then <tt>(integer?
<i>q</i>)</tt> is true if and only if <tt>(= (denominator
<i>q</i>) 1)</tt> is true.  If <i>q</i> is not a rational number object,
then <tt>(integer? <i>q</i>)</tt> is <tt>#f</tt>.</p>
<p>
</p>

<tt>(complex?&nbsp;3+4i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(complex?&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real?&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real?&nbsp;-2.5+0.0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(real?&nbsp;-2.5+0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real?&nbsp;-2.5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real?&nbsp;<tt>#</tt>e1e10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(rational?&nbsp;6/10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(rational?&nbsp;6/3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(rational?&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(integer?&nbsp;3+0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(integer?&nbsp;3.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(integer?&nbsp;8/4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
<br>
(number?&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(complex?&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real?&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(rational?&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(complex?&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real?&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(rational?&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(integer?&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><p></tt></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
Except for <tt>number?</tt>, the behavior of these type predicates
on inexact number objects is
unreliable, because any inaccuracy may
affect the result.
</blockquote>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_450"></a>real-valued?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_452"></a>rational-valued?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_454"></a>integer-valued?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These numerical type predicates can be applied to any kind of
argument.  The <tt>real-valued?</tt> procedure
returns <tt>#t</tt> if the object is a number object and is equal in the
sense of <tt>=</tt> to some real number object, or if the object is a NaN, or a
complex number object whose real part is a NaN and whose imaginary
part is zero
in the sense of <tt>zero?</tt>.  The <tt>rational-valued?</tt> and <tt>integer-valued?</tt> procedures return <tt>#t</tt> if the object is a
number object and is equal in the sense of <tt>=</tt> to some object of the
named type, and otherwise they return <tt>#f</tt>.</p>
<p>
</p>

<tt>(real-valued?&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real-valued?&nbsp;+nan.0+0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real-valued?&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real-valued?&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real-valued?&nbsp;-2.5+0.0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real-valued?&nbsp;-2.5+0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real-valued?&nbsp;-2.5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(real-valued?&nbsp;<tt>#</tt>e1e10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
<br>
(rational-valued?&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(rational-valued?&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(rational-valued?&nbsp;6/10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(rational-valued?&nbsp;6/10+0.0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(rational-valued?&nbsp;6/10+0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(rational-valued?&nbsp;6/3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
<br>
(integer-valued?&nbsp;3+0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(integer-valued?&nbsp;3+0.0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(integer-valued?&nbsp;3.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(integer-valued?&nbsp;3.0+0.0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(integer-valued?&nbsp;8/4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><p></tt></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
These procedures test whether a given number object can be coerced
to the specified type without loss of numerical accuracy.
Specifically, the behavior of these predicates differs from the
behavior of <tt>real?</tt>, <tt>rational?</tt>, and <tt>integer?</tt> on
complex number objects whose imaginary part is inexact zero.
</blockquote><p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
The behavior of these type predicates on inexact number objects is
unreliable, because any inaccuracy may
affect the result.
</blockquote>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_456"></a>exact?<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_458"></a>inexact?<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These numerical predicates provide tests for the exactness of a
quantity.  For any number object, precisely one of these predicates is
true.</p>
<p>
</p>

<tt>(exact?&nbsp;5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(inexact?&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><p></tt>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.7.4.2"></a>
<h4 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.7.4.2">11.7.4.2&nbsp;&nbsp;Generic conversions</a></h4>
<p></p>
<p></p>
<div align=left><tt>(<a name="node_idx_460"></a>inexact<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_462"></a>exact<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <tt>inexact</tt> procedure returns an inexact representation of <i>z</i>.  If
inexact number objects of the appropriate type have bounded precision, then
the value returned is an inexact number object that is nearest to the
argument.  If an exact argument has no reasonably close inexact
equivalent, an exception with condition type
<tt>&amp;implementation-violation</tt> may be
raised.</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
For a real number object whose magnitude is finite but so large that it has
no reasonable finite approximation as an inexact number, a
reasonably close inexact equivalent may be <tt>+inf.0</tt> or <tt>-inf.0</tt>.  Similarly, the inexact representation of a complex
number object whose components are finite may have infinite components.
</blockquote><p>
The <tt>exact</tt> procedure returns an exact representation of <i>z</i>.  The value
returned is the exact number object that is numerically closest to the
argument; in most cases, the result of this procedure should be
numerically equal to its argument.  If an inexact argument has no
reasonably close exact equivalent, an exception with condition type
<tt>&amp;implementation-violation</tt> may be
raised.</p>
<p>
These procedures implement the natural one-to-one correspondence
between exact and inexact integer objects throughout an
implementation-dependent range.</p>
<p>
The <tt>inexact</tt> and <tt>exact</tt> procedures are idempotent.
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.7.4.3"></a>
<h4 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.7.4.3">11.7.4.3&nbsp;&nbsp;Arithmetic operations</a></h4>
<p></p>
<p></p>
<div align=left><tt>(<a name="node_idx_464"></a>=<i> <i>z<sub>1</sub></i> <i>z<sub>2</sub></i> <i>z<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_466"></a>&lt;<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i> <i>x<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_468"></a>&gt;<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i> <i>x<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_470"></a>&lt;=<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i> <i>x<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_472"></a>&gt;=<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i> <i>x<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These procedures return <tt>#t</tt> if their arguments are
(respectively): equal, monotonically increasing, monotonically
decreasing, monotonically nondecreasing, or monotonically
nonincreasing, and <tt>#f</tt> otherwise.</p>
<p>
</p>

<tt>(=&nbsp;+inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(=&nbsp;-inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(=&nbsp;-inf.0&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><p></tt></p>
<p>
For any real number object <i>x</i> that is neither infinite nor NaN:</p>
<p>
</p>

<tt>(&lt;&nbsp;-inf.0&nbsp;<i>x</i>&nbsp;+inf.0))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(&gt;&nbsp;+inf.0&nbsp;<i>x</i>&nbsp;-inf.0))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><p></tt></p>
<p>
For any number object <i>z</i>:
</p>

<tt>(=&nbsp;+nan.0&nbsp;<i>z</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><p></tt>
For any real number object <i>x</i>:
</p>

<tt>(&lt;&nbsp;+nan.0&nbsp;<i>x</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(&gt;&nbsp;+nan.0&nbsp;<i>x</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><p></tt></p>
<p>
These predicates must be transitive.</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
The traditional implementations of these predicates in Lisp-like
languages are not transitive.
</blockquote><p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
While it is possible to compare inexact number objects using these
predicates, the results may be unreliable because a small inaccuracy
may affect the result; this is especially true of <tt>=</tt> and <tt>zero?</tt> (below).<p>
When in doubt, consult a numerical analyst.
</p>
</blockquote>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_474"></a>zero?<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_476"></a>positive?<i> x</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_478"></a>negative?<i> x</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_480"></a>odd?<i> n</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_482"></a>even?<i> n</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_484"></a>finite?<i> x</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_486"></a>infinite?<i> x</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_488"></a>nan?<i> x</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These numerical predicates test a number object for a particular property,
returning <tt>#t</tt> or <tt>#f</tt>.  The <tt>zero?</tt>
procedure
tests if the number object is <tt>=</tt> to zero, <tt>positive?</tt> tests whether it is
greater than zero, <tt>negative?</tt> tests whether it is less than zero, <tt>odd?</tt> tests whether it is odd, <tt>even?</tt> tests whether it is even, <tt>finite?</tt> tests whether it is not an infinity and not a NaN, <tt>infinite?</tt> tests whether it is an infinity, <tt>nan?</tt> tests whether it is a
NaN.</p>
<p>
</p>

<tt>(zero?&nbsp;+0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(zero?&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(zero?&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(positive?&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(negative?&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(positive?&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(negative?&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(finite?&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(finite?&nbsp;5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(finite?&nbsp;5.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(infinite?&nbsp;5.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(infinite?&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><p></tt></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
As with the predicates above, the results may be unreliable because
a small inaccuracy may affect the result.
</blockquote>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_490"></a>max<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_492"></a>min<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These procedures return the maximum or minimum of their arguments.</p>
<p>
</p>

<tt>(max&nbsp;3&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;4<br>
(max&nbsp;3.9&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;4.0<p></tt></p>
<p>
For any real number object <i>x</i>:</p>
<p>
</p>

<tt>(max&nbsp;+inf.0&nbsp;<i>x</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<br>
(min&nbsp;-inf.0&nbsp;<i>x</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-inf.0<p></tt></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
If any argument is inexact, then the result is also inexact (unless
the procedure can prove that the inaccuracy is not large enough to affect the
result, which is possible only in unusual implementations).  If <tt>min</tt> or
<tt>max</tt> is used to compare number objects of mixed exactness, and the numerical
value of the result cannot be represented as an inexact number object without loss of
accuracy, then the procedure may raise an exception with condition
type <tt>&amp;implementation-restriction</tt>.
</blockquote><p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_494"></a>+<i> <i>z<sub>1</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_496"></a>*<i> <i>z<sub>1</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These procedures return the sum or product of their arguments.</p>
<p>
</p>

<tt>(+&nbsp;3&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;7<br>
(+&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;3<br>
(+)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0<br>
(+&nbsp;+inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<br>
(+&nbsp;+inf.0&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+nan.0<br>
<br>
(*&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;4<br>
(*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;1<br>
(*&nbsp;5&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<br>
(*&nbsp;-5&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-inf.0<br>
(*&nbsp;+inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<br>
(*&nbsp;+inf.0&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-inf.0<br>
(*&nbsp;0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0&nbsp;<i>or</i>&nbsp;+nan.0<br>
(*&nbsp;0&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0&nbsp;<i>or</i>&nbsp;+nan.0<br>
(*&nbsp;1.0&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0&nbsp;<i>or</i>&nbsp;0.0<p></tt></p>
<p>
For any real number object <i>x</i> that is neither infinite nor NaN:</p>
<p>
</p>

<tt>(+&nbsp;+inf.0&nbsp;<i>x</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<br>
(+&nbsp;-inf.0&nbsp;<i>x</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-inf.0<p></tt></p>
<p>
For any real number object <i>x</i>:</p>
<p>
</p>

<tt>(+&nbsp;+nan.0&nbsp;<i>x</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+nan.0<p></tt></p>
<p>
For any real number object <i>x</i> that is not an exact 0:</p>
<p>
</p>

<tt>(*&nbsp;+nan.0&nbsp;<i>x</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+nan.0<p></tt></p>
<p>
If any of these procedures are applied to mixed non-rational real and
non-real complex arguments, they either raise an exception with
condition type <tt>&amp;implementation-restriction</tt> or return an
unspecified number object.</p>
<p>
Implementations that distinguish  <tt>-</tt> 0.0 should adopt behavior
consistent with the following examples:</p>
<p>
</p>

<tt>(+&nbsp;0.0&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0.0<br>
(+&nbsp;-0.0&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0.0<br>
(+&nbsp;0.0&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0.0<br>
(+&nbsp;-0.0&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;-0.0<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_498"></a>-<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_500"></a>-<i> <i>z<sub>1</sub></i> <i>z<sub>2</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
With two or more arguments, this procedures returns the difference of
its arguments, associating to the left.  With one argument, however,
it returns the additive inverse of its argument.</p>
<p>
</p>

<tt>(-&nbsp;3&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-1<br>
(-&nbsp;3&nbsp;4&nbsp;5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-6<br>
(-&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-3<br>
(-&nbsp;+inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+nan.0<p></tt></p>
<p>
If this procedure is applied to mixed non-rational real and
non-real complex arguments, it either raises an exception with
condition type <tt>&amp;implementation-restriction</tt> or returns an
unspecified number object.</p>
<p>
Implementations that distinguish  <tt>-</tt> 0.0 should adopt behavior
consistent with the following examples:</p>
<p>
</p>

<tt>(-&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;-0.0<br>
(-&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0.0<br>
(-&nbsp;0.0&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0.0<br>
(-&nbsp;-0.0&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;-0.0<br>
(-&nbsp;0.0&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0.0<br>
(-&nbsp;-0.0&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0.0<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_502"></a>/<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_504"></a>/<i> <i>z<sub>1</sub></i> <i>z<sub>2</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
If all of the arguments are exact, then the divisors must all
be nonzero.
With two or more arguments, this procedure returns the 
quotient of its arguments, associating to the left.  With one
argument, however, it returns the multiplicative inverse
of its argument.</p>
<p>
</p>

<tt>(/&nbsp;3&nbsp;4&nbsp;5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;3/20<br>
(/&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;1/3<br>
(/&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<br>
(/&nbsp;1.0&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<br>
(/&nbsp;-1&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-inf.0<br>
(/&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0.0<br>
(/&nbsp;0&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>&nbsp;&amp;assertion</tt>&nbsp;<i>exception</i><br>
(/&nbsp;3&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>&nbsp;&amp;assertion</tt>&nbsp;<i>exception</i><br>
(/&nbsp;0&nbsp;3.5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0.0<br>
(/&nbsp;0&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+nan.0<br>
(/&nbsp;0.0&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+nan.0<br>
(/&nbsp;0.0&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+nan.0<p></tt></p>
<p>
If this procedure is applied to mixed non-rational real and
non-real complex arguments, it either raises an exception with
condition type <tt>&amp;implementation-restriction</tt> or returns an
unspecified number object.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_506"></a>abs<i> x</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns the absolute value of its argument.</p>
<p>
</p>

<tt>(abs&nbsp;-7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;7<br>
(abs&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_508"></a>div-and-mod<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_510"></a>div<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_512"></a>mod<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_514"></a>div0-and-mod0<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_516"></a>div0<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_518"></a>mod0<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These procedures implement number-theoretic integer division and
return the results of the corresponding mathematical operations
specified in section&nbsp;<a href="#node_sec_11.7.3.1">11.7.3.1</a>.  In each case, <i>x<sub>1</sub></i>
must be neither infinite nor a NaN, and <i>x<sub>2</sub></i> must be nonzero;
otherwise, an exception with condition type <tt>&amp;assertion</tt> is raised.</p>
<p>
</p>

<tt>(div&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<i>x<sub>1</sub></i>&nbsp;<em>d</em><em>i</em><em>v</em>&nbsp;<i>x<sub>2</sub></i><br>
(mod&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<i>x<sub>1</sub></i>&nbsp;<em>m</em><em>o</em><em>d</em>&nbsp;<i>x<sub>2</sub></i><br>
(div-and-mod&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<i>x<sub>1</sub></i>&nbsp;<em>d</em><em>i</em><em>v</em>&nbsp;<i>x<sub>2</sub></i>,&nbsp;<i>x<sub>1</sub></i>&nbsp;<em>m</em><em>o</em><em>d</em>&nbsp;<i>x<sub>2</sub></i><br>
;&nbsp;two&nbsp;return&nbsp;values<br>
(div0&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<i>x<sub>1</sub></i>&nbsp;<em>d</em><em>i</em><em>v</em><sub>0</sub>&nbsp;<i>x<sub>2</sub></i><br>
(mod0&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<i>x<sub>1</sub></i>&nbsp;<em>m</em><em>o</em><em>d</em><sub>0</sub>&nbsp;<i>x<sub>2</sub></i><br>
(div0-and-mod0&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<i>x<sub>1</sub></i>&nbsp;<em>d</em><em>i</em><em>v</em><sub>0</sub>&nbsp;<i>x<sub>2</sub></i>,&nbsp;<i>x<sub>1</sub></i>&nbsp;<em>m</em><em>o</em><em>d</em><sub>0</sub>&nbsp;<i>x<sub>2</sub></i><br>
;&nbsp;two&nbsp;return&nbsp;values<p></tt></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_520"></a>gcd<i> <i>n<sub>1</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_522"></a>lcm<i> <i>n<sub>1</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non-negative.</p>
<p>
</p>

<tt>(gcd&nbsp;32&nbsp;-36)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;4<br>
(gcd)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0<br>
(lcm&nbsp;32&nbsp;-36)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;288<br>
(lcm&nbsp;32.0&nbsp;-36)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;288.0<br>
(lcm)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;1<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_524"></a>numerator<i> q</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_526"></a>denominator<i> q</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These procedures return the numerator or denominator of their
argument; the result is computed as if the argument was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0 is defined to be 1.</p>
<p>
</p>

<tt>(numerator&nbsp;(/&nbsp;6&nbsp;4))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;3<br>
(denominator&nbsp;(/&nbsp;6&nbsp;4))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;2<br>
(denominator<br>
&nbsp;&nbsp;(inexact&nbsp;(/&nbsp;6&nbsp;4)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;2.0<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_528"></a>floor<i> x</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_530"></a>ceiling<i> x</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_532"></a>truncate<i> x</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_534"></a>round<i> x</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These procedures return inexact integer objects for inexact arguments that are
not infinities or NaNs, and exact integer objects for exact rational
arguments.  For such arguments, <tt>floor</tt> returns the largest
integer object not larger than <i>x</i>.  The <tt>ceiling</tt> procedure returns the smallest
integer object not smaller than <i>x</i>.  The <tt>truncate</tt> procedure returns the integer
object closest to <i>x</i> whose absolute value is not larger than the
absolute value of <i>x</i>.  The <tt>round</tt> procedure returns the
closest integer object to
<i>x</i>, rounding to even when <i>x</i> represents a number halfway between two
integers.</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
If the argument to one of these procedures is inexact, then the result
is also inexact.  If an exact value is needed, the
result should be passed to the <tt>exact</tt> procedure.
</blockquote><p>
Although infinities and NaNs are not integer objects, these procedures return
an infinity when given an infinity as an argument, and a NaN when
given a NaN.</p>
<p>
</p>

<tt>(floor&nbsp;-4.3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-5.0<br>
(ceiling&nbsp;-4.3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-4.0<br>
(truncate&nbsp;-4.3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-4.0<br>
(round&nbsp;-4.3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-4.0<br>
<br>
(floor&nbsp;3.5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;3.0<br>
(ceiling&nbsp;3.5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;4.0<br>
(truncate&nbsp;3.5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;3.0<br>
(round&nbsp;3.5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;4.0<br>
<br>
(round&nbsp;7/2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;4<br>
(round&nbsp;7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;7<br>
<br>
(floor&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<br>
(ceiling&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-inf.0<br>
(round&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+nan.0<p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_536"></a>rationalize<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <tt>rationalize</tt> procedure returns the a number object
representing the <em>simplest</em> rational
number differing from <i>x<sub>1</sub></i> by no more than <i>x<sub>2</sub></i>.    A rational number <em>r</em><sub>1</sub> is
<em>simpler</em> <a name="node_idx_538"></a>than another rational number
<em>r</em><sub>2</sub> if <em>r</em><sub>1</sub>  =  <em>p</em><sub>1</sub>/<em>q</em><sub>1</sub> and <em>r</em><sub>2</sub>  =  <em>p</em><sub>2</sub>/<em>q</em><sub>2</sub> (in lowest terms) and |<em>p</em><sub>1</sub>|
&le; |<em>p</em><sub>2</sub>| and |<em>q</em><sub>1</sub>| &le; |<em>q</em><sub>2</sub>|.  Thus 3/5 is simpler than 4/7.
Although not all rationals are comparable in this ordering (consider 2/7
and 3/5) any interval contains a rational number that is simpler than
every other rational number in that interval (the simpler 2/5 lies
between 2/7 and 3/5).  Note that 0  =  0/1 is the simplest rational of
all.
</p>

<tt>(rationalize&nbsp;(exact&nbsp;.3)&nbsp;1/10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;1/3<br>
(rationalize&nbsp;.3&nbsp;1/10)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<tt>#</tt>i1/3&nbsp;&nbsp;;&nbsp;approximately<br>
<br>
(rationalize&nbsp;+inf.0&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<br>
(rationalize&nbsp;+inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+nan.0<br>
(rationalize&nbsp;3&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0.0<p></tt>
The first two examples hold only in implementations whose inexact real
number objects have sufficient precision.</p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_540"></a>exp<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_542"></a>log<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_544"></a>log<i> <i>z<sub>1</sub></i> <i>z<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_546"></a>sin<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_548"></a>cos<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_550"></a>tan<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_552"></a>asin<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_554"></a>acos<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_556"></a>atan<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_558"></a>atan<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These procedures compute the usual transcendental functions.  The <tt>exp</tt> procedure computes the base-<em>e</em> exponential of <i>z</i>. 
The <tt>log</tt> procedure with a single argument computes the natural logarithm of
<i>z</i> (not the base-ten logarithm); <tt>(log <i>z<sub>1</sub></i>
<i>z<sub>2</sub></i>)</tt> computes the base-<i>z<sub>2</sub></i> logarithm of <i>z<sub>1</sub></i>.
The <tt>asin</tt>, <tt>acos</tt>, and <tt>atan</tt> procedures compute arcsine,
arccosine, and arctangent, respectively.  The two-argument variant of
<tt>atan</tt> computes <tt>(angle (make-rectangular <i>x<sub>2</sub></i>
<i>x<sub>1</sub></i>))</tt>.</p>
<p>
See section&nbsp;<a href="#node_sec_11.7.3.2">11.7.3.2</a> for the underlying
mathematical operations. These procedures may return inexact results
even when given exact arguments.</p>
<p>
</p>

<tt>(exp&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;+inf.0<br>
(exp&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0.0<br>
(log&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;+inf.0<br>
(log&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;-inf.0<br>
(log&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>&nbsp;&amp;assertion</tt>&nbsp;<i>exception</i><br>
(log&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;+inf.0+3.141592653589793i<br>
&nbsp;;&nbsp;approximately<br>
(atan&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;-1.5707963267948965&nbsp;;&nbsp;approximately<br>
(atan&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;1.5707963267948965&nbsp;;&nbsp;approximately<br>
(log&nbsp;-1.0+0.0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0.0+3.141592653589793i&nbsp;;&nbsp;approximately<br>
(log&nbsp;-1.0-0.0i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0.0-3.141592653589793i&nbsp;;&nbsp;approximately<br>
;&nbsp;if&nbsp;-0.0&nbsp;is&nbsp;distinguished<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_560"></a>sqrt<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns the principal square root of <i>z</i>.  For rational <i>z</i>,
the result has either positive real part, or zero real part and
non-negative imaginary part.  With log defined as in
section&nbsp;<a href="#node_sec_11.7.3.2">11.7.3.2</a>, the value of <tt>(sqrt
<i>z</i>)</tt> could be expressed as <em>e</em><sup>(log <em>z</em>/2)</sup>.</p>
<p>
The <tt>sqrt</tt> procedure may return an inexact result even when given an exact
argument.</p>
<p>
</p>

<tt>(sqrt&nbsp;-5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0.0+2.23606797749979i&nbsp;;&nbsp;approximately<br>
(sqrt&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<br>
(sqrt&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0i<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_562"></a>exact-integer-sqrt<i> k</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <tt>exact-integer-sqrt</tt> procedure returns two non-negative exact
integer objects <em>s</em> and <em>r</em> where <i>k</i>  =  <em>s</em><sup>2</sup>  + 
<em>r</em> and <i>k</i> &lt; (<em>s</em> + 1)<sup>2</sup>.</p>
<p>
</p>

<tt>(exact-integer-sqrt&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;2&nbsp;0<br>
;&nbsp;two&nbsp;return&nbsp;values<br>
(exact-integer-sqrt&nbsp;5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;2&nbsp;1<br>
;&nbsp;two&nbsp;return&nbsp;values<br>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_564"></a>expt<i> <i>z<sub>1</sub></i> <i>z<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <i>z<sub>1</sub></i> raised to the power <i>z<sub>2</sub></i>.  For nonzero <i>z<sub>1</sub></i>,
this is <em>e</em><sup><em>z</em><sub>2</sub> log <em>z</em><sub>1</sub></sup>.
0.0<sup><em>z</em></sup> is 1.0 if <i>z</i>  =  0.0, and 0.0 if <tt>(real-part <i>z</i>)</tt> is positive.  For other cases in which
the first argument is zero, either an exception is raised with
condition type <tt>&amp;implementation-restriction</tt>, or an unspecified
number object is returned.</p>
<p>
For an exact real number object <i>z<sub>1</sub></i> and an exact
integer object <i>z<sub>2</sub></i>, <tt>(expt <i>z<sub>1</sub></i>
<i>z<sub>2</sub></i>)</tt> must return an exact result.  For all other
values of <i>z<sub>1</sub></i> and <i>z<sub>2</sub></i>, <tt>(expt <i>z<sub>1</sub></i>
<i>z<sub>2</sub></i>)</tt> may return an inexact result, even when both
<i>z<sub>1</sub></i> and <i>z<sub>2</sub></i> are exact.</p>
<p>
</p>

<tt>(expt&nbsp;5&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;125<br>
(expt&nbsp;5&nbsp;-3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;1/125<br>
(expt&nbsp;5&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;1<br>
(expt&nbsp;0&nbsp;5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0<br>
(expt&nbsp;0&nbsp;5+.0000312i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0<br>
(expt&nbsp;0&nbsp;-5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(expt&nbsp;0&nbsp;-5+.0000312i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
(expt&nbsp;0&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;1<br>
(expt&nbsp;0.0&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;1.0<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_566"></a>make-rectangular<i> <i>x<sub>1</sub></i> <i>x<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_568"></a>make-polar<i> <i>x<sub>3</sub></i> <i>x<sub>4</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_570"></a>real-part<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_572"></a>imag-part<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_574"></a>magnitude<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_576"></a>angle<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Suppose <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>3</sub>, and <em>a</em><sub>4</sub> are real
numbers, and <em>c</em> is a complex number such that the
following holds:
</p>
<div align=left><img src="r6rs-Z-G-5.gif" border="0" alt="[r6rs-Z-G-5.gif]"></div><p></p>
<p>
Then, if <i>x<sub>1</sub></i>, <i>x<sub>2</sub></i>, <i>x<sub>3</sub></i>, and <i>x<sub>4</sub></i> are number
objects representing <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>3</sub>, and <em>a</em><sub>4</sub>, respectively,
<tt>(make-rectangular <i>x<sub>1</sub></i> <i>x<sub>2</sub></i>)</tt> returns <em>c</em>, and <tt>(make-polar <i>x<sub>3</sub></i> <i>x<sub>4</sub></i>)</tt> returns <em>c</em>.
</p>

<tt>(make-rectangular&nbsp;1.1&nbsp;2.2)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;1.1+2.2i&nbsp;;&nbsp;approximately<br>
(make-polar&nbsp;1.1&nbsp;2.2)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;1.1@2.2&nbsp;;&nbsp;approximately<br>
<p></tt>
Conversely, if  <tt>-</tt> <img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]"> &le; <em>a</em><sub>4</sub> &le; <img src="r6rs-Z-G-D-3.gif" border="0" alt="[r6rs-Z-G-D-3.gif]">, and if <em>z</em> is a number object
representing <em>c</em>, then <tt>(real-part <i>z</i>)</tt> returns <em>a</em><sub>1</sub> <tt>(imag-part <i>z</i>)</tt> returns <em>a</em><sub>2</sub>, <tt>(magnitude <i>z</i>)</tt>
returns <em>a</em><sub>3</sub>, and <tt>(angle <i>z</i>)</tt> returns <em>a</em><sub>4</sub>.</p>
<p>
</p>

<tt>(real-part&nbsp;1.1+2.2i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;1.1&nbsp;;&nbsp;approximately<br>
(imag-part&nbsp;1.1+2.2i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;2.2i&nbsp;;&nbsp;approximately<br>
(magnitude&nbsp;1.1@2.2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;1.1&nbsp;;&nbsp;approximately<br>
(angle&nbsp;1.1@2.2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;2.2&nbsp;;&nbsp;approximately<br>
<br>
(angle&nbsp;-1.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;3.141592653589793&nbsp;;&nbsp;approximately<br>
(angle&nbsp;-1.0+0.0i)&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;3.141592653589793&nbsp;;&nbsp;approximately<br>
(angle&nbsp;-1.0-0.0i)&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;-3.141592653589793&nbsp;;&nbsp;approximately<br>
;&nbsp;if&nbsp;-0.0&nbsp;is&nbsp;distinguished<br>
(angle&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;0.0<br>
(angle&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;3.141592653589793&nbsp;;&nbsp;approximately<p></tt></p>
<p>
Moreover, suppose <i>x<sub>1</sub></i>, <i>x<sub>2</sub></i> are such that either <i>x<sub>1</sub></i>
or <i>x<sub>2</sub></i> is an infinity, then
</p>

<tt>(make-rectangular&nbsp;<i>x<sub>1</sub></i>&nbsp;<i>x<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<i>z</i><br>
(magnitude&nbsp;<i>z</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;+inf.0<p></tt>
</p>
<p></p>
<p>
The <tt>make-polar</tt>, <tt>magnitude</tt>, and
<tt>angle</tt> procedures may return inexact results even when given exact
arguments.</p>
<p>
</p>

<tt>(angle&nbsp;-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;3.141592653589793&nbsp;;&nbsp;approximately<br>
<p></tt>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.7.4.4"></a>
<h4 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.7.4.4">11.7.4.4&nbsp;&nbsp;Numerical Input and Output</a></h4>
<p></p>
<p></p>
<div align=left><tt>(<a name="node_idx_578"></a>number-&gt;string<i> z</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_580"></a>number-&gt;string<i> z radix</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_582"></a>number-&gt;string<i> z radix precision</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>Radix</i> must be an exact integer object, either 2, 8, 10, or 16.  If
omitted, <i>radix</i> defaults to 10.  If a <i>precision</i> is
specified, then <i>z</i> must be an inexact complex number object,
<i>precision</i> must be an exact positive integer object, and <i>radix</i>
must be 10.  The <tt>number-&gt;string</tt> procedure takes a number object and a
radix and returns as a string an external representation of the given
number object in the given radix such that
</p>

<tt>(let&nbsp;((number&nbsp;<i>z</i>)&nbsp;(radix&nbsp;<i>radix</i>))<br>
&nbsp;&nbsp;(eqv?&nbsp;(string-&gt;number<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(number-&gt;string&nbsp;number&nbsp;radix)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;radix)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number))<p></tt>
is true.  If no possible result makes this expression
true, an exception with condition type
<tt>&amp;implementation-restriction</tt> is raised.</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
The error case can occur only when <i>z</i> is not a complex number object
or is a complex number object with a non-rational real or imaginary part.
</blockquote><p>
If a <i>precision</i> is specified, then the representations of the
inexact real components of the result, unless they are infinite or
NaN, specify an explicit &lt;mantissa width&gt; <i>p</i>, and <i>p</i> is the
least <i>p</i> &ge; <i>precision</i> for which the above expression is
true.</p>
<p>
If <i>z</i> is inexact, the radix is 10, and the above expression and
condition can be satisfied by a result that contains a decimal point,
then the result contains a decimal point and is expressed using the
minimum number of digits (exclusive of exponent, trailing zeroes, and
mantissa width) needed to make the above expression and condition
true&nbsp;[<a href="r6rs-Z-H-21.html#node_bib_4">4</a>,&nbsp;<a href="r6rs-Z-H-21.html#node_bib_7">7</a>]; otherwise the format of the result
is unspecified.</p>
<p>
The result returned by <tt>number-&gt;string</tt> never contains an explicit
radix prefix.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_584"></a>string-&gt;number<i> string</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_586"></a>string-&gt;number<i> string radix</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns a number object with maximally precise representation expressed by the
given <i>string</i>.  <i>Radix</i> must be an exact integer object, either 2, 8, 10,
or 16.  If supplied, <i>radix</i> is a default radix that may be overridden
by an explicit radix prefix in <i>string</i> (e.g., <tt>&quot;#o177&quot;</tt>).  If <i>radix</i>
is not supplied, then the default radix is 10.  If <i>string</i> is not
a syntactically valid notation for a number object or a notation for a
rational number object with a zero denominator, then <tt>string-&gt;number</tt>
returns <tt>#f</tt>.
</p>

<tt>(string-&gt;number&nbsp;&quot;100&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;100<br>
(string-&gt;number&nbsp;&quot;100&quot;&nbsp;16)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;256<br>
(string-&gt;number&nbsp;&quot;1e2&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;100.0<br>
(string-&gt;number&nbsp;&quot;0/0&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(string-&gt;number&nbsp;&quot;+inf.0&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+inf.0<br>
(string-&gt;number&nbsp;&quot;-inf.0&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-inf.0<br>
(string-&gt;number&nbsp;&quot;+nan.0&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;+nan.0<p></tt></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
The <tt>string-&gt;number</tt> procedure always returns a number object or
<tt>#f</tt>; it never raises an exception.
</blockquote>
<p></p>
<p>
</p>
<a name="node_sec_11.8"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.8">11.8&nbsp;&nbsp;Booleans</a></h2>
<p></p>
<p>
The standard boolean objects for true and false have external representations
<tt>#t</tt> and <tt>#f</tt>.<a name="node_idx_588"></a><a name="node_idx_590"></a>However, of all
objects, only <tt>#f</tt> counts as false in
conditional expressions.  See section&nbsp;<a href="r6rs-Z-H-8.html#node_sec_5.7">5.7</a>.</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
Programmers accustomed to other dialects of Lisp should be aware that
Scheme distinguishes both <tt>#f</tt> and the empty list <a name="node_idx_592"></a>from each other and from the symbol <tt>nil</tt>.
</blockquote><p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_594"></a>not<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is <tt>#f</tt>, and returns
<tt>#f</tt> otherwise.</p>
<p>
</p>

<tt>(not&nbsp;<tt>#t</tt>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(not&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(not&nbsp;(list&nbsp;3))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(not&nbsp;<tt>#f</tt>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(not&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(not&nbsp;(list))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(not&nbsp;&#8217;nil)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_596"></a>boolean?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is either <tt>#t</tt> or
<tt>#f</tt> and returns <tt>#f</tt> otherwise.</p>
<p>
</p>

<tt>(boolean?&nbsp;<tt>#f</tt>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(boolean?&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(boolean?&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><p></tt></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_598"></a>boolean=?<i> <i>bool<sub>1</sub></i> <i>bool<sub>2</sub></i> <i>bool<sub>3</sub></i>
<tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if the booleans are the same.
</p>
<p></p>
<p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.9"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.9">11.9&nbsp;&nbsp;Pairs and lists</a></h2>
<p></p>
<p>
A <a name="node_idx_600"></a><em>pair</em> is a
compound structure with two fields called the car and cdr fields (for
historical reasons).  Pairs are created by the procedure <tt>cons</tt>.
The car and cdr fields are accessed by the procedures <tt>car</tt> and
<tt>cdr</tt>.</p>
<p>
Pairs are used primarily to represent lists.  A list can
be defined recursively as either the empty list<a name="node_idx_602"></a>or a pair whose
cdr is a list.  More precisely, the set of lists is defined as the smallest
set <i>X</i> such that</p>
<p>
</p>
<ul>
<li><p>The empty list is in <i>X</i>.
</p>
<li><p>If <i>list</i> is in <i>X</i>, then any pair whose cdr field contains
<i>list</i> is also in <i>X</i>.
</p>
</ul><p></p>
<p>
The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two-element list is a pair whose car
is the first element and whose cdr is a pair whose car is the second element
and whose cdr is the empty list.  The length of a list is the number of
elements, which is the same as the number of pairs.</p>
<p>
The empty list<a name="node_idx_604"></a>is a special object of its own type.
It is not a pair.  It has no elements and its length is zero.</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
The above definitions imply that all lists have finite length and are
terminated by the empty list.
</blockquote><p>
A chain of pairs not ending in the empty list is called an
<a name="node_idx_606"></a><em>improper list</em>.  Note that an improper list is not a list.
The list and dotted notations can be combined to represent
improper lists:</p>
<p>
</p>

<tt>(a&nbsp;b&nbsp;c&nbsp;.&nbsp;d)<p></tt></p>
<p>
is equivalent to</p>
<p>
</p>

<tt>(a&nbsp;.&nbsp;(b&nbsp;.&nbsp;(c&nbsp;.&nbsp;d)))<p></tt></p>
<p>
Whether a given pair is a list depends upon what is stored in the cdr
field.</p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_608"></a>pair?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is a pair, and otherwise
returns <tt>#f</tt>.</p>
<p>
</p>

<tt>(pair?&nbsp;&#8217;(a&nbsp;.&nbsp;b))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(pair?&nbsp;&#8217;(a&nbsp;b&nbsp;c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(pair?&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(pair?&nbsp;&#8217;#(a&nbsp;b))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_610"></a>cons<i> <i>obj<sub>1</sub></i> <i>obj<sub>2</sub></i></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns a newly allocated pair whose car is <i>obj<sub>1</sub></i> and whose cdr is
<i>obj<sub>2</sub></i>.  The pair is guaranteed to be different (in the sense of
<tt>eqv?</tt>) from every existing object.</p>
<p>
</p>

<tt>(cons&nbsp;&#8217;a&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(a)<br>
(cons&nbsp;&#8217;(a)&nbsp;&#8217;(b&nbsp;c&nbsp;d))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;((a)&nbsp;b&nbsp;c&nbsp;d)<br>
(cons&nbsp;&quot;a&quot;&nbsp;&#8217;(b&nbsp;c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(&quot;a&quot;&nbsp;b&nbsp;c)<br>
(cons&nbsp;&#8217;a&nbsp;3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(a&nbsp;.&nbsp;3)<br>
(cons&nbsp;&#8217;(a&nbsp;b)&nbsp;&#8217;c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;((a&nbsp;b)&nbsp;.&nbsp;c)<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_612"></a>car<i> pair</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns the contents of the car field of <i>pair</i>.</p>
<p>
</p>

<tt>(car&nbsp;&#8217;(a&nbsp;b&nbsp;c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;a<br>
(car&nbsp;&#8217;((a)&nbsp;b&nbsp;c&nbsp;d))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(a)<br>
(car&nbsp;&#8217;(1&nbsp;.&nbsp;2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;1<br>
(car&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>&nbsp;&amp;assertion</tt>&nbsp;<i>exception</i><p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_614"></a>cdr<i> pair</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns the contents of the cdr field of <i>pair</i>.</p>
<p>
</p>

<tt>(cdr&nbsp;&#8217;((a)&nbsp;b&nbsp;c&nbsp;d))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(b&nbsp;c&nbsp;d)<br>
(cdr&nbsp;&#8217;(1&nbsp;.&nbsp;2))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;2<br>
(cdr&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>&nbsp;&amp;assertion</tt>&nbsp;<i>exception</i><p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_616"></a>caar<i> pair</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_618"></a>cadr<i> pair</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<img src="r6rs-Z-G-D-1.gif" border="0" alt="[r6rs-Z-G-D-1.gif]"> <div align=left><tt>(<a name="node_idx_620"></a>cdddar<i> pair</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_622"></a>cddddr<i> pair</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These procedures are compositions of <tt>car</tt> and <tt>cdr</tt>, where
for example <tt>caddr</tt> could be defined by</p>
<p>
</p>

<tt>(define&nbsp;caddr&nbsp;(lambda&nbsp;(x)&nbsp;(car&nbsp;(cdr&nbsp;(cdr&nbsp;x))))).<p></tt></p>
<p>
Arbitrary compositions, up to four deep, are provided.  There are
twenty-eight of these procedures in all.</p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_624"></a>null?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is the empty list<a name="node_idx_626"></a>,
<tt>#f</tt>otherwise.</p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_628"></a>list?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is a list, <tt>#f</tt> otherwise.
By definition, all lists are chains of pairs that have finite length and are terminated by
the empty list.</p>
<p>
</p>

<tt>(list?&nbsp;&#8217;(a&nbsp;b&nbsp;c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(list?&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(list?&nbsp;&#8217;(a&nbsp;.&nbsp;b))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_630"></a>list<i> <i>obj</i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns a newly allocated list of its arguments.</p>
<p>
</p>

<tt>(list&nbsp;&#8217;a&nbsp;(+&nbsp;3&nbsp;4)&nbsp;&#8217;c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(a&nbsp;7&nbsp;c)<br>
(list)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;()<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_632"></a>length<i> list</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns the length of <i>list</i>.</p>
<p>
</p>

<tt>(length&nbsp;&#8217;(a&nbsp;b&nbsp;c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;3<br>
(length&nbsp;&#8217;(a&nbsp;(b)&nbsp;(c&nbsp;d&nbsp;e)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;3<br>
(length&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;0<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_634"></a>append<i> list <tt>...</tt> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns a possibly improper list consisting of the elements of the first <i>list</i>
followed by the elements of the other <i>list</i>s, with <i>obj</i> as
the cdr of the final pair.
An improper list results if <i>obj</i> is not a
list.</p>
<p>
</p>

<tt>(append&nbsp;&#8217;(x)&nbsp;&#8217;(y))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(x&nbsp;y)<br>
(append&nbsp;&#8217;(a)&nbsp;&#8217;(b&nbsp;c&nbsp;d))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(a&nbsp;b&nbsp;c&nbsp;d)<br>
(append&nbsp;&#8217;(a&nbsp;(b))&nbsp;&#8217;((c)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(a&nbsp;(b)&nbsp;(c))<br>
(append&nbsp;&#8217;(a&nbsp;b)&nbsp;&#8217;(c&nbsp;.&nbsp;d))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(a&nbsp;b&nbsp;c&nbsp;.&nbsp;d)<br>
(append&nbsp;&#8217;()&nbsp;&#8217;a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;a<p></tt></p>
<p>
If <tt>append</tt> constructs a nonempty chain of pairs, it is always
newly allocated.  If no pairs are allocated, <i>obj</i> is returned.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_636"></a>reverse<i> list</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns a newly allocated list consisting of the elements of <i>list</i>
in reverse order.</p>
<p>
</p>

<tt>(reverse&nbsp;&#8217;(a&nbsp;b&nbsp;c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(c&nbsp;b&nbsp;a)<br>
(reverse&nbsp;&#8217;(a&nbsp;(b&nbsp;c)&nbsp;d&nbsp;(e&nbsp;(f))))&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;((e&nbsp;(f))&nbsp;d&nbsp;(b&nbsp;c)&nbsp;a)<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_638"></a>list-tail<i> list k</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>List</i> should be a list of size at least <i>k</i>.
The <tt>list-tail</tt> procedure returns the subchain of pairs of <i>list</i>
obtained by omitting the first <i>k</i> elements.</p>
<p>
</p>

<tt>(list-tail&nbsp;&#8217;(a&nbsp;b&nbsp;c&nbsp;d)&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(c&nbsp;d)<p></tt></p>
<p>
<em>Implementation responsibilities: </em>The implementation must check that <i>list</i> is a chain of
pairs whose length is at least <i>k</i>.  It should not check that it is a chain
of pairs beyond this length.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_640"></a>list-ref<i> list k</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>List</i> must be a list whose length is at least <i>k</i> + 1.
The <tt>list-tail</tt> procedure returns the <i>k</i>th element of <i>list</i>.</p>
<p>
</p>

<tt>(list-ref&nbsp;&#8217;(a&nbsp;b&nbsp;c&nbsp;d)&nbsp;2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;c<p></tt></p>
<p>
<em>Implementation responsibilities: </em>The implementation must check that <i>list</i> is a chain of
pairs whose length is at least <i>k</i> + 1.  It should not check that it is a list
of pairs beyond this length.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_642"></a>map<i> proc <i>list<sub>1</sub></i> <i>list<sub>2</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <i>list</i>s should all have the same length.  <i>Proc</i>
should accept as many arguments as there are
<i>list</i>s and return a single value.  <i>Proc</i> should not mutate
any of the <i>list</i>s.</p>
<p>
The <tt>map</tt> procedure applies <i>proc</i> element-wise to the elements of the
<i>list</i>s and returns a list of the results, in order.
<i>Proc</i> is always called in the same dynamic environment 
as <tt>map</tt> itself.
The order in which <i>proc</i> is applied to the elements of the
<i>list</i>s is unspecified.
If multiple returns occur from <tt>map</tt>, the 
values returned by earlier returns are not mutated.</p>
<p>
</p>

<tt>(map&nbsp;cadr&nbsp;&#8217;((a&nbsp;b)&nbsp;(d&nbsp;e)&nbsp;(g&nbsp;h)))&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(b&nbsp;e&nbsp;h)<br>
<br>
(map&nbsp;(lambda&nbsp;(n)&nbsp;(expt&nbsp;n&nbsp;n))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8217;(1&nbsp;2&nbsp;3&nbsp;4&nbsp;5))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(1&nbsp;4&nbsp;27&nbsp;256&nbsp;3125)<br>
<br>
(map&nbsp;+&nbsp;&#8217;(1&nbsp;2&nbsp;3)&nbsp;&#8217;(4&nbsp;5&nbsp;6))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(5&nbsp;7&nbsp;9)<br>
<br>
(let&nbsp;((count&nbsp;0))<br>
&nbsp;&nbsp;(map&nbsp;(lambda&nbsp;(ignored)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;count&nbsp;(+&nbsp;count&nbsp;1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8217;(a&nbsp;b)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(1&nbsp;2)&nbsp;<i>or</i>&nbsp;(2&nbsp;1)<p></tt></p>
<p>
<em>Implementation responsibilities: </em>The implementation should check that the <i>list</i>s all
have the same length.  The implementation must check the restrictions
on <i>proc</i> to the extent performed by applying it as described.  An
implementation may check whether <i>proc</i> is an appropriate argument
before applying it.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_644"></a>for-each<i> proc <i>list<sub>1</sub></i> <i>list<sub>2</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <i>list</i>s should all have the same length.  <i>Proc</i>
should accept as many arguments as there are
<i>list</i>s.  <i>Proc</i> should not mutate
any of the <i>list</i>s.</p>
<p>
The <tt>for-each</tt> procedure applies <i>proc</i>
element-wise to the elements of the
<i>list</i>s for its side effects,  in order from the first elements to the
last.
<i>Proc</i> is always called in the same dynamic environment 
as <tt>for-each</tt> itself.
The return values of <tt>for-each</tt> are unspecified.</p>
<p>
</p>

<tt>(let&nbsp;((v&nbsp;(make-vector&nbsp;5)))<br>
&nbsp;&nbsp;(for-each&nbsp;(lambda&nbsp;(i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vector-set!&nbsp;v&nbsp;i&nbsp;(*&nbsp;i&nbsp;i)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8217;(0&nbsp;1&nbsp;2&nbsp;3&nbsp;4))<br>
&nbsp;&nbsp;v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;#(0&nbsp;1&nbsp;4&nbsp;9&nbsp;16)<br>
<br>
(for-each&nbsp;(lambda&nbsp;(x)&nbsp;x)&nbsp;&#8217;(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<em>unspecified</em><br>
<br>
(for-each&nbsp;even?&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<em>unspecified</em><p></tt></p>
<p>
<em>Implementation responsibilities: </em>The implementation should check that the <i>list</i>s all
have the same length.  The implementation must check the restrictions
on <i>proc</i> to the extent performed by applying it as described.
An implementation may check whether <i>proc</i> is an appropriate argument
before applying it.</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
Implementations of <tt>for-each</tt> may or may not tail-call
<i>proc</i> on the last elements.
</blockquote><p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.10"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.10">11.10&nbsp;&nbsp;Symbols</a></h2>
<p></p>
<p>
Symbols are objects whose usefulness rests on the fact that two
symbols are identical (in the sense of <tt>eq?</tt>, <tt>eqv?</tt> and <tt>equal?</tt>) if and only if their
names are spelled the same way. 
A symbol literal is formed using <tt>quote</tt>.</p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_646"></a>symbol?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is a symbol, otherwise returns <tt>#f</tt>.</p>
<p>
</p>

<tt>(symbol?&nbsp;&#8217;foo)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(symbol?&nbsp;(car&nbsp;&#8217;(a&nbsp;b)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(symbol?&nbsp;&quot;bar&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(symbol?&nbsp;&#8217;nil)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(symbol?&nbsp;&#8217;())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(symbol?&nbsp;<tt>#f</tt>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_648"></a>symbol-&gt;string<i> symbol</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns the name of <i>symbol</i> as an immutable string.  </p>
<p>
</p>

<tt>(symbol-&gt;string&nbsp;&#8217;flying-fish)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&quot;flying-fish&quot;<br>
(symbol-&gt;string&nbsp;&#8217;Martin)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&quot;Martin&quot;<br>
(symbol-&gt;string<br>
&nbsp;&nbsp;&nbsp;(string-&gt;symbol&nbsp;&quot;Malvina&quot;))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&quot;Malvina&quot;<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_650"></a>symbol=?<i> <i>symbol<sub>1</sub></i> <i>symbol<sub>2</sub></i> <i>symbol<sub>3</sub></i>
<tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if the symbols are the same, i.e., if their names
are spelled the same.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_652"></a>string-&gt;symbol<i> string</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns the symbol whose name is <i>string</i>. </p>
<p>
</p>

<tt>(eq?&nbsp;&#8217;mISSISSIppi&nbsp;&#8217;mississippi)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
(string-&gt;symbol&nbsp;&quot;mISSISSIppi&quot;)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;the&nbsp;symbol&nbsp;with&nbsp;name&nbsp;&quot;mISSISSIppi&quot;<br>
(eq?&nbsp;&#8217;bitBlt&nbsp;(string-&gt;symbol&nbsp;&quot;bitBlt&quot;))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(eq?&nbsp;&#8217;JollyWog<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(symbol-&gt;string&nbsp;&#8217;JollyWog)))&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><br>
(string=?&nbsp;&quot;K.&nbsp;Harper,&nbsp;M.D.&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(symbol-&gt;string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(string-&gt;symbol&nbsp;&quot;K.&nbsp;Harper,&nbsp;M.D.&quot;)))&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.11"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.11">11.11&nbsp;&nbsp;Characters</a></h2>
<p></p>
<p>
<a name="node_idx_654"></a><a name="node_idx_656"></a></p>
<p>
<a name="node_idx_658"></a><em>Characters</em> are objects that represent Unicode scalar
values&nbsp;[<a href="r6rs-Z-H-21.html#node_bib_27">27</a>].</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
Unicode defines a standard mapping between sequences of
<i>Unicode scalar values</i><a name="node_idx_660"></a><a name="node_idx_662"></a>(integers in the range 0 to
#x10FFFF, excluding the range #xD800 to #xDFFF) in the latest
version of the standard and human-readable &#8220;characters&#8221;. More
precisely, Unicode distinguishes between glyphs, which are printed
for humans to read, and characters, which are abstract entities that
map to glyphs (sometimes in a way that&#8217;s sensitive to surrounding
characters).  Furthermore, different sequences of scalar values
sometimes correspond to the same character.  The relationships among
scalar, characters, and glyphs are subtle and complex.<p>
Despite this complexity, most things that a literate human would
call a &#8220;character&#8221; can be represented by a single Unicode scalar
value (although several sequences of Unicode scalar values may
represent that same character). For example, Roman letters, Cyrillic
letters, Hebrew consonants, and most Chinese characters fall into
this category.</p>
<p>
Unicode scalar values exclude the range #xD800 to #xDFFF, which
are part of the range of Unicode <i>code points</i><a name="node_idx_664"></a>.  However, the Unicode code points in this range,
the so-called <i>surrogates</i><a name="node_idx_666"></a>, are an
artifact of the UTF-16 encoding, and can only appear in specific
Unicode encodings, and even then only in pairs that encode scalar
values.  Consequently, all characters represent code points, but the
surrogate code points do not have representations as characters.
</p>
</blockquote><p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_668"></a>char?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is a character, otherwise returns <tt>#f</tt>.</p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_670"></a>char-&gt;integer<i> char</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_672"></a>integer-&gt;char<i> 
<p class=noindent><em>s</em><em>v</em></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure</p>
&nbsp;</div>
<p>
<i>Sv</i> must be a Unicode scalar value, i.e., a non-negative exact
integer object in [0, #<em>x</em>D7FF] &cup;
[#<em>x</em>E000, #<em>x</em>10FFFF].</p>
<p>
Given a character, <tt>char-&gt;integer</tt> returns its Unicode scalar value
as an exact integer object.  
For a Unicode scalar value <i>sv</i>, <tt>integer-&gt;char</tt>
returns its associated character.</p>
<p>
</p>

<tt>(integer-&gt;char&nbsp;32)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<tt>#</tt><tt>\</tt>space<br>
(char-&gt;integer&nbsp;(integer-&gt;char&nbsp;5000))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;5000<br>
(integer-&gt;char&nbsp;<tt>#</tt><tt>\</tt>xD800)&nbsp;&nbsp;<tt>&nbsp;&amp;assertion</tt>&nbsp;<i>exception</i><p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_674"></a>char=?<i> <i>char<sub>1</sub></i> <i>char<sub>2</sub></i> <i>char<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_676"></a>char&lt;?<i> <i>char<sub>1</sub></i> <i>char<sub>2</sub></i> <i>char<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_678"></a>char&gt;?<i> <i>char<sub>1</sub></i> <i>char<sub>2</sub></i> <i>char<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_680"></a>char&lt;=?<i> <i>char<sub>1</sub></i> <i>char<sub>2</sub></i> <i>char<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_682"></a>char&gt;=?<i> <i>char<sub>1</sub></i> <i>char<sub>2</sub></i> <i>char<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>

These procedures impose a total ordering on the set of characters
according to their Unicode scalar values.</p>
<p>
</p>

<tt>(char&lt;?&nbsp;<tt>#</tt><tt>\</tt>z&nbsp;<tt>#</tt><tt>\</tt>&szlig;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<tt>#t</tt><br>
(char&lt;?&nbsp;<tt>#</tt><tt>\</tt>z&nbsp;<tt>#</tt><tt>\</tt>Z)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<tt>#f</tt><p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.12"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.12">11.12&nbsp;&nbsp;Strings</a></h2>
<p></p>
<p>
Strings are sequences of characters.  </p>
<p>
The <em>length</em> of a string is the number of characters that it
contains.  This number is fixed when the
string is created.  The <a name="node_idx_684"></a><em>valid indices</em> of a string are the
integers less than the length of the string.  The first
character of a string has index 0, the second has index 1, and so on.</p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_686"></a>string?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is a string, otherwise returns <tt>#f</tt>.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_688"></a>make-string<i> k</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_690"></a>make-string<i> k char</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns a newly allocated string of
length <i>k</i>.  If <i>char</i> is given, then all elements of the string
are initialized to <i>char</i>, otherwise the contents of the
<i>string</i> are unspecified.</p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_692"></a>string<i> char <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns a newly allocated string composed of the arguments.</p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_694"></a>string-length<i> string</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns the number of characters in the given <i>string</i> as an exact
integer object.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_696"></a>string-ref<i> string k</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>K</i> must be a valid index of <i>string</i>.
The <tt>string-ref</tt> procedure returns character </p>

<p class=noindent><em>k</em> of <i>string</i> using zero-origin indexing.</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
Implementors should make <tt>string-ref</tt> run in constant
time.
</blockquote>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_698"></a>string=?<i> <i>string<sub>1</sub></i> <i>string<sub>2</sub></i> <i>string<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if the strings are the same length and contain the same
characters in the same positions.  Otherwise, the <tt>string=?</tt>
procedure returns <tt>#f</tt>.</p>
<p>
</p>

<tt>(string=?&nbsp;&quot;Stra&szlig;e&quot;&nbsp;&quot;Strasse&quot;)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<tt>#f</tt><p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_700"></a>string&lt;?<i> <i>string<sub>1</sub></i> <i>string<sub>2</sub></i> <i>string<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_702"></a>string&gt;?<i> <i>string<sub>1</sub></i> <i>string<sub>2</sub></i> <i>string<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_704"></a>string&lt;=?<i> <i>string<sub>1</sub></i> <i>string<sub>2</sub></i> <i>string<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_706"></a>string&gt;=?<i> <i>string<sub>1</sub></i> <i>string<sub>2</sub></i> <i>string<sub>3</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, <tt>string&lt;?</tt> is
the lexicographic ordering on strings induced by the ordering
<tt>char&lt;?</tt> on characters.  If two strings differ in length but
are the same up to the length of the shorter string, the shorter string
is considered to be lexicographically less than the longer string.</p>
<p>
</p>

<tt>(string&lt;?&nbsp;&quot;z&quot;&nbsp;&quot;&szlig;&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<tt>#t</tt><br>
(string&lt;?&nbsp;&quot;z&quot;&nbsp;&quot;zz&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<tt>#t</tt><br>
(string&lt;?&nbsp;&quot;z&quot;&nbsp;&quot;Z&quot;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<tt>#f</tt><p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_708"></a>substring<i> string start end</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>String</i> must be a string, and <i>start</i> and <i>end</i>
must be exact integer objects satisfying
</p>
<div class=mathdisplay align=left><table><tr><td>0 &le; <i>start</i> &le; <i>end</i> &le; <tt>(string-length <i>string</i>).</tt></td></tr></table></div>
<p class=noindent>
The <tt>substring</tt> procedure returns a newly allocated string formed from the characters of
<i>string</i> beginning with index <i>start</i> (inclusive) and ending with index
<i>end</i> (exclusive).
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_710"></a>string-append<i> <i>string</i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns a newly allocated string whose characters form the concatenation of the
given strings.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_712"></a>string-&gt;list<i> string</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_714"></a>list-&gt;string<i> list</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>List</i> must be a list of characters.
The <tt>string-&gt;list</tt> procedure returns a newly allocated list of the
characters that make up the given string.  The <tt>list-&gt;string</tt> procedure
returns a newly allocated string formed from the characters in 
<i>list</i>. The <tt>string-&gt;list</tt>
and <tt>list-&gt;string</tt> procedures are
inverses so far as <tt>equal?</tt> is concerned.  
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_716"></a>string-for-each<i> proc <i>string<sub>1</sub></i> <i>string<sub>2</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <i>string</i>s must all have the same length.  <i>Proc</i>
should accept as many arguments as there are <i>string</i>s.
The <tt>string-for-each</tt> procedure applies <i>proc</i>
element-wise to the characters of the
<i>string</i>s for its side effects,  in order from the first characters to the
last.
<i>Proc</i> is always called in the same dynamic environment 
as <tt>string-for-each</tt> itself.
The return values of <tt>string-for-each</tt> are unspecified.</p>
<p>
Analogous to <tt>for-each</tt>.</p>
<p>
<em>Implementation responsibilities: </em>The implementation must check the restrictions
on <i>proc</i> to the extent performed by applying it as described.
An
implementation may check whether <i>proc</i> is an appropriate argument
before applying it.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_718"></a>string-copy<i> string</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns a newly allocated copy of the given <i>string</i>.</p>
<p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.13"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.13">11.13&nbsp;&nbsp;Vectors</a></h2>
<p></p>
<p>
Vectors are heterogeneous structures whose elements are indexed
by integers.  A vector typically occupies less space than a list
of the same length, and the average time needed to access a randomly
chosen element is typically less for the vector than for the list.</p>
<p>
The <em>length</em> of a vector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when the
vector is created.
The <em>valid indices</em><a name="node_idx_720"></a>of a
vector are the exact non-negative integer objects less than the length of the
vector.  The first element in a vector is indexed by zero, and the last
element is indexed by one less than the length of the vector.</p>
<p>
Like list constants, vector constants must be quoted:</p>
<p>
</p>

<tt>&#8217;#(0&nbsp;(2&nbsp;2&nbsp;2&nbsp;2)&nbsp;&quot;Anna&quot;)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;#(0&nbsp;(2&nbsp;2&nbsp;2&nbsp;2)&nbsp;&quot;Anna&quot;)<p></tt></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_722"></a>vector?<i> obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is a vector.  Otherwise the procedure
returns <tt>#f</tt>.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_724"></a>make-vector<i> k</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_726"></a>make-vector<i> k fill</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns a newly allocated vector of <i>k</i> elements.  If a second
argument is given, then each element is initialized to <i>fill</i>.
Otherwise the initial contents of each element is unspecified.</p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_728"></a>vector<i> obj <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns a newly allocated vector whose elements contain the given
arguments.  Analogous to <tt>list</tt>.</p>
<p>
</p>

<tt>(vector&nbsp;&#8217;a&nbsp;&#8217;b&nbsp;&#8217;c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;#(a&nbsp;b&nbsp;c)<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_730"></a>vector-length<i> vector</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Returns the number of elements in <i>vector</i> as an exact integer object.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_732"></a>vector-ref<i> vector k</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>K</i> must be a valid index of <i>vector</i>.
The <tt>vector-ref</tt> procedure returns the contents of element </p>

<p class=noindent><em>k</em> of
<i>vector</i>.</p>
<p>
</p>

<tt>(vector-ref&nbsp;&#8217;#(1&nbsp;1&nbsp;2&nbsp;3&nbsp;5&nbsp;8&nbsp;13&nbsp;21)&nbsp;5)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;8<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_734"></a>vector-set!<i> vector k obj</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>K</i> must be a valid index of <i>vector</i>.
The <tt>vector-set!</tt> procedure stores <i>obj</i> in element </p>

<p class=noindent><em>k</em> of
<i>vector</i>, and returns unspecified values.</p>
<p>
Passing an immutable vector to <tt>vector-set!</tt> should cause an exception
with condition type <tt>&amp;assertion</tt> to be raised.</p>
<p>
</p>

<tt>(let&nbsp;((vec&nbsp;(vector&nbsp;0&nbsp;&#8217;(2&nbsp;2&nbsp;2&nbsp;2)&nbsp;&quot;Anna&quot;)))<br>
&nbsp;&nbsp;(vector-set!&nbsp;vec&nbsp;1&nbsp;&#8217;(&quot;Sue&quot;&nbsp;&quot;Sue&quot;))<br>
&nbsp;&nbsp;vec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;#(0&nbsp;(&quot;Sue&quot;&nbsp;&quot;Sue&quot;)&nbsp;&quot;Anna&quot;)<br>
<br>
(vector-set!&nbsp;&#8217;#(0&nbsp;1&nbsp;2)&nbsp;1&nbsp;&quot;doe&quot;)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<i>unspecified</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;constant&nbsp;vector<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;should&nbsp;raise&nbsp;<tt>&nbsp;&amp;assertion</tt>&nbsp;<i>exception</i><p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_736"></a>vector-&gt;list<i> vector</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_738"></a>list-&gt;vector<i> list</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <tt>vector-&gt;list</tt> procedure returns a newly allocated list of the objects contained
in the elements of <i>vector</i>.  The <tt>list-&gt;vector</tt> procedure returns a newly
created vector initialized to the elements of the list <i>list</i>.</p>
<p>
</p>

<tt>(vector-&gt;list&nbsp;&#8217;#(dah&nbsp;dah&nbsp;didah))&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(dah&nbsp;dah&nbsp;didah)<br>
(list-&gt;vector&nbsp;&#8217;(dididit&nbsp;dah))&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;#(dididit&nbsp;dah)<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_740"></a>vector-fill!<i> vector fill</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Stores <i>fill</i> in every element of <i>vector</i>
and returns unspecified values.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_742"></a>vector-map<i> proc <i>vector<sub>1</sub></i> <i>vector<sub>2</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <i>vector</i>s must all have the same length.  <i>Proc</i>
should accept as many arguments as there are <i>vector</i>s and return a
single value.</p>
<p>
The <tt>vector-map</tt> procedure applies <i>proc</i> element-wise to the elements of the
<i>vector</i>s and returns a vector of the results, in order.
<i>Proc</i> is always called in the same dynamic environment 
as <tt>vector-map</tt> itself.
The order in which <i>proc</i> is applied to the elements of the
<i>vector</i>s is unspecified.
If multiple returns occur from <tt>vector-map</tt>, the return
values returned by earlier returns are not mutated.</p>
<p>
Analogous to <tt>map</tt>.</p>
<p>
<em>Implementation responsibilities: </em>The implementation must check the restrictions
on <i>proc</i> to the extent performed by applying it as described.
An
implementation may check whether <i>proc</i> is an appropriate argument
before applying it.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_744"></a>vector-for-each<i> proc <i>vector<sub>1</sub></i> <i>vector<sub>2</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
The <i>vector</i>s must all have the same length.  <i>Proc</i>
should accept as many arguments as there are <i>vector</i>s.
The <tt>vector-for-each</tt> procedure applies <i>proc</i>
element-wise to the elements of the
<i>vector</i>s for its side effects,  in order from the first elements to the
last.
<i>Proc</i> is always called in the same dynamic environment 
as <tt>vector-for-each</tt> itself.
The return values of <tt>vector-for-each</tt> are unspecified.</p>
<p>
Analogous to <tt>for-each</tt>.</p>
<p>
<em>Implementation responsibilities: </em>The implementation must check the restrictions
on <i>proc</i> to the extent performed by applying it as described.
An
implementation may check whether <i>proc</i> is an appropriate argument
before applying it.
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.14"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.14">11.14&nbsp;&nbsp;Errors and violations</a></h2>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_746"></a>error<i> who message <i>irritant<sub>1</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_748"></a>assertion-violation<i> who message <i>irritant<sub>1</sub></i> <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>Who</i> must be a string or a symbol or <tt>#f</tt>.
<i>Message</i> must be a string.
The <i>irritant</i>s are arbitrary objects.</p>
<p>
These procedures raise an exception.  The <tt>error</tt>
procedure should be called when an error has occurred, typically caused by
something that has gone wrong in the interaction of the program with the
external world or the user.  The <tt>assertion-violation</tt> procedure
should be called when an invalid call to a procedure was made, either passing an
invalid number of arguments, or passing an argument that it is not
specified to handle.</p>
<p>
The <i>who</i> argument should describe the procedure or operation that
detected the exception.  The <i>message</i> argument should describe
the exceptional situation.  The <i>irritant</i>s should be the arguments
to the operation that detected the operation.</p>
<p>
The condition object provided with the exception (see
library chapter&nbsp;on &#8220;Exceptions
and conditions&#8221;) has the following condition types:
</p>
<ul>
<li><p>If <i>who</i> is not <tt>#f</tt>, the condition has condition type
<tt>&amp;who</tt>, with <i>who</i> as the value of its field.  In
that case, <i>who</i> should be the name of the procedure or entity that
detected the exception.  If it is <tt>#f</tt>, the condition does not
have condition type <tt>&amp;who</tt>.
</p>
<li><p>The condition has condition type <tt>&amp;message</tt>, with
<i>message</i> as the value of its field.
</p>
<li><p>The condition has condition type <tt>&amp;irritants</tt>, and its
field has as its value a list of the <i>irritant</i>s.
</p>
</ul><p>
Moreover, the condition created by <tt>error</tt> has condition type 
<tt>&amp;error</tt>, and the condition created by <tt>assertion-violation</tt> has
condition type <tt>&amp;assertion</tt>.</p>
<p>
</p>

<tt>(define&nbsp;(fac&nbsp;n)<br>
&nbsp;&nbsp;(if&nbsp;(not&nbsp;(integer-valued?&nbsp;n))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8217;fac&nbsp;&quot;non-integral&nbsp;argument&quot;&nbsp;n))<br>
&nbsp;&nbsp;(if&nbsp;(negative?&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(assertion-violation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8217;fac&nbsp;&quot;negative&nbsp;argument&quot;&nbsp;n))<br>
&nbsp;&nbsp;(letrec<br>
&nbsp;&nbsp;&nbsp;&nbsp;((loop&nbsp;(lambda&nbsp;(n&nbsp;r)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(zero?&nbsp;n)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(-&nbsp;n&nbsp;1)&nbsp;(*&nbsp;r&nbsp;n))))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;n&nbsp;1)))<br>
<br>
(fac&nbsp;5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;120<br>
(fac&nbsp;4.5)&nbsp;&nbsp;<tt>&nbsp;&amp;assertion</tt>&nbsp;<i>exception</i><br>
(fac&nbsp;-3)&nbsp;&nbsp;<tt>&nbsp;&amp;assertion</tt>&nbsp;<i>exception</i><p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_750"></a>assert<i> &lt;expression&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
An <tt>assert</tt> form is evaluated by evaluating &lt;expression&gt;.
If &lt;expression&gt; returns a true value, that value is returned
from the <tt>assert</tt> expression.  If &lt;expression&gt; returns
<tt>#f</tt>, an exception with condition types <tt>&amp;assertion</tt> and
<tt>&amp;message</tt> is raised.  The message provided in the condition
object is implementation-dependent.</p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
Implementations should exploit the fact that
<tt>assert</tt> is syntax to provide as much information as possible
about the location of the assertion failure.
</blockquote>
<p></p>
<p>
</p>
<a name="node_sec_11.15"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.15">11.15&nbsp;&nbsp;Control features</a></h2>
<p>
</p>
<p>
This chapter describes various primitive procedures which control the
flow of program execution in special ways.</p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_752"></a>apply<i> proc <i>arg<sub>1</sub></i> <tt>...</tt> rest-args</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>Rest-args</i> must be a list.
<i>Proc</i> should accept <em>n</em> arguments, where <em>n</em> is
number of <i>arg</i>s plus the length of <i>rest-args</i>.
The <tt>apply</tt> procedure calls <i>proc</i> with the elements of the list
<tt>(append (list <i>arg<sub>1</sub></i> <tt>...</tt>) <i>rest-args</i>)</tt> as the actual
arguments.</p>
<p>
If a call to <tt>apply</tt> occurs in a tail context, the call
to <i>proc</i> is also in a tail context.</p>
<p>
</p>

<tt>(apply&nbsp;+&nbsp;(list&nbsp;3&nbsp;4))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;7<br>
<br>
(define&nbsp;compose<br>
&nbsp;&nbsp;(lambda&nbsp;(f&nbsp;g)<br>
&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;args<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(f&nbsp;(apply&nbsp;g&nbsp;args)))))<br>
<br>
((compose&nbsp;sqrt&nbsp;*)&nbsp;12&nbsp;75)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;30<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_754"></a>call-with-current-continuation<i> proc</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_756"></a>call/cc<i> proc</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
 <i>Proc</i> should accept one
argument. The procedure <tt>call-with-current-continuation</tt> 
(which is the same as the procedure <tt>call/cc</tt>) packages
the current continuation as an &#8220;escape
procedure&#8221;<a name="node_idx_758"></a>and passes it as an argument to
<i>proc</i>.  The escape procedure is a Scheme procedure that, if it is
later called, will abandon whatever continuation is in effect at that later
time and will instead reinstate the continuation that was in effect
when the escape procedure was created.  Calling the escape procedure
may cause the invocation of <i>before</i> and <i>after</i> procedures installed using
<tt>dynamic-wind</tt>.</p>
<p>
The escape procedure accepts the same number of arguments as the
continuation of the original call to <tt>call-with-current-continuation</tt>.</p>
<p>
The escape procedure that is passed to <i>proc</i> has
unlimited extent just like any other procedure in Scheme.  It may be stored
in variables or data structures and may be called as many times as desired.</p>
<p>
If a call to <tt>call-with-current-continuation</tt> occurs in a tail
context, the call to <i>proc</i> is also in a tail context.</p>
<p>
The following examples show only some ways in which
<tt>call-with-current-continuation</tt> is used.  If all real uses were as
simple as these examples, there would be no need for a procedure with
the power of <tt>call-with-current-continuation</tt>.</p>
<p>
</p>

<tt>(call-with-current-continuation<br>
&nbsp;&nbsp;(lambda&nbsp;(exit)<br>
&nbsp;&nbsp;&nbsp;&nbsp;(for-each&nbsp;(lambda&nbsp;(x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(negative?&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exit&nbsp;x)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8217;(54&nbsp;0&nbsp;37&nbsp;-3&nbsp;245&nbsp;19))<br>
&nbsp;&nbsp;&nbsp;&nbsp;<tt>#t</tt>))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-3<br>
<br>
(define&nbsp;list-length<br>
&nbsp;&nbsp;(lambda&nbsp;(obj)<br>
&nbsp;&nbsp;&nbsp;&nbsp;(call-with-current-continuation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(return)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(letrec&nbsp;((r<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(obj)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;obj)&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((pair?&nbsp;obj)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+&nbsp;(r&nbsp;(cdr&nbsp;obj))&nbsp;1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(else&nbsp;(return&nbsp;<tt>#f</tt>))))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(r&nbsp;obj))))))<br>
<br>
(list-length&nbsp;&#8217;(1&nbsp;2&nbsp;3&nbsp;4))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;4<br>
<br>
(list-length&nbsp;&#8217;(a&nbsp;b&nbsp;.&nbsp;c))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#f</tt><br>
<br>
(call-with-current-continuation&nbsp;procedure?)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;<tt>#t</tt><p></tt></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
Calling an escape procedure reenters the dynamic extent of the call
to <tt>call-with-current-continuation</tt>, and thus restores its
dynamic environment; see section&nbsp;<a href="r6rs-Z-H-8.html#node_sec_5.12">5.12</a>.
</blockquote><p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_760"></a>values<i> obj <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
Delivers all of its arguments to its continuation.
The <tt>values</tt> procedure might be defined as follows:
</p>

<tt>(define&nbsp;(values&nbsp;.&nbsp;things)<br>
&nbsp;&nbsp;(call-with-current-continuation&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(cont)&nbsp;(apply&nbsp;cont&nbsp;things))))<p></tt></p>
<p>
The continuations of all non-final expressions within a sequence of
expressions, such as in <tt>lambda</tt>, <tt>begin</tt>, <tt>let</tt>, <tt>let*</tt>, <tt>letrec</tt>, <tt>letrec*</tt>, <tt>let-values</tt>, <tt>let*-values</tt>, <tt>case</tt>, and <tt>cond</tt> forms, usually take an
arbitrary number of values.</p>
<p>
Except for these and the continuations created by <tt>call-with-values</tt>, <tt>let-values</tt>, and <tt>let*-values</tt>,
continuations implicitly accepting a single value, such as the
continuations of &lt;operator&gt; and &lt;operand&gt;s of procedure
calls or the &lt;test&gt; expressions in conditionals, take exactly
one value.  The effect of passing an inappropriate number of values to
such a continuation is undefined.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_762"></a>call-with-values<i> producer consumer</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>Producer</i> must be a procedure and should accept zero
arguments.  <i>Consumer</i> must be a procedure and should accept as many
values as <i>producer</i> returns.
The <tt>call-with-values</tt> procedure calls <i>producer</i> with no arguments and
a continuation that, when passed some values, calls the
<i>consumer</i> procedure with those values as arguments.
The continuation for the call to <i>consumer</i> is the
continuation of the call to <tt>call-with-values</tt>.</p>
<p>
</p>

<tt>(call-with-values&nbsp;(lambda&nbsp;()&nbsp;(values&nbsp;4&nbsp;5))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(a&nbsp;b)&nbsp;b))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;5<br>
<br>
(call-with-values&nbsp;*&nbsp;-)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;-1<p></tt></p>
<p>
If a call to <tt>call-with-values</tt> occurs in a tail context, the call
to <i>consumer</i> is also in a tail context.</p>
<p>
<em>Implementation responsibilities: </em>After <i>producer</i> returns, the implementation must check
that <i>consumer</i> accepts as many values as <i>consumer</i> has
returned.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_764"></a>dynamic-wind<i> before thunk after</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;procedure&nbsp;</div>
<p>
<i>Before</i>, <i>thunk</i>, and <i>after</i> must be procedures,
and each should accept zero arguments.  These procedures may return
any number of values.  The <tt>dynamic-wind</tt> procedure calls
<i>thunk</i> without arguments, returning the results of this call.
Moreover, <tt>dynamic-wind</tt> calls <i>before</i> without arguments
whenever the dynamic extent of the call to <i>thunk</i> is entered, and
<i>after</i> without arguments whenever the dynamic extent of the call
to <i>thunk</i> is exited.  Thus, in the absence of calls to escape
procedures created by <tt>call-with-current-continuation</tt>, <tt>dynamic-wind</tt> calls <i>before</i>, <i>thunk</i>, and <i>after</i>, in
that order.</p>
<p>
While the calls to <i>before</i> and <i>after</i> are not considered to be
within the dynamic extent of the call to <i>thunk</i>, calls to the <i>before</i>
and <i>after</i> procedures of any other calls to <tt>dynamic-wind</tt> that occur
within the dynamic extent of the call to <i>thunk</i> are considered to be
within the dynamic extent of the call to <i>thunk</i>.</p>
<p>
More precisely, an escape procedure transfers control out of the
dynamic extent of a set of zero or more active <tt>dynamic-wind</tt>
calls <em>x</em> <tt>...</tt> and transfer control into the dynamic extent
of a set of zero or more active <tt>dynamic-wind</tt> calls
<em>y</em> <tt>...</tt>.  
It leaves the dynamic extent of the most recent <em>x</em> and calls without
arguments the corresponding <i>after</i> procedure.
If the <i>after</i> procedure returns, the escape procedure proceeds to
the next most recent <em>x</em>, and so on.
Once each <em>x</em> has been handled in this manner,
the escape procedure calls without arguments the <i>before</i> procedure
corresponding to the least recent <em>y</em>.
If the <i>before</i> procedure returns, the escape procedure reenters the
dynamic extent of the least recent <em>y</em> and proceeds with the next least
recent <em>y</em>, and so on.
Once each <em>y</em> has been handled in this manner, control is transferred to
the continuation packaged in the escape procedure.</p>
<p>
<em>Implementation responsibilities: </em>The implementation must check the restrictions on
<i>thunk</i> and <i>after</i> only if they are actually called.</p>
<p>
</p>

<tt>(let&nbsp;((path&nbsp;&#8217;())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c&nbsp;#f))<br>
&nbsp;&nbsp;(let&nbsp;((add&nbsp;(lambda&nbsp;(s)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;path&nbsp;(cons&nbsp;s&nbsp;path)))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(dynamic-wind<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(add&nbsp;&#8217;connect))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(add&nbsp;(call-with-current-continuation<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(c0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;c&nbsp;c0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8217;talk1))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()&nbsp;(add&nbsp;&#8217;disconnect)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;(&lt;&nbsp;(length&nbsp;path)&nbsp;4)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(c&nbsp;&#8217;talk2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(reverse&nbsp;path))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;(connect&nbsp;talk1&nbsp;disconnect<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect&nbsp;talk2&nbsp;disconnect)<br>
<br>
(let&nbsp;((n&nbsp;0))<br>
&nbsp;&nbsp;(call-with-current-continuation<br>
&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dynamic-wind<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;n&nbsp;(+&nbsp;n&nbsp;1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(k))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;n&nbsp;(+&nbsp;n&nbsp;2)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;n&nbsp;(+&nbsp;n&nbsp;4))))))<br>
&nbsp;&nbsp;n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;1<br>
<br>
(let&nbsp;((n&nbsp;0))<br>
&nbsp;&nbsp;(call-with-current-continuation<br>
&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;(k)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dynamic-wind<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dynamic-wind<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;n&nbsp;(+&nbsp;n&nbsp;1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(k))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;n&nbsp;(+&nbsp;n&nbsp;2))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(k))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;n&nbsp;(+&nbsp;n&nbsp;4))))))<br>
&nbsp;&nbsp;n)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;7<p></tt></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
Entering a dynamic extent restores its dynamic environment; see
section&nbsp;<a href="r6rs-Z-H-8.html#node_sec_5.12">5.12</a>.
</blockquote>
<p></p>
<p>
</p>
<a name="node_sec_11.16"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.16">11.16&nbsp;&nbsp;Iteration</a></h2>
<p><div style="height: -9.0pt"></div>
<p style="margin-top: 0pt; margin-bottom: 0pt"></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_766"></a>let<i> &lt;variable&gt; &lt;bindings&gt; &lt;body&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>

&#8220;Named <tt>let</tt>&#8221; is a variant on the syntax of <tt>let</tt> that provides
a general looping construct and may also be used to express
recursion.
It has the same syntax and semantics as ordinary <tt>let</tt>
except that &lt;variable&gt; is bound within &lt;body&gt; to a procedure
whose parameters are the bound variables and whose body is
&lt;body&gt;.  Thus the execution of &lt;body&gt; may be repeated by
invoking the procedure named by &lt;variable&gt;.</p>
<p>
</p>

<tt>(let&nbsp;loop&nbsp;((numbers&nbsp;&#8217;(3&nbsp;-2&nbsp;1&nbsp;6&nbsp;-5))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(nonneg&nbsp;&#8217;())<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(neg&nbsp;&#8217;()))<br>
&nbsp;&nbsp;(cond&nbsp;((null?&nbsp;numbers)&nbsp;(list&nbsp;nonneg&nbsp;neg))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&gt;=&nbsp;(car&nbsp;numbers)&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(cdr&nbsp;numbers)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;numbers)&nbsp;nonneg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neg))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((&lt;&nbsp;(car&nbsp;numbers)&nbsp;0)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(loop&nbsp;(cdr&nbsp;numbers)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonneg<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;(car&nbsp;numbers)&nbsp;neg)))))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;((6&nbsp;1&nbsp;3)&nbsp;(-5&nbsp;-2))<p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.17"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.17">11.17&nbsp;&nbsp;Quasiquotation</a></h2>
<p><div style="height: -9.0pt"></div>
<p style="margin-top: 0pt; margin-bottom: 0pt"></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_768"></a>quasiquote<i> &lt;qq template&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>

<a name="node_idx_770"></a><div align=left><tt>unquote</tt>&nbsp;&nbsp;&nbsp;&nbsp;auxiliary syntax&nbsp;</div>

<a name="node_idx_772"></a><div align=left><tt>unquote-splicing</tt>&nbsp;&nbsp;&nbsp;&nbsp;auxiliary syntax&nbsp;</div>
<p>
&#8220;Backquote&#8221; or &#8220;quasiquote&#8221;<a name="node_idx_774"></a>expressions are useful
for constructing a list or vector structure when some but not all of the
desired structure is known in advance.  </p>
<p>
<em>Syntax: </em>&lt;Qq template&gt; should be as specified by the grammar at
the end of this entry.</p>
<p>
<em>Semantics: </em>If no
<tt>unquote</tt> or <tt>unquote-splicing</tt> forms
appear within the &lt;qq template&gt;, the result of
evaluating
<tt>(quasiquote &lt;qq template&gt;)</tt> is equivalent to the result of evaluating
<tt>(quote &lt;qq template&gt;)</tt>.</p>
<p>
If an <tt>(unquote &lt;expression&gt; <tt>...</tt>)</tt> form appears inside a
&lt;qq template&gt;, however, the &lt;expression&gt;s are evaluated
(&#8220;unquoted&#8221;) and their results are inserted into the structure instead
of the <tt>unquote</tt> form.</p>
<p>
If an <tt>(unquote-splicing &lt;expression&gt; <tt>...</tt>)</tt> form
appears inside a &lt;qq template&gt;, then the &lt;expression&gt;s must
evaluate to lists; the opening and closing parentheses of the lists are
then &#8220;stripped away&#8221; and the elements of the lists are inserted in
place of the <tt>unquote-splicing</tt> form.</p>
<p>
Any <tt>unquote-splicing</tt> or multi-operand <tt>unquote</tt> form must
appear only within a list or vector &lt;qq template&gt;.</p>
<p>
As noted in section&nbsp;<a href="r6rs-Z-H-7.html#node_sec_4.3.5">4.3.5</a>,
<tt>(quasiquote &lt;qq template&gt;)</tt> may be abbreviated
<tt>&#8216;</tt>&lt;qq template&gt;,
<tt>(unquote &lt;expression&gt;)</tt> may be abbreviated
<tt>,</tt>&lt;expression&gt;, and
<tt>(unquote-splicing &lt;expression&gt;)</tt> may be abbreviated
<tt>,</tt><tt>@</tt>&lt;expression&gt;.</p>
<p>
</p>

<tt>&#8216;(list&nbsp;,(+&nbsp;1&nbsp;2)&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(list&nbsp;3&nbsp;4)<br>
(let&nbsp;((name&nbsp;&#8217;a))&nbsp;&#8216;(list&nbsp;,name&nbsp;&#8217;,name))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(list&nbsp;a&nbsp;(quote&nbsp;a))<br>
&#8216;(a&nbsp;,(+&nbsp;1&nbsp;2)&nbsp;,@(map&nbsp;abs&nbsp;&#8217;(4&nbsp;-5&nbsp;6))&nbsp;b)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(a&nbsp;3&nbsp;4&nbsp;5&nbsp;6&nbsp;b)<br>
&#8216;((<tt>&nbsp;foo</tt>&nbsp;,(-&nbsp;10&nbsp;3))&nbsp;,@(cdr&nbsp;&#8217;(c))&nbsp;.&nbsp;,(car&nbsp;&#8217;(cons)))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;((foo&nbsp;7)&nbsp;.&nbsp;cons)<br>
&#8216;#(10&nbsp;5&nbsp;,(sqrt&nbsp;4)&nbsp;,@(map&nbsp;sqrt&nbsp;&#8217;(16&nbsp;9))&nbsp;8)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;#(10&nbsp;5&nbsp;2&nbsp;4&nbsp;3&nbsp;8)<br>
(let&nbsp;((name&nbsp;&#8217;foo))<br>
&nbsp;&nbsp;&#8216;((unquote&nbsp;name&nbsp;name&nbsp;name)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;(foo&nbsp;foo&nbsp;foo)<br>
(let&nbsp;((name&nbsp;&#8217;(foo)))<br>
&nbsp;&nbsp;&#8216;((unquote-splicing&nbsp;name&nbsp;name&nbsp;name)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;(foo&nbsp;foo&nbsp;foo)<br>
(let&nbsp;((q&nbsp;&#8217;((append&nbsp;x&nbsp;y)&nbsp;(sqrt&nbsp;9))))<br>
&nbsp;&nbsp;&#8216;&#8216;(foo&nbsp;,,@q))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&#8216;(foo<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(unquote&nbsp;(append&nbsp;x&nbsp;y)&nbsp;(sqrt&nbsp;9)))<br>
(let&nbsp;((x&nbsp;&#8217;(2&nbsp;3))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(y&nbsp;&#8217;(4&nbsp;5)))<br>
&nbsp;&nbsp;&#8216;(foo&nbsp;(unquote&nbsp;(append&nbsp;x&nbsp;y)&nbsp;(sqrt&nbsp;9))))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;(foo&nbsp;(2&nbsp;3&nbsp;4&nbsp;5)&nbsp;3)<p></tt></p>
<p>
Quasiquote forms may be nested.  Substitutions are made only for
unquoted components appearing at the same nesting level
as the outermost <tt>quasiquote</tt>.  The nesting level increases by one inside
each successive quasiquotation, and decreases by one inside each
unquotation.</p>
<p>
</p>

<tt>&#8216;(a&nbsp;&#8216;(b&nbsp;,(+&nbsp;1&nbsp;2)&nbsp;,(foo&nbsp;,(+&nbsp;1&nbsp;3)&nbsp;d)&nbsp;e)&nbsp;f)&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(a&nbsp;&#8216;(b&nbsp;,(+&nbsp;1&nbsp;2)&nbsp;,(foo&nbsp;4&nbsp;d)&nbsp;e)&nbsp;f)<br>
(let&nbsp;((name1&nbsp;&#8217;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(name2&nbsp;&#8217;y))<br>
&nbsp;&nbsp;&#8216;(a&nbsp;&#8216;(b&nbsp;,,name1&nbsp;,&#8217;,name2&nbsp;d)&nbsp;e))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;(a&nbsp;&#8216;(b&nbsp;,x&nbsp;,&#8217;y&nbsp;d)&nbsp;e)<p></tt></p>
<p>
A <tt>quasiquote</tt> expression may return either fresh, mutable objects
or literal structure for any structure that is constructed at run time
during the evaluation of the expression.  Portions that do not need to
be rebuilt are always literal.  Thus,
</p>

<tt>(let&nbsp;((a&nbsp;3))&nbsp;&#8216;((1&nbsp;2)&nbsp;,a&nbsp;,4&nbsp;,&#8217;five&nbsp;6))<p></tt>
may be equivalent to either of the following expressions:
</p>

<tt>&#8217;((1&nbsp;2)&nbsp;3&nbsp;4&nbsp;five&nbsp;6)<br>
(let&nbsp;((a&nbsp;3))&nbsp;<br>
&nbsp;&nbsp;(cons&nbsp;&#8217;(1&nbsp;2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cons&nbsp;a&nbsp;(cons&nbsp;4&nbsp;(cons&nbsp;&#8217;five&nbsp;&#8217;(6))))))<p></tt>
However, it is not equivalent to this expression:
</p>

<tt>(let&nbsp;((a&nbsp;3))&nbsp;(list&nbsp;(list&nbsp;1&nbsp;2)&nbsp;a&nbsp;4&nbsp;&#8217;five&nbsp;6))<br>
<p></tt>
It is a syntax violation if any of the identifiers
<tt>quasiquote</tt>, <tt>unquote</tt>, or <tt>unquote-splicing</tt> appear in
positions within a &lt;qq template&gt; otherwise than as described above.</p>
<p>
The following grammar for quasiquote expressions is not context-free.
It is presented as a recipe for generating an infinite number of
production rules.  Imagine a copy of the following rules for <em>D</em>  =  1, 2,
3, <tt>...</tt>.  <em>D</em> keeps track of the nesting depth.</p>
<p>
</p>
<tt>&lt;qq template&gt; &rarr; &lt;qq template 1&gt;<br>
&lt;qq template 0&gt; &rarr; &lt;expression&gt;<br>
&lt;quasiquotation <em>D</em>&gt; &rarr; (quasiquote &lt;qq template <em>D</em>&gt;)<br>
&lt;qq template <em>D</em>&gt; &rarr; &lt;lexeme datum&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    | &lt;list qq template <em>D</em>&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    | &lt;vector qq template <em>D</em>&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    | &lt;unquotation <em>D</em>&gt;<br>
&lt;list qq template <em>D</em>&gt; &rarr; (&lt;qq template or splice <em>D</em>&gt;*)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    | (&lt;qq template or splice <em>D</em>&gt;<sup>+</sup> . &lt;qq template <em>D</em>&gt;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    | &lt;quasiquotation <em>D</em> + 1&gt;<br>
&lt;vector qq template <em>D</em>&gt; &rarr; #(&lt;qq template or splice <em>D</em>&gt;*)<br>
&lt;unquotation <em>D</em>&gt; &rarr; (unquote &lt;qq template <em>D</em> <tt>-</tt> 1&gt;)<br>
&lt;qq template or splice <em>D</em>&gt; &rarr; &lt;qq template <em>D</em>&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    | &lt;splicing unquotation <em>D</em>&gt;<br>
&lt;splicing unquotation <em>D</em>&gt; &rarr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unquote-splicing &lt;qq template <em>D</em> <tt>-</tt> 1&gt;*)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    | (unquote &lt;qq template <em>D</em> <tt>-</tt> 1&gt;*) </tt><p>
In &lt;quasiquotation&gt;s, a &lt;list qq template <em>D</em>&gt; can sometimes
be confused with either an &lt;unquotation <em>D</em>&gt; or a &lt;splicing
unquotation <em>D</em>&gt;.  The interpretation as an
&lt;unquotation&gt; or &lt;splicing
unquotation <em>D</em>&gt; takes precedence.</p>
<p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.18"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.18">11.18&nbsp;&nbsp;Binding constructs for syntactic keywords</a></h2>
<p></p>
<p>
The <tt>let-syntax</tt> and <tt>letrec-syntax</tt> forms 
bind keywords.
Like a <tt>begin</tt> form, a <tt>let-syntax</tt> or <tt>letrec-syntax</tt> form
may appear in a definition context, in which case it is treated as a
definition, and the forms in the body must also be
definitions.
A <tt>let-syntax</tt> or <tt>letrec-syntax</tt> form may also appear in an
expression context, in which case the forms within their bodies must be
expressions.</p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_776"></a>let-syntax<i> &lt;bindings&gt; &lt;form&gt; <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>&lt;Bindings&gt; must have the form
</p>

<tt>((&lt;keyword&gt;&nbsp;&lt;expression&gt;)&nbsp;<tt>...</tt>)<p></tt>
Each &lt;keyword&gt; is an identifier,
and each &lt;expression&gt; is 
an expression that evaluates, at macro-expansion
time, to a <i>transformer</i><a name="node_idx_778"></a><a name="node_idx_780"></a>.
Transformers may be created by <tt>syntax-rules</tt> or <tt>identifier-syntax</tt>
(see section&nbsp;<a href="#node_sec_11.19">11.19</a>) or by one of the other mechanisms
described in library chapter&nbsp;on &#8220;<tt>syntax-case</tt>&#8221;.  It is a
syntax violation for &lt;keyword&gt; to appear more than once in the list of keywords
being bound.</p>
<p>
<em>Semantics: </em>The &lt;form&gt;s are expanded in the syntactic environment
obtained by extending the syntactic environment of the
<tt>let-syntax</tt> form with macros whose keywords are
the &lt;keyword&gt;s, bound to the specified transformers.
Each binding of a &lt;keyword&gt; has the &lt;form&gt;s as its region.</p>
<p>
The &lt;form&gt;s of a <tt>let-syntax</tt>
form are treated, whether in definition or expression context, as if
wrapped in an implicit <tt>begin</tt>; see section&nbsp;<a href="#node_sec_11.4.7">11.4.7</a>.
Thus definitions in the result of expanding the &lt;form&gt;s have
the same region as any definition appearing in place of the <tt>let-syntax</tt> form would have.</p>
<p>
<em>Implementation responsibilities: </em>The implementation should detect if the value of
&lt;expression&gt; cannot possibly be a transformer.</p>
<p>
</p>

<tt>(let-syntax&nbsp;((when&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((when&nbsp;test&nbsp;stmt1&nbsp;stmt2&nbsp;...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;test<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;stmt1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stmt2&nbsp;...))))))<br>
&nbsp;&nbsp;(let&nbsp;((if&nbsp;<tt>#t</tt>))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(when&nbsp;if&nbsp;(set!&nbsp;if&nbsp;&#8217;now))<br>
&nbsp;&nbsp;&nbsp;&nbsp;if))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;now<br>
<br>
(let&nbsp;((x&nbsp;&#8217;outer))<br>
&nbsp;&nbsp;(let-syntax&nbsp;((m&nbsp;(syntax-rules&nbsp;()&nbsp;((m)&nbsp;x))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((x&nbsp;&#8217;inner))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(m))))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;outer<br>
<br>
(let&nbsp;()<br>
&nbsp;&nbsp;(let-syntax<br>
&nbsp;&nbsp;&nbsp;&nbsp;((def&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((def&nbsp;stuff&nbsp;...)&nbsp;(define&nbsp;stuff&nbsp;...)))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(def&nbsp;foo&nbsp;42))<br>
&nbsp;&nbsp;foo)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;42<br>
<br>
(let&nbsp;()<br>
&nbsp;&nbsp;(let-syntax&nbsp;())<br>
&nbsp;&nbsp;5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;5<p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_782"></a>letrec-syntax<i> &lt;bindings&gt; &lt;form&gt; <tt>...</tt></i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;</div>
<p>
<em>Syntax: </em>Same as for <tt>let-syntax</tt>.</p>
<p>
<em>Semantics: </em>The &lt;form&gt;s are
expanded in the syntactic environment obtained by
extending the syntactic environment of the <tt>letrec-syntax</tt>
form with macros whose keywords are the
&lt;keyword&gt;s, bound to the specified transformers.
Each binding of a &lt;keyword&gt; has the &lt;bindings&gt;
as well as the &lt;form&gt;s within its region,
so the transformers can
transcribe forms into uses of the macros
introduced by the <tt>letrec-syntax</tt> form.</p>
<p>
The &lt;form&gt;s of a <tt>letrec-syntax</tt>
form are treated, whether in definition or expression context, as if
wrapped in an implicit <tt>begin</tt>; see section&nbsp;<a href="#node_sec_11.4.7">11.4.7</a>.
Thus definitions in the result of expanding the &lt;form&gt;s have
the same region as any definition appearing in place of the <tt>letrec-syntax</tt> form would have.</p>
<p>
<em>Implementation responsibilities: </em>The implementation should detect if the value of
&lt;expression&gt; cannot possibly be a transformer.</p>
<p>
</p>

<tt>(letrec-syntax<br>
&nbsp;&nbsp;((my-or&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((my-or)&nbsp;<tt>#f</tt>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((my-or&nbsp;e)&nbsp;e)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((my-or&nbsp;e1&nbsp;e2&nbsp;...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((temp&nbsp;e1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;temp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(my-or&nbsp;e2&nbsp;...)))))))<br>
&nbsp;&nbsp;(let&nbsp;((x&nbsp;<tt>#f</tt>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(y&nbsp;7)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(temp&nbsp;8)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;odd?)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;even?))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(my-or&nbsp;x<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;temp)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;y)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;7<p></tt></p>
<p>
The following example highlights how <tt>let-syntax</tt>
and <tt>letrec-syntax</tt> differ.</p>
<p>
</p>

<tt>(let&nbsp;((f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))))<br>
&nbsp;&nbsp;(let-syntax&nbsp;((f&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((f&nbsp;x)&nbsp;x)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(g&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((g&nbsp;x)&nbsp;(f&nbsp;x)))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(f&nbsp;1)&nbsp;(g&nbsp;1))))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;(1&nbsp;2)<br>
<br>
(let&nbsp;((f&nbsp;(lambda&nbsp;(x)&nbsp;(+&nbsp;x&nbsp;1))))<br>
&nbsp;&nbsp;(letrec-syntax&nbsp;((f&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((f&nbsp;x)&nbsp;x)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(g&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((g&nbsp;x)&nbsp;(f&nbsp;x)))))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(list&nbsp;(f&nbsp;1)&nbsp;(g&nbsp;1))))&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;(1&nbsp;1)<p></tt></p>
<p>
The two expressions are identical except that the <tt>let-syntax</tt> form
in the first expression is a <tt>letrec-syntax</tt> form in the second.
In the first expression, the <tt>f</tt> occurring in <tt>g</tt> refers to
the <tt>let</tt>-bound variable <tt>f</tt>, whereas in the second it refers
to the keyword <tt>f</tt> whose binding is established by the
<tt>letrec-syntax</tt> form.
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.19"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.19">11.19&nbsp;&nbsp;Macro transformers</a></h2>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(syntax-rules (&lt;literal&gt; <tt>...</tt>) &lt;syntax rule&gt; <tt>...</tt>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;(<tt>expand</tt>)&nbsp;</div>

<div align=left><tt>_</tt>&nbsp;&nbsp;&nbsp;&nbsp;auxiliary syntax (<tt>expand)</tt>&nbsp;</div>

<a name="node_idx_784"></a><div align=left><tt>...</tt>&nbsp;&nbsp;&nbsp;&nbsp;auxiliary syntax (<tt>expand)</tt>&nbsp;</div>

<a name="node_idx_786"></a><a name="node_idx_788"></a><p>
<em>Syntax: </em>Each &lt;literal&gt; must be an identifier.
Each &lt;syntax rule&gt; must have the following form:</p>
<p>
</p>

<tt>(&lt;srpattern&gt;&nbsp;&lt;template&gt;)<p></tt></p>
<p>
An &lt;srpattern&gt; is a restricted form of &lt;pattern&gt;,
namely, a nonempty &lt;pattern&gt; in one of four parenthesized forms below
whose first subform is an identifier or an underscore <tt>_</tt><a name="node_idx_790"></a>.
A &lt;pattern&gt; is an identifier, constant, or one of the following.</p>
<p>
</p>

<tt>(&lt;pattern&gt;&nbsp;<tt>...</tt>)<br>
(&lt;pattern&gt;&nbsp;&lt;pattern&gt;&nbsp;<tt>...</tt>&nbsp;.&nbsp;&lt;pattern&gt;)<br>
(&lt;pattern&gt;&nbsp;<tt>...</tt>&nbsp;&lt;pattern&gt;&nbsp;&lt;ellipsis&gt;&nbsp;&lt;pattern&gt;&nbsp;<tt>...</tt>)<br>
(&lt;pattern&gt;&nbsp;<tt>...</tt>&nbsp;&lt;pattern&gt;&nbsp;&lt;ellipsis&gt;&nbsp;&lt;pattern&gt;&nbsp;<tt>...</tt>&nbsp;.&nbsp;&lt;pattern&gt;)<br>
#(&lt;pattern&gt;&nbsp;<tt>...</tt>)<br>
#(&lt;pattern&gt;&nbsp;<tt>...</tt>&nbsp;&lt;pattern&gt;&nbsp;&lt;ellipsis&gt;&nbsp;&lt;pattern&gt;&nbsp;<tt>...</tt>)<p></tt></p>
<p>
An &lt;ellipsis&gt; is the identifier &#8220;<tt>...</tt>&#8221; (three periods).<a name="node_idx_792"></a></p>
<p>
A &lt;template&gt; is a pattern variable, an identifier that
is not a pattern
variable, a pattern datum, or one of the following.</p>
<p>
</p>

<tt>(&lt;subtemplate&gt;&nbsp;<tt>...</tt>)<br>
(&lt;subtemplate&gt;&nbsp;<tt>...</tt>&nbsp;.&nbsp;&lt;template&gt;)<br>
#(&lt;subtemplate&gt;&nbsp;<tt>...</tt>)<p></tt></p>
<p>
A &lt;subtemplate&gt; is a &lt;template&gt; followed by zero or more ellipses.</p>
<p>
<em>Semantics: </em>An instance of <tt>syntax-rules</tt> evaluates, at
macro-expansion time, to a new macro
transformer by specifying a sequence of hygienic rewrite rules.  A use
of a macro whose keyword is associated with a transformer specified by
<tt>syntax-rules</tt> is matched against the patterns contained in the
&lt;syntax rule&gt;s, beginning with the leftmost &lt;syntax rule&gt;.
When a match is found, the macro use is transcribed hygienically
according to the template.  It is a syntax violation when no match is found.</p>
<p>
An identifier appearing within a &lt;pattern&gt; may be an underscore
(&nbsp;<tt>_</tt>&nbsp;), a literal identifier listed in the list of literals
<tt>(&lt;literal&gt; <tt>...</tt>)</tt>, or an ellipsis (&nbsp;<tt>...</tt>&nbsp;).
All other identifiers appearing within a &lt;pattern&gt; are
<i>pattern variables<a name="node_idx_794"></a></i>.
It is a syntax violation if an ellipsis or underscore appears in <tt>(&lt;literal&gt; <tt>...</tt>)</tt>.</p>
<p>
While the first subform of &lt;srpattern&gt; may be an identifier, the
identifier is not involved in the matching and
is not considered a pattern variable or literal identifier.</p>
<p>
Pattern variables match arbitrary input subforms and
are used to refer to elements of the input.
It is a syntax violation if the same pattern variable appears more than once in a
&lt;pattern&gt;.</p>
<p>
Underscores also match arbitrary input subforms but are not pattern variables
and so cannot be used to refer to those elements.
Multiple underscores may appear in a &lt;pattern&gt;.</p>
<p>
A literal identifier matches an input subform if and only if the input
subform is an identifier and either both its occurrence in the input
expression and its occurrence in the list of literals have the same
lexical binding, or the two identifiers have the same name and both have
no lexical binding.</p>
<p>
A subpattern followed by an ellipsis can match zero or more elements of
the input.</p>
<p>
More formally, an input form <em>F</em> matches a pattern <em>P</em> if and only if
one of the following holds:</p>
<p>
</p>
<ul>
<li><p><em>P</em> is an underscore (&nbsp;<tt>_</tt>&nbsp;).</p>
<p>
</p>
<li><p><em>P</em> is a pattern variable.</p>
<p>
</p>
<li><p><em>P</em> is a literal identifier
and <em>F</em> is an identifier such that both <em>P</em> and <em>F</em> would refer to the
same binding if both were to appear in the output of the macro outside
of any bindings inserted into the output of the macro.
(If neither of two like-named identifiers refers to any binding, i.e., both
are undefined, they are considered to refer to the same binding.)</p>
<p>
</p>
<li><p><em>P</em> is of the form
<tt>(<em>P</em><sub>1</sub> <tt>...</tt> <em>P</em><sub><em>n</em></sub>)</tt>
and <em>F</em> is a list of <em>n</em> elements that match <em>P</em><sub>1</sub> through
<em>P</em><sub><em>n</em></sub>.</p>
<p>
</p>
<li><p><em>P</em> is of the form
<tt>(<em>P</em><sub>1</sub> <tt>...</tt> <em>P</em><sub><em>n</em></sub> . <em>P</em><sub><em>x</em></sub>)</tt>
and <em>F</em> is a list or improper list of <em>n</em> or more elements
whose first <em>n</em> elements match <em>P</em><sub>1</sub> through <em>P</em><sub><em>n</em></sub>
and
whose <em>n</em>th cdr matches <em>P</em><sub><em>x</em></sub>.</p>
<p>
</p>
<li><p><em>P</em> is of the form
<tt>(<em>P</em><sub>1</sub> <tt>...</tt> <em>P</em><sub><em>k</em></sub> <em>P</em><sub><em>e</em></sub> &lt;ellipsis&gt; <em>P</em><sub><em>m</em>+1</sub> <tt>...</tt> <em>P</em><sub><em>n</em></sub>)</tt>,
where &lt;ellipsis&gt; is the identifier <tt>...</tt>
and <em>F</em> is a list of <em>n</em>
elements whose first <em>k</em> elements match <em>P</em><sub>1</sub> through <em>P</em><sub><em>k</em></sub>,
whose next <em>m</em> <tt>-</tt> <em>k</em> elements each match <em>P</em><sub><em>e</em></sub>,
and
whose remaining <em>n</em> <tt>-</tt> <em>m</em> elements match <em>P</em><sub><em>m</em>+1</sub> through <em>P</em><sub><em>n</em></sub>.</p>
<p>
</p>
<li><p><em>P</em> is of the form
<tt>(<em>P</em><sub>1</sub> <tt>...</tt> <em>P</em><sub><em>k</em></sub> <em>P</em><sub><em>e</em></sub> &lt;ellipsis&gt; <em>P</em><sub><em>m</em>+1</sub> <tt>...</tt> <em>P</em><sub><em>n</em></sub> . <em>P</em><sub><em>x</em></sub>)</tt>,
where &lt;ellipsis&gt; is the identifier <tt>...</tt>
and <em>F</em> is a list or improper list of <em>n</em>
elements whose first <em>k</em> elements match <em>P</em><sub>1</sub> through <em>P</em><sub><em>k</em></sub>,
whose next <em>m</em> <tt>-</tt> <em>k</em> elements each match <em>P</em><sub><em>e</em></sub>,
whose next <em>n</em> <tt>-</tt> <em>m</em> elements match <em>P</em><sub><em>m</em>+1</sub> through <em>P</em><sub><em>n</em></sub>,
and 
whose <em>n</em>th and final cdr matches <em>P</em><sub><em>x</em></sub>.</p>
<p>
</p>
<li><p><em>P</em> is of the form
<tt>#(<em>P</em><sub>1</sub> <tt>...</tt> <em>P</em><sub><em>n</em></sub>)</tt>
and <em>F</em> is a vector of <em>n</em> elements that match <em>P</em><sub>1</sub> through
<em>P</em><sub><em>n</em></sub>.</p>
<p>
</p>
<li><p><em>P</em> is of the form
<tt>#(<em>P</em><sub>1</sub> <tt>...</tt> <em>P</em><sub><em>k</em></sub> <em>P</em><sub><em>e</em></sub> &lt;ellipsis&gt; <em>P</em><sub><em>m</em>+1</sub> <tt>...</tt> <em>P</em><sub><em>n</em></sub>)</tt>,
where &lt;ellipsis&gt; is the identifier <tt>...</tt>
and <em>F</em> is a vector of <em>n</em> or more elements
whose first <em>k</em> elements match <em>P</em><sub>1</sub> through <em>P</em><sub><em>k</em></sub>,
whose next <em>m</em> <tt>-</tt> <em>k</em> elements each match <em>P</em><sub><em>e</em></sub>,
and
whose remaining <em>n</em> <tt>-</tt> <em>m</em> elements match <em>P</em><sub><em>m</em>+1</sub> through <em>P</em><sub><em>n</em></sub>.</p>
<p>
</p>
<li><p><em>P</em> is a pattern datum (any nonlist, nonvector, nonsymbol
datum) and <em>F</em> is equal to <em>P</em> in the sense of the
<tt>equal?</tt> procedure.
</p>
</ul><p></p>
<p>
When a macro use is transcribed according to the template of the
matching &lt;syntax rule&gt;, pattern variables that occur in the
template are replaced by the subforms they match in the input.</p>
<p>
Pattern data and identifiers that are not pattern variables
or ellipses are copied into the output.
A subtemplate followed by an ellipsis expands
into zero or more occurrences of the subtemplate.
Pattern variables that occur in subpatterns followed by one or more
ellipses may occur only in subtemplates that are
followed by (at least) as many ellipses.
These pattern variables are replaced in the output by the input
subforms to which they are bound, distributed as specified.
If a pattern variable is followed by more ellipses in the subtemplate
than in the associated subpattern, the input form is replicated as
necessary.
The subtemplate must contain at least one pattern variable from a
subpattern followed by an ellipsis, and for at least one such pattern
variable, the subtemplate must be followed by exactly as many ellipses as
the subpattern in which the pattern variable appears.
(Otherwise, the expander would not be able to determine how many times the
subform should be repeated in the output.)
It is a syntax violation if the constraints of this paragraph are not met.</p>
<p>
A template of the form
<tt>(&lt;ellipsis&gt; &lt;template&gt;)</tt> is identical to &lt;template&gt;, except that
ellipses within the template have no special meaning.
That is, any ellipses contained within &lt;template&gt; are
treated as ordinary identifiers.
In particular, the template <tt>(... ...)</tt> produces a single
ellipsis, <tt>...</tt>.
This allows syntactic abstractions to expand into forms containing
ellipses.</p>
<p>
</p>

<tt>(define-syntax&nbsp;be-like-begin<br>
&nbsp;&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;((be-like-begin&nbsp;name)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(define-syntax&nbsp;name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules&nbsp;()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((name&nbsp;expr&nbsp;(...&nbsp;...))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin&nbsp;expr&nbsp;(...&nbsp;...))))))))<br>
<br>
(be-like-begin&nbsp;sequence)<br>
(sequence&nbsp;1&nbsp;2&nbsp;3&nbsp;4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;4<p></tt></p>
<p>
As an example for hygienic use of auxiliary identifier,
if <tt>let</tt> and <tt>cond</tt> are defined as in
section&nbsp;<a href="#node_sec_11.16">11.16</a> and appendix&nbsp;<a href="r6rs-Z-H-16.html#node_chap_B">B</a> then they
are hygienic (as required) and the following is not an error.</p>
<p>
</p>

<tt>(let&nbsp;((=&gt;&nbsp;<tt>#f</tt>))<br>
&nbsp;&nbsp;(cond&nbsp;(<tt>#t</tt>&nbsp;=&gt;&nbsp;&#8217;ok)))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;ok<p></tt></p>
<p>
The macro transformer for <tt>cond</tt> recognizes <tt>=&gt;</tt>
as a local variable, and hence an expression, and not as the
identifier <tt>=&gt;</tt>, which the macro transformer treats
as a syntactic keyword.  Thus the example expands into</p>
<p>
</p>

<tt>(let&nbsp;((=&gt;&nbsp;<tt>#f</tt>))<br>
&nbsp;&nbsp;(if&nbsp;<tt>#t</tt>&nbsp;(begin&nbsp;=&gt;&nbsp;&#8217;ok)))<p></tt></p>
<p>
instead of</p>
<p>
</p>

<tt>(let&nbsp;((=&gt;&nbsp;<tt>#f</tt>))<br>
&nbsp;&nbsp;(let&nbsp;((temp&nbsp;<tt>#t</tt>))<br>
&nbsp;&nbsp;&nbsp;&nbsp;(if&nbsp;temp&nbsp;(&#8217;ok&nbsp;temp))))<p></tt></p>
<p>
which would result in an assertion violation.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_796"></a>identifier-syntax<i> &lt;template&gt;</i>)</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;(<tt>expand</tt>)&nbsp;</div>

<div align=left><tt>(identifier-syntax</tt>&nbsp;&nbsp;&nbsp;&nbsp;syntax&nbsp;(<tt>expand</tt>)&nbsp;</div>
<br>
<tt>(&lt;id<sub>1</sub>&gt;&nbsp;&lt;template<sub>1</sub>&gt;)<br>

((set!&nbsp;&lt;id<sub>2</sub>&gt;&nbsp;&lt;pattern&gt;)<br>

&lt;template<sub>2</sub>&gt;))<br>

<div align=left><tt>set!</tt>&nbsp;&nbsp;&nbsp;&nbsp;auxiliary&nbsp;syntax&nbsp;(<tt>&nbsp;expand)</tt>&nbsp;</div>
</tt><p>
<em>Syntax: </em>The &lt;id&gt;s must be identifiers.  The &lt;template&gt;s
must be as for <tt>syntax-rules</tt>.</p>
<p>
<em>Semantics: </em>When a keyword is bound to a transformer produced by the first form of
<tt>identifier-syntax</tt>, references to the keyword within the scope
of the binding are replaced by &lt;template&gt;.</p>
<p>
</p>

<tt>(define&nbsp;p&nbsp;(cons&nbsp;4&nbsp;5))<br>
(define-syntax&nbsp;p.car&nbsp;(identifier-syntax&nbsp;(car&nbsp;p)))<br>
p.car&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;4<br>
(set!&nbsp;p.car&nbsp;15)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;<tt>&nbsp;&amp;syntax</tt>&nbsp;<i>exception</i><p></tt></p>
<p>
The second, more general, form of <tt>identifier-syntax</tt> permits
the transformer to determine what happens when <tt>set!</tt> is used.
In this case, uses of the identifier by itself are replaced by
&lt;template<sub>1</sub>&gt;, and uses of <tt>set!</tt> with the identifier are
replaced by &lt;template<sub>2</sub>&gt;.</p>
<p>
</p>

<tt>(define&nbsp;p&nbsp;(cons&nbsp;4&nbsp;5))<br>
(define-syntax&nbsp;p.car<br>
&nbsp;&nbsp;(identifier-syntax<br>
&nbsp;&nbsp;&nbsp;&nbsp;(_&nbsp;(car&nbsp;p))<br>
&nbsp;&nbsp;&nbsp;&nbsp;((set!&nbsp;_&nbsp;e)&nbsp;(set-car!&nbsp;p&nbsp;e))))<br>
(set!&nbsp;p.car&nbsp;15)<br>
p.car&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;15<br>
p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rArr;&nbsp;(15&nbsp;5)<p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<a name="node_sec_11.20"></a>
<h2 class=section><a href="r6rs-Z-H-2.html#node_toc_node_sec_11.20">11.20&nbsp;&nbsp;Tail calls and tail contexts</a></h2>
<p></p>
<p>
A <em>tail call</em><a name="node_idx_798"></a>is a procedure call that occurs
in a <em>tail context</em>.  Tail contexts are defined inductively.  Note
that a tail context is always determined with respect to a particular lambda
expression.</p>
<p>
</p>
<ul>
<li><p>The last expression within the body of a lambda expression,
shown as &lt;tail expression&gt; below, occurs in a tail context.
</p>

<tt>(l&acirc;mbda&nbsp;&lt;formals&gt;<br>
&nbsp;&nbsp;&lt;definition&gt;*&nbsp;<br>
&nbsp;&nbsp;&lt;expression&gt;*&nbsp;&lt;tail&nbsp;expression&gt;)<p></tt>
</p>
<li><p>If one of the following expressions is in a tail context,
then the subexpressions shown as &lt;tail expression&gt; are in a tail context.
These were derived from specifications of the syntax of the forms described in
this chapter by replacing some occurrences of &lt;expression&gt;
with &lt;tail expression&gt;.  Only those rules that contain tail contexts
are shown here.
</p>

<tt>(if&nbsp;&lt;expression&gt;&nbsp;&lt;tail&nbsp;expression&gt;&nbsp;&lt;tail&nbsp;expression&gt;)<br>
(if&nbsp;&lt;expression&gt;&nbsp;&lt;tail&nbsp;expression&gt;)<br>
<br>
(cond&nbsp;&lt;cond&nbsp;clause&gt;<sup>+</sup>)<br>
(cond&nbsp;&lt;cond&nbsp;clause&gt;*&nbsp;(else&nbsp;&lt;tail&nbsp;sequence&gt;))<br>
<br>
(c&acirc;se&nbsp;&lt;expression&gt;<br>
&nbsp;&nbsp;&lt;case&nbsp;clause&gt;<sup>+</sup>)<br>
(c&acirc;se&nbsp;&lt;expression&gt;<br>
&nbsp;&nbsp;&lt;case&nbsp;clause&gt;*<br>
&nbsp;&nbsp;(else&nbsp;&lt;tail&nbsp;sequence&gt;))<br>
<br>
(and&nbsp;&lt;expression&gt;*&nbsp;&lt;tail&nbsp;expression&gt;)<br>
(or&nbsp;&lt;expression&gt;*&nbsp;&lt;tail&nbsp;expression&gt;)<br>
<br>
(let&nbsp;&lt;bindings&gt;&nbsp;&lt;tail&nbsp;body&gt;)<br>
(let&nbsp;&lt;variable&gt;&nbsp;&lt;bindings&gt;&nbsp;&lt;tail&nbsp;body&gt;)<br>
(let*&nbsp;&lt;bindings&gt;&nbsp;&lt;tail&nbsp;body&gt;)<br>
(letrec*&nbsp;&lt;bindings&gt;&nbsp;&lt;tail&nbsp;body&gt;)<br>
(letrec&nbsp;&lt;bindings&gt;&nbsp;&lt;tail&nbsp;body&gt;)<br>
(let-values&nbsp;&lt;mv-bindings&gt;&nbsp;&lt;tail&nbsp;body&gt;)<br>
(let*-values&nbsp;&lt;mv-bindings&gt;&nbsp;&lt;tail&nbsp;body&gt;)<br>
<br>
(let-syntax&nbsp;&lt;bindings&gt;&nbsp;&lt;tail&nbsp;body&gt;)<br>
(letrec-syntax&nbsp;&lt;bindings&gt;&nbsp;&lt;tail&nbsp;body&gt;)<br>
<br>
(begin&nbsp;&lt;tail&nbsp;sequence&gt;)<p></tt>
A &lt;cond clause&gt; is 
</p>

<tt>(&lt;test&gt;&nbsp;&lt;tail&nbsp;sequence&gt;),<p></tt>
a &lt;case clause&gt; is
</p>

<tt>((&lt;datum&gt;*)&nbsp;&lt;tail&nbsp;sequence&gt;),<p></tt>
a &lt;tail body&gt; is
</p>

<tt>&lt;definition&gt;*&nbsp;&lt;tail&nbsp;sequence&gt;,<p></tt>
and a &lt;tail sequence&gt; is
</p>

<tt>&lt;expression&gt;*&nbsp;&lt;tail&nbsp;expression&gt;.<p></tt></p>
<p>
</p>
<li><p>If a <tt>cond</tt> expression is in a tail context, and has a clause of
the form <tt>(&lt;expression<sub>1</sub>&gt; =&gt; &lt;expression<sub>2</sub>&gt;)</tt>
then the (implied) call to
the procedure that results from the evaluation of &lt;expression<sub>2</sub>&gt; is in a
tail context.  &lt;Expression<sub>2</sub>&gt; itself is not in a tail context.</p>
<p>
</p>
</ul><p></p>
<p>
Certain built-in procedures must also perform tail calls.
The first argument passed to <tt>apply</tt> and to
<tt>call-with-current-continuation</tt>, and the second argument passed to
<tt>call-with-values</tt>, must be called via a tail call.</p>
<p>
In the following example the only tail call is the call to <tt>f</tt>.
None of the calls to <tt>g</tt> or <tt>h</tt> are tail calls.  The reference to
<tt>x</tt> is in a tail context, but it is not a call and thus is not a
tail call.
</p>

<tt>(lambda&nbsp;()<br>
&nbsp;&nbsp;(if&nbsp;(g)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let&nbsp;((x&nbsp;(h)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and&nbsp;(g)&nbsp;(f))))<p></tt></p>
<p>
</p>
<blockquote><em>Note:&nbsp;&nbsp;</em>
Implementations may
recognize that some non-tail calls, such as the call to <tt>h</tt>
above, can be evaluated as though they were tail calls.
In the example above, the <tt>let</tt> expression could be compiled
as a tail call to <tt>h</tt>. (The possibility of <tt>h</tt> returning
an unexpected number of values can be ignored, because in that
case the effect of the <tt>let</tt> is explicitly unspecified and
implementation-dependent.)
</blockquote><p>
</p>
<p>
    </p>
<p>

</p>
<div class=smallskip></div>
<p style="margin-top: 0pt; margin-bottom: 0pt">
<div align=right class=navigation>[Go to <span><a href="r6rs.html">first</a>, <a href="r6rs-Z-H-13.html">previous</a></span><span>, <a href="r6rs-Z-H-15.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="r6rs-Z-H-2.html#node_toc_start">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="r6rs-Z-H-21.html#node_index_start">index</a></span>]</div>
</p>
<p></p>
</div>
</body>
</html>
